     1                                  
     2                                  	BITS 16
     3                                  	
     4                                  	ORG 32768
     5                                  	
     6                                  ; ------------------------------------------------------------------
     7                                  ; MACROS
     8                                  ; ------------------------------------------------------------------
     9                                  	
    10                                  %macro clr 1
    11                                  	xor %1, %1
    12                                  %endmacro
    13                                  
    14                                  %macro mov16 3
    15                                  	mov %1, (%2 + %3 * 256)
    16                                  %endmacro
    17                                  
    18                                  %define ADLIB_BUFFER 0500h
    19                                  %define DESKTOP_BACKGROUND 0600h
    20                                  %define SYSTEM_FONT 1600h
    21                                  %define FILE_MANAGER 2600h
    22                                  %define disk_buffer 0E000h
    23                                  
    24                                  ; ------------------------------------------------------------------
    25                                  ; crepeOS memory map:
    26                                  ; Segment 0000h:
    27                                  ;   - 0000h - 03FFh = Interrupt vector table
    28                                  ;   - 0400h - 04FFh = BIOS data area
    29                                  ;   - 0500h - 05FFh = AdLib register buffer
    30                                  ;   - 0600h - 15FFh = Desktop background (BG.ASC)
    31                                  ;   - 1600h - 25FFh = System font (FONT.SYS)
    32                                  ;   - 2600h - 35FFh = File manager (FILEMAN.APP)
    33                                  ; Segment 0360h:
    34                                  ;   - 0000h - 00FFh = System variables
    35                                  ;      - 0000h = RET instruction
    36                                  ;      - 0001h - 0050h = Footer buffer
    37                                  ;      - 0051h - 0081h = File selector filter buffer
    38                                  ;      - 0082h = System state (byte)
    39                                  ;         - 0 if a GUI application is running
    40                                  ;         - 1 if a non-GUI application is running (no header/footer)
    41                                  ;      - 0083h = Sound state (byte)
    42                                  ;         - 0 if sound disabled
    43                                  ;         - 1 if sound enabled
    44                                  ;      - 0084h = Default boot device (byte)
    45                                  ;      - 0085h = Default button for os_dialog_box (0 = OK, 1 = Cancel) (byte)
    46                                  ;      - 0086h = int_filename_convert error status (byte)
    47                                  ;         - 0 if filename too long
    48                                  ;         - 1 if filename empty
    49                                  ;         - 2 if no extension found
    50                                  ;         - 3 if no basename found
    51                                  ;         - 4 if extension too short
    52                                  ;      - 0087h = Flag for os_file_selector input (byte)
    53                                  ;      - 0088h = Maximum number of characters that os_input_string can input (byte)
    54                                  ;      - 0089h = Width of os_list_dialog (word)
    55                                  ;      - 00E0h - 00EFh - parameters for an app (eg. a file to open when an app launches)
    56                                  ;      - 00F0h - 00FFh - temporary buffer for storing apps' filenames
    57                                  ;   - 0100h - 7FFEh = Application
    58                                  ;   - 7FFEh - Application return flag
    59                                  ;      - 0 = return to the desktop after an application quits
    60                                  ;      - 1 = launch another application (00F0h-00FFh) after an application quits
    61                                  ;      (example: when a user opens an app through Terminal, then terminal stores its name to 00F0h-00FFh so it starts after the requested application exits)
    62                                  ;   - 7FFFh - Application launch flag
    63                                  ;      - 0 = return to the desktop after an application quits
    64                                  ;      - 1 = launch another application (filename passed in AX) after an application quits
    65                                  ;         - Note: after launching another application this flag is set to 0
    66                                  ;   - 8000h - DEA7h = crepeOS kernel
    67                                  ;   - DEA8h - DFFFh = Configuration file (SYSTEM.CFG)
    68                                  ;      - described in CONFIG.ASM
    69                                  ;   - E000h - FFFFh = Disk buffer
    70                                  ; End of memory: 2048 bytes stack
    71                                  ; ------------------------------------------------------------------
    72                                  
    73                                  ; ------------------------------------------------------------------
    74                                  ; OS CALL VECTORS
    75                                  
    76                                  os_call_vectors:
    77 00000000 E95601                  	jmp os_main					; 8000h -- Called from bootloader
    78 00000003 E9EF17                  	jmp os_print_string			; 8003h
    79 00000006 E95D18                  	jmp os_move_cursor			; 8006h
    80 00000009 E94418                  	jmp os_clear_screen			; 8009h
    81 0000000C E97318                  	jmp os_print_horiz_line		; 800Ch
    82 0000000F E9301F                  	jmp os_print_newline		; 800Fh
    83 00000012 E96512                  	jmp os_wait_for_key			; 8012h
    84 00000015 E90513                  	jmp os_check_for_key		; 8015h
    85 00000018 E92D2B                  	jmp os_int_to_string		; 8018h
    86 0000001B E91026                  	jmp os_speaker_tone			; 801Bh
    87 0000001E E94D26                  	jmp os_speaker_off			; 801Eh
    88 00000021 E9690B                  	jmp os_load_file			; 8021h
    89 00000024 E9A514                  	jmp os_pause				; 8024h
    90 00000027 E97615                  	jmp os_fatal_error			; 8027h
    91 0000002A E9441E                  	jmp os_draw_background		; 802Ah
    92 0000002D E98729                  	jmp os_string_length		; 802Dh
    93 00000030 E9DD29                  	jmp os_string_uppercase		; 8030h
    94 00000033 E9F729                  	jmp os_string_lowercase		; 8033h
    95 00000036 E97821                  	jmp os_input_string			; 8036h
    96 00000039 E90E2A                  	jmp os_string_copy			; 8039h
    97 0000003C E9FD1F                  	jmp os_dialog_box			; 803Ch
    98 0000003F E9112A                  	jmp os_string_join			; 803Fh
    99 00000042 E91B0A                  	jmp os_get_file_list		; 8042h
   100 00000045 E9612A                  	jmp os_string_compare		; 8045h
   101 00000048 E91E2A                  	jmp os_string_chomp			; 8048h
   102 0000004B E9B32A                  	jmp os_string_to_hex		; 804Bh
   103 0000004E E9E726                  	jmp os_adlib_regwrite		; 804Eh
   104 00000051 E9AF13                  	jmp os_bcd_to_int			; 8051h
   105 00000054 E9592B                  	jmp os_get_time_string		; 8054h
   106 00000057 E9B523                  	jmp os_draw_logo			; 8057h
   107 0000005A E96B18                  	jmp os_file_selector		; 805Ah
   108 0000005D E9972B                  	jmp os_get_date_string		; 805Dh
   109 00000060 E95B17                  	jmp os_send_via_serial		; 8060h
   110 00000063 E96A17                  	jmp os_get_via_serial		; 8063h
   111 00000066 E98729                  	jmp os_find_char_in_string	; 8066h
   112 00000069 E90318                  	jmp os_get_cursor_pos		; 8069h
   113 0000006C E90421                  	jmp os_print_space			; 806Ch
   114 0000006F E92C24                  	jmp os_option_menu			; 806Fh
   115 00000072 E90621                  	jmp os_print_digit			; 8072h
   116 00000075 E91521                  	jmp os_print_1hex			; 8075h
   117 00000078 E91B21                  	jmp os_print_2hex			; 8078h
   118 0000007B E92621                  	jmp os_print_4hex			; 807Bh
   119 0000007E E95247                  	jmp os_set_timer_speed		; 807Eh
   120 00000081 E96509                  	jmp os_report_free_space	; 8081h
   121 00000084 E92129                  	jmp os_string_add			; 8084h
   122 00000087 E9D625                  	jmp os_speaker_note_length	; 8087h
   123 0000008A E90E18                  	jmp os_show_cursor			; 808Ah
   124 0000008D E91618                  	jmp os_hide_cursor			; 808Dh
   125 00000090 E9BC1E                  	jmp os_dump_registers		; 8090h
   126 00000093 E9E11A                  	jmp os_list_dialog_tooltip	; 8093h
   127 00000096 E9560C                  	jmp os_write_file			; 8096h
   128 00000099 E9350E                  	jmp os_file_exists			; 8099h
   129 0000009C E9530E                  	jmp os_create_file			; 809Ch
   130 0000009F E92E0F                  	jmp os_remove_file			; 809Fh
   131 000000A2 E9AD0F                  	jmp os_rename_file			; 80A2h
   132 000000A5 E9DF0F                  	jmp os_get_file_size		; 80A5h
   133 000000A8 E9FB1E                  	jmp os_input_dialog			; 80A8h
   134 000000AB E9061B                  	jmp os_list_dialog			; 80ABh
   135 000000AE E91F29                  	jmp os_string_reverse		; 80AEh
   136 000000B1 E9492A                  	jmp os_string_to_int		; 80B1h
   137 000000B4 E9F917                  	jmp os_draw_block			; 80B4h
   138 000000B7 E92413                  	jmp os_get_random			; 80B7h
   139 000000BA E90B2C                  	jmp os_print_32int			; 80BAh
   140 000000BD E9EA16                  	jmp os_serial_port_enable	; 80BDh
   141 000000C0 E9B32A                  	jmp os_sint_to_string		; 80C0h
   142 000000C3 E9FA29                  	jmp os_string_parse			; 80C3h
   143 000000C6 E90C2C                  	jmp os_run_basic			; 80C6h
   144 000000C9 E92728                  	jmp os_adlib_calcfreq		; 80C9h
   145 000000CC E9DD46                  	jmp os_attach_app_timer		; 80CCh
   146 000000CF E9692B                  	jmp os_string_tokenize		; 80CFh
   147 000000D2 E93714                  	jmp os_clear_registers		; 80D2h
   148 000000D5 E94717                  	jmp os_format_string		; 80D5h
   149 000000D8 E90617                  	jmp os_putchar				; 80D8h
   150 000000DB E99925                  	jmp os_start_adlib			; 80DBh
   151 000000DE E9DA46                  	jmp os_return_app_timer		; 80DEh
   152 000000E1 E90723                  	jmp os_reset_font			; 80E1h
   153 000000E4 E91B17                  	jmp os_print_string_box		; 80E4h
   154 000000E7 E9FE16                  	jmp os_put_chars			; 80E7h
   155 000000EA E92926                  	jmp os_check_adlib			; 80EAh
   156 000000ED E9EE47                  	jmp os_draw_line			; 80EDh
   157 000000F0 E9FD49                  	jmp os_draw_polygon			; 80F0h
   158 000000F3 E97D4A                  	jmp os_draw_circle			; 80F3h
   159 000000F6 E9664A                  	jmp os_clear_graphics		; 80F6h
   160 000000F9 E9B90F                  	jmp os_get_file_datetime	; 80F9h
   161 000000FC E98428                  	jmp os_string_encrypt		; 80FCh
   162 000000FF E9B947                  	jmp os_put_pixel			; 80FFh
   163 00000102 E9BD47                  	jmp os_get_pixel			; 8102h
   164 00000105 E92123                  	jmp os_draw_icon			; 8105h
   165 00000108 E9BB25                  	jmp os_stop_adlib			; 8108h
   166 0000010B E95128                  	jmp os_adlib_noteoff		; 810Bh
   167 0000010E E9A815                  	jmp os_int_1Ah				; 810Eh
   168 00000111 E90A13                  	jmp os_int_to_bcd			; 8111h
   169 00000114 E90814                  	jmp os_illegal_call			; 8114h ; FREE!!!!!!!!!!!!!!!!!!!
   170 00000117 E9D61E                  	jmp os_password_dialog		; 8117h
   171 0000011A E9D826                  	jmp os_adlib_mute			; 811Ah
   172 0000011D E93C49                  	jmp os_draw_rectangle		; 811Dh
   173 00000120 E97715                  	jmp os_get_memory			; 8120h
   174 00000123 E96821                  	jmp os_color_selector		; 8123h
   175 00000126 E93D46                  	jmp os_modify_int_handler	; 8126h
   176 00000129 E9282B                  	jmp os_32int_to_string		; 8129h
   177 0000012C E95722                  	jmp os_print_footer			; 812Ch
   178 0000012F E90222                  	jmp os_print_8hex			; 812Fh
   179 00000132 E9592B                  	jmp os_string_to_32int		; 8132h
   180 00000135 E90013                  	jmp os_math_power			; 8135h
   181 00000138 E94213                  	jmp os_math_root			; 8138h
   182 0000013B E9DD20                  	jmp os_input_password		; 813Bh
   183 0000013E E93F46                  	jmp os_get_int_handler		; 813Eh
   184 00000141 E9DB13                  	jmp os_illegal_call			; 8141h ; FREE!!!!!!!!!!!!!!!!!!!
   185 00000144 E90022                  	jmp os_temp_box				; 8144h
   186 00000147 E9CF26                  	jmp os_adlib_unmute			; 8147h
   187 0000014A E9EB08                  	jmp os_read_root			; 814Ah
   188 0000014D E9CF13                  	jmp os_illegal_call			; 814Dh ; FREE!!!!!!!!!!!!!!!!!!!
   189 00000150 E9CC13                  	jmp os_illegal_call			; 8150h ; FREE!!!!!!!!!!!!!!!!!!!
   190 00000153 E9C913                  	jmp os_illegal_call			; 8153h ; FREE!!!!!!!!!!!!!!!!!!!
   191 00000156 E9F110                  	jmp disk_convert_l2hts		; 8156h
   192                                  	
   193                                  ; ------------------------------------------------------------------
   194                                  ; START OF MAIN KERNEL CODE
   195                                  
   196                                  os_main:
   197 00000159 CD12                    	int 12h						; Get RAM size
   198 0000015B 48                      	dec ax						; Some BIOSes round up, so we have to sacrifice 1 kB :(
   199 0000015C C1E006                  	shl ax, 6					; Convert kB to segments
   200                                  
   201 0000015F FA                      	cli
   202                                  
   203 00000160 2D0010                  	sub ax, 65536 / 16			; Set the stack to the top of the memory
   204 00000163 8ED0                    	mov ss, ax
   205 00000165 BCFEFF                  	mov sp, 0FFFEh
   206                                  
   207                                  ;	xor ax, ax
   208                                  ;	mov ss, ax					; Set stack segment and pointer
   209                                  ;	mov sp, 0FFFEh
   210                                  
   211 00000168 FB                      	sti
   212                                  
   213 00000169 FC                      	cld							; The default direction for string operations
   214                                  								; will be 'up' - incrementing address in RAM
   215                                  
   216 0000016A 8CC8                    	mov ax, cs					; Set all segments to match where kernel is loaded
   217 0000016C 8ED8                    	mov ds, ax			
   218 0000016E 8EC0                    	mov es, ax
   219 00000170 8E26[F205]              	mov fs, [driversgmt]
   220 00000174 050010                  	add ax, 1000h
   221 00000177 8EE8                    	mov gs, ax
   222                                  	
   223 00000179 C6060000C3              	mov byte [0000h], 0xC3
   224 0000017E 88168400                	mov [0084h], dl
   225 00000182 8816[7912]              	mov [bootdev], dl			; Save boot device number
   226 00000186 C6068800FF              	mov byte [0088h], 255
   227 0000018B C70689004C00            	mov word [0089h], 76
   228 00000191 C606E00000              	mov byte [00E0h], 0
   229                                  
   230 00000196 891E[7512]              	mov [Sides], bx
   231 0000019A 890E[7712]              	mov [SecsPerTrack], cx
   232                                  
   233                                  	clr ax
    11 0000019E 31C0                <1>  xor %1, %1
   234 000001A0 E80716                  	call os_serial_port_enable
   235                                  
   236                                  	; Load the files
   237                                  	
   238 000001A3 06                      	push es
   239 000001A4 8E06[F205]              	mov es, [driversgmt]
   240                                  	
   241 000001A8 B8[0807]                	mov ax, fileman_name
   242 000001AB B90026                  	mov cx, FILE_MANAGER
   243 000001AE E8DC09                  	call os_load_file
   244                                  	
   245 000001B1 B8[0107]                	mov ax, bg_name
   246 000001B4 B90006                  	mov cx, DESKTOP_BACKGROUND
   247 000001B7 E8D309                  	call os_load_file
   248 000001BA 7305                    	jnc .background_ok
   249                                  	
   250 000001BC C606000600              	mov byte [DESKTOP_BACKGROUND], 0
   251                                  	
   252                                  .background_ok:	
   253 000001C1 B8[2C07]                	mov ax, font_name
   254 000001C4 B90016                  	mov cx, SYSTEM_FONT
   255 000001C7 E8C309                  	call os_load_file
   256                                  	
   257 000001CA 07                      	pop es
   258                                  	
   259 000001CB FA                      	cli
   260                                  
   261 000001CC 8CCF                    	mov di, cs
   262                                  
   263 000001CE B100                    	mov cl, 00h					; Divide by 0 error handler
   264 000001D0 BE[E647]                	mov si, os_compat_int00
   265 000001D3 E89045                  	call os_modify_int_handler
   266                                  
   267 000001D6 B10C                    	mov cl, 0Ch					; Stack overflow
   268 000001D8 BE[2348]                	mov si, os_compat_int0C
   269 000001DB E88845                  	call os_modify_int_handler
   270                                  
   271 000001DE B105                    	mov cl, 05h					; Debugger
   272 000001E0 BE[0848]                	mov si, os_compat_int05
   273 000001E3 E88045                  	call os_modify_int_handler
   274                                  	
   275 000001E6 B106                    	mov cl, 06h					; Bad instruction error handler
   276 000001E8 BE[3D48]                	mov si, os_compat_int06
   277 000001EB E87845                  	call os_modify_int_handler
   278                                  
   279 000001EE B107                    	mov cl, 07h					; Processor extension error handler
   280 000001F0 BE[5748]                	mov si, os_compat_int07
   281 000001F3 E87045                  	call os_modify_int_handler
   282                                  
   283 000001F6 B11C                    	mov cl, 1Ch					; RTC handler
   284 000001F8 BE[7C48]                	mov si, os_compat_int1C
   285 000001FB E86845                  	call os_modify_int_handler
   286                                  	
   287 000001FE FB                      	sti
   288                                  
   289                                  ;	int 5
   290                                  	
   291 000001FF E8BC11                  	call os_seed_random
   292                                  
   293 00000202 BF0001                  	mov di, 100h
   294 00000205 B000                    	mov al, 0
   295 00000207 B9FF7E                  	mov cx, 7EFFh
   296 0000020A F3AA                    	rep stosb
   297                                  
   298 0000020C E8DC21                  	call os_reset_font
   299                                  
   300 0000020F B80310                  	mov ax, 1003h				; Set text output with certain attributes
   301 00000212 B300                    	mov bl, 0					; to be bright, and not blinking
   302 00000214 CD10                    	int 10h
   303                                  	
   304 00000216 B80503                  	mov ax, 0305h
   305 00000219 BB0401                  	mov bx, 0104h
   306 0000021C CD16                    	int 16h
   307                                  	
   308 0000021E C606820000              	mov byte [0082h], 0
   309                                  	
   310 00000223 B8[2107]                	mov ax, system_cfg			; Try to load SYSTEM.CFG
   311 00000226 B9A8DE                  	mov cx, 57000
   312 00000229 E86109                  	call os_load_file
   313                                  
   314 0000022C A0EDDE                  	mov al, [57069]				; Copy the default sound volume (on/off)
   315 0000022F A28300                  	mov [0083h], al
   316                                  	
   317 00000232 0F82E902                	jc load_demotour			; If failed, it doesn't exist, so the system is run for the first time
   318                                  	
   319                                  logoinput:
   320 00000236 B8[464C]                	mov ax, osname				; Set up the welcome screen
   321 00000239 BB[4907]                	mov bx, empty_string
   322 0000023C B90700                  	mov cx, 07h					; Colour: black
   323 0000023F E82F1C                  	call os_draw_background
   324                                  
   325 00000242 BA0009                  	mov dx, 9 * 256
   326 00000245 E81E16                  	call os_move_cursor
   327                                  
   328 00000248 B82009                  	mov ax, 0920h
   329 0000024B BB0400                  	mov bx, 00000100b
   330 0000024E B93002                  	mov cx, 560
   331 00000251 CD10                    	int 10h
   332                                  
   333 00000253 BE[6909]                	mov si, logo
   334 00000256 E8D021                  	call os_draw_icon
   335                                  
   336 00000259 BE[EA02]                	mov si, ver_msg
   337 0000025C E89615                  	call os_print_string
   338                                  
   339 0000025F BA0216                  	mov dx, 22 * 256 + 2
   340 00000262 E80116                  	call os_move_cursor
   341                                  
   342 00000265 BE[2F03]                	mov si, passwordmsg
   343 00000268 E88A15                  	call os_print_string
   344 0000026B E83816                  	call os_hide_cursor
   345                                  
   346 0000026E B80B02                  	mov ax, 523
   347 00000271 B90200                  	mov cx, 2
   348 00000274 E8E923                  	call os_speaker_note_length
   349 00000277 B80503                  	mov ax, 773
   350 0000027A B90200                  	mov cx, 2
   351 0000027D E8E023                  	call os_speaker_note_length
   352 00000280 B86202                  	mov ax, 610
   353 00000283 B90500                  	mov cx, 5
   354 00000286 E8D723                  	call os_speaker_note_length
   355                                  
   356 00000289 E8EE0F                  	call os_wait_for_key
   357                                  	
   358                                  enterpressed:
   359 0000028C E80C16                  	call os_show_cursor
   360 0000028F 803EAADE00              	cmp byte [57002], 0				; Is the password disabled?
   361 00000294 743D                    	je checkformenu				; If it is, continue
   362                                  
   363                                  .try:	
   364 00000296 BA0016                  	mov dx, 22 * 256					; Clean the text on the screen
   365 00000299 E8CA15                  	call os_move_cursor
   366                                  
   367 0000029C B82009                  	mov ax, 0920h
   368 0000029F BB0700                  	mov bx, 7
   369 000002A2 B95000                  	mov cx, 80
   370 000002A5 CD10                    	int 10h
   371                                  	
   372 000002A7 BA0216                  	mov dx, 22 * 256 + 2					; Ask for the password
   373 000002AA E8B915                  	call os_move_cursor
   374 000002AD BE[4A03]                	mov si, passentermsg
   375 000002B0 E84215                  	call os_print_string
   376                                  	
   377 000002B3 B80001                  	mov ax, 100h
   378 000002B6 B307                    	mov bl, 7
   379 000002B8 C606880020              	mov byte [0088h], 32
   380 000002BD E85B1F                  	call os_input_password
   381 000002C0 C6068800FF              	mov byte [0088h], 255
   382                                  
   383 000002C5 BE0001                  	mov si, 100h
   384 000002C8 E8B826                  	call os_string_encrypt
   385                                  
   386 000002CB BFABDE                  	mov di, 57003
   387 000002CE E8D827                  	call os_string_compare
   388 000002D1 73C3                    	jnc .try
   389                                  	
   390                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;end LOGO!
   391                                  	
   392                                  checkformenu:
   393 000002D3 E8D015                  	call os_hide_cursor
   394 000002D6 E8F702                  	call background
   395                                  
   396                                  checkformenuloop:	
   397 000002D9 E89E0F                  	call os_wait_for_key
   398 000002DC 3C20                    	cmp al, 32					; Space pressed?
   399 000002DE 0F84C500                	je near option_screen		; Open the menu
   400 000002E2 3C66                    	cmp al, 'f'					; f pressed?
   401 000002E4 0F842402                	je near load_fileman		; Open the file manager
   402 000002E8 EBEF                    	jmp checkformenuloop
   403                                  	
   404 000002EA 202020202020202020-     	ver_msg			db '                                                              v0.7b3',0
   404 000002F3 202020202020202020-
   404 000002FC 202020202020202020-
   404 00000305 202020202020202020-
   404 0000030E 202020202020202020-
   404 00000317 202020202020202020-
   404 00000320 202020202020202076-
   404 00000329 302E37623300       
   405 0000032F 507265737320616E79-     	passwordmsg		db 'Press any key to log in...', 0
   405 00000338 206B657920746F206C-
   405 00000341 6F6720696E2E2E2E00 
   406 0000034A 456E74657220796F75-     	passentermsg		db 'Enter your password: ', 0
   406 00000353 722070617373776F72-
   406 0000035C 643A2000           
   407                                  
   408 00000360 63726570654F532044-     	os_init_msg			db 'crepeOS Desktop', 0
   408 00000369 65736B746F7000     
   409 00000370 5B53706163655D204F-     	os_version_msg		db '[Space] Open the system menu [A] Open the file manager', 0
   409 00000379 70656E207468652073-
   409 00000382 797374656D206D656E-
   409 0000038B 75205B415D204F7065-
   409 00000394 6E207468652066696C-
   409 0000039D 65206D616E61676572-
   409 000003A6 00                 
   410                                  
   411                                  ; TODO: THE FOLLOWING CODE NEEDS TO BE REWRITTEN
   412                                  	
   413                                  option_screen:
   414 000003A7 E83502                  	call menu_background
   415                                  
   416 000003AA B8[4A07]                	mov ax, menuoptions
   417 000003AD BB0D00                  	mov bx, 13
   418 000003B0 E8EB20                  	call os_option_menu
   419                                  
   420 000003B3 0F821CFF                	jc checkformenu
   421                                  	
   422 000003B7 83F801                  	cmp ax, 1
   423 000003BA 0F841500                	je near app_selector
   424                                  
   425 000003BE 83F802                  	cmp ax, 2
   426 000003C1 0F848000                	je near game_selector
   427                                  	
   428 000003C5 83F803                  	cmp ax, 3
   429 000003C8 0F846AFE                	je near logoinput
   430                                  	
   431 000003CC 83F804                  	cmp ax, 4
   432 000003CF 0F848248                	je near os_shutdown
   433                                  
   434                                  app_selector:
   435 000003D3 E80902                  	call menu_background
   436                                  
   437 000003D6 B8[1A08]                	mov ax, progoptions
   438 000003D9 BB1400                  	mov bx, 20
   439 000003DC E8BF20                  	call os_option_menu
   440                                  
   441 000003DF 72C6                    	jc option_screen
   442                                  
   443 000003E1 83F801                  	cmp ax, 1
   444 000003E4 0F842401                	je near load_fileman
   445                                  
   446 000003E8 83F80D                  	cmp ax, 13
   447 000003EB 0F842500                	je near debug_stuff
   448                                  	
   449 000003EF 89C6                    	mov si, ax
   450 000003F1 83EE02                  	sub si, 2
   451 000003F4 D1E6                    	shl si, 1
   452 000003F6 81C6[2B06]              	add si, appindex1
   453 000003FA AD                      	lodsw
   454 000003FB 89C6                    	mov si, ax
   455 000003FD BF0001                  	mov di, 0100h
   456 00000400 E84726                  	call os_string_copy
   457                                  	
   458 00000403 B80001                  	mov ax, 0100h
   459 00000406 BB[F806]                	mov bx, app_prefix
   460 00000409 B9F000                  	mov cx, 00F0h
   461 0000040C E84426                  	call os_string_join
   462                                  	
   463 0000040F 89CB                    	mov bx, cx
   464 00000411 E93201                  	jmp start_program
   465                                  	
   466                                  debug_stuff:
   467 00000414 E8C801                  	call menu_background
   468                                  
   469 00000417 B8[8807]                	mov ax, debugoptions
   470 0000041A BB1F00                  	mov bx, 31
   471 0000041D E87E20                  	call os_option_menu
   472                                  	
   473 00000420 72B1                    	jc app_selector
   474                                  	
   475 00000422 89C6                    	mov si, ax
   476 00000424 4E                      	dec si
   477 00000425 D1E6                    	shl si, 1
   478 00000427 81C6[3F06]              	add si, debugindex1
   479 0000042B AD                      	lodsw
   480 0000042C 89C6                    	mov si, ax
   481 0000042E BF0001                  	mov di, 0100h
   482 00000431 E81626                  	call os_string_copy
   483                                  	
   484 00000434 B80001                  	mov ax, 0100h
   485 00000437 BB[F806]                	mov bx, app_prefix
   486 0000043A B9F000                  	mov cx, 00F0h
   487 0000043D E81326                  	call os_string_join
   488                                  	
   489 00000440 89CB                    	mov bx, cx
   490 00000442 E90101                  	jmp start_program
   491                                  	
   492                                  	
   493                                  game_selector:
   494 00000445 E89701                  	call menu_background
   495                                  
   496 00000448 B8[6B07]                	mov ax, gameoptions
   497 0000044B BB1300                  	mov bx, 19
   498 0000044E E84D20                  	call os_option_menu
   499                                  
   500 00000451 0F8252FF                	jc option_screen
   501                                  
   502 00000455 89C6                    	mov si, ax
   503 00000457 4E                      	dec si
   504 00000458 D1E6                    	shl si, 1
   505 0000045A 81C6[4F06]              	add si, gameindex1
   506 0000045E AD                      	lodsw
   507                                  	
   508                                  launch_program:
   509 0000045F C606FF7F00              	mov byte [32767], 0
   510                                  
   511 00000464 E86901                  	call background
   512                                  	
   513 00000467 60                      	pusha
   514 00000468 89C6                    	mov si, ax
   515 0000046A 89F3                    	mov bx, si
   516 0000046C 89F0                    	mov ax, si
   517 0000046E E84625                  	call os_string_length
   518 00000471 89DE                    	mov si, bx
   519 00000473 01C6                    	add si, ax				; SI now points to end of filename...
   520 00000475 4E                      	dec si
   521 00000476 4E                      	dec si
   522 00000477 4E                      	dec si					; ...and now to start of extension!
   523 00000478 BF[F906]                	mov di, app_ext
   524 0000047B B90300                  	mov cx, 3
   525 0000047E F3A6                    	rep cmpsb				; Are final 3 chars 'APP'?
   526 00000480 7521                    	jne launch_basic		; If not, try 'BAS'
   527 00000482 61                      	popa
   528                                  	
   529 00000483 B90001                  	mov cx, 100h			; Where to load the program file
   530 00000486 E80407                  	call os_load_file		; Load filename pointed to by AX
   531                                  
   532 00000489 0F8246FE                	jc checkformenu
   533                                  	
   534 0000048D 60                      	pusha
   535 0000048E B9FD7E                  	mov cx, 7EFDh
   536 00000491 29D9                    	sub cx, bx
   537 00000493 BF0001                  	mov di, 100h
   538 00000496 01DF                    	add di, bx
   539 00000498 B000                    	mov al, 0
   540 0000049A F3AA                    	rep stosb
   541 0000049C 61                      	popa
   542                                  	
   543 0000049D E8FB13                  	call os_show_cursor
   544                                  	
   545 000004A0 E9CB00                  	jmp execute_bin_program
   546                                  
   547                                  launch_basic:
   548 000004A3 61                      	popa
   549                                  	
   550 000004A4 60                      	pusha
   551 000004A5 89C6                    	mov si, ax
   552 000004A7 89F3                    	mov bx, si
   553 000004A9 89F0                    	mov ax, si
   554 000004AB E80925                  	call os_string_length
   555 000004AE 89DE                    	mov si, bx
   556 000004B0 01C6                    	add si, ax				; SI now points to end of filename...
   557 000004B2 4E                      	dec si
   558 000004B3 4E                      	dec si
   559 000004B4 4E                      	dec si					; ...and now to start of extension!
   560 000004B5 BF[FD06]                	mov di, bas_ext
   561 000004B8 B90300                  	mov cx, 3
   562 000004BB F3A6                    	rep cmpsb				; Are final 3 chars 'BAS'?
   563 000004BD 753A                    	jne program_error		; If not, error out
   564 000004BF 61                      	popa
   565                                  
   566 000004C0 B90001                  	mov cx, 100h			; Where to load the program file
   567 000004C3 E8C706                  	call os_load_file		; Load filename pointed to by AX
   568                                  
   569 000004C6 0F8209FE                	jc checkformenu
   570                                  	
   571 000004CA 60                      	pusha
   572 000004CB B9FD7E                  	mov cx, 7EFDh
   573 000004CE 29D9                    	sub cx, bx
   574 000004D0 BF0001                  	mov di, 100h
   575 000004D3 01DF                    	add di, bx
   576 000004D5 B000                    	mov al, 0
   577 000004D7 F3AA                    	rep stosb
   578 000004D9 61                      	popa
   579                                  
   580 000004DA E8BE13                  	call os_show_cursor
   581                                  	
   582 000004DD B80001                  	mov ax, 100h
   583                                  	clr si
    11 000004E0 31F6                <1>  xor %1, %1
   584 000004E2 E8F027                  	call os_run_basic
   585                                  
   586 000004E5 BE[3507]                	mov si, basic_finished_msg
   587 000004E8 E80A13                  	call os_print_string
   588 000004EB E88C0D                  	call os_wait_for_key
   589                                  
   590 000004EE E85F13                  	call os_clear_screen
   591                                  	
   592 000004F1 C606820000              	mov byte [0082h], 0
   593                                  	
   594 000004F6 E9DAFD                  	jmp checkformenu
   595                                  	
   596                                  program_error:
   597 000004F9 61                      	popa
   598 000004FA E8D300                  	call background
   599 000004FD B8[F405]                	mov ax, prog_msg
   600                                  	clr bx
    11 00000500 31DB                <1>  xor %1, %1
   601                                  	clr cx
    11 00000502 31C9                <1>  xor %1, %1
   602                                  	clr dx
    11 00000504 31D2                <1>  xor %1, %1
   603 00000506 E8331B                  	call os_dialog_box
   604 00000509 E9C7FD                  	jmp checkformenu
   605                                  	
   606                                  load_fileman:
   607 0000050C 1E                      	push ds
   608 0000050D 8E1E[F205]              	mov ds, [driversgmt]
   609 00000511 BE0026                  	mov si, FILE_MANAGER
   610 00000514 BF0001                  	mov di, 0100h
   611 00000517 B90010                  	mov cx, 1000h
   612 0000051A F3A4                    	rep movsb
   613 0000051C 1F                      	pop ds
   614 0000051D EB4F                    	jmp execute_bin_program
   615                                  	
   616                                  load_demotour:
   617 0000051F C606830001              	mov byte [0083h], 1
   618 00000524 B8[1407]                	mov ax, demotour_name
   619 00000527 B90001                  	mov cx, 100h
   620 0000052A E86006                  	call os_load_file
   621 0000052D E8DC0F                  	call os_clear_registers
   622 00000530 E8(0001)                	call 100h
   623 00000533 E900FD                  	jmp logoinput
   624                                  	
   625                                  load_command:
   626 00000536 B8[6C06]                	mov ax, cmd_name
   627 00000539 BB[F806]                	mov bx, app_prefix
   628 0000053C B9F000                  	mov cx, 00F0h
   629 0000053F E81125                  	call os_string_join
   630 00000542 89CB                    	mov bx, cx
   631 00000544 EB00                    	jmp start_program
   632                                  	
   633                                  start_program:				; BX = program name
   634 00000546 60                      	pusha
   635 00000547 B9FD7E                  	mov cx, 7EFDh
   636 0000054A BF0001                  	mov di, 100h
   637 0000054D B000                    	mov al, 0
   638 0000054F F3AA                    	rep stosb
   639 00000551 61                      	popa
   640                                  	
   641 00000552 89D8                    	mov ax, bx
   642 00000554 B90001                  	mov cx, 100h			; Where to load the program file
   643 00000557 E83306                  	call os_load_file		; Load filename pointed to by AX
   644                                  
   645 0000055A 0F828E00                	jc systemfilemissing
   646                                  	
   647 0000055E E83A13                  	call os_show_cursor
   648                                  
   649 00000561 EB0B                    	jmp execute_bin_program
   650                                  	
   651                                  return_to_app:
   652 00000563 B8F000                  	mov ax, 00F0h
   653 00000566 B90001                  	mov cx, 100h			; Where to load the program file
   654 00000569 E82106                  	call os_load_file		; Load filename pointed to by AX
   655                                  
   656 0000056C 727E                    	jc systemfilemissing	
   657                                  
   658                                  execute_bin_program:
   659 0000056E E8DF12                  	call os_clear_screen	; Clear the screen before running
   660                                  
   661 00000571 C606820000              	mov byte [0082h], 0
   662                                  	
   663 00000576 C606[B408]01            	mov byte [app_running], 1
   664                                  
   665 0000057B 8926[B208]              	mov [origstack], sp
   666                                  	
   667 0000057F E88A0F                  	call os_clear_registers
   668                                  	
   669 00000582 E8(0001)                	call 100h	
   670                                  	
   671                                  finish:
   672 00000585 C606[B408]00            	mov byte [app_running], 0
   673                                  	
   674 0000058A E83921                  	call os_stop_adlib		; Reset everything (in case the app crashed or something)
   675 0000058D E8DE20                  	call os_speaker_off
   676                                  
   677 00000590 50                      	push ax
   678 00000591 8CC8                    	mov ax, cs
   679 00000593 8ED8                    	mov ds, ax
   680 00000595 8EC0                    	mov es, ax
   681 00000597 58                      	pop ax
   682                                  	
   683 00000598 60                      	pusha
   684 00000599 B40F                    	mov ah, 0Fh				; Get the current video mode
   685 0000059B CD10                    	int 10h
   686                                  	
   687 0000059D 3C03                    	cmp al, 3
   688 0000059F 7405                    	je .skip_gfx
   689                                  	
   690 000005A1 B80300                  	mov ax, 3
   691 000005A4 CD10                    	int 10h
   692                                  
   693                                  .skip_gfx:
   694 000005A6 B80310                  	mov ax, 1003h			; Set text output with certain attributes
   695                                  	clr bx					; to be bright, and not blinking
    11 000005A9 31DB                <1>  xor %1, %1
   696 000005AB CD10                    	int 10h
   697                                  
   698 000005AD C606820000              	mov byte [0082h], 0
   699 000005B2 C606850000              	mov byte [0085h], 0
   700                                  	
   701 000005B7 E8311E                  	call os_reset_font
   702 000005BA 61                      	popa
   703                                  	
   704 000005BB 803EFF7F01              	cmp byte [7FFFh], 1
   705 000005C0 0F849BFE                	je near launch_program
   706                                  	
   707 000005C4 803EFE7F01              	cmp byte [7FFEh], 1
   708 000005C9 0F8496FF                	je near return_to_app
   709                                  	
   710 000005CD E903FD                  	jmp checkformenu		; When finished, go back to the program list
   711                                  
   712                                  	
   713                                  ; TODO: THE CODE ABOVE NEEDS TO BE REWRITTEN
   714                                  	
   715                                  background:
   716 000005D0 60                      	pusha
   717 000005D1 B8[6003]                	mov ax, os_init_msg		; Draw main screen layout
   718 000005D4 BB[7003]                	mov bx, os_version_msg
   719 000005D7 B90001                  	mov cx, 256				; Colour: white text on light blue
   720 000005DA E89418                  	call os_draw_background
   721 000005DD 61                      	popa
   722 000005DE C3                      	ret
   723                                  
   724                                  menu_background:
   725 000005DF 60                      	pusha
   726 000005E0 803EEFDE01              	cmp byte [57071], 1
   727 000005E5 7403                    	je .done
   728                                  	
   729 000005E7 E8E6FF                  	call background
   730                                  	
   731                                  .done:
   732 000005EA 61                      	popa
   733 000005EB C3                      	ret
   734                                  	
   735                                  systemfilemissing:
   736 000005EC B8[1506]                	mov ax, noprogerror
   737 000005EF E8AE0F                  	call os_fatal_error
   738                                  	
   739                                  	; And now data for the above code...
   740                                  
   741 000005F2 0000                    	driversgmt				dw 0000h
   742                                  	
   743 000005F4 546869732066696C65-     	prog_msg				db 'This file is not an application.', 0
   743 000005FD 206973206E6F742061-
   743 00000606 6E206170706C696361-
   743 0000060F 74696F6E2E00       
   744                                  
   745 00000615 53797374656D206669-     	noprogerror				db 'System file not found', 0
   745 0000061E 6C65206E6F7420666F-
   745 00000627 756E6400           
   746                                  
   747 0000062B [5506][5A06][6106]-     	appindex1				dw edit_name, viewer_name, calc_name, clock_name, cmd_name, config_name, ascii_name, pixel_name, player_name, hwcheck_name
   747 00000631 [6606][6C06][7506]-
   747 00000637 [7C06][8506][8B06]-
   747 0000063D [9206]             
   748 0000063F [A006][A906][B106]-     	debugindex1				dw debug1_name, debug2_name, debug3_name, debug4_name, debug5_name, debug6_name, debug7_name, debug8_name
   748 00000645 [B906][C106][C706]-
   748 0000064B [CC06][D206]       
   749 0000064F [D906][E006][EC06]      	gameindex1				dw cf_name, hangman_name, tetris_name
   750                                  	
   751 00000655 4544495400              	edit_name				db 'EDIT', 0
   752 0000065A 56494557455200          	viewer_name				db 'VIEWER', 0
   753 00000661 43414C4300              	calc_name				db 'CALC', 0
   754 00000666 434C4F434B00            	clock_name				db 'CLOCK', 0
   755 0000066C 5445524D494E414C00      	cmd_name				db 'TERMINAL', 0
   756 00000675 434F4E46494700          	config_name				db 'CONFIG', 0
   757 0000067C 415343494941525400      	ascii_name				db 'ASCIIART', 0
   758 00000685 504958454C00            	pixel_name				db 'PIXEL', 0
   759 0000068B 504C4159455200          	player_name				db 'PLAYER', 0
   760 00000692 4857434845434B00        	hwcheck_name				db 'HWCHECK', 0
   761 0000069A 41424F555400            	about_name				db 'ABOUT', 0
   762                                  
   763 000006A0 4449534B5445535400      	debug1_name				db 'DISKTEST', 0
   764 000006A9 4B42445445535400        	debug2_name				db 'KBDTEST', 0
   765 000006B1 5254435445535400        	debug3_name				db 'RTCTEST', 0
   766 000006B9 4D454D4544495400        	debug4_name				db 'MEMEDIT', 0
   767 000006C1 424F58455300            	debug5_name				db 'BOXES', 0
   768 000006C7 444F545300              	debug6_name				db 'DOTS', 0
   769 000006CC 524454534300            	debug7_name				db 'RDTSC', 0
   770 000006D2 53544154494300          	debug8_name				db 'STATIC', 0
   771                                  	
   772 000006D9 43462E42415300          	cf_name					db 'CF.BAS', 0
   773 000006E0 48414E474D414E2E41-     	hangman_name				db 'HANGMAN.APP', 0
   773 000006E9 505000             
   774 000006EC 41534D545249532E41-     	tetris_name				db 'ASMTRIS.APP', 0
   774 000006F5 505000             
   775                                  	
   776 000006F8 2E                      	app_prefix				db '.'
   777 000006F9 41505000                	app_ext					db 'APP', 0
   778 000006FD 42415300                	bas_ext					db 'BAS', 0
   779                                  
   780 00000701 42472E53595300          	bg_name					db 'BG.SYS', 0
   781 00000708 46494C454D414E2E41-     	fileman_name				db 'FILEMAN.APP', 0
   781 00000711 505000             
   782 00000714 44454D4F544F55522E-     	demotour_name				db 'DEMOTOUR.APP', 0
   782 0000071D 41505000           
   783 00000721 53595354454D2E4346-     	system_cfg				db 'SYSTEM.CFG', 0
   783 0000072A 4700               
   784 0000072C 464F4E542E53595300      	font_name				db 'FONT.SYS', 0
   785                                  
   786 00000735 42415349432070726F-     	basic_finished_msg		db 'BASIC program ended', 0
   786 0000073E 6772616D20656E6465-
   786 00000747 6400               
   787                                  
   788 00000749 00                      	empty_string			db 0
   789                                  	
   790 0000074A 50726F6772616D732C-     	menuoptions				db 'Programs,Games,Log out,Shut down', 0
   790 00000753 47616D65732C4C6F67-
   790 0000075C 206F75742C53687574-
   790 00000765 20646F776E00       
   791 0000076B 436F736D696320466C-     	gameoptions				db 'Cosmic Flight,Hangman,Tetris', 0
   791 00000774 696768742C48616E67-
   791 0000077D 6D616E2C5465747269-
   791 00000786 7300               
   792 00000788 4469736B2064657465-     	debugoptions			db 'Disk detection test,Keyboard tester,RTC clock tester,Disk Sector inspector,Memory editor,Boxes,Dots,TSC register tester,TV static generator (CGA)', 0
   792 00000791 6374696F6E20746573-
   792 0000079A 742C4B6579626F6172-
   792 000007A3 64207465737465722C-
   792 000007AC 52544320636C6F636B-
   792 000007B5 207465737465722C44-
   792 000007BE 69736B20536563746F-
   792 000007C7 7220696E7370656374-
   792 000007D0 6F722C4D656D6F7279-
   792 000007D9 20656469746F722C42-
   792 000007E2 6F7865732C446F7473-
   792 000007EB 2C5453432072656769-
   792 000007F4 737465722074657374-
   792 000007FD 65722C545620737461-
   792 00000806 7469632067656E6572-
   792 0000080F 61746F722028434741-
   792 00000818 2900               
   793 0000081A 46696C65206D616E61-     	progoptions				db 'File manager,Text editor,Image viewer,Calculator,Clock,Terminal,Settings,ASCII art editor,Pixel art editor,Music player,Hardware checker,Other stuff...', 0
   793 00000823 6765722C5465787420-
   793 0000082C 656469746F722C496D-
   793 00000835 616765207669657765-
   793 0000083E 722C43616C63756C61-
   793 00000847 746F722C436C6F636B-
   793 00000850 2C5465726D696E616C-
   793 00000859 2C53657474696E6773-
   793 00000862 2C4153434949206172-
   793 0000086B 7420656469746F722C-
   793 00000874 506978656C20617274-
   793 0000087D 20656469746F722C4D-
   793 00000886 7573696320706C6179-
   793 0000088F 65722C486172647761-
   793 00000898 726520636865636B65-
   793 000008A1 722C4F746865722073-
   793 000008AA 747566662E2E2E00   
   794                                  	
   795                                  ; ------------------------------------------------------------------
   796                                  ; SYSTEM VARIABLES -- Settings for programs and system calls
   797                                  
   798                                  	; System runtime variables
   799                                  								
   800 000008B2 0000                    	origstack		dw 0		; SP before launching a program
   801                                  
   802 000008B4 00                      	app_running		db 0		; Is a program running?
   803                                  	
   804                                  ;	program_drawn	db 0		; Is the program already drawn by os_draw_background?
   805                                  	
   806                                  ; ------------------------------------------------------------------
   807                                  ; FEATURES -- Code to pull into the kernel
   808                                  
   809                                  	%INCLUDE "drivers/icons.asm"
   810                              <1> 
   811 000008B5 0910                <1> 	bomblogo	db 9, 16
   812 000008B7 000000000020006000  <1> 				db 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00100000b, 00000000b, 01100000b, 00000000b
   813 000008C0 000000000402018000  <1> 				db 00000000b, 00000000b, 00000000b, 00000000b, 00000100b, 00000010b, 00000001b, 10000000b, 00000000b
   814 000008C9 000000000084800000  <1> 				db 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 10000100b, 10000000b, 00000000b, 00000000b
   815 000008D2 0000006AA501508880  <1> 				db 00000000b, 00000000b, 00000000b, 01101010b, 10100101b, 00000001b, 01010000b, 10001000b, 10000000b
   816 000008DB 0000030000A8004000  <1> 				db 00000000b, 00000000b, 00000011b, 00000000b, 00000000b, 10101000b, 00000000b, 01000000b, 00000000b
   817 000008E4 000057540018202400  <1> 				db 00000000b, 00000000b, 01010111b, 01010100b, 00000000b, 00011000b, 00100000b, 00100100b, 00000000b
   818 000008ED 0000FFFC0080200200  <1> 				db 00000000b, 00000000b, 11111111b, 11111100b, 00000000b, 10000000b, 00100000b, 00000010b, 00000000b
   819 000008F6 005FFFFFD400200000  <1> 				db 00000000b, 01011111b, 11111111b, 11111111b, 11010100b, 00000000b, 00100000b, 00000000b, 00000000b
   820 000008FF 01FFFFFFFD00000000  <1> 				db 00000001b, 11111111b, 11111111b, 11111111b, 11111101b, 00000000b, 00000000b, 00000000b, 00000000b
   821 00000908 07FFFFFFFF40000000  <1> 				db 00000111b, 11111111b, 11111111b, 11111111b, 11111111b, 01000000b, 00000000b, 00000000b, 00000000b
   822 00000911 0FFFFFFFFFC0000000  <1> 				db 00001111b, 11111111b, 11111111b, 11111111b, 11111111b, 11000000b, 00000000b, 00000000b, 00000000b
   823 0000091A 0FFFFFFFFFC0000000  <1> 				db 00001111b, 11111111b, 11111111b, 11111111b, 11111111b, 11000000b, 00000000b, 00000000b, 00000000b
   824 00000923 0FFFFFFFFFC0000000  <1> 				db 00001111b, 11111111b, 11111111b, 11111111b, 11111111b, 11000000b, 00000000b, 00000000b, 00000000b
   825 0000092C 03FFFFFFFF00000000  <1> 				db 00000011b, 11111111b, 11111111b, 11111111b, 11111111b, 00000000b, 00000000b, 00000000b, 00000000b
   826 00000935 00FFFFFFFC00000000  <1> 				db 00000000b, 11111111b, 11111111b, 11111111b, 11111100b, 00000000b, 00000000b, 00000000b, 00000000b
   827 0000093E 000AFFFE8000000000  <1> 				db 00000000b, 00001010b, 11111111b, 11111110b, 10000000b, 00000000b, 00000000b, 00000000b, 00000000b
   828                              <1> 
   829 00000947 0408                <1> 	filelogo	db 4, 8
   830 00000949 0EAAD000            <1> 				db 00001110b, 10101010b, 11010000b, 00000000b
   831 0000094D 0C00C900            <1> 				db 00001100b, 00000000b, 11001001b, 00000000b
   832 00000951 0C00AAC0            <1> 				db 00001100b, 00000000b, 10101010b, 11000000b
   833 00000955 0C5500C0            <1> 				db 00001100b, 01010101b, 00000000b, 11000000b
   834 00000959 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
   835 0000095D 0C5554C0            <1> 				db 00001100b, 01010101b, 01010100b, 11000000b
   836 00000961 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
   837 00000965 0D5555C0            <1> 				db 00001101b, 01010101b, 01010101b, 11000000b
   838                              <1> 	
   839 00000969 1207                <1> 	logo	db 18, 7
   840 0000096B 00000FFFFF00000000- <1> 				db 00000000b, 00000000b, 00001111b, 11111111b, 11111111b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 11111111b, 00001111b, 11110000b
   840 00000974 000000000000FF0FF0  <1>
   841 0000097D 00000F000000000000- <1> 				db 00000000b, 00000000b, 00001111b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 11000011b, 00001111b, 00000000b
   841 00000986 000000000000C30F00  <1>
   842 0000098F 00000F000007FFC7FF- <1> 				db 00000000b, 00000000b, 00001111b, 00000000b, 00000000b, 00000111b, 11111111b, 11000111b, 11111111b, 11110000b, 01111111b, 11110000b, 01111111b, 11111111b, 00000000b, 11000011b, 00001111b, 11110000b
   842 00000998 F07FF07FFF00C30FF0  <1>
   843 000009A1 00000F00000F000F00- <1> 				db 00000000b, 00000000b, 00001111b, 00000000b, 00000000b, 00001111b, 00000000b, 00001111b, 00000000b, 11110000b, 11110000b, 11110000b, 11110000b, 00001111b, 00000000b, 11000011b, 00000000b, 11110000b
   843 000009AA F0F0F0F00F00C300F0  <1>
   844 000009B3 00000F00000F000F0F- <1> 				db 00000000b, 00000000b, 00001111b, 00000000b, 00000000b, 00001111b, 00000000b, 00001111b, 00001111b, 11110000b, 11111111b, 11100000b, 11110000b, 11111111b, 00000000b, 11111111b, 00001111b, 11110000b
   844 000009BC F0FFE0F0FF00FF0FF0  <1>
   845 000009C5 00000F00000F000F00- <1> 				db 00000000b, 00000000b, 00001111b, 00000000b, 00000000b, 00001111b, 00000000b, 00001111b, 00000000b, 00000000b, 11110000b, 00000000b, 11110000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b
   845 000009CE 00F000F00000000000  <1>
   846 000009D7 00000FFFFF0F000FFF- <1> 				db 00000000b, 00000000b, 00001111b, 11111111b, 11111111b, 00001111b, 00000000b, 00001111b, 11111111b, 11110000b, 11110000b, 00000000b, 11111111b, 11111111b, 00000000b, 00000000b, 00000000b, 00000000b
   846 000009E0 F0F000FFFF00000000  <1>
   847                              <1> 			
   810                                   	%INCLUDE "drivers/disk.asm"
   811                              <1> ; ==================================================================
   812                              <1> ; FAT12 FLOPPY DISK ROUTINES
   813                              <1> ; ==================================================================
   814                              <1> 
   815                              <1> ; os_report_free_space -- Returns the amount of free space on disk
   816                              <1> ; OUT: AX = Number of sectors free
   817                              <1> 
   818                              <1> os_report_free_space:
   819 000009E9 60                  <1> 	pusha
   820 000009EA C706[340A]0000      <1> 	mov word [.counter], 0
   821 000009F0 C706[360A]0000      <1> 	mov word [.sectors_read], 0
   822                              <1> 	
   823 000009F6 E8AE07              <1> 	call disk_read_fat				; Read the FAT into memory
   824 000009F9 BE00E0              <1> 	mov si, disk_buffer
   825                              <1> 	
   826                              <1> .loop:
   827                              <1> 	; 0 = nothing, 1 = 1st nibble, 2 = 2nd nibble, 3 = 3rd nibble, G = data we don't care about
   828                              <1> 
   829 000009FC 8B04                <1> 	mov ax, [si]					; AX = 3333GGGG11112222
   830 000009FE 8A7C01              <1> 	mov bh, [si + 1]				; BX = GGGG111122223333
   831 00000A01 8A5C02              <1> 	mov bl, [si + 2]
   832                              <1> 	
   833 00000A04 C1C004              <1> 	rol ax, 4						; AX = GGGG111122223333
   834                              <1> 	
   835 00000A07 80E40F              <1> 	and ah, 0Fh						; AX = 0000111122223333
   836 00000A0A 80E70F              <1> 	and bh, 0Fh						; BX = 0000111122223333
   837                              <1> 		
   838 00000A0D 83F800              <1> 	cmp ax, 0
   839 00000A10 7504                <1> 	jne .no_increment_1
   840                              <1> 	
   841 00000A12 FF06[340A]          <1> 	inc word [.counter]
   842                              <1> 	
   843                              <1> .no_increment_1:
   844 00000A16 83FB00              <1> 	cmp bx, 0
   845                              <1> 		
   846 00000A19 7504                <1> 	jne .no_increment_2
   847                              <1> 	
   848 00000A1B FF06[340A]          <1> 	inc word [.counter]
   849                              <1> 	
   850                              <1> .no_increment_2:
   851 00000A1F 83C603              <1> 	add si, 3						; Increment the pointer
   852 00000A22 8306[360A]02        <1> 	add word [.sectors_read], 2		; Increment the counter of sectors
   853                              <1> 	
   854 00000A27 813E[360A]1F0B      <1> 	cmp word [.sectors_read], 2847	; Are we done? (33 of the sectors are the bootloader, FAT and root dir)
   855 00000A2D 7CCD                <1> 	jl .loop
   856                              <1> 	
   857 00000A2F 61                  <1> 	popa
   858 00000A30 A1[340A]            <1> 	mov ax, [.counter]
   859                              <1> 
   860 00000A33 C3                  <1> 	ret
   861                              <1> 	
   862 00000A34 0000                <1> 	.counter		dw 0
   863 00000A36 0000                <1> 	.sectors_read	dw 0
   864                              <1> 	
   865                              <1> ; --------------------------------------------------------------------------
   866                              <1> ; os_read_root -- Get the root directory contents
   867                              <1> ; IN: SI = where to store the root directory; OUT: carry set if error
   868                              <1> 
   869                              <1> os_read_root:
   870 00000A38 60                  <1> 	pusha
   871                              <1> 
   872 00000A39 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   873 00000A3C E80B08              <1> 	call disk_convert_l2hts
   874                              <1> 
   875 00000A3F 8CDB                <1> 	mov bx, ds
   876 00000A41 8EC3                <1> 	mov es, bx
   877 00000A43 89F3                <1> 	mov bx, si
   878                              <1> 
   879 00000A45 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
   880 00000A47 B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
   881                              <1> 
   882 00000A49 60                  <1> 	pusha				; Prepare to enter loop
   883                              <1> 
   884                              <1> 
   885                              <1> .read_root_dir_loop:
   886 00000A4A 61                  <1> 	popa
   887 00000A4B 60                  <1> 	pusha
   888                              <1> 
   889 00000A4C F9                  <1> 	stc				; A few BIOSes do not set properly on error
   890 00000A4D CD13                <1> 	int 13h				; Read sectors
   891                              <1> 
   892 00000A4F 7308                <1> 	jnc .root_dir_finished
   893 00000A51 E8E707              <1> 	call disk_reset_floppy		; Reset controller and try again
   894 00000A54 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
   895                              <1> 
   896 00000A56 61                  <1> 	popa
   897 00000A57 EB04                <1> 	jmp .read_failure		; Fatal double error
   898                              <1> 
   899                              <1> 
   900                              <1> .root_dir_finished:
   901 00000A59 61                  <1> 	popa				; Restore registers from main loop
   902                              <1> 
   903 00000A5A 61                  <1> 	popa				; And restore from start of this system call
   904                              <1> 
   905 00000A5B F8                  <1> 	clc				; Clear carry (for success)
   906 00000A5C C3                  <1> 	ret
   907                              <1> 
   908                              <1> .read_failure:
   909 00000A5D 61                  <1> 	popa
   910                              <1> 
   911 00000A5E F9                  <1> 	stc				; Set carry flag (for failure)
   912 00000A5F C3                  <1> 	ret
   913                              <1> 
   914                              <1> ; ------------------------------------------------------------------
   915                              <1> ; os_get_file_list -- Generate comma-separated string of files on floppy
   916                              <1> ; IN/OUT: AX = location to store zero-terminated filename string,
   917                              <1> ;         If [0087h] = 1, then BX = location of file extension list
   918                              <1> 
   919                              <1> os_get_file_list:
   920 00000A60 60                  <1> 	pusha
   921                              <1> 
   922 00000A61 C606[450B]00        <1> 	mov byte [.num_entries], 0
   923 00000A66 891E[460B]          <1> 	mov [.extension_list], bx
   924                              <1> 	
   925 00000A6A BE[4A0B]            <1> 	mov si, .msg_load
   926 00000A6D E81619              <1> 	call os_print_footer
   927                              <1> 	
   928 00000A70 A3[480B]            <1> 	mov word [.file_list_tmp], ax
   929                              <1> 
   930 00000A73 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
   931                              <1> 
   932 00000A79 E8BF07              <1> 	call disk_reset_floppy		; Just in case disk was changed
   933                              <1> 
   934 00000A7C B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   935 00000A7F E8C807              <1> 	call disk_convert_l2hts
   936                              <1> 
   937 00000A82 BE00E0              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
   938 00000A85 89F3                <1> 	mov bx, si
   939                              <1> 
   940 00000A87 B80E02              <1> 	mov ax, 2 * 256 + 14	; Params for int 13h: read floppy sectors
   941                              <1> 
   942 00000A8A 60                  <1> 	pusha				; Prepare to enter loop
   943                              <1> 
   944                              <1> 
   945                              <1> .read_root_dir:
   946 00000A8B 61                  <1> 	popa
   947 00000A8C 60                  <1> 	pusha
   948                              <1> 
   949 00000A8D F9                  <1> 	stc
   950 00000A8E CD13                <1> 	int 13h				; Read sectors
   951 00000A90 E8A807              <1> 	call disk_reset_floppy		; Check we've read them OK
   952 00000A93 730B                <1> 	jnc .show_dir_init		; No errors, continue
   953                              <1> 
   954 00000A95 E8A307              <1> 	call disk_reset_floppy		; Error = reset controller and try again
   955 00000A98 73F1                <1> 	jnc .read_root_dir
   956                              <1> 
   957 00000A9A B8[690B]            <1> 	mov ax, .error
   958 00000A9D E8000B              <1> 	call os_fatal_error
   959                              <1> 	
   960                              <1> .show_dir_init:
   961 00000AA0 61                  <1> 	popa
   962                              <1> 
   963 00000AA1 B80000              <1> 	mov ax, 0
   964 00000AA4 BE00E0              <1> 	mov si, disk_buffer		; Data reader from start of filenames
   965                              <1> 
   966 00000AA7 8B3E[480B]          <1> 	mov word di, [.file_list_tmp]	; Name destination buffer
   967                              <1> 
   968                              <1> 
   969                              <1> .start_entry:
   970 00000AAB 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
   971 00000AAE 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
   972 00000AB0 7478                <1> 	je .skip
   973                              <1> 
   974 00000AB2 A808                <1> 	test al, 08h			; Is this a directory entry or volume label?
   975 00000AB4 7574                <1> 	jnz .skip			; Yes, ignore it
   976                              <1> 
   977 00000AB6 8A04                <1> 	mov al, [si]
   978 00000AB8 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
   979 00000ABA 746E                <1> 	je .skip
   980                              <1> 
   981 00000ABC 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
   982 00000ABE 7470                <1> 	je .done
   983                              <1> 	
   984 00000AC0 B90100              <1> 	mov cx, 1			; Set char counter
   985 00000AC3 89F2                <1> 	mov dx, si			; Beginning of possible entry
   986                              <1> 
   987                              <1> .testdirentry:
   988 00000AC5 46                  <1> 	inc si
   989 00000AC6 8A04                <1> 	mov al, [si]			; Test for most unusable characters
   990 00000AC8 3C20                <1> 	cmp al, ' '			; Windows sometimes puts 0 (UTF-8) or 0FFh
   991 00000ACA 7C5C                <1> 	jl .nxtdirentry
   992 00000ACC 3C7E                <1> 	cmp al, '~'
   993 00000ACE 7758                <1> 	ja .nxtdirentry
   994                              <1> 
   995 00000AD0 41                  <1> 	inc cx
   996 00000AD1 83F90B              <1> 	cmp cx, 11			; Done 11 char filename?
   997 00000AD4 7402                <1> 	je .gotfilename
   998 00000AD6 EBED                <1> 	jmp .testdirentry
   999                              <1> 
  1000                              <1> 
  1001                              <1> .gotfilename:				; Got a filename that passes testing
  1002 00000AD8 89D6                <1> 	mov si, dx			; DX = where getting string
  1003                              <1> 
  1004 00000ADA 803E870001          <1> 	cmp byte [0087h], 1
  1005 00000ADF 7522                <1> 	jne .no_extension_check
  1006                              <1> 	
  1007 00000AE1 8B1E[460B]          <1> 	mov bx, [.extension_list]
  1008 00000AE5 0FB60F              <1> 	movzx cx, byte [bx]
  1009                              <1> 
  1010                              <1> .extension_loop:
  1011 00000AE8 60                  <1> 	pusha
  1012 00000AE9 83C608              <1> 	add si, 8
  1013                              <1> 	
  1014 00000AEC 49                  <1> 	dec cx
  1015 00000AED 89CF                <1> 	mov di, cx
  1016 00000AEF C1E702              <1> 	shl di, 2	; Each entry is 4 bytes long
  1017 00000AF2 47                  <1> 	inc di		; The entry list starts with a 1-byte header
  1018 00000AF3 033E[460B]          <1> 	add di, [.extension_list]	
  1019                              <1> 	
  1020 00000AF7 B90300              <1> 	mov cx, 3
  1021 00000AFA F3A6                <1> 	rep cmpsb
  1022 00000AFC 61                  <1> 	popa
  1023 00000AFD 7404                <1> 	je .no_extension_check
  1024                              <1> 	
  1025 00000AFF E2E7                <1> 	loop .extension_loop
  1026                              <1> 	
  1027 00000B01 EB25                <1> 	jmp .nxtdirentry
  1028                              <1> 	
  1029                              <1> .no_extension_check:
  1030 00000B03 31C9                <1> 	xor cx, cx
  1031                              <1> 	
  1032                              <1> .loopy:
  1033 00000B05 AC                  <1> 	lodsb
  1034 00000B06 3C20                <1> 	cmp al, ' '
  1035 00000B08 7401                <1> 	je .ignore_space
  1036 00000B0A AA                  <1> 	stosb
  1037                              <1> 	
  1038                              <1> .ignore_space:
  1039 00000B0B 41                  <1> 	inc cx
  1040 00000B0C 83F908              <1> 	cmp cx, 8
  1041 00000B0F 7407                <1> 	je .add_dot
  1042 00000B11 83F90B              <1> 	cmp cx, 11
  1043 00000B14 7409                <1> 	je .done_copy
  1044 00000B16 EBED                <1> 	jmp .loopy
  1045                              <1> 
  1046                              <1> .add_dot:
  1047 00000B18 26C6052E            <1> 	mov byte [es:di], '.'
  1048 00000B1C 47                  <1> 	inc di
  1049 00000B1D EBE6                <1> 	jmp .loopy
  1050                              <1> 
  1051                              <1> .done_copy:
  1052 00000B1F 26C6052C            <1> 	mov byte [es:di], ','		; Use comma to separate filenames
  1053 00000B23 47                  <1> 	inc di
  1054 00000B24 FE06[450B]          <1> 	inc byte [.num_entries]
  1055                              <1> 	
  1056                              <1> .nxtdirentry:
  1057 00000B28 89D6                <1> 	mov si, dx			; Start of entry, pretend to skip to next
  1058                              <1> 
  1059                              <1> .skip:
  1060 00000B2A 83C620              <1> 	add si, 32			; Shift to next 32 bytes (next filename)
  1061 00000B2D E97BFF              <1> 	jmp .start_entry
  1062                              <1> 
  1063                              <1> 
  1064                              <1> .done:
  1065 00000B30 803E[450B]00        <1> 	cmp byte [.num_entries], 0
  1066 00000B35 7401                <1> 	je .no_dec
  1067                              <1> 	
  1068 00000B37 4F                  <1> 	dec di
  1069                              <1> 
  1070                              <1> .no_dec:
  1071 00000B38 26C60500            <1> 	mov byte [es:di], 0		; Zero-terminate string (gets rid of final comma)
  1072                              <1> 
  1073 00000B3C 60                  <1> 	pusha
  1074 00000B3D 31F6                <1> 	xor si, si
  1075 00000B3F E84418              <1> 	call os_print_footer
  1076 00000B42 61                  <1> 	popa
  1077                              <1> 
  1078 00000B43 61                  <1> 	popa
  1079                              <1> 
  1080 00000B44 C3                  <1> 	ret
  1081                              <1> 
  1082 00000B45 00                  <1> 	.num_entries		db 0
  1083 00000B46 0000                <1> 	.extension_list		dw 0
  1084 00000B48 0000                <1> 	.file_list_tmp		dw 0
  1085 00000B4A 2052656164696E6720- <1> 	.msg_load			db ' Reading directory contents...', 0
  1085 00000B53 6469726563746F7279- <1>
  1085 00000B5C 20636F6E74656E7473- <1>
  1085 00000B65 2E2E2E00            <1>
  1086 00000B69 6F735F6765745F6669- <1> 	.error				db 'os_get_file_list: Floppy reset fail', 0
  1086 00000B72 6C655F6C6973743A20- <1>
  1086 00000B7B 466C6F707079207265- <1>
  1086 00000B84 736574206661696C00  <1>
  1087                              <1> 	
  1088                              <1> ; ------------------------------------------------------------------
  1089                              <1> ; os_load_file -- Load a file into RAM
  1090                              <1> ; IN: AX = location of filename, ES:CX = location in RAM to load file
  1091                              <1> ; OUT: BX = file size (in bytes), carry set if file not found
  1092                              <1> 
  1093                              <1> os_load_file:
  1094 00000B8D 06                  <1> 	push es
  1095 00000B8E 8C06[E30C]          <1> 	mov [.old_segment], es
  1096                              <1> 
  1097 00000B92 0E                  <1> 	push cs
  1098 00000B93 07                  <1> 	pop es
  1099                              <1> 	
  1100 00000B94 E8791E              <1> 	call os_string_uppercase
  1101                              <1> 
  1102 00000B97 60                  <1> 	pusha							; Message display routine
  1103 00000B98 89C3                <1> 	mov bx, ax
  1104 00000B9A B8[E50C]            <1> 	mov ax, .msg_load
  1105 00000B9D B95200              <1> 	mov cx, 82
  1106 00000BA0 E8B01E              <1> 	call os_string_join
  1107 00000BA3 BE5200              <1> 	mov si, 82
  1108 00000BA6 E8DD17              <1> 	call os_print_footer
  1109 00000BA9 61                  <1> 	popa
  1110                              <1> 	
  1111 00000BAA E83D05              <1> 	call int_filename_convert
  1112                              <1> 
  1113 00000BAD A3[BB0C]            <1> 	mov [.filename_loc], ax		; Store filename location
  1114 00000BB0 890E[BD0C]          <1> 	mov [.load_position], cx	; And where to load the file!
  1115                              <1> 
  1116 00000BB4 6631C0              <1> 	xor eax, eax			; Needed for some older BIOSes
  1117                              <1> 
  1118 00000BB7 E88106              <1> 	call disk_reset_floppy		; In case floppy has been changed
  1119 00000BBA 7306                <1> 	jnc .floppy_ok			; Did the floppy reset OK?
  1120                              <1> 
  1121 00000BBC B8[C30C]            <1> 	mov ax, .err_msg_floppy_reset	; If not, bail out
  1122 00000BBF E9DE09              <1> 	jmp os_fatal_error
  1123                              <1> 
  1124                              <1> 
  1125                              <1> .floppy_ok:				; Ready to read first block of data
  1126 00000BC2 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1127 00000BC5 E88206              <1> 	call disk_convert_l2hts
  1128                              <1> 
  1129 00000BC8 BE00E0              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
  1130 00000BCB 89F3                <1> 	mov bx, si
  1131                              <1> 
  1132 00000BCD B80E02              <1> 	mov ax, 2 * 256 + 14	; Params for int 13h: read floppy sectors
  1133                              <1> 
  1134 00000BD0 60                  <1> 	pusha				; Prepare to enter loop
  1135                              <1> 
  1136                              <1> 
  1137                              <1> .read_root_dir:
  1138 00000BD1 61                  <1> 	popa
  1139 00000BD2 60                  <1> 	pusha
  1140                              <1> 
  1141 00000BD3 F9                  <1> 	stc				; A few BIOSes clear, but don't set properly
  1142                              <1> 	
  1143 00000BD4 CD13                <1> 	int 13h				; Read sectors
  1144 00000BD6 7308                <1> 	jnc .search_root_dir		; No errors = continue
  1145                              <1> 
  1146 00000BD8 E86006              <1> 	call disk_reset_floppy		; Problem = reset controller and try again
  1147 00000BDB 73F4                <1> 	jnc .read_root_dir
  1148                              <1> 
  1149 00000BDD 61                  <1> 	popa
  1150 00000BDE EB38                <1> 	jmp .root_problem		; Double error = exit
  1151                              <1> 
  1152                              <1> .search_root_dir:
  1153 00000BE0 61                  <1> 	popa
  1154                              <1> 
  1155 00000BE1 B9E000              <1> 	mov cx, 224		; Search all entries in root dir
  1156 00000BE4 BBE0FF              <1> 	mov bx, -32			; Begin searching at offset 0 in root dir
  1157                              <1> 
  1158                              <1> .next_root_entry:
  1159 00000BE7 83C320              <1> 	add bx, 32			; Bump searched entries by 1 (offset + 32 bytes)
  1160 00000BEA BF00E0              <1> 	mov di, disk_buffer		; Point root dir at next entry
  1161 00000BED 01DF                <1> 	add di, bx
  1162                              <1> 
  1163 00000BEF 8A05                <1> 	mov al, [di]			; First character of name
  1164                              <1> 
  1165 00000BF1 3C00                <1> 	cmp al, 0			; Last file name already checked?
  1166 00000BF3 7423                <1> 	je .root_problem
  1167                              <1> 
  1168 00000BF5 3CE5                <1> 	cmp al, 229			; Was this file deleted?
  1169 00000BF7 74EE                <1> 	je .next_root_entry		; If yes, skip it
  1170                              <1> 
  1171 00000BF9 8A450B              <1> 	mov al, [di+11]			; Get the attribute byte
  1172                              <1> 
  1173 00000BFC 3C0F                <1> 	cmp al, 0Fh			; Is this a special Windows entry?
  1174 00000BFE 74E7                <1> 	je .next_root_entry
  1175                              <1> 
  1176 00000C00 A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
  1177 00000C02 75E3                <1> 	jnz .next_root_entry
  1178                              <1> 
  1179 00000C04 C6450B00            <1> 	mov byte [di+11], 0		; Add a terminator to directory name entry
  1180                              <1> 
  1181 00000C08 89F8                <1> 	mov ax, di			; Convert root buffer name to upper case
  1182 00000C0A E8031E              <1> 	call os_string_uppercase
  1183                              <1> 
  1184 00000C0D 8B36[BB0C]          <1> 	mov si, [.filename_loc]		; DS:SI = location of filename to load
  1185                              <1> 
  1186 00000C11 E8951E              <1> 	call os_string_compare		; Current entry same as requested?
  1187 00000C14 7208                <1> 	jc .found_file_to_load
  1188                              <1> 
  1189 00000C16 E2CF                <1> 	loop .next_root_entry
  1190                              <1> 
  1191                              <1> .root_problem:
  1192 00000C18 BB0000              <1> 	mov bx, 0			; If file not found or major disk error,
  1193 00000C1B 07                  <1> 	pop es
  1194                              <1> 
  1195 00000C1C F9                  <1> 	stc				; return with size = 0 and carry set
  1196 00000C1D C3                  <1> 	ret
  1197                              <1> 
  1198                              <1> 
  1199                              <1> .found_file_to_load:			; Now fetch cluster and load FAT into RAM
  1200 00000C1E 668B451C            <1> 	mov eax, [di+28]			; Store file size to return to calling routine
  1201 00000C22 66A3[BF0C]          <1> 	mov [.file_size], eax
  1202                              <1> 
  1203 00000C26 6683F800            <1> 	cmp eax, 0			; If the file size is zero, don't bother trying
  1204 00000C2A 747B                <1> 	je .end				; to read more clusters
  1205                              <1> 
  1206 00000C2C 8B451A              <1> 	mov ax, [di+26]			; Now fetch cluster and load FAT into RAM
  1207 00000C2F A3[B70C]            <1> 	mov word [.cluster], ax
  1208                              <1> 
  1209 00000C32 B80100              <1> 	mov ax, 1			; Sector 1 = first sector of first FAT
  1210 00000C35 E81206              <1> 	call disk_convert_l2hts
  1211                              <1> 
  1212 00000C38 BB00E0              <1> 	mov bx, disk_buffer		; ES:BX points to our buffer
  1213                              <1> 
  1214 00000C3B B402                <1> 	mov ah, 2			; int 13h params: read sectors
  1215 00000C3D B009                <1> 	mov al, 9			; And read 9 of them
  1216                              <1> 
  1217 00000C3F 60                  <1> 	pusha
  1218                              <1> 
  1219                              <1> .read_fat:
  1220 00000C40 61                  <1> 	popa				; In case registers altered by int 13h
  1221 00000C41 60                  <1> 	pusha
  1222                              <1> 
  1223 00000C42 F9                  <1> 	stc
  1224 00000C43 CD13                <1> 	int 13h
  1225 00000C45 7308                <1> 	jnc .read_fat_ok
  1226                              <1> 
  1227 00000C47 E8F105              <1> 	call disk_reset_floppy
  1228 00000C4A 73F4                <1> 	jnc .read_fat
  1229                              <1> 
  1230 00000C4C 61                  <1> 	popa
  1231 00000C4D EBC9                <1> 	jmp .root_problem
  1232                              <1> 
  1233                              <1> 
  1234                              <1> .read_fat_ok:
  1235 00000C4F 61                  <1> 	popa
  1236                              <1> 
  1237                              <1> 
  1238                              <1> .load_file_sector:
  1239 00000C50 A1[B70C]            <1> 	mov ax, word [.cluster]		; Convert sector to logical
  1240 00000C53 83C01F              <1> 	add ax, 31
  1241                              <1> 
  1242 00000C56 E8F105              <1> 	call disk_convert_l2hts		; Make appropriate params for int 13h
  1243                              <1> 
  1244 00000C59 8B1E[BD0C]          <1> 	mov bx, [.load_position]
  1245 00000C5D 8E06[E30C]          <1> 	mov es, [.old_segment]
  1246                              <1> 
  1247 00000C61 B80102              <1> 	mov ax, 0201h			; AH = read sectors, AL = just read 1
  1248                              <1> 
  1249 00000C64 F9                  <1> 	stc
  1250 00000C65 CD13                <1> 	int 13h
  1251                              <1> 
  1252 00000C67 0E                  <1> 	push cs
  1253 00000C68 07                  <1> 	pop es
  1254                              <1> 	
  1255 00000C69 730B                <1> 	jnc .calculate_next_cluster	; If there's no error...
  1256                              <1> 
  1257 00000C6B E8CD05              <1> 	call disk_reset_floppy		; Otherwise, reset floppy and retry
  1258 00000C6E 73E0                <1> 	jnc .load_file_sector
  1259                              <1> 
  1260 00000C70 B8[C30C]            <1> 	mov ax, .err_msg_floppy_reset	; Reset failed, bail out
  1261 00000C73 E92A09              <1> 	jmp os_fatal_error
  1262                              <1> 
  1263                              <1> 
  1264                              <1> .calculate_next_cluster:
  1265 00000C76 A1[B70C]            <1> 	mov ax, [.cluster]
  1266 00000C79 BB0300              <1> 	mov bx, 3
  1267 00000C7C F7E3                <1> 	mul bx
  1268 00000C7E BB0200              <1> 	mov bx, 2
  1269 00000C81 F7F3                <1> 	div bx				; DX = [CLUSTER] mod 2
  1270 00000C83 BE00E0              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
  1271 00000C86 01C6                <1> 	add si, ax
  1272 00000C88 3E8B04              <1> 	mov ax, word [ds:si]
  1273                              <1> 
  1274 00000C8B 83FA00              <1> 	cmp dx, 0			; If DX = 0 [CLUSTER] = even, if DX = 1 then odd
  1275 00000C8E 7405                <1> 	je .even			; If [CLUSTER] = even, drop last 4 bits of word
  1276                              <1> 					; with next cluster; if odd, drop first 4 bits
  1277                              <1> 
  1278                              <1> .odd:
  1279 00000C90 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (belong to another entry)
  1280 00000C93 EB03                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
  1281                              <1> 
  1282                              <1> .even:
  1283 00000C95 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits
  1284                              <1> 
  1285                              <1> .calculate_cluster_cont:
  1286 00000C98 A3[B70C]            <1> 	mov word [.cluster], ax		; Store cluster
  1287                              <1> 
  1288 00000C9B 3DF80F              <1> 	cmp ax, 0FF8h
  1289 00000C9E 7D07                <1> 	jge .end
  1290                              <1> 
  1291 00000CA0 8306[E30C]20        <1> 	add word [.old_segment], 512 / 16
  1292 00000CA5 EBA9                <1> 	jmp .load_file_sector		; Onto next sector!
  1293                              <1> 
  1294                              <1> 
  1295                              <1> .end:
  1296 00000CA7 668B1E[BF0C]        <1> 	mov ebx, [.file_size]		; Get file size to pass back in BX
  1297 00000CAC 60                  <1> 	pusha
  1298 00000CAD 31F6                <1> 	xor si, si
  1299 00000CAF E8D416              <1> 	call os_print_footer
  1300 00000CB2 61                  <1> 	popa
  1301 00000CB3 07                  <1> 	pop es
  1302                              <1> 
  1303 00000CB4 F8                  <1> 	clc				; Carry clear = good load
  1304 00000CB5 C3                  <1> 	ret
  1305                              <1> 
  1306                              <1> 
  1307 00000CB6 00                  <1> 	.bootd					db 0 		; Boot device number
  1308 00000CB7 0000                <1> 	.cluster				dw 0 		; Cluster of the file we want to load
  1309 00000CB9 0000                <1> 	.pointer				dw 0 		; Pointer into disk_buffer, for loading 'file2load'
  1310                              <1> 
  1311 00000CBB 0000                <1> 	.filename_loc			dw 0		; Temporary store of filename location
  1312 00000CBD 0000                <1> 	.load_position			dw 0		; Where we'll load the file
  1313 00000CBF 00000000            <1> 	.file_size				dd 0		; Size of the file
  1314                              <1> 
  1315 00000CC3 6F735F6C6F61645F66- <1> 	.err_msg_floppy_reset	db 'os_load_file: Floppy reset fail', 0
  1315 00000CCC 696C653A20466C6F70- <1>
  1315 00000CD5 707920726573657420- <1>
  1315 00000CDE 6661696C00          <1>
  1316                              <1> 
  1317 00000CE3 0000                <1> 	.old_segment			dw 0
  1318                              <1> 	
  1319 00000CE5 204C6F6164696E6720- <1> 	.msg_load				db ' Loading ', 0
  1319 00000CEE 00                  <1>
  1320                              <1> 	
  1321                              <1> ; --------------------------------------------------------------------------
  1322                              <1> ; os_write_file -- Save (max 64K) file to disk
  1323                              <1> ; IN: AX = filename, ES:BX = data location, CX = bytes to write
  1324                              <1> ; OUT: Carry clear if OK, set if failure
  1325                              <1> 
  1326                              <1> os_write_file:
  1327 00000CEF 60                  <1> 	pusha
  1328                              <1> 	
  1329 00000CF0 8C06[C60E]          <1> 	mov [.old_segment], es
  1330                              <1> 	
  1331 00000CF4 0E                  <1> 	push cs
  1332 00000CF5 07                  <1> 	pop es
  1333                              <1> 		
  1334 00000CF6 60                  <1> 	pusha							; Message display routine
  1335 00000CF7 89C3                <1> 	mov bx, ax
  1336 00000CF9 B8[C80E]            <1> 	mov ax, .msg_save
  1337 00000CFC B95200              <1> 	mov cx, 82
  1338 00000CFF E8511D              <1> 	call os_string_join
  1339 00000D02 BE5200              <1> 	mov si, 82
  1340 00000D05 E87E16              <1> 	call os_print_footer
  1341 00000D08 61                  <1> 	popa
  1342                              <1> 
  1343 00000D09 89C6                <1> 	mov si, ax
  1344 00000D0B E8A91C              <1> 	call os_string_length
  1345 00000D0E 83F800              <1> 	cmp ax, 0
  1346 00000D11 0F849601            <1> 	je near .failure
  1347 00000D15 89F0                <1> 	mov ax, si
  1348                              <1> 
  1349 00000D17 E8F61C              <1> 	call os_string_uppercase
  1350                              <1> 
  1351 00000D1A E8CD03              <1> 	call int_filename_convert	; Make filename FAT12-style
  1352 00000D1D 0F828A01            <1> 	jc near .failure
  1353                              <1> 
  1354 00000D21 890E[BA0E]          <1> 	mov word [.filesize], cx
  1355 00000D25 891E[C00E]          <1> 	mov word [.location], bx
  1356 00000D29 A3[C40E]            <1> 	mov word [.filename], ax
  1357                              <1> 
  1358 00000D2C E8A201              <1> 	call os_file_exists		; Don't overwrite a file if it exists!
  1359 00000D2F 0F837801            <1> 	jnc near .failure
  1360                              <1> 
  1361                              <1> 
  1362                              <1> 	; First, zero out the .free_clusters list from any previous execution
  1363 00000D33 60                  <1> 	pusha
  1364                              <1> 
  1365 00000D34 BF00FF              <1> 	mov di, .free_clusters
  1366 00000D37 B98000              <1> 	mov cx, 128
  1367                              <1> .clean_free_loop:
  1368 00000D3A C7050000            <1> 	mov word [di], 0
  1369 00000D3E 47                  <1> 	inc di
  1370 00000D3F 47                  <1> 	inc di
  1371 00000D40 E2F8                <1> 	loop .clean_free_loop
  1372                              <1> 
  1373 00000D42 61                  <1> 	popa
  1374                              <1> 
  1375                              <1> 
  1376                              <1> 	; Next, we need to calculate now many 512 byte clusters are required
  1377                              <1> 
  1378 00000D43 89C8                <1> 	mov ax, cx
  1379 00000D45 31D2                <1> 	xor dx, dx
  1380 00000D47 BB0002              <1> 	mov bx, 512			; Divide file size by 512 to get clusters needed
  1381 00000D4A F7F3                <1> 	div bx
  1382 00000D4C 83FA00              <1> 	cmp dx, 0
  1383 00000D4F 7F02                <1> 	jg .add_a_bit			; If there's a remainder, we need another cluster
  1384 00000D51 EB03                <1> 	jmp .carry_on
  1385                              <1> 
  1386                              <1> .add_a_bit:
  1387 00000D53 83C001              <1> 	add ax, 1
  1388                              <1> .carry_on:
  1389                              <1> 
  1390 00000D56 A3[C20E]            <1> 	mov word [.clusters_needed], ax
  1391                              <1> 
  1392 00000D59 A1[C40E]            <1> 	mov word ax, [.filename]	; Get filename back
  1393                              <1> 
  1394 00000D5C E89301              <1> 	call os_create_file		; Create empty root dir entry for this file
  1395 00000D5F 0F824801            <1> 	jc near .failure		; If we can't write to the media, jump out
  1396                              <1> 
  1397 00000D63 8B1E[BA0E]          <1> 	mov word bx, [.filesize]
  1398 00000D67 83FB00              <1> 	cmp bx, 0
  1399 00000D6A 0F842F01            <1> 	je near .finished
  1400                              <1> 
  1401 00000D6E E83604              <1> 	call disk_read_fat		; Get FAT copy into RAM
  1402 00000D71 BE03E0              <1> 	mov si, disk_buffer + 3		; And point SI at it (skipping first two clusters)
  1403                              <1> 
  1404 00000D74 BB0200              <1> 	mov bx, 2			; Current cluster counter
  1405 00000D77 8B0E[C20E]          <1> 	mov word cx, [.clusters_needed]
  1406 00000D7B 31D2                <1> 	xor dx, dx			; Offset in .free_clusters list
  1407                              <1> 
  1408                              <1> .find_free_cluster:
  1409 00000D7D AD                  <1> 	lodsw				; Get a word
  1410 00000D7E 25FF0F              <1> 	and ax, 0FFFh			; Mask out for even
  1411 00000D81 740D                <1> 	jz .found_free_even		; Free entry?
  1412                              <1> 
  1413                              <1> .more_odd:
  1414 00000D83 43                  <1> 	inc bx				; If not, bump our counter
  1415 00000D84 4E                  <1> 	dec si				; 'lodsw' moved on two chars; we only want to move on one
  1416                              <1> 
  1417 00000D85 AD                  <1> 	lodsw				; Get word
  1418 00000D86 C1E804              <1> 	shr ax, 4			; Shift for odd
  1419 00000D89 09C0                <1> 	or ax, ax			; Free entry?
  1420 00000D8B 7413                <1> 	jz .found_free_odd
  1421                              <1> 
  1422                              <1> .more_even:
  1423 00000D8D 43                  <1> 	inc bx				; If not, keep going
  1424 00000D8E EBED                <1> 	jmp .find_free_cluster
  1425                              <1> 
  1426                              <1> 
  1427                              <1> .found_free_even:
  1428 00000D90 56                  <1> 	push si
  1429 00000D91 BE00FF              <1> 	mov si, .free_clusters		; Store cluster
  1430 00000D94 01D6                <1> 	add si, dx
  1431 00000D96 891C                <1> 	mov word [si], bx
  1432 00000D98 5E                  <1> 	pop si
  1433                              <1> 
  1434 00000D99 49                  <1> 	dec cx				; Got all the clusters we need?
  1435 00000D9A E314                <1> 	jcxz .finished_list
  1436                              <1> 
  1437 00000D9C 42                  <1> 	inc dx				; Next word in our list
  1438 00000D9D 42                  <1> 	inc dx
  1439 00000D9E EBE3                <1> 	jmp .more_odd
  1440                              <1> 
  1441                              <1> .found_free_odd:
  1442 00000DA0 56                  <1> 	push si
  1443 00000DA1 BE00FF              <1> 	mov si, .free_clusters		; Store cluster
  1444 00000DA4 01D6                <1> 	add si, dx
  1445 00000DA6 891C                <1> 	mov word [si], bx
  1446 00000DA8 5E                  <1> 	pop si
  1447                              <1> 
  1448 00000DA9 49                  <1> 	dec cx
  1449 00000DAA E304                <1> 	jcxz .finished_list
  1450                              <1> 
  1451 00000DAC 42                  <1> 	inc dx				; Next word in our list
  1452 00000DAD 42                  <1> 	inc dx
  1453 00000DAE EBDD                <1> 	jmp .more_even
  1454                              <1> 
  1455                              <1> 
  1456                              <1> 
  1457                              <1> .finished_list:
  1458                              <1> 
  1459                              <1> 	; Now the .free_clusters table contains a series of numbers (words)
  1460                              <1> 	; that correspond to free clusters on the disk; the next job is to
  1461                              <1> 	; create a cluster chain in the FAT for our file
  1462                              <1> 
  1463 00000DB0 31C9                <1> 	xor cx, cx			; .free_clusters offset counter
  1464 00000DB2 C706[BE0E]0100      <1> 	mov word [.count], 1		; General cluster counter
  1465                              <1> 
  1466                              <1> .chain_loop:
  1467 00000DB8 A1[BE0E]            <1> 	mov word ax, [.count]		; Is this the last cluster?
  1468 00000DBB 3B06[C20E]          <1> 	cmp word ax, [.clusters_needed]
  1469 00000DBF 7454                <1> 	je .last_cluster
  1470                              <1> 
  1471 00000DC1 BF00FF              <1> 	mov di, .free_clusters
  1472                              <1> 
  1473 00000DC4 01CF                <1> 	add di, cx
  1474 00000DC6 8B1D                <1> 	mov word bx, [di]		; Get cluster
  1475                              <1> 
  1476 00000DC8 89D8                <1> 	mov ax, bx			; Find out if it's an odd or even cluster
  1477 00000DCA 31D2                <1> 	xor dx, dx
  1478 00000DCC BB0300              <1> 	mov bx, 3
  1479 00000DCF F7E3                <1> 	mul bx
  1480 00000DD1 BB0200              <1> 	mov bx, 2
  1481 00000DD4 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
  1482 00000DD6 BE00E0              <1> 	mov si, disk_buffer
  1483 00000DD9 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
  1484 00000DDB 3E8B04              <1> 	mov ax, word [ds:si]
  1485                              <1> 
  1486 00000DDE 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
  1487 00000DE0 741B                <1> 	jz .even
  1488                              <1> 
  1489                              <1> .odd:
  1490 00000DE2 83E00F              <1> 	and ax, 000Fh			; Zero out bits we want to use
  1491 00000DE5 BF00FF              <1> 	mov di, .free_clusters
  1492 00000DE8 01CF                <1> 	add di, cx			; Get offset in .free_clusters
  1493 00000DEA 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT cluster
  1494 00000DED C1E304              <1> 	shl bx, 4			; And convert it into right format for FAT
  1495 00000DF0 01D8                <1> 	add ax, bx
  1496                              <1> 
  1497 00000DF2 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
  1498                              <1> 
  1499 00000DF5 FF06[BE0E]          <1> 	inc word [.count]
  1500 00000DF9 41                  <1> 	inc cx				; Move on a word in .free_clusters
  1501 00000DFA 41                  <1> 	inc cx
  1502                              <1> 
  1503 00000DFB EBBB                <1> 	jmp .chain_loop
  1504                              <1> 
  1505                              <1> .even:
  1506 00000DFD 2500F0              <1> 	and ax, 0F000h			; Zero out bits we want to use
  1507 00000E00 BF00FF              <1> 	mov di, .free_clusters
  1508 00000E03 01CF                <1> 	add di, cx			; Get offset in .free_clusters
  1509 00000E05 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT free cluster
  1510                              <1> 
  1511 00000E08 01D8                <1> 	add ax, bx
  1512                              <1> 
  1513 00000E0A 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
  1514                              <1> 
  1515 00000E0D FF06[BE0E]          <1> 	inc word [.count]
  1516 00000E11 41                  <1> 	inc cx				; Move on a word in .free_clusters
  1517 00000E12 41                  <1> 	inc cx
  1518                              <1> 
  1519 00000E13 EBA3                <1> 	jmp .chain_loop
  1520                              <1> 
  1521                              <1> 
  1522                              <1> 
  1523                              <1> .last_cluster:
  1524 00000E15 BF00FF              <1> 	mov di, .free_clusters
  1525 00000E18 01CF                <1> 	add di, cx
  1526 00000E1A 8B1D                <1> 	mov word bx, [di]		; Get cluster
  1527                              <1> 
  1528 00000E1C 89D8                <1> 	mov ax, bx
  1529                              <1> 
  1530 00000E1E 31D2                <1> 	xor dx, dx
  1531 00000E20 BB0300              <1> 	mov bx, 3
  1532 00000E23 F7E3                <1> 	mul bx
  1533 00000E25 BB0200              <1> 	mov bx, 2
  1534 00000E28 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
  1535 00000E2A BE00E0              <1> 	mov si, disk_buffer
  1536 00000E2D 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
  1537 00000E2F 3E8B04              <1> 	mov ax, word [ds:si]
  1538                              <1> 
  1539 00000E32 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
  1540 00000E34 7408                <1> 	jz .even_last
  1541                              <1> 
  1542                              <1> .odd_last:
  1543 00000E36 83E00F              <1> 	and ax, 000Fh			; Set relevant parts to FF8h (last cluster in file)
  1544 00000E39 83C080              <1> 	add ax, 0FF80h
  1545 00000E3C EB06                <1> 	jmp .finito
  1546                              <1> 
  1547                              <1> .even_last:
  1548 00000E3E 2500F0              <1> 	and ax, 0F000h			; Same as above, but for an even cluster
  1549 00000E41 05F80F              <1> 	add ax, 0FF8h
  1550                              <1> 
  1551                              <1> 
  1552                              <1> .finito:
  1553 00000E44 3E8904              <1> 	mov word [ds:si], ax
  1554                              <1> 
  1555 00000E47 E88803              <1> 	call disk_write_fat		; Save our FAT back to disk
  1556                              <1> 
  1557                              <1> 
  1558                              <1> 	; Now it's time to save the sectors to disk!
  1559                              <1> 
  1560 00000E4A 31C9                <1> 	xor cx, cx
  1561                              <1> 
  1562                              <1> .save_loop:
  1563 00000E4C BF00FF              <1> 	mov di, .free_clusters
  1564 00000E4F 01CF                <1> 	add di, cx
  1565 00000E51 8B05                <1> 	mov word ax, [di]
  1566                              <1> 
  1567 00000E53 83F800              <1> 	cmp ax, 0
  1568 00000E56 0F842200            <1> 	je near .write_root_entry
  1569                              <1> 
  1570 00000E5A 60                  <1> 	pusha
  1571                              <1> 
  1572 00000E5B 83C01F              <1> 	add ax, 31
  1573                              <1> 
  1574 00000E5E E8E903              <1> 	call disk_convert_l2hts
  1575                              <1> 
  1576 00000E61 8B1E[C00E]          <1> 	mov word bx, [.location]
  1577 00000E65 8E06[C60E]          <1> 	mov es, [.old_segment]
  1578                              <1> 	
  1579 00000E69 B80103              <1> 	mov ax, 0301h
  1580 00000E6C F9                  <1> 	stc
  1581 00000E6D CD13                <1> 	int 13h
  1582                              <1> 
  1583 00000E6F 0E                  <1> 	push cs
  1584 00000E70 07                  <1> 	pop es
  1585                              <1> 		
  1586 00000E71 61                  <1> 	popa
  1587                              <1> 
  1588 00000E72 8106[C00E]0002      <1> 	add word [.location], 512
  1589 00000E78 41                  <1> 	inc cx
  1590 00000E79 41                  <1> 	inc cx
  1591 00000E7A EBD0                <1> 	jmp .save_loop
  1592                              <1> 
  1593                              <1> 
  1594                              <1> .write_root_entry:
  1595                              <1> 
  1596                              <1> 	; Now it's time to head back to the root directory, find our
  1597                              <1> 	; entry and update it with the cluster in use and file size
  1598                              <1> 
  1599 00000E7C E87203              <1> 	call disk_read_root_dir
  1600                              <1> 
  1601 00000E7F A1[C40E]            <1> 	mov word ax, [.filename]
  1602 00000E82 E8EA02              <1> 	call disk_get_root_entry
  1603                              <1> 
  1604 00000E85 A100FF              <1> 	mov word ax, [.free_clusters]	; Get first free cluster
  1605                              <1> 
  1606 00000E88 89451A              <1> 	mov word [di+26], ax		; Save cluster location into root dir entry
  1607                              <1> 
  1608 00000E8B 8B0E[BA0E]          <1> 	mov word cx, [.filesize]
  1609 00000E8F 894D1C              <1> 	mov word [di+28], cx
  1610                              <1> 
  1611 00000E92 C6451E00            <1> 	mov byte [di+30], 0		; File size
  1612 00000E96 C6451F00            <1> 	mov byte [di+31], 0
  1613                              <1> 
  1614 00000E9A E87F03              <1> 	call disk_write_root_dir
  1615                              <1> 
  1616                              <1> .finished:
  1617 00000E9D 61                  <1> 	popa
  1618 00000E9E 60                  <1> 	pusha
  1619 00000E9F 31F6                <1> 	xor si, si
  1620 00000EA1 E8E214              <1> 	call os_print_footer
  1621 00000EA4 61                  <1> 	popa
  1622 00000EA5 8E06[C60E]          <1> 	mov es, [.old_segment]
  1623                              <1> 
  1624 00000EA9 F8                  <1> 	clc
  1625 00000EAA C3                  <1> 	ret
  1626                              <1> 
  1627                              <1> .failure:
  1628 00000EAB 61                  <1> 	popa
  1629 00000EAC 60                  <1> 	pusha
  1630 00000EAD BE0000              <1> 	mov si, 0
  1631 00000EB0 E8D314              <1> 	call os_print_footer
  1632 00000EB3 61                  <1> 	popa
  1633 00000EB4 8E06[C60E]          <1> 	mov es, [.old_segment]
  1634                              <1> 
  1635 00000EB8 F9                  <1> 	stc				; Couldn't write!
  1636 00000EB9 C3                  <1> 	ret
  1637                              <1> 
  1638                              <1> 
  1639 00000EBA 0000                <1> 	.filesize				dw 0
  1640 00000EBC 0000                <1> 	.cluster				dw 0
  1641 00000EBE 0000                <1> 	.count					dw 0
  1642 00000EC0 0000                <1> 	.location				dw 0
  1643                              <1> 
  1644 00000EC2 0000                <1> 	.clusters_needed		dw 0
  1645                              <1> 
  1646 00000EC4 0000                <1> 	.filename				dw 0
  1647                              <1> 
  1648                              <1> 	.free_clusters			equ 65280
  1649                              <1> 
  1650 00000EC6 0000                <1> 	.old_segment			dw 0
  1651                              <1> 
  1652 00000EC8 20536176696E672000  <1> 	.msg_save				db ' Saving ', 0
  1653                              <1> 	
  1654                              <1> ; --------------------------------------------------------------------------
  1655                              <1> ; os_file_exists -- Check for presence of file on the floppy
  1656                              <1> ; IN: AX = filename location; OUT: carry clear if found, set if not
  1657                              <1> 
  1658                              <1> os_file_exists:
  1659 00000ED1 E83C1B              <1> 	call os_string_uppercase
  1660 00000ED4 E81302              <1> 	call int_filename_convert	; Make FAT12-style filename
  1661                              <1> 
  1662 00000ED7 50                  <1> 	push ax
  1663 00000ED8 E8DC1A              <1> 	call os_string_length
  1664 00000EDB 83F800              <1> 	cmp ax, 0
  1665 00000EDE 740F                <1> 	je .failure
  1666 00000EE0 58                  <1> 	pop ax
  1667                              <1> 
  1668 00000EE1 50                  <1> 	push ax
  1669 00000EE2 E80C03              <1> 	call disk_read_root_dir
  1670                              <1> 
  1671 00000EE5 58                  <1> 	pop ax				; Restore filename
  1672                              <1> 
  1673 00000EE6 BF00E0              <1> 	mov di, disk_buffer
  1674                              <1> 
  1675 00000EE9 E88302              <1> 	call disk_get_root_entry	; Set or clear carry flag
  1676                              <1> 
  1677 00000EEC 9C                  <1> 	pushf
  1678                              <1> 
  1679 00000EED 9D                  <1> 	popf
  1680 00000EEE C3                  <1> 	ret
  1681                              <1> 
  1682                              <1> .failure:
  1683 00000EEF 58                  <1> 	pop ax
  1684                              <1> 
  1685 00000EF0 F9                  <1> 	stc
  1686 00000EF1 C3                  <1> 	ret
  1687                              <1> 
  1688                              <1> 
  1689                              <1> ; --------------------------------------------------------------------------
  1690                              <1> ; os_create_file -- Creates a new 0-byte file on the floppy disk
  1691                              <1> ; IN: AX = location of filename; OUT: Nothing
  1692                              <1> 
  1693                              <1> os_create_file:
  1694 00000EF2 F8                  <1> 	clc
  1695                              <1> 
  1696 00000EF3 E81A1B              <1> 	call os_string_uppercase
  1697 00000EF6 E8F101              <1> 	call int_filename_convert	; Make FAT12-style filename
  1698 00000EF9 60                  <1> 	pusha
  1699                              <1> 
  1700 00000EFA 50                  <1> 	push ax				; Save filename for now
  1701                              <1> 
  1702 00000EFB E8D3FF              <1> 	call os_file_exists		; Does the file already exist?
  1703 00000EFE 731B                <1> 	jnc .exists_error
  1704                              <1> 
  1705                              <1> 
  1706                              <1> 	; Root dir already read into disk_buffer by os_file_exists
  1707                              <1> 
  1708 00000F00 BF00E0              <1> 	mov di, disk_buffer		; So point DI at it!
  1709                              <1> 
  1710 00000F03 B9E000              <1> 	mov cx, 224			; Cycle through root dir entries
  1711                              <1> .next_entry:
  1712 00000F06 8A05                <1> 	mov byte al, [di]
  1713 00000F08 3C00                <1> 	cmp al, 0			; Is this a free entry?
  1714 00000F0A 7412                <1> 	je .found_free_entry
  1715 00000F0C 3CE5                <1> 	cmp al, 0E5h			; Is this a free entry?
  1716 00000F0E 740E                <1> 	je .found_free_entry
  1717 00000F10 83C720              <1> 	add di, 32			; If not, go onto next entry
  1718 00000F13 E2F1                <1> 	loop .next_entry
  1719                              <1> 	
  1720 00000F15 B8[B20F]            <1> 	mov ax, .err_msg		; Is the root directory full?
  1721 00000F18 E88506              <1> 	call os_fatal_error
  1722                              <1> 
  1723                              <1> .exists_error:				; We also get here if above loop finds nothing
  1724 00000F1B 58                  <1> 	pop ax				; Get filename back
  1725                              <1> 
  1726 00000F1C EB7C                <1> 	jmp .failure
  1727                              <1> 
  1728                              <1> .found_free_entry:
  1729 00000F1E 5E                  <1> 	pop si				; Get filename back
  1730 00000F1F B90B00              <1> 	mov cx, 11
  1731 00000F22 F3A4                <1> 	rep movsb			; And copy it into RAM copy of root dir (in DI)
  1732                              <1> 
  1733                              <1> 	; Get the time information
  1734                              <1> 	
  1735 00000F24 60                  <1> 	pusha
  1736 00000F25 B402                <1> 	mov ah, 2
  1737 00000F27 E88F07              <1> 	call os_int_1Ah
  1738                              <1> 
  1739 00000F2A 88E8                <1> 	mov al, ch			; Hours
  1740 00000F2C E8D404              <1> 	call os_bcd_to_int
  1741 00000F2F 89C3                <1> 	mov bx, ax
  1742 00000F31 C1E306              <1> 	shl bx, 6
  1743                              <1> 	
  1744 00000F34 88C8                <1> 	mov al, cl			; Minutes
  1745 00000F36 E8CA04              <1> 	call os_bcd_to_int
  1746 00000F39 09C3                <1> 	or bx, ax
  1747 00000F3B C1E305              <1> 	shl bx, 5
  1748                              <1> 	
  1749 00000F3E D0EE                <1> 	shr dh, 1			; Seconds (they're stored as "doubleseconds")
  1750 00000F40 88F0                <1> 	mov al, dh
  1751 00000F42 E8BE04              <1> 	call os_bcd_to_int
  1752 00000F45 09C3                <1> 	or bx, ax
  1753                              <1> 	
  1754 00000F47 891E[A00F]          <1> 	mov [.creation_time], bx
  1755 00000F4B 891E[A80F]          <1> 	mov [.write_time], bx
  1756                              <1> 
  1757                              <1> 	; Get date information
  1758                              <1> 	
  1759 00000F4F B404                <1> 	mov ah, 4
  1760 00000F51 E86507              <1> 	call os_int_1Ah
  1761                              <1> 
  1762 00000F54 52                  <1> 	push dx
  1763 00000F55 88E8                <1> 	mov al, ch			; Century
  1764 00000F57 E8A904              <1> 	call os_bcd_to_int
  1765 00000F5A BB6400              <1> 	mov bx, 100
  1766 00000F5D F7E3                <1> 	mul bx
  1767 00000F5F 89C3                <1> 	mov bx, ax
  1768                              <1> 	
  1769 00000F61 88C8                <1> 	mov al, cl			; Years
  1770 00000F63 E89D04              <1> 	call os_bcd_to_int
  1771 00000F66 01C3                <1> 	add bx, ax
  1772                              <1> 	
  1773 00000F68 81EBBC07            <1> 	sub bx, 1980		; Years are stored as "years past 1980"
  1774                              <1> 	
  1775 00000F6C C1E304              <1> 	shl bx, 4
  1776 00000F6F 5A                  <1> 	pop dx
  1777                              <1> 	
  1778 00000F70 88F0                <1> 	mov al, dh			; Months
  1779 00000F72 E88E04              <1> 	call os_bcd_to_int
  1780 00000F75 09C3                <1> 	or bx, ax
  1781 00000F77 C1E305              <1> 	shl bx, 5
  1782                              <1> 	
  1783 00000F7A 88D0                <1> 	mov al, dl			; Days
  1784 00000F7C E88404              <1> 	call os_bcd_to_int
  1785 00000F7F 09C3                <1> 	or bx, ax
  1786                              <1> 	
  1787 00000F81 891E[A20F]          <1> 	mov [.creation_date], bx
  1788 00000F85 891E[AA0F]          <1> 	mov [.write_date], bx
  1789 00000F89 61                  <1> 	popa
  1790                              <1> 	
  1791 00000F8A BE[9D0F]            <1> 	mov si, .table		; Copy over all the attributes
  1792 00000F8D B91500              <1> 	mov cx, 21
  1793 00000F90 F3A4                <1> 	rep movsb
  1794                              <1> 	
  1795 00000F92 E88702              <1> 	call disk_write_root_dir
  1796 00000F95 7203                <1> 	jc .failure
  1797                              <1> 
  1798 00000F97 61                  <1> 	popa
  1799                              <1> 
  1800 00000F98 F8                  <1> 	clc				; Clear carry for success
  1801 00000F99 C3                  <1> 	ret
  1802                              <1> 
  1803                              <1> .failure:
  1804 00000F9A 61                  <1> 	popa
  1805                              <1> 
  1806 00000F9B F9                  <1> 	stc
  1807 00000F9C C3                  <1> 	ret
  1808                              <1> 
  1809                              <1> ;	.table			db 0, 0, 0, 0C6h, 07Eh, 0, 0, 0, 0, 0, 0, 0C6h, 07Eh, 0, 0, 0, 0, 0, 0, 0, 0 
  1810                              <1> 	.table:
  1811 00000F9D 00                  <1> 		.atttribute		db 0
  1812 00000F9E 00<rep 2h>          <1> 		.reserved		times 2 db 0
  1813 00000FA0 0000                <1> 		.creation_time	dw 0
  1814 00000FA2 0000                <1> 		.creation_date	dw 0
  1815 00000FA4 00<rep 4h>          <1> 		.reserved2		times 4 db 0
  1816 00000FA8 0000                <1> 		.write_time		dw 0
  1817 00000FAA 0000                <1> 		.write_date		dw 0
  1818 00000FAC 00<rep 6h>          <1> 		.reserved3		times 6 db 0
  1819 00000FB2 4E6F7420656E6F7567- <1> 	.err_msg		db 'Not enough space in directory', 0
  1819 00000FBB 682073706163652069- <1>
  1819 00000FC4 6E206469726563746F- <1>
  1819 00000FCD 727900              <1>
  1820                              <1> 
  1821                              <1> ; --------------------------------------------------------------------------
  1822                              <1> ; os_remove_file -- Deletes the specified file from the filesystem
  1823                              <1> ; IN: AX = location of filename to remove
  1824                              <1> 
  1825                              <1> os_remove_file:
  1826 00000FD0 60                  <1> 	pusha
  1827 00000FD1 E83C1A              <1> 	call os_string_uppercase
  1828 00000FD4 E81301              <1> 	call int_filename_convert	; Make filename FAT12-style
  1829 00000FD7 50                  <1> 	push ax				; Save filename
  1830                              <1> 
  1831 00000FD8 F8                  <1> 	clc
  1832                              <1> 
  1833 00000FD9 E81502              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1834                              <1> 
  1835 00000FDC BF00E0              <1> 	mov di, disk_buffer		; Point DI to root dir
  1836                              <1> 
  1837 00000FDF 58                  <1> 	pop ax				; Get chosen filename back
  1838                              <1> 
  1839 00000FE0 E88C01              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1840 00000FE3 7268                <1> 	jc .failure			; If entry can't be found
  1841                              <1> 
  1842                              <1> 
  1843 00000FE5 268B451A            <1> 	mov ax, word [es:di+26]		; Get first cluster number from the dir entry
  1844 00000FE9 A3[5010]            <1> 	mov word [.cluster], ax		; And save it
  1845                              <1> 
  1846 00000FEC C605E5              <1> 	mov byte [di], 0E5h		; Mark directory entry (first byte of filename) as empty
  1847                              <1> 
  1848 00000FEF 47                  <1> 	inc di
  1849                              <1> 
  1850 00000FF0 31C9                <1> 	xor cx, cx			; Set rest of data in root dir entry to zeros
  1851                              <1> .clean_loop:
  1852 00000FF2 C60500              <1> 	mov byte [di], 0
  1853 00000FF5 47                  <1> 	inc di
  1854 00000FF6 41                  <1> 	inc cx
  1855 00000FF7 83F91F              <1> 	cmp cx, 31			; 32-byte entries, minus E5h byte we marked before
  1856 00000FFA 7CF6                <1> 	jl .clean_loop
  1857                              <1> 
  1858 00000FFC E81D02              <1> 	call disk_write_root_dir	; Save back the root directory from RAM
  1859                              <1> 
  1860                              <1> 
  1861 00000FFF E8A501              <1> 	call disk_read_fat		; Now FAT is in disk_buffer
  1862 00001002 BF00E0              <1> 	mov di, disk_buffer		; And DI points to it
  1863                              <1> 
  1864                              <1> 
  1865                              <1> .more_clusters:
  1866 00001005 A1[5010]            <1> 	mov word ax, [.cluster]		; Get cluster contents
  1867                              <1> 
  1868 00001008 83F800              <1> 	cmp ax, 0			; If it's zero, this was an empty file
  1869 0000100B 743D                <1> 	je .nothing_to_do
  1870                              <1> 
  1871 0000100D BB0300              <1> 	mov bx, 3			; Determine if cluster is odd or even number
  1872 00001010 F7E3                <1> 	mul bx
  1873 00001012 BB0200              <1> 	mov bx, 2
  1874 00001015 F7F3                <1> 	div bx				; DX = [first_cluster] mod 2
  1875 00001017 BE00E0              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
  1876 0000101A 01C6                <1> 	add si, ax
  1877 0000101C 3E8B04              <1> 	mov ax, word [ds:si]
  1878                              <1> 
  1879 0000101F 09D2                <1> 	or dx, dx			; If DX = 0 [.cluster] = even, if DX = 1 then odd
  1880                              <1> 
  1881 00001021 740D                <1> 	jz .even			; If [.cluster] = even, drop last 4 bits of word
  1882                              <1> 					; with next cluster; if odd, drop first 4 bits
  1883                              <1> .odd:
  1884 00001023 50                  <1> 	push ax
  1885 00001024 83E00F              <1> 	and ax, 000Fh			; Set cluster data to zero in FAT in RAM
  1886 00001027 3E8904              <1> 	mov word [ds:si], ax
  1887 0000102A 58                  <1> 	pop ax
  1888                              <1> 
  1889 0000102B C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (they belong to another entry)
  1890 0000102E EB0B                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
  1891                              <1> 
  1892                              <1> .even:
  1893 00001030 50                  <1> 	push ax
  1894 00001031 2500F0              <1> 	and ax, 0F000h			; Set cluster data to zero in FAT in RAM
  1895 00001034 3E8904              <1> 	mov word [ds:si], ax
  1896 00001037 58                  <1> 	pop ax
  1897                              <1> 
  1898 00001038 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits (they belong to another entry)
  1899                              <1> 
  1900                              <1> .calculate_cluster_cont:
  1901 0000103B A3[5010]            <1> 	mov word [.cluster], ax		; Store cluster
  1902                              <1> 
  1903 0000103E 3DF80F              <1> 	cmp ax, 0FF8h			; Final cluster marker?
  1904 00001041 7302                <1> 	jae .end
  1905                              <1> 
  1906 00001043 EBC0                <1> 	jmp .more_clusters		; If not, grab more
  1907                              <1> 
  1908                              <1> .end:
  1909 00001045 E88A01              <1> 	call disk_write_fat
  1910 00001048 7203                <1> 	jc .failure
  1911                              <1> 
  1912                              <1> .nothing_to_do:
  1913 0000104A 61                  <1> 	popa
  1914                              <1> 
  1915 0000104B F8                  <1> 	clc
  1916 0000104C C3                  <1> 	ret
  1917                              <1> 
  1918                              <1> .failure:
  1919 0000104D 61                  <1> 	popa
  1920                              <1> 
  1921 0000104E F9                  <1> 	stc
  1922 0000104F C3                  <1> 	ret
  1923                              <1> 
  1924                              <1> 
  1925 00001050 0000                <1> 	.cluster dw 0
  1926                              <1> 
  1927                              <1> 
  1928                              <1> ; --------------------------------------------------------------------------
  1929                              <1> ; os_rename_file -- Change the name of a file on the disk
  1930                              <1> ; IN: AX = filename to change, BX = new filename (zero-terminated strings)
  1931                              <1> ; OUT: carry set on error
  1932                              <1> 
  1933                              <1> os_rename_file:
  1934 00001052 53                  <1> 	push bx
  1935 00001053 50                  <1> 	push ax
  1936                              <1> 
  1937 00001054 F8                  <1> 	clc
  1938                              <1> 
  1939 00001055 E89901              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1940                              <1> 
  1941 00001058 BF00E0              <1> 	mov di, disk_buffer		; Point DI to root dir
  1942                              <1> 
  1943 0000105B 58                  <1> 	pop ax				; Get chosen filename back
  1944                              <1> 
  1945 0000105C E8B119              <1> 	call os_string_uppercase
  1946 0000105F E88800              <1> 	call int_filename_convert
  1947 00001062 721E                <1> 	jc .fail_read
  1948                              <1> 	
  1949 00001064 E80801              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1950 00001067 7219                <1> 	jc .fail_read			; Quit out if file not found
  1951                              <1> 
  1952 00001069 5B                  <1> 	pop bx				; Get new filename string (originally passed in BX)
  1953                              <1> 
  1954 0000106A 89D8                <1> 	mov ax, bx
  1955                              <1> 
  1956 0000106C E8A119              <1> 	call os_string_uppercase
  1957 0000106F E87800              <1> 	call int_filename_convert
  1958 00001072 7211                <1> 	jc .fail_write
  1959                              <1> 	
  1960 00001074 89C6                <1> 	mov si, ax
  1961                              <1> 
  1962 00001076 B90B00              <1> 	mov cx, 11			; Copy new filename string into root dir entry in disk_buffer
  1963 00001079 F3A4                <1> 	rep movsb
  1964                              <1> 
  1965 0000107B E89E01              <1> 	call disk_write_root_dir	; Save root dir to disk
  1966 0000107E 7205                <1> 	jc .fail_write
  1967                              <1> 
  1968                              <1> 
  1969 00001080 F8                  <1> 	clc
  1970 00001081 C3                  <1> 	ret
  1971                              <1> 
  1972                              <1> .fail_read:
  1973 00001082 58                  <1> 	pop ax
  1974                              <1> 
  1975 00001083 F9                  <1> 	stc
  1976 00001084 C3                  <1> 	ret
  1977                              <1> 
  1978                              <1> .fail_write:
  1979                              <1> 
  1980 00001085 F9                  <1> 	stc
  1981 00001086 C3                  <1> 	ret
  1982                              <1> 
  1983                              <1> 
  1984                              <1> ; --------------------------------------------------------------------------
  1985                              <1> ; os_get_file_size -- Get file size information for specified file
  1986                              <1> ; IN: AX = filename; OUT: EBX = file size in bytes (up to 4GB)
  1987                              <1> ; or carry set if file not found
  1988                              <1> 
  1989                              <1> os_get_file_size:
  1990 00001087 60                  <1> 	pusha
  1991                              <1> 
  1992 00001088 E88519              <1> 	call os_string_uppercase
  1993 0000108B E85C00              <1> 	call int_filename_convert
  1994                              <1> 
  1995 0000108E F8                  <1> 	clc
  1996                              <1> 
  1997 0000108F 50                  <1> 	push ax
  1998                              <1> 
  1999 00001090 E85E01              <1> 	call disk_read_root_dir
  2000 00001093 7219                <1> 	jc .failure
  2001                              <1> 
  2002 00001095 58                  <1> 	pop ax
  2003                              <1> 
  2004 00001096 BF00E0              <1> 	mov di, disk_buffer
  2005                              <1> 
  2006 00001099 E8D300              <1> 	call disk_get_root_entry
  2007 0000109C 7210                <1> 	jc .failure
  2008                              <1> 
  2009 0000109E 668B5D1C            <1> 	mov ebx, [di+28]
  2010                              <1> 
  2011 000010A2 66891E[B110]        <1> 	mov [.tmp], ebx
  2012                              <1> 
  2013 000010A7 61                  <1> 	popa
  2014                              <1> 
  2015 000010A8 668B1E[B110]        <1> 	mov ebx, [.tmp]
  2016                              <1> 
  2017                              <1> 
  2018 000010AD C3                  <1> 	ret
  2019                              <1> 
  2020                              <1> .failure:
  2021 000010AE 61                  <1> 	popa
  2022 000010AF F9                  <1> 	stc
  2023                              <1> 
  2024 000010B0 C3                  <1> 	ret
  2025                              <1> 
  2026                              <1> 
  2027 000010B1 00000000            <1> 	.tmp	dd 0
  2028                              <1> 
  2029                              <1> ; --------------------------------------------------------------------------
  2030                              <1> ; os_get_file_datetime -- Get file write time/date information for specified file
  2031                              <1> ; IN: AX = filename; OUT: BX = time of creation (HHHHHMMMMMMSSSSS), CX = date of creation (YYYYYYYMMMMDDDDD)
  2032                              <1> ; or carry set if file not found
  2033                              <1> 
  2034                              <1> os_get_file_datetime:
  2035 000010B5 60                  <1> 	pusha
  2036                              <1> 
  2037 000010B6 E85719              <1> 	call os_string_uppercase
  2038 000010B9 E82E00              <1> 	call int_filename_convert
  2039                              <1> 
  2040 000010BC F8                  <1> 	clc
  2041                              <1> 
  2042 000010BD 50                  <1> 	push ax
  2043                              <1> 
  2044 000010BE E83001              <1> 	call disk_read_root_dir
  2045 000010C1 7220                <1> 	jc .failure
  2046                              <1> 
  2047 000010C3 58                  <1> 	pop ax
  2048                              <1> 
  2049 000010C4 BF00E0              <1> 	mov di, disk_buffer
  2050                              <1> 
  2051 000010C7 E8A500              <1> 	call disk_get_root_entry
  2052 000010CA 7217                <1> 	jc .failure
  2053                              <1> 
  2054 000010CC 8B4516              <1> 	mov ax, [di+22]
  2055 000010CF 8B5D18              <1> 	mov bx, [di+24]
  2056                              <1> 
  2057 000010D2 A3[E610]            <1> 	mov [.tmp], ax
  2058 000010D5 891E[E810]          <1> 	mov [.tmp + 2], bx
  2059                              <1> 
  2060 000010D9 61                  <1> 	popa
  2061                              <1> 
  2062 000010DA 8B1E[E610]          <1> 	mov bx, [.tmp]
  2063 000010DE 8B0E[E810]          <1> 	mov cx, [.tmp + 2]
  2064                              <1> 
  2065                              <1> 
  2066 000010E2 C3                  <1> 	ret
  2067                              <1> 
  2068                              <1> .failure:
  2069 000010E3 61                  <1> 	popa
  2070 000010E4 F9                  <1> 	stc
  2071                              <1> 
  2072 000010E5 C3                  <1> 	ret
  2073                              <1> 
  2074                              <1> 
  2075 000010E6 00000000            <1> 	.tmp	dd 0
  2076                              <1> 
  2077                              <1> 
  2078                              <1> ; ==================================================================
  2079                              <1> ; INTERNAL OS ROUTINES -- Not accessible to user programs
  2080                              <1> 
  2081                              <1> ; ------------------------------------------------------------------
  2082                              <1> ; int_filename_convert -- Change 'TEST.BIN' into 'TEST    BIN' as per FAT12
  2083                              <1> ; IN: AX = filename string
  2084                              <1> ; OUT: AX = location of converted string (carry set if invalid)
  2085                              <1> 
  2086                              <1> 
  2087                              <1> int_filename_convert:
  2088 000010EA 60                  <1> 	pusha
  2089                              <1> 
  2090 000010EB 89C6                <1> 	mov si, ax
  2091                              <1> 
  2092 000010ED E8C718              <1> 	call os_string_length
  2093 000010F0 83F80C              <1> 	cmp ax, 12			; Filename too long?
  2094 000010F3 7F49                <1> 	jg .failure0			; Fail if so
  2095                              <1> 
  2096 000010F5 83F800              <1> 	cmp ax, 0
  2097 000010F8 744B                <1> 	je .failure1			; Similarly, fail if zero-char string
  2098                              <1> 
  2099 000010FA 89C2                <1> 	mov dx, ax			; Store string length for now
  2100                              <1> 
  2101 000010FC BF[6211]            <1> 	mov di, .dest_string
  2102                              <1> 
  2103 000010FF B90000              <1> 	mov cx, 0
  2104                              <1> .copy_loop:
  2105 00001102 AC                  <1> 	lodsb
  2106 00001103 3C2E                <1> 	cmp al, '.'
  2107 00001105 7408                <1> 	je .extension_found
  2108 00001107 AA                  <1> 	stosb
  2109 00001108 41                  <1> 	inc cx
  2110 00001109 39D1                <1> 	cmp cx, dx
  2111 0000110B 7F3F                <1> 	jg .failure2			; No extension found = wrong
  2112 0000110D EBF3                <1> 	jmp .copy_loop
  2113                              <1> 
  2114                              <1> .extension_found:
  2115 0000110F 83F900              <1> 	cmp cx, 0
  2116 00001112 743F                <1> 	je .failure3			; Fail if extension dot is first char
  2117                              <1> 
  2118 00001114 83F908              <1> 	cmp cx, 8
  2119 00001117 740A                <1> 	je .do_extension		; Skip spaces if first bit is 8 chars
  2120                              <1> 
  2121                              <1> 	; Now it's time to pad out the rest of the first part of the filename
  2122                              <1> 	; with spaces, if necessary
  2123                              <1> 
  2124                              <1> .add_spaces:
  2125 00001119 C60520              <1> 	mov byte [di], ' '
  2126 0000111C 47                  <1> 	inc di
  2127 0000111D 41                  <1> 	inc cx
  2128 0000111E 83F908              <1> 	cmp cx, 8
  2129 00001121 7CF6                <1> 	jl .add_spaces
  2130                              <1> 
  2131                              <1> 	; Finally, copy over the extension
  2132                              <1> .do_extension:
  2133 00001123 AC                  <1> 	lodsb				; 3 characters
  2134 00001124 3C00                <1> 	cmp al, 0
  2135 00001126 7432                <1> 	je .failure4
  2136 00001128 AA                  <1> 	stosb
  2137 00001129 AC                  <1> 	lodsb
  2138 0000112A 3C00                <1> 	cmp al, 0
  2139 0000112C 742C                <1> 	je .failure4
  2140 0000112E AA                  <1> 	stosb
  2141 0000112F AC                  <1> 	lodsb
  2142 00001130 3C00                <1> 	cmp al, 0
  2143 00001132 7426                <1> 	je .failure4
  2144 00001134 AA                  <1> 	stosb
  2145                              <1> 
  2146 00001135 C60500              <1> 	mov byte [di], 0		; Zero-terminate filename
  2147                              <1> 
  2148 00001138 61                  <1> 	popa
  2149 00001139 B8[6211]            <1> 	mov ax, .dest_string
  2150 0000113C F8                  <1> 	clc				; Clear carry for success
  2151 0000113D C3                  <1> 	ret
  2152                              <1> 
  2153                              <1> 
  2154                              <1> .failure0:
  2155 0000113E C606860000          <1> 	mov byte [0086h], 0
  2156 00001143 EB1A                <1> 	jmp .failure
  2157                              <1> 	
  2158                              <1> .failure1:
  2159 00001145 C606860001          <1> 	mov byte [0086h], 1
  2160 0000114A EB13                <1> 	jmp .failure
  2161                              <1> 	
  2162                              <1> .failure2:
  2163 0000114C C606860002          <1> 	mov byte [0086h], 2
  2164 00001151 EB0C                <1> 	jmp .failure
  2165                              <1> 	
  2166                              <1> .failure3:
  2167 00001153 C606860003          <1> 	mov byte [0086h], 3
  2168 00001158 EB05                <1> 	jmp .failure
  2169                              <1> 	
  2170                              <1> .failure4:
  2171 0000115A C606860004          <1> 	mov byte [0086h], 4
  2172                              <1> 
  2173                              <1> .failure:	
  2174 0000115F 61                  <1> 	popa
  2175 00001160 F9                  <1> 	stc				; Set carry for failure
  2176 00001161 C3                  <1> 	ret
  2177                              <1> 
  2178 00001162 00<rep Dh>          <1> 	.dest_string	times 13 db 0
  2179                              <1> 
  2180                              <1> 
  2181                              <1> ; --------------------------------------------------------------------------
  2182                              <1> ; disk_get_root_entry -- Search RAM copy of root dir for file entry
  2183                              <1> ; IN: AX = filename; OUT: DI = location in disk_buffer of root dir entry,
  2184                              <1> ; or carry set if file not found
  2185                              <1> 
  2186                              <1> disk_get_root_entry:
  2187 0000116F 60                  <1> 	pusha
  2188                              <1> 
  2189 00001170 A3[A311]            <1> 	mov word [.filename], ax
  2190                              <1> 
  2191 00001173 B9E000              <1> 	mov cx, 224			; Search all (224) entries
  2192 00001176 B80000              <1> 	mov ax, 0			; Searching at offset 0
  2193                              <1> 
  2194                              <1> .to_next_root_entry:
  2195 00001179 87CA                <1> 	xchg cx, dx			; We use CX in the inner loop...
  2196                              <1> 
  2197 0000117B 8B36[A311]          <1> 	mov word si, [.filename]	; Start searching for filename
  2198 0000117F B90B00              <1> 	mov cx, 11
  2199 00001182 F3A6                <1> 	rep cmpsb
  2200 00001184 740F                <1> 	je .found_file			; Pointer DI will be at offset 11, if file found
  2201                              <1> 
  2202 00001186 83C020              <1> 	add ax, 32			; Bump searched entries by 1 (32 bytes/entry)
  2203                              <1> 
  2204 00001189 BF00E0              <1> 	mov di, disk_buffer		; Point to next root dir entry
  2205 0000118C 01C7                <1> 	add di, ax
  2206                              <1> 
  2207 0000118E 87D1                <1> 	xchg dx, cx			; Get the original CX back
  2208 00001190 E2E7                <1> 	loop .to_next_root_entry
  2209                              <1> 
  2210 00001192 61                  <1> 	popa
  2211                              <1> 
  2212 00001193 F9                  <1> 	stc				; Set carry if entry not found
  2213 00001194 C3                  <1> 	ret
  2214                              <1> 
  2215                              <1> 
  2216                              <1> .found_file:
  2217 00001195 83EF0B              <1> 	sub di, 11			; Move back to start of this root dir entry
  2218                              <1> 
  2219 00001198 893E[A511]          <1> 	mov word [.tmp], di		; Restore all registers except for DI
  2220                              <1> 
  2221 0000119C 61                  <1> 	popa
  2222                              <1> 
  2223 0000119D 8B3E[A511]          <1> 	mov word di, [.tmp]
  2224                              <1> 
  2225 000011A1 F8                  <1> 	clc
  2226 000011A2 C3                  <1> 	ret
  2227                              <1> 
  2228                              <1> 
  2229 000011A3 0000                <1> 	.filename	dw 0
  2230 000011A5 0000                <1> 	.tmp		dw 0
  2231                              <1> 
  2232                              <1> 
  2233                              <1> ; --------------------------------------------------------------------------
  2234                              <1> ; disk_read_fat -- Read FAT entry from floppy into disk_buffer
  2235                              <1> ; IN: Nothing; OUT: carry set if failure
  2236                              <1> 
  2237                              <1> disk_read_fat:
  2238 000011A7 60                  <1> 	pusha
  2239                              <1> 
  2240 000011A8 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  2241 000011AB E89C00              <1> 	call disk_convert_l2hts
  2242                              <1> 
  2243 000011AE BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  2244 000011B1 8CCB                <1> 	mov bx, cs
  2245 000011B3 8EC3                <1> 	mov es, bx
  2246 000011B5 89F3                <1> 	mov bx, si
  2247                              <1> 
  2248 000011B7 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  2249 000011B9 B009                <1> 	mov al, 9			; And read 9 of them for first FAT
  2250                              <1> 
  2251 000011BB 60                  <1> 	pusha				; Prepare to enter loop
  2252                              <1> 
  2253                              <1> 
  2254                              <1> .read_fat_loop:
  2255 000011BC 61                  <1> 	popa
  2256 000011BD 60                  <1> 	pusha
  2257                              <1> 
  2258 000011BE F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2259 000011BF CD13                <1> 	int 13h				; Read sectors
  2260                              <1> 
  2261 000011C1 7308                <1> 	jnc .fat_done
  2262 000011C3 E87500              <1> 	call disk_reset_floppy		; Reset controller and try again
  2263 000011C6 73F4                <1> 	jnc .read_fat_loop		; Floppy reset OK?
  2264                              <1> 
  2265 000011C8 61                  <1> 	popa
  2266 000011C9 EB04                <1> 	jmp .read_failure		; Fatal double error
  2267                              <1> 
  2268                              <1> .fat_done:
  2269 000011CB 61                  <1> 	popa				; Restore registers from main loop
  2270                              <1> 
  2271 000011CC 61                  <1> 	popa				; And restore registers from start of system call
  2272 000011CD F8                  <1> 	clc
  2273 000011CE C3                  <1> 	ret
  2274                              <1> 
  2275                              <1> .read_failure:
  2276 000011CF 61                  <1> 	popa
  2277 000011D0 F9                  <1> 	stc				; Set carry flag (for failure)
  2278 000011D1 C3                  <1> 	ret
  2279                              <1> 
  2280                              <1> 
  2281                              <1> ; --------------------------------------------------------------------------
  2282                              <1> ; disk_write_fat -- Save FAT contents from disk_buffer in RAM to disk
  2283                              <1> ; IN: FAT in disk_buffer; OUT: carry set if failure
  2284                              <1> 
  2285                              <1> disk_write_fat:
  2286 000011D2 60                  <1> 	pusha
  2287                              <1> 
  2288 000011D3 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  2289 000011D6 E87100              <1> 	call disk_convert_l2hts
  2290                              <1> 
  2291 000011D9 BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  2292 000011DC 8CDB                <1> 	mov bx, ds
  2293 000011DE 8EC3                <1> 	mov es, bx
  2294 000011E0 89F3                <1> 	mov bx, si
  2295                              <1> 
  2296 000011E2 B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  2297 000011E4 B009                <1> 	mov al, 9			; And write 9 of them for first FAT
  2298                              <1> 
  2299 000011E6 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2300 000011E7 CD13                <1> 	int 13h				; Write sectors
  2301                              <1> 
  2302 000011E9 7203                <1> 	jc .write_failure		; Fatal double error
  2303                              <1> 
  2304 000011EB 61                  <1> 	popa				; And restore from start of system call
  2305 000011EC F8                  <1> 	clc
  2306 000011ED C3                  <1> 	ret
  2307                              <1> 
  2308                              <1> .write_failure:
  2309 000011EE 61                  <1> 	popa
  2310 000011EF F9                  <1> 	stc				; Set carry flag (for failure)
  2311 000011F0 C3                  <1> 	ret
  2312                              <1> 
  2313                              <1> 
  2314                              <1> ; --------------------------------------------------------------------------
  2315                              <1> ; disk_read_root_dir -- Get the root directory contents
  2316                              <1> ; IN: Nothing; OUT: root directory contents in disk_buffer, carry set if error
  2317                              <1> 
  2318                              <1> disk_read_root_dir:
  2319 000011F1 60                  <1> 	pusha
  2320                              <1> 
  2321 000011F2 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  2322 000011F5 E85200              <1> 	call disk_convert_l2hts
  2323                              <1> 
  2324 000011F8 BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  2325 000011FB 8CDB                <1> 	mov bx, ds
  2326 000011FD 8EC3                <1> 	mov es, bx
  2327 000011FF 89F3                <1> 	mov bx, si
  2328                              <1> 
  2329 00001201 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  2330 00001203 B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
  2331                              <1> 
  2332 00001205 60                  <1> 	pusha				; Prepare to enter loop
  2333                              <1> 
  2334                              <1> 
  2335                              <1> .read_root_dir_loop:
  2336 00001206 61                  <1> 	popa
  2337 00001207 60                  <1> 	pusha
  2338                              <1> 
  2339 00001208 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2340 00001209 CD13                <1> 	int 13h				; Read sectors
  2341                              <1> 
  2342 0000120B 7308                <1> 	jnc .root_dir_finished
  2343 0000120D E82B00              <1> 	call disk_reset_floppy		; Reset controller and try again
  2344 00001210 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
  2345                              <1> 
  2346 00001212 61                  <1> 	popa
  2347 00001213 EB04                <1> 	jmp .read_failure		; Fatal double error
  2348                              <1> 
  2349                              <1> 
  2350                              <1> .root_dir_finished:
  2351 00001215 61                  <1> 	popa				; Restore registers from main loop
  2352                              <1> 
  2353 00001216 61                  <1> 	popa				; And restore from start of this system call
  2354 00001217 F8                  <1> 	clc				; Clear carry (for success)
  2355 00001218 C3                  <1> 	ret
  2356                              <1> 
  2357                              <1> .read_failure:
  2358 00001219 61                  <1> 	popa
  2359 0000121A F9                  <1> 	stc				; Set carry flag (for failure)
  2360 0000121B C3                  <1> 	ret
  2361                              <1> 
  2362                              <1> ; --------------------------------------------------------------------------
  2363                              <1> ; disk_write_root_dir -- Write root directory contents from disk_buffer to disk
  2364                              <1> ; IN: root dir copy in disk_buffer; OUT: carry set if error
  2365                              <1> 
  2366                              <1> disk_write_root_dir:
  2367 0000121C 60                  <1> 	pusha
  2368                              <1> 
  2369 0000121D B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  2370 00001220 E82700              <1> 	call disk_convert_l2hts
  2371                              <1> 
  2372 00001223 BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  2373 00001226 8CDB                <1> 	mov bx, ds
  2374 00001228 8EC3                <1> 	mov es, bx
  2375 0000122A 89F3                <1> 	mov bx, si
  2376                              <1> 
  2377 0000122C B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  2378 0000122E B00E                <1> 	mov al, 14			; And write 14 of them (from 19 onwards)
  2379                              <1> 
  2380 00001230 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2381 00001231 CD13                <1> 	int 13h				; Write sectors
  2382 00001233 7203                <1> 	jc .write_failure
  2383                              <1> 
  2384 00001235 61                  <1> 	popa				; And restore from start of this system call
  2385 00001236 F8                  <1> 	clc
  2386 00001237 C3                  <1> 	ret
  2387                              <1> 
  2388                              <1> .write_failure:
  2389 00001238 61                  <1> 	popa
  2390 00001239 F9                  <1> 	stc				; Set carry flag (for failure)
  2391 0000123A C3                  <1> 	ret
  2392                              <1> 
  2393                              <1> 
  2394                              <1> ; --------------------------------------------------------------------------
  2395                              <1> ; Reset floppy disk
  2396                              <1> 
  2397                              <1> disk_reset_floppy:
  2398 0000123B 50                  <1> 	push ax
  2399 0000123C 52                  <1> 	push dx
  2400 0000123D B80000              <1> 	mov ax, 0
  2401                              <1> ; ******************************************************************
  2402 00001240 8A16[7912]          <1> 	mov dl, [bootdev]
  2403                              <1> ; ******************************************************************
  2404 00001244 F9                  <1> 	stc
  2405 00001245 CD13                <1> 	int 13h
  2406 00001247 5A                  <1> 	pop dx
  2407 00001248 58                  <1> 	pop ax
  2408 00001249 C3                  <1> 	ret
  2409                              <1> 
  2410                              <1> 
  2411                              <1> ; --------------------------------------------------------------------------
  2412                              <1> ; disk_convert_l2hts -- Calculate head, track and sector for int 13h
  2413                              <1> ; IN: logical sector in AX; OUT: correct registers for int 13h
  2414                              <1> 
  2415                              <1> disk_convert_l2hts:
  2416 0000124A 53                  <1> 	push bx
  2417 0000124B 50                  <1> 	push ax
  2418                              <1> 
  2419 0000124C 89C3                <1> 	mov bx, ax			; Save logical sector
  2420                              <1> 
  2421 0000124E BA0000              <1> 	mov dx, 0			; First the sector
  2422 00001251 F736[7712]          <1> 	div word [SecsPerTrack]		; Sectors per track
  2423 00001255 80C201              <1> 	add dl, 01h			; Physical sectors start at 1
  2424 00001258 88D1                <1> 	mov cl, dl			; Sectors belong in CL for int 13h
  2425 0000125A 89D8                <1> 	mov ax, bx
  2426                              <1> 
  2427 0000125C BA0000              <1> 	mov dx, 0			; Now calculate the head
  2428 0000125F F736[7712]          <1> 	div word [SecsPerTrack]		; Sectors per track
  2429 00001263 BA0000              <1> 	mov dx, 0
  2430 00001266 F736[7512]          <1> 	div word [Sides]		; Floppy sides
  2431 0000126A 88D6                <1> 	mov dh, dl			; Head/side
  2432 0000126C 88C5                <1> 	mov ch, al			; Track
  2433                              <1> 	
  2434 0000126E 58                  <1> 	pop ax
  2435 0000126F 5B                  <1> 	pop bx
  2436                              <1> 
  2437 00001270 8A16[7912]          <1> 	mov dl, [bootdev]		; Set correct device
  2438                              <1> 
  2439 00001274 C3                  <1> 	ret
  2440                              <1> 
  2441                              <1> 
  2442                              <1> 
  2443 00001275 0200                <1> 	Sides dw 2
  2444 00001277 1200                <1> 	SecsPerTrack dw 18
  2445                              <1> 	
  2446 00001279 00                  <1> 	bootdev db 0			; Boot device number
  2447                              <1> 
  2448                              <1> 
  2449                              <1> ; ==================================================================
  2450                              <1> 
  2451                              <1> 
   811                                  	%INCLUDE "drivers/keyboard.asm"
   812                              <1> ; ==================================================================
   813                              <1> ; KEYBOARD HANDLING ROUTINES
   814                              <1> ; ==================================================================
   815                              <1> 
   816                              <1> ; ------------------------------------------------------------------
   817                              <1> ; os_wait_for_key -- Waits for keypress and returns key
   818                              <1> ; Also handles the screensaver. TODO: move the screensaver code to "int.asm"
   819                              <1> ; IN: Nothing; OUT: AX = key pressed, other regs preserved
   820                              <1> 
   821                              <1> os_wait_for_key:
   822 0000127A 60                  <1> 	pusha
   823                              <1> 	
   824                              <1> .try_again:
   825 0000127B B700                <1> 	mov bh, 0
   826 0000127D E88200              <1> 	call .screen_power
   827                              <1> 
   828                              <1> 	; Reset the screensaver tick
   829 00001280 0FB606F2DE          <1> 	movzx ax, byte [57074]
   830 00001285 BB4404              <1> 	mov bx, 1092		; 18.2 Hz * 60 seconds
   831 00001288 F7E3                <1> 	mul bx
   832 0000128A A3[B948]            <1> 	mov [screensaver_timer], ax		; See "int.asm"
   833                              <1> 	
   834 0000128D C606[1B13]00        <1> 	mov byte [.scrn_active], 0	; Reset all the screensaver variables
   835                              <1> 
   836 00001292 A08200              <1> 	mov al, [0082h]				; Save the current screen state, for later
   837 00001295 A2[1813]            <1> 	mov [.gfx_state], al
   838 00001298 B403                <1> 	mov ah, 03h
   839 0000129A B700                <1> 	mov bh, 0
   840 0000129C CD10                <1> 	int 10h
   841 0000129E 890E[1913]          <1> 	mov [.orig_crsr], cx		; Get the shape of the cursor
   842                              <1> 	
   843                              <1> .loop:
   844 000012A2 F4                  <1> 	hlt							; Halt the CPU for 1/18.2 seconds, to save the CPU usage
   845 000012A3 E82C00              <1> 	call .screensaver
   846 000012A6 E87400              <1> 	call os_check_for_key
   847                              <1> 	
   848 000012A9 83F800              <1> 	cmp ax, 0
   849 000012AC 74F4                <1> 	je .loop
   850                              <1> 
   851 000012AE 60                  <1> 	pusha
   852 000012AF B80005              <1> 	mov ax, 0500h
   853 000012B2 CD10                <1> 	int 10h
   854                              <1> 	
   855 000012B4 A0[1813]            <1> 	mov al, [.gfx_state]
   856 000012B7 A28200              <1> 	mov [0082h], al
   857 000012BA 8B0E[1913]          <1> 	mov cx, [.orig_crsr]
   858 000012BE B401                <1> 	mov ah, 01h
   859 000012C0 CD10                <1> 	int 10h
   860 000012C2 61                  <1> 	popa
   861                              <1> 	
   862 000012C3 803E[1B13]01        <1> 	cmp byte [.scrn_active], 1
   863 000012C8 74B1                <1> 	je .try_again
   864                              <1> 	
   865 000012CA A3[1613]            <1> 	mov [.tmp_buf], ax
   866                              <1> 
   867 000012CD 61                  <1> 	popa
   868 000012CE A1[1613]            <1> 	mov ax, [.tmp_buf]
   869 000012D1 C3                  <1> 	ret
   870                              <1> 	
   871                              <1> .screensaver:
   872 000012D2 833E[B948]00        <1> 	cmp word [screensaver_timer], 0
   873 000012D7 7528                <1> 	jne .good
   874                              <1> 	
   875 000012D9 803EF2DE00          <1> 	cmp byte [57074], 0
   876 000012DE 7421                <1> 	je .good
   877                              <1> 	
   878 000012E0 B40F                <1> 	mov ah, 0Fh
   879 000012E2 CD10                <1> 	int 10h
   880                              <1> 	
   881 000012E4 3C03                <1> 	cmp al, 3
   882 000012E6 7519                <1> 	jne .good
   883                              <1> 	
   884 000012E8 60                  <1> 	pusha
   885 000012E9 C606820001          <1> 	mov byte [0082h], 1
   886 000012EE B80105              <1> 	mov ax, 0501h
   887 000012F1 CD10                <1> 	int 10h
   888 000012F3 E8B005              <1> 	call os_hide_cursor
   889 000012F6 C606[1B13]01        <1> 	mov byte [.scrn_active], 1
   890                              <1> 
   891 000012FB B704                <1> 	mov bh, 4
   892 000012FD E80200              <1> 	call .screen_power
   893 00001300 61                  <1> 	popa
   894                              <1> 
   895                              <1> .good:
   896 00001301 C3                  <1> 	ret
   897                              <1> 	
   898                              <1> .screen_power:
   899 00001302 3A3E[1C13]          <1> 	cmp bh, [.scrn_power]
   900 00001306 74F9                <1> 	je .good
   901                              <1> 
   902 00001308 60                  <1> 	pusha
   903 00001309 B8104F              <1> 	mov ax, 4F10h
   904 0000130C B301                <1> 	mov bl, 1
   905 0000130E 883E[1C13]          <1> 	mov [.scrn_power], bh
   906 00001312 CD10                <1> 	int 10h
   907 00001314 61                  <1> 	popa
   908 00001315 C3                  <1> 	ret
   909                              <1> 	
   910 00001316 0000                <1> 	.tmp_buf		dw 0
   911 00001318 00                  <1> 	.gfx_state		db 0
   912 00001319 0000                <1> 	.orig_crsr		dw 0
   913 0000131B 00                  <1> 	.scrn_active	db 0
   914 0000131C 00                  <1> 	.scrn_power		db 0
   915                              <1> 	
   916                              <1> ; ------------------------------------------------------------------
   917                              <1> ; os_check_for_key -- Scans keyboard buffer for input, but doesn't wait
   918                              <1> ; Also handles special keyboard shortcuts.
   919                              <1> ; IN: Nothing; OUT: AX = 0 if no key pressed, otherwise scan code
   920                              <1> 
   921                              <1> os_check_for_key:
   922 0000131D 60                  <1> 	pusha
   923                              <1> 
   924 0000131E B411                <1> 	mov ah, 11h			; BIOS call to check for key
   925                              <1> 	
   926 00001320 CD16                <1> 	int 16h
   927                              <1> 		
   928 00001322 740F                <1> 	jz .nokey			; If no key, skip to end
   929                              <1> 
   930 00001324 B410                <1> 	mov ah, 10h			; Otherwise get it from buffer
   931 00001326 CD16                <1> 	int 16h
   932                              <1> 
   933 00001328 E80E00              <1> 	call special_keys
   934                              <1> 
   935 0000132B A3[3713]            <1> 	mov [.tmp_buf], ax		; Store resulting keypress
   936                              <1> 
   937 0000132E 61                  <1> 	popa				; But restore all other regs
   938 0000132F A1[3713]            <1> 	mov ax, [.tmp_buf]
   939 00001332 C3                  <1> 	ret
   940                              <1> 
   941                              <1> .nokey:
   942 00001333 61                  <1> 	popa
   943                              <1> 	clr ax			; Zero result if no key pressed
    11 00001334 31C0                <2>  xor %1, %1
   944 00001336 C3                  <1> 	ret
   945                              <1> 
   946                              <1> 
   947 00001337 0000                <1> 	.tmp_buf	dw 0
   948                              <1> 
   949                              <1> 
   950                              <1> ; ==================================================================
   951                              <1> 
   952                              <1> ; Checks for special keys and performs their action.
   953                              <1> ; IN: AX = key
   954                              <1> ; OUT: nothing
   955                              <1> special_keys:
   956 00001339 60                  <1> 	pusha
   957 0000133A 80FC69              <1> 	cmp ah, 105
   958 0000133D 0F844E00            <1> 	je near .disable_sound
   959 00001341 80FC6A              <1> 	cmp ah, 106
   960 00001344 0F844000            <1> 	je near .enable_sound
   961 00001348 80FC6B              <1> 	cmp ah, 107
   962 0000134B 0F842500            <1> 	je near .exit_app
   963 0000134F 80FC8B              <1> 	cmp ah, 139
   964 00001352 0F840200            <1> 	je near .intended_system_crash
   965 00001356 61                  <1> 	popa
   966 00001357 C3                  <1> 	ret
   967                              <1> 	
   968                              <1> .intended_system_crash:
   969 00001358 B8[5E13]            <1> 	mov ax, .crash_msg
   970 0000135B E84202              <1> 	call os_fatal_error
   971                              <1> 	
   972 0000135E 496E74656E64656420- <1> 	.crash_msg		db 'Intended system crash', 0
   972 00001367 73797374656D206372- <1>
   972 00001370 61736800            <1>
   973                              <1> 	
   974                              <1> .exit_app:
   975 00001374 803E[B408]00        <1> 	cmp byte [app_running], 0
   976 00001379 0F840900            <1> 	je near .no_exit
   977                              <1> 	
   978 0000137D 61                  <1> 	popa
   979                              <1> 	
   980 0000137E 8B26[B208]          <1> 	mov sp, [origstack]
   981 00001382 83EC02              <1> 	sub sp, 2
   982                              <1> 	
   983 00001385 C3                  <1> 	ret
   984                              <1> 	
   985                              <1> .no_exit:
   986 00001386 61                  <1> 	popa
   987 00001387 C3                  <1> 	ret
   988                              <1> 		
   989                              <1> .enable_sound:
   990 00001388 C606830001          <1> 	mov byte [0083h], 1
   991 0000138D EB08                <1> 	jmp .display_speaker
   992                              <1> 	
   993                              <1> .disable_sound:
   994 0000138F C606830000          <1> 	mov byte [0083h], 0
   995 00001394 E8D712              <1> 	call os_speaker_off
   996                              <1> 
   997                              <1> .display_speaker:
   998 00001397 803E820001          <1> 	cmp byte [0082h], 1
   999 0000139C 741E                <1> 	je .no_display_spkr
  1000                              <1> 
  1001 0000139E E8CE04              <1> 	call os_get_cursor_pos
  1002 000013A1 52                  <1> 	push dx
  1003 000013A2 BA4F00              <1> 	mov dx, 79			; Print the little speaker icon
  1004 000013A5 E8BE04              <1> 	call os_move_cursor
  1005                              <1> 	
  1006 000013A8 B8170E              <1> 	mov ax, 0E17h
  1007 000013AB B700                <1> 	mov bh, 0
  1008 000013AD 803E830000          <1> 	cmp byte [0083h], 0
  1009 000013B2 7402                <1> 	je .no_crossed_spkr
  1010                              <1> 	
  1011 000013B4 FEC8                <1> 	dec al
  1012                              <1> 	
  1013                              <1> .no_crossed_spkr:
  1014 000013B6 CD10                <1> 	int 10h
  1015 000013B8 5A                  <1> 	pop dx
  1016 000013B9 E8AA04              <1> 	call os_move_cursor
  1017                              <1> 	
  1018                              <1> .no_display_spkr:
  1019 000013BC 61                  <1> 	popa
  1020 000013BD C3                  <1> 	ret
  1021                              <1> 	
  1022                              <1> ; ==================================================================
  1023                              <1> 
   812                                  	%INCLUDE "drivers/math.asm"
   813                              <1> ; ==================================================================
   814                              <1> ; MATH ROUTINES
   815                              <1> ; ==================================================================
   816                              <1> 
   817                              <1> ; ------------------------------------------------------------------
   818                              <1> ; os_seed_random -- Seed the random number generator based on the current state of registers and time
   819                              <1> ; IN: every register; OUT: Nothing (registers preserved)
   820                              <1> 
   821                              <1> os_seed_random:
   822 000013BE 60                  <1> 	pusha
   823                              <1> 
   824 000013BF B402                <1> 	mov ah, 02h
   825 000013C1 CD1A                <1> 	int 1Ah
   826                              <1> 	
   827 000013C3 31D8                <1> 	xor ax, bx
   828 000013C5 01C8                <1> 	add ax, cx
   829 000013C7 31D0                <1> 	xor ax, dx
   830 000013C9 01F0                <1> 	add ax, si
   831 000013CB 31F8                <1> 	xor ax, di
   832 000013CD 01E0                <1> 	add ax, sp
   833 000013CF 31E8                <1> 	xor ax, bp
   834 000013D1 05ADDE              <1> 	add ax, 0xDEAD
   835 000013D4 35EFBE              <1> 	xor ax, 0xBEEF
   836                              <1> 	
   837 000013D7 A3[DC13]            <1> 	mov [os_random_seed], ax	; Store the data
   838 000013DA 61                  <1> 	popa
   839 000013DB C3                  <1> 	ret
   840                              <1> 
   841                              <1> 
   842 000013DC 0000                <1> 	os_random_seed	dw 0
   843                              <1> 
   844                              <1> 
   845                              <1> ; ------------------------------------------------------------------
   846                              <1> ; os_get_random -- Return a random integer between low and high (inclusive)
   847                              <1> ; IN: AX = low integer, BX = high integer
   848                              <1> ; OUT: CX = random integer
   849                              <1> 
   850                              <1> os_get_random:
   851 000013DE 52                  <1> 	push dx
   852 000013DF 53                  <1> 	push bx
   853 000013E0 50                  <1> 	push ax
   854                              <1> 
   855 000013E1 29C3                <1> 	sub bx, ax			; We want a number between 0 and (high-low)
   856 000013E3 E80D00              <1> 	call .generate_random
   857 000013E6 89DA                <1> 	mov dx, bx
   858 000013E8 42                  <1> 	inc dx
   859 000013E9 F7E2                <1> 	mul dx
   860 000013EB 89D1                <1> 	mov cx, dx
   861                              <1> 
   862 000013ED 58                  <1> 	pop ax
   863 000013EE 5B                  <1> 	pop bx
   864 000013EF 5A                  <1> 	pop dx
   865 000013F0 01C1                <1> 	add cx, ax			; Add the low offset back
   866 000013F2 C3                  <1> 	ret
   867                              <1> 
   868                              <1> 
   869                              <1> .generate_random:
   870 000013F3 52                  <1> 	push dx
   871 000013F4 53                  <1> 	push bx
   872                              <1> 
   873 000013F5 A1[DC13]            <1> 	mov ax, [os_random_seed]
   874 000013F8 BA8373              <1> 	mov dx, 0x7383			; The magic number (random.org)
   875 000013FB F7E2                <1> 	mul dx				; DX:AX = AX * DX
   876 000013FD A3[DC13]            <1> 	mov [os_random_seed], ax
   877                              <1> 
   878 00001400 5B                  <1> 	pop bx
   879 00001401 5A                  <1>  	pop dx
   880 00001402 C3                  <1> 	ret
   881                              <1> 
   882                              <1> 
   883                              <1> ; ------------------------------------------------------------------
   884                              <1> ; os_bcd_to_int -- Converts a binary coded decimal number to an integer
   885                              <1> ; IN: AL = BCD number; OUT: AX = integer value
   886                              <1> 
   887                              <1> os_bcd_to_int:
   888 00001403 60                  <1> 	pusha
   889                              <1> 
   890 00001404 88C3                <1> 	mov bl, al			; Store entire number for now
   891                              <1> 
   892 00001406 83E00F              <1> 	and ax, 0Fh			; Zero-out high bits
   893 00001409 89C1                <1> 	mov cx, ax			; CH/CL = lower BCD number, zero extended
   894                              <1> 
   895 0000140B C0EB04              <1> 	shr bl, 4			; Move higher BCD number into lower bits, zero fill msb
   896 0000140E B00A                <1> 	mov al, 10
   897 00001410 F6E3                <1> 	mul bl				; AX = 10 * BL
   898                              <1> 
   899 00001412 01C8                <1> 	add ax, cx			; Add lower BCD to 10*higher
   900 00001414 A3[1C14]            <1> 	mov [.tmp], ax
   901                              <1> 
   902 00001417 61                  <1> 	popa
   903 00001418 A1[1C14]            <1> 	mov ax, [.tmp]			; And return it in AX!
   904 0000141B C3                  <1> 	ret
   905                              <1> 
   906                              <1> 
   907 0000141C 0000                <1> 	.tmp	dw 0
   908                              <1> 
   909                              <1> 	
   910                              <1> ; ------------------------------------------------------------------
   911                              <1> ; os_int_to_bcd -- Converts an integer to a binary coded decimal number
   912                              <1> ; IN: AL = integer value; OUT: AL = BCD number
   913                              <1> 
   914                              <1> os_int_to_bcd:
   915 0000141E 60                  <1> 	pusha
   916 0000141F 0FB6C0              <1> 	movzx ax, al
   917 00001422 31D2                <1> 	xor dx, dx
   918                              <1> 	
   919 00001424 BB0A00              <1> 	mov bx, 10
   920 00001427 F7F3                <1> 	div bx
   921                              <1> 	
   922 00001429 C0E004              <1> 	shl al, 4
   923 0000142C 00C2                <1> 	add dl, al
   924                              <1> 	
   925 0000142E 8816[3714]          <1> 	mov [.tmp], dl
   926 00001432 61                  <1> 	popa
   927 00001433 A0[3714]            <1> 	mov al, [.tmp]
   928 00001436 C3                  <1> 	ret
   929                              <1> 
   930 00001437 00                  <1> 	.tmp	db 0
   931                              <1> 
   932                              <1> 
   933                              <1> ; Calculates EAX^EBX.
   934                              <1> ; IN: EAX^EBX = input
   935                              <1> ; OUT: EAX = result
   936                              <1> 
   937                              <1> os_math_power:
   938 00001438 6660                <1> 	pushad
   939 0000143A 6683FB01            <1> 	cmp ebx, 1
   940 0000143E 0F841900            <1> 	je near .power_end
   941 00001442 6683FB00            <1> 	cmp ebx, 0
   942 00001446 0F841F00            <1> 	je near .zero
   943 0000144A 6689D9              <1> 	mov ecx, ebx				; Prepare the data
   944 0000144D 6689C3              <1> 	mov ebx, eax
   945                              <1> .power_loop:
   946 00001450 66F7E3              <1> 	mul ebx
   947 00001453 6649                <1> 	dec ecx
   948 00001455 6683F901            <1> 	cmp ecx, 1
   949 00001459 7FF5                <1> 	jnle .power_loop
   950                              <1> .power_end:
   951 0000145B 66A3[7514]          <1> 	mov [.tmp_dword], eax
   952 0000145F 6661                <1> 	popad
   953 00001461 66A1[7514]          <1> 	mov eax, [.tmp_dword]
   954 00001465 6631D2              <1> 	xor edx, edx
   955 00001468 C3                  <1> 	ret
   956                              <1> .zero:
   957 00001469 6661                <1> 	popad
   958 0000146B 66B801000000        <1> 	mov eax, 1
   959 00001471 6631D2              <1> 	xor edx, edx
   960 00001474 C3                  <1> 	ret
   961                              <1> 	
   962 00001475 00000000            <1> 	.tmp_dword		dd 0
   963 00001479 00000000            <1> 	.tmp_dword2		dd 0
   964                              <1> 	
   965                              <1> ; Calculates the EBX root of EAX.
   966                              <1> ; IN: EAX = input, EBX = root
   967                              <1> ; OUT: EAX(EDX = 0) = result; EAX to EDX = range
   968                              <1> 
   969                              <1> os_math_root:
   970 0000147D 6660                <1> 	pushad
   971 0000147F 6689C1              <1> 	mov ecx, eax				; Prepare the data
   972 00001482 66BE02000000        <1> 	mov esi, 2
   973                              <1> .root_loop:
   974 00001488 6689F0              <1> 	mov eax, esi
   975 0000148B E8AAFF              <1> 	call os_math_power
   976 0000148E 6639C8              <1> 	cmp eax, ecx
   977 00001491 0F840800            <1> 	je near .root_exact
   978 00001495 0F8F1300            <1> 	jg near .root_range
   979 00001499 6646                <1> 	inc esi
   980 0000149B EBEB                <1> 	jmp .root_loop
   981                              <1> .root_exact:
   982 0000149D 668936[C414]        <1> 	mov [.tmp_dword], esi
   983 000014A2 6661                <1> 	popad
   984 000014A4 66A1[C414]          <1> 	mov eax, [.tmp_dword]
   985 000014A8 6631D2              <1> 	xor edx, edx
   986 000014AB C3                  <1> 	ret
   987                              <1> .root_range:
   988 000014AC 668936[C814]        <1> 	mov [.tmp_dword2], esi
   989 000014B1 664E                <1> 	dec esi
   990 000014B3 668936[C414]        <1> 	mov [.tmp_dword], esi
   991 000014B8 6661                <1> 	popad
   992 000014BA 66A1[C414]          <1> 	mov eax, [.tmp_dword]
   993 000014BE 668B16[C814]        <1> 	mov edx, [.tmp_dword2]
   994 000014C3 C3                  <1> 	ret
   995                              <1> 	
   996 000014C4 00000000            <1> 	.tmp_dword		dd 0
   997 000014C8 00000000            <1> 	.tmp_dword2		dd 0
   998                              <1> 
   999                              <1> ; ==================================================================
   813                                  	%INCLUDE "drivers/misc.asm"
   814                              <1> ; ==================================================================
   815                              <1> ; MISCELLANEOUS ROUTINES
   816                              <1> ; ==================================================================
   817                              <1> 
   818                              <1> ; ------------------------------------------------------------------
   819                              <1> ; os_pause -- Delay execution for specified 110ms chunks
   820                              <1> ; IN: AX = amount of ticks to wait
   821                              <1> 
   822                              <1> os_pause:
   823 000014CC 60                  <1> 	pusha
   824 000014CD 83F800              <1> 	cmp ax, 0
   825 000014D0 741F                <1> 	je .time_up			; If delay = 0 then bail out
   826                              <1> 
   827 000014D2 C706[0815]0000      <1> 	mov word [.counter_var], 0		; Zero the counter variable
   828                              <1> 
   829 000014D8 A3[0615]            <1> 	mov [.orig_req_delay], ax	; Save it
   830                              <1> 
   831 000014DB B400                <1> 	mov ah, 0
   832 000014DD E8D901              <1> 	call os_int_1Ah				; Get tick count	
   833                              <1> 
   834 000014E0 8916[0A15]          <1> 	mov [.prev_tick_count], dx	; Save it for later comparison
   835                              <1> 
   836                              <1> .checkloop:
   837 000014E4 B400                <1> 	mov ah,0
   838 000014E6 E8D001              <1> 	call os_int_1Ah				; Get tick count again
   839                              <1> 
   840 000014E9 3916[0A15]          <1> 	cmp [.prev_tick_count], dx	; Compare with previous tick count
   841                              <1> 
   842 000014ED 7504                <1> 	jne .up_date			; If it's changed check it
   843 000014EF EBF3                <1> 	jmp .checkloop			; Otherwise wait some more
   844                              <1> 
   845                              <1> .time_up:
   846 000014F1 61                  <1> 	popa
   847 000014F2 C3                  <1> 	ret
   848                              <1> 
   849                              <1> .up_date:
   850 000014F3 FF06[0815]          <1> 	inc word [.counter_var]		; Inc counter_var
   851 000014F7 A1[0815]            <1> 	mov ax, [.counter_var]
   852                              <1> 	
   853 000014FA 3B06[0615]          <1> 	cmp ax, [.orig_req_delay]	; Is counter_var = required delay?
   854 000014FE 7DF1                <1> 	jge .time_up			; Yes, so bail out
   855                              <1> 
   856 00001500 8916[0A15]          <1> 	mov [.prev_tick_count], dx	; No, so update .prev_tick_count 
   857                              <1> 
   858 00001504 EBDE                <1> 	jmp .checkloop			; And go wait some more
   859                              <1> 
   860                              <1> 
   861 00001506 0000                <1> 	.orig_req_delay		dw	0
   862 00001508 0000                <1> 	.counter_var		dw	0
   863 0000150A 0000                <1> 	.prev_tick_count	dw	0
   864                              <1> 
   865                              <1> ; ------------------------------------------------------------------
   866                              <1> ; os_clear_registers -- Clear all registers
   867                              <1> ; IN: Nothing; OUT: Clear registers
   868                              <1> 
   869                              <1> os_clear_registers:
   870 0000150C 6631C0              <1> 	xor eax, eax
   871 0000150F 6631DB              <1> 	xor ebx, ebx
   872 00001512 6631C9              <1> 	xor ecx, ecx
   873 00001515 6631D2              <1> 	xor edx, edx
   874 00001518 6631F6              <1> 	xor esi, esi
   875 0000151B 6631FF              <1> 	xor edi, edi
   876 0000151E C3                  <1> 	ret
   877                              <1> 
   878                              <1> os_illegal_call:
   879 0000151F B8[2415]            <1> 	mov ax, .msg
   880 00001522 EB7C                <1> 	jmp os_fatal_error
   881                              <1> 	
   882 00001524 43616C6C6564206120- <1> 	.msg db 'Called a non-existent system function', 0
   882 0000152D 6E6F6E2D6578697374- <1>
   882 00001536 656E74207379737465- <1>
   882 0000153F 6D2066756E6374696F- <1>
   882 00001548 6E00                <1>
   883                              <1> 	
   884                              <1> os_update_clock:
   885 0000154A 60                  <1> 	pusha
   886 0000154B 803E820001          <1> 	cmp byte [0082h], 1
   887 00001550 0F843B00            <1> 	je near .update_time_end
   888                              <1> 	
   889 00001554 B402                <1> 	mov ah, 02h			; Get the time
   890 00001556 E86001              <1> 	call os_int_1Ah
   891 00001559 3B0E[9D15]          <1> 	cmp cx, [.tmp_time]
   892 0000155D 0F842E00            <1> 	je near .update_time_end
   893 00001561 890E[9D15]          <1> 	mov [.tmp_time], cx
   894                              <1> 	
   895 00001565 E80703              <1> 	call os_get_cursor_pos
   896 00001568 52                  <1> 	push dx
   897                              <1> 	
   898 00001569 BB[9115]            <1> 	mov bx, .tmp_buffer
   899 0000156C E88816              <1> 	call os_get_date_string
   900                              <1> 	
   901 0000156F BA4500              <1> 	mov dx, 69			; Display date
   902 00001572 E8F102              <1> 	call os_move_cursor
   903                              <1> 
   904 00001575 89DE                <1> 	mov si, bx
   905 00001577 E87B02              <1> 	call os_print_string
   906                              <1> 	
   907 0000157A BB[9115]            <1> 	mov bx, .tmp_buffer
   908 0000157D E83016              <1> 	call os_get_time_string
   909                              <1> 
   910 00001580 BA3F00              <1> 	mov dx, 63			; Display time
   911 00001583 E8E002              <1> 	call os_move_cursor
   912 00001586 89DE                <1> 	mov si, bx
   913 00001588 E86A02              <1> 	call os_print_string
   914                              <1> 	
   915 0000158B 5A                  <1> 	pop dx
   916 0000158C E8D702              <1> 	call os_move_cursor
   917                              <1> 	
   918                              <1> .update_time_end:
   919 0000158F 61                  <1> 	popa
   920 00001590 C3                  <1> 	ret
   921                              <1> 	
   922 00001591 00<rep Ch>          <1> 	.tmp_buffer		times 12 db 0
   923 0000159D 0000                <1> 	.tmp_time		dw 0
   924 0000159F 00                  <1> 	.tmp_hours		db 0
   925                              <1> 
   926                              <1> ; ------------------------------------------------------------------
   927                              <1> ; os_fatal_error -- Display error message and halt execution
   928                              <1> ; IN: AX = error message string location
   929                              <1> 
   930                              <1> os_fatal_error:
   931 000015A0 A3[9816]            <1> 	mov [.ax], ax			; Store string location for now, ...
   932 000015A3 E8AA02              <1> 	call os_clear_screen
   933                              <1> 	
   934                              <1> .main_screen:
   935 000015A6 8CC8                <1> 	mov ax, cs
   936 000015A8 8ED8                <1> 	mov ds, ax
   937 000015AA 8EC0                <1> 	mov es, ax
   938                              <1> 
   939 000015AC B80300              <1> 	mov ax, 3
   940 000015AF CD10                <1> 	int 10h
   941                              <1> 	
   942 000015B1 B80310              <1> 	mov ax, 1003h				; Set text output with certain attributes
   943 000015B4 31DB                <1> 	xor bx, bx					; to be bright, and not blinking
   944 000015B6 CD10                <1> 	int 10h	
   945                              <1> 
   946 000015B8 B8[5416]            <1> 	mov ax, .title_msg
   947 000015BB BB[6816]            <1> 	mov bx, .footer_msg
   948 000015BE B94F00              <1> 	mov cx, 01001111b
   949 000015C1 E8AD08              <1> 	call os_draw_background
   950 000015C4 E8240E              <1> 	call os_reset_font
   951                              <1> 	
   952 000015C7 BA0002              <1> 	mov dx, 2 * 256
   953 000015CA E89902              <1> 	call os_move_cursor
   954 000015CD BE[B508]            <1> 	mov si, bomblogo
   955 000015D0 E8560E              <1> 	call os_draw_icon
   956                              <1> 	
   957 000015D3 BA2302              <1> 	mov dx, 2 * 256 + 35
   958 000015D6 E88D02              <1> 	call os_move_cursor
   959                              <1> 	
   960 000015D9 BE[6916]            <1> 	mov si, .msg0
   961 000015DC E81602              <1> 	call os_print_string
   962                              <1> 	
   963 000015DF BA2303              <1> 	mov dx, 3 * 256 + 35
   964 000015E2 E88102              <1> 	call os_move_cursor
   965                              <1> 	
   966 000015E5 B82A0A              <1> 	mov ax, 0A2Ah					; Write a 43-character long asterisk-type line
   967 000015E8 B700                <1> 	mov bh, 0
   968 000015EA B92B00              <1> 	mov cx, 43
   969 000015ED CD10                <1> 	int 10h
   970                              <1> 	
   971 000015EF BA2305              <1> 	mov dx, 5 * 256 + 35
   972 000015F2 E87102              <1> 	call os_move_cursor
   973 000015F5 BE[9016]            <1> 	mov si, .msg3
   974 000015F8 E8FA01              <1> 	call os_print_string
   975                              <1> 
   976 000015FB 8B36[9816]          <1> 	mov si, [.ax]
   977 000015FF E8F301              <1> 	call os_print_string
   978                              <1> 
   979 00001602 E8A102              <1> 	call os_hide_cursor
   980                              <1> 	
   981 00001605 5B                  <1> 	pop bx
   982 00001606 58                  <1> 	pop ax
   983                              <1> 	
   984                              <1> 	mov16 dx, 35, 7
    15 00001607 BA2307              <2>  mov %1, (%2 + %3 * 256)
   985 0000160A E85902              <1> 	call os_move_cursor
   986                              <1> 	
   987 0000160D BE[3316]            <1> 	mov si, .msg
   988 00001610 E8E201              <1> 	call os_print_string
   989                              <1> 	
   990 00001613 E88E0B              <1> 	call os_print_4hex
   991                              <1> 	
   992 00001616 B03A                <1> 	mov al, ':'
   993 00001618 E8C601              <1> 	call os_putchar
   994                              <1> 	
   995 0000161B 89D8                <1> 	mov ax, bx
   996 0000161D E8840B              <1> 	call os_print_4hex
   997                              <1> 	
   998                              <1> 	mov16 dx, 35, 8
    15 00001620 BA2308              <2>  mov %1, (%2 + %3 * 256)
   999 00001623 E84002              <1> 	call os_move_cursor
  1000                              <1> 	
  1001 00001626 BE[4416]            <1> 	mov si, .msg1
  1002 00001629 E8C901              <1> 	call os_print_string
  1003                              <1> 	
  1004 0000162C 89E0                <1> 	mov ax, sp
  1005 0000162E E8730B              <1> 	call os_print_4hex
  1006                              <1> 	
  1007 00001631 FA                  <1> 	cli
  1008 00001632 F4                  <1> 	hlt
  1009                              <1> 	
  1010 00001633 4372617368206C6F63- <1> 	.msg 			db 'Crash location: ', 0
  1010 0000163C 6174696F6E3A2000    <1>
  1011 00001644 537461636B20706F69- <1> 	.msg1			db 'Stack pointer: ', 0
  1011 0000164D 6E7465723A2000      <1>
  1012                              <1> 	
  1013 00001654 43726570654F532053- <1> 	.title_msg		db 'CrepeOS System Error'
  1013 0000165D 797374656D20457272- <1>
  1013 00001666 6F72                <1>
  1014 00001668 00                  <1> 	.footer_msg		db 0
  1015                              <1> 	
  1016 00001669 43726570654F532068- <1> 	.msg0			db 'CrepeOS has encountered a fatal error.', 0
  1016 00001672 617320656E636F756E- <1>
  1016 0000167B 746572656420612066- <1>
  1016 00001684 6174616C206572726F- <1>
  1016 0000168D 722E00              <1>
  1017 00001690 4572726F723A2000    <1> 	.msg3			db 'Error: ', 0
  1018                              <1> 
  1019 00001698 0000                <1> 	.ax				dw 0
  1020                              <1> 
  1021                              <1> ; Gets the amount of system RAM.
  1022                              <1> ; IN: nothing
  1023                              <1> ; OUT: AX = conventional memory(kB), EBX = high memory(kB)
  1024                              <1> os_get_memory:
  1025 0000169A 60                  <1> 	pusha
  1026 0000169B 31C9                <1> 	xor cx, cx
  1027 0000169D CD12                <1> 	int 12h					; Get the conventional memory size...
  1028 0000169F A3[B216]            <1> 	mov [.conv_mem], ax		; ...and store it
  1029                              <1> 	
  1030 000016A2 B488                <1> 	mov ah, 88h				; Also get the high memory (>1MB)...
  1031 000016A4 CD15                <1> 	int 15h
  1032 000016A6 A3[B416]            <1> 	mov [.high_mem], ax		; ...and store it too
  1033 000016A9 61                  <1> 	popa
  1034 000016AA A1[B216]            <1> 	mov ax, [.conv_mem]
  1035 000016AD 8B1E[B416]          <1> 	mov bx, [.high_mem]
  1036 000016B1 C3                  <1> 	ret
  1037                              <1> 
  1038 000016B2 0000                <1> 	.conv_mem	dw 0
  1039 000016B4 0000                <1> 	.high_mem	dw 0
  1040                              <1> 
  1041                              <1> ; Calls a system function from a far location.
  1042                              <1> ; IN: BP = System function number (8000h, 8003h...)
  1043                              <1> ; OUT: nothing
  1044                              <1> os_far_call:
  1045 000016B6 FFD5                <1> 	call bp
  1046 000016B8 CB                  <1> 	retf
  1047                              <1> 	
  1048                              <1> ; Serves as a middle-man between the INT 1Ah call and the kernel/apps (used for timezones).
  1049                              <1> ; IN/OUT: same as int 1Ah
  1050                              <1> os_int_1Ah:
  1051 000016B9 60                  <1> 	pusha
  1052                              <1> 
  1053 000016BA 80FC02              <1> 	cmp ah, 2		; Read system time
  1054 000016BD 7416                <1> 	je .read_time
  1055                              <1> 	
  1056 000016BF 80FC04              <1> 	cmp ah, 4		; Read system date
  1057 000016C2 7404                <1> 	je .read_date
  1058                              <1> 	
  1059 000016C4 61                  <1> 	popa
  1060 000016C5 CD1A                <1> 	int 1Ah
  1061 000016C7 C3                  <1> 	ret
  1062                              <1> 	
  1063                              <1> .read_date:
  1064 000016C8 E81700              <1> 	call .update_time
  1065 000016CB 61                  <1> 	popa
  1066 000016CC 8B16[A617]          <1> 	mov dx, [.days]
  1067 000016D0 8B0E[A817]          <1> 	mov cx, [.years]
  1068 000016D4 C3                  <1> 	ret
  1069                              <1> 	
  1070                              <1> .read_time:
  1071 000016D5 E80A00              <1> 	call .update_time
  1072                              <1> 	
  1073 000016D8 61                  <1> 	popa
  1074 000016D9 8A36[A317]          <1> 	mov dh, [.seconds]
  1075 000016DD 8B0E[A417]          <1> 	mov cx, [.minutes]
  1076                              <1> 	
  1077 000016E1 C3                  <1> 	ret
  1078                              <1> 
  1079                              <1> .update_time:
  1080 000016E2 B404                <1> 	mov ah, 4
  1081 000016E4 CD1A                <1> 	int 1Ah
  1082 000016E6 8916[A617]          <1> 	mov [.days], dx
  1083 000016EA 890E[A817]          <1> 	mov [.years], cx
  1084                              <1> 	
  1085 000016EE B402                <1> 	mov ah, 2
  1086 000016F0 CD1A                <1> 	int 1Ah
  1087                              <1> 
  1088 000016F2 8836[A317]          <1> 	mov [.seconds], dh
  1089 000016F6 890E[A417]          <1> 	mov [.minutes], cx
  1090                              <1> 	
  1091                              <1> 	; Convert all of these values from BCD to integers
  1092                              <1> 	
  1093 000016FA B90700              <1> 	mov cx, 7
  1094 000016FD BE[A317]            <1> 	mov si, .seconds
  1095 00001700 89F7                <1> 	mov di, si
  1096                              <1> 	
  1097                              <1> .loop:
  1098 00001702 AC                  <1> 	lodsb
  1099 00001703 E8FDFC              <1> 	call os_bcd_to_int
  1100 00001706 AA                  <1> 	stosb
  1101                              <1> 	
  1102 00001707 E2F9                <1> 	loop .loop
  1103                              <1> 	
  1104                              <1> 	; Calculate the time with the time offset
  1105                              <1> 	
  1106 00001709 A1F9DE              <1> 	mov ax, [57081]
  1107 0000170C A90080              <1> 	test ax, 8000h
  1108 0000170F 7541                <1> 	jnz .subtract
  1109                              <1> 	
  1110 00001711 31D2                <1> 	xor dx, dx
  1111 00001713 BB3C00              <1> 	mov bx, 60
  1112 00001716 F7F3                <1> 	div bx
  1113                              <1> 	
  1114                              <1> 	; DX = value to add to minutes
  1115                              <1> 	; AX = value to add to hours
  1116                              <1> 	
  1117 00001718 0016[A417]          <1> 	add [.minutes], dl
  1118 0000171C 803E[A417]3C        <1> 	cmp byte [.minutes], 60
  1119 00001721 7C19                <1> 	jl .add_minutes_ok
  1120                              <1> 	
  1121 00001723 802E[A417]3C        <1> 	sub byte [.minutes], 60
  1122 00001728 FE06[A517]          <1> 	inc byte [.hours]
  1123 0000172C 803E[A517]18        <1> 	cmp byte [.hours], 24
  1124 00001731 7C09                <1> 	jl .add_minutes_ok
  1125                              <1> 	
  1126 00001733 802E[A517]18        <1> 	sub byte [.hours], 24
  1127 00001738 FE06[A617]          <1> 	inc byte [.days]
  1128                              <1> 	
  1129                              <1> 	; At this point I don't care
  1130                              <1> 	
  1131                              <1> .add_minutes_ok:
  1132 0000173C 0006[A517]          <1> 	add [.hours], al
  1133 00001740 803E[A517]18        <1> 	cmp byte [.hours], 24
  1134 00001745 7C4C                <1> 	jl .encodeandexit
  1135                              <1> 	
  1136 00001747 802E[A517]18        <1> 	sub byte [.hours], 24
  1137 0000174C FE06[A617]          <1> 	inc byte [.days]
  1138                              <1> 	
  1139 00001750 EB41                <1> 	jmp .encodeandexit
  1140                              <1> 	
  1141                              <1> .subtract:
  1142 00001752 F7D8                <1> 	neg ax
  1143                              <1> 	
  1144 00001754 31D2                <1> 	xor dx, dx
  1145 00001756 BB3C00              <1> 	mov bx, 60
  1146 00001759 F7F3                <1> 	div bx
  1147                              <1> 	
  1148                              <1> 	; DX = value to subtract from minutes
  1149                              <1> 	; AX = value to subtract from hours
  1150                              <1> 
  1151 0000175B 2816[A417]          <1> 	sub [.minutes], dl
  1152 0000175F 803E[A417]00        <1> 	cmp byte [.minutes], 0
  1153 00001764 7D19                <1> 	jge .sub_minutes_ok
  1154                              <1> 	
  1155                              <1> 	
  1156 00001766 8006[A417]3C        <1> 	add byte [.minutes], 60
  1157 0000176B FE0E[A517]          <1> 	dec byte [.hours]
  1158 0000176F 803E[A517]00        <1> 	cmp byte [.hours], 0
  1159 00001774 7D09                <1> 	jge .sub_minutes_ok
  1160                              <1> 	
  1161 00001776 8006[A517]18        <1> 	add byte [.hours], 24
  1162 0000177B FE0E[A617]          <1> 	dec byte [.days]
  1163                              <1> 	
  1164                              <1> 	; At this point I don't care
  1165                              <1> 	
  1166                              <1> .sub_minutes_ok:
  1167 0000177F 2806[A517]          <1> 	sub [.hours], al
  1168 00001783 803E[A517]00        <1> 	cmp byte [.hours], 0
  1169 00001788 7D09                <1> 	jge .encodeandexit
  1170                              <1> 	
  1171 0000178A 8006[A517]18        <1> 	add byte [.hours], 24
  1172 0000178F FE0E[A617]          <1> 	dec byte [.days]
  1173                              <1> 	
  1174                              <1> .encodeandexit:
  1175 00001793 B90700              <1> 	mov cx, 7
  1176 00001796 BE[A317]            <1> 	mov si, .seconds
  1177 00001799 89F7                <1> 	mov di, si
  1178                              <1> 	
  1179                              <1> .encode_loop:
  1180 0000179B AC                  <1> 	lodsb
  1181 0000179C E87FFC              <1> 	call os_int_to_bcd
  1182 0000179F AA                  <1> 	stosb
  1183 000017A0 E2F9                <1> 	loop .encode_loop
  1184                              <1> 
  1185 000017A2 C3                  <1> 	ret
  1186                              <1> 	
  1187                              <1> 	
  1188 000017A3 00                  <1> 	.seconds	db 0
  1189 000017A4 00                  <1> 	.minutes	db 0
  1190 000017A5 00                  <1> 	.hours		db 0
  1191 000017A6 00                  <1> 	.days		db 0
  1192 000017A7 00                  <1> 	.months		db 0
  1193 000017A8 00                  <1> 	.years		db 0
  1194 000017A9 00                  <1> 	.centuries	db 0
  1195                              <1> 	
  1196                              <1> ; ==================================================================
  1197                              <1> 
   814                                  	%INCLUDE "drivers/ports.asm"
   815                              <1> ; ==================================================================
   816                              <1> ; PORT INPUT AND OUTPUT ROUTINES
   817                              <1> ; ==================================================================
   818                              <1> 
   819                              <1> ; ------------------------------------------------------------------
   820                              <1> ; os_serial_port_enable -- Set up the serial port for transmitting data
   821                              <1> ; IN: AX = 0 for normal mode (9600 baud), or 1 for slow mode (1200 baud)
   822                              <1> 
   823                              <1> os_serial_port_enable:
   824 000017AA 60                  <1> 	pusha
   825                              <1> 
   826                              <1> 	clr dx			; Configure serial port 1
    11 000017AB 31D2                <2>  xor %1, %1
   827 000017AD 83F801              <1> 	cmp ax, 1
   828 000017B0 7405                <1> 	je .slow_mode
   829                              <1> 
   830 000017B2 B8E300              <1> 	mov ax, 11100011b		; 9600 baud, no parity, 8 data bits, 1 stop bit
   831 000017B5 EB03                <1> 	jmp .finish
   832                              <1> 
   833                              <1> .slow_mode:
   834 000017B7 B88300              <1> 	mov ax, 10000011b		; 1200 baud, no parity, 8 data bits, 1 stop bit	
   835                              <1> 
   836                              <1> .finish:
   837 000017BA CD14                <1> 	int 14h
   838                              <1> 
   839 000017BC 61                  <1> 	popa
   840 000017BD C3                  <1> 	ret
   841                              <1> 
   842                              <1> 
   843                              <1> ; ------------------------------------------------------------------
   844                              <1> ; os_send_via_serial -- Send a byte via the serial port
   845                              <1> ; IN: AL = byte to send via serial; OUT: AH = Bit 7 clear on success
   846                              <1> 
   847                              <1> os_send_via_serial:
   848 000017BE 60                  <1> 	pusha
   849                              <1> 
   850 000017BF B401                <1> 	mov ah, 01h
   851                              <1> 	clr dx			; COM1
    11 000017C1 31D2                <2>  xor %1, %1
   852                              <1> 
   853 000017C3 CD14                <1> 	int 14h
   854                              <1> 
   855 000017C5 8826[CF17]          <1> 	mov [.tmp], ah
   856                              <1> 
   857 000017C9 61                  <1> 	popa
   858                              <1> 
   859 000017CA 8A26[CF17]          <1> 	mov ah, [.tmp]
   860                              <1> 
   861 000017CE C3                  <1> 	ret
   862                              <1> 
   863 000017CF 00                  <1> 	.tmp db 0
   864                              <1> 
   865                              <1> 
   866                              <1> ; ------------------------------------------------------------------
   867                              <1> ; os_get_via_serial -- Get a byte from the serial port
   868                              <1> ; IN: nothing; OUT: AL = byte that was received, AH = Bit 7 clear on success
   869                              <1> 
   870                              <1> os_get_via_serial:
   871 000017D0 60                  <1> 	pusha
   872                              <1> 
   873 000017D1 B402                <1> 	mov ah, 02h
   874                              <1> 	clr dx			; COM1
    11 000017D3 31D2                <2>  xor %1, %1
   875                              <1> 
   876 000017D5 CD14                <1> 	int 14h
   877                              <1> 
   878 000017D7 A3[DF17]            <1> 	mov [.tmp], ax
   879                              <1> 
   880 000017DA 61                  <1> 	popa
   881                              <1> 
   882 000017DB A1[DF17]            <1> 	mov ax, [.tmp]
   883                              <1> 
   884 000017DE C3                  <1> 	ret
   885                              <1> 
   886                              <1> 
   887 000017DF 0000                <1> 	.tmp dw 0
   888                              <1> 
   889                              <1> ; ==================================================================
   890                              <1> 
   815                                  	%INCLUDE "drivers/screen.asm"
   816                              <1> ; ==================================================================
   817                              <1> ; SCREEN HANDLING SYSTEM CALLS
   818                              <1> ; ==================================================================
   819                              <1> 
   820                              <1> ; ------------------------------------------------------------------
   821                              <1> ; os_putchar -- Puts a character on the screen
   822                              <1> ; IN: AL = character
   823                              <1> ; OUT: Nothing (registers preserved)
   824                              <1> 
   825                              <1> os_putchar:
   826 000017E1 60                  <1> 	pusha
   827 000017E2 B40E                <1> 	mov ah, 0Eh
   828 000017E4 CD10                <1> 	int 10h
   829 000017E6 61                  <1> 	popa
   830 000017E7 C3                  <1> 	ret
   831                              <1> 
   832                              <1> ; ------------------------------------------------------------------
   833                              <1> ; os_put_chars -- Puts up to a set amount of characters on the screen
   834                              <1> ; IN: BL = terminator, SI = location, CX = character count
   835                              <1> ; OUT: Nothing (registers preserved)
   836                              <1> 
   837                              <1> os_put_chars:
   838 000017E8 60                  <1> 	pusha
   839                              <1> 	
   840                              <1> .loop:
   841 000017E9 AC                  <1> 	lodsb
   842 000017EA 38D8                <1> 	cmp al, bl
   843 000017EC 7405                <1> 	je .done
   844                              <1> 	
   845 000017EE E8F0FF              <1> 	call os_putchar
   846                              <1> 	
   847 000017F1 E2F6                <1> 	loop .loop
   848                              <1> 	
   849                              <1> .done:
   850 000017F3 61                  <1> 	popa
   851 000017F4 C3                  <1> 	ret
   852                              <1> 
   853                              <1> ; ------------------------------------------------------------------
   854                              <1> ; os_print_string -- Displays text
   855                              <1> ; IN: SI = message location (zero-terminated string)
   856                              <1> ; OUT: Nothing (registers preserved)
   857                              <1> 
   858                              <1> os_print_string:
   859 000017F5 60                  <1> 	pusha
   860                              <1> 
   861                              <1> .repeat:
   862 000017F6 AC                  <1> 	lodsb				; Get char from string
   863 000017F7 3C00                <1> 	cmp al, 0
   864 000017F9 7405                <1> 	je .done			; If char is zero, end of string
   865                              <1> 
   866 000017FB E8E3FF              <1> 	call os_putchar
   867 000017FE EBF6                <1> 	jmp .repeat			; And move on to next char
   868                              <1> 
   869                              <1> .done:
   870 00001800 61                  <1> 	popa
   871 00001801 C3                  <1> 	ret
   872                              <1> 
   873                              <1> ; ------------------------------------------------------------------
   874                              <1> ; os_print_string_box -- Displays text inside a text-box.
   875                              <1> ; IN: SI = message location (zero-terminated string), DL = left alignment
   876                              <1> ; OUT: Nothing (registers preserved)
   877                              <1> 
   878                              <1> os_print_string_box:
   879 00001802 60                  <1> 	pusha
   880 00001803 88D1                <1> 	mov cl, dl
   881                              <1> 
   882                              <1> .repeat:
   883 00001805 AC                  <1> 	lodsb				; Get char from string
   884 00001806 3C00                <1> 	cmp al, 0
   885 00001808 7409                <1> 	je .done			; If char is zero, end of string
   886                              <1> 
   887 0000180A 3C0D                <1> 	cmp al, 13
   888 0000180C 7407                <1> 	je .cr
   889                              <1> 	
   890 0000180E E8D0FF              <1> 	call os_putchar
   891 00001811 EBF2                <1> 	jmp .repeat			; And move on to next char
   892                              <1> 
   893                              <1> .done:
   894 00001813 61                  <1> 	popa
   895 00001814 C3                  <1> 	ret
   896                              <1> 	
   897                              <1> .cr:
   898 00001815 E85700              <1> 	call os_get_cursor_pos
   899 00001818 88CA                <1> 	mov dl, cl
   900 0000181A E84900              <1> 	call os_move_cursor
   901 0000181D EBE6                <1> 	jmp .repeat
   902                              <1> 
   903                              <1> ; ------------------------------------------------------------------
   904                              <1> ; os_format_string -- Displays colored text
   905                              <1> ; IN: BL/SI = text color/message location (zero-terminated string)
   906                              <1> ; OUT: Nothing (registers preserved)
   907                              <1> 
   908                              <1> os_format_string:
   909 0000181F 60                  <1> 	pusha
   910                              <1> 
   911 00001820 B409                <1> 	mov ah, 09h			; int 09h
   912 00001822 B700                <1> 	mov bh, 0
   913 00001824 B90100              <1> 	mov cx, 1
   914 00001827 E84500              <1> 	call os_get_cursor_pos
   915                              <1> 	
   916                              <1> .repeat:
   917 0000182A AC                  <1> 	lodsb				; Get char from string
   918 0000182B 3C0D                <1> 	cmp al, 13
   919 0000182D 7411                <1> 	je .cr
   920 0000182F 3C0A                <1> 	cmp al, 10
   921 00001831 7414                <1> 	je .lf
   922 00001833 3C00                <1> 	cmp al, 0
   923 00001835 7417                <1> 	je .done			; If char is zero, end of string
   924                              <1> 
   925 00001837 CD10                <1> 	int 10h				; Otherwise, print it
   926                              <1> 
   927 00001839 FEC2                <1> 	inc dl
   928 0000183B E82800              <1> 	call os_move_cursor
   929                              <1> 	
   930 0000183E EBEA                <1> 	jmp .repeat			; And move on to next char
   931                              <1> 	
   932                              <1> .cr:
   933 00001840 B200                <1> 	mov dl, 0
   934 00001842 E82100              <1> 	call os_move_cursor
   935 00001845 EBE3                <1> 	jmp .repeat
   936                              <1> 
   937                              <1> .lf:
   938 00001847 FEC6                <1> 	inc dh
   939 00001849 E81A00              <1> 	call os_move_cursor
   940 0000184C EBDC                <1> 	jmp .repeat
   941                              <1> 	
   942                              <1> .done:
   943 0000184E 61                  <1> 	popa
   944 0000184F C3                  <1> 	ret
   945                              <1> 
   946                              <1> 
   947                              <1> ; ------------------------------------------------------------------
   948                              <1> ; os_clear_screen -- Clears the screen to background
   949                              <1> ; IN/OUT: Nothing (registers preserved)
   950                              <1> 
   951                              <1> os_clear_screen:
   952 00001850 60                  <1> 	pusha
   953                              <1> 
   954 00001851 BA0000              <1> 	mov dx, 0			; Position cursor at top-left
   955 00001854 E80F00              <1> 	call os_move_cursor
   956                              <1> 
   957                              <1> 	mov16 ax, 0, 6		; Scroll full-screen
    15 00001857 B80006              <2>  mov %1, (%2 + %3 * 256)
   958 0000185A B707                <1> 	mov bh, 7
   959                              <1> 	mov16 cx, 0, 0		; Top-left
    15 0000185C B90000              <2>  mov %1, (%2 + %3 * 256)
   960                              <1> 	mov16 dx, 79, 24	; Bottom-right
    15 0000185F BA4F18              <2>  mov %1, (%2 + %3 * 256)
   961 00001862 CD10                <1> 	int 10h
   962                              <1> 
   963 00001864 61                  <1> 	popa
   964 00001865 C3                  <1> 	ret
   965                              <1> 
   966                              <1> 
   967                              <1> ; ------------------------------------------------------------------
   968                              <1> ; os_move_cursor -- Moves cursor in text mode
   969                              <1> ; IN: DH, DL = row, column; OUT: Nothing (registers preserved)
   970                              <1> 
   971                              <1> os_move_cursor:
   972 00001866 60                  <1> 	pusha
   973                              <1> 
   974 00001867 B700                <1> 	mov bh, 0
   975 00001869 B402                <1> 	mov ah, 2
   976 0000186B CD10                <1> 	int 10h				; BIOS interrupt to move cursor
   977                              <1> 
   978 0000186D 61                  <1> 	popa
   979 0000186E C3                  <1> 	ret
   980                              <1> 
   981                              <1> 
   982                              <1> ; ------------------------------------------------------------------
   983                              <1> ; os_get_cursor_pos -- Return position of text cursor
   984                              <1> ; OUT: DH, DL = row, column
   985                              <1> 
   986                              <1> os_get_cursor_pos:
   987 0000186F 60                  <1> 	pusha
   988                              <1> 
   989 00001870 B700                <1> 	mov bh, 0
   990 00001872 B403                <1> 	mov ah, 3
   991 00001874 CD10                <1> 	int 10h				; BIOS interrupt to get cursor position
   992                              <1> 
   993 00001876 8916[8018]          <1> 	mov [.tmp], dx
   994 0000187A 61                  <1> 	popa
   995 0000187B 8B16[8018]          <1> 	mov dx, [.tmp]
   996 0000187F C3                  <1> 	ret
   997                              <1> 
   998                              <1> 
   999 00001880 0000                <1> 	.tmp dw 0
  1000                              <1> 
  1001                              <1> 
  1002                              <1> ; ------------------------------------------------------------------
  1003                              <1> ; os_print_horiz_line -- Draw a horizontal line on the screen
  1004                              <1> ; IN: AX = line type (1 for double (-), otherwise single (=))
  1005                              <1> ; OUT: Nothing (registers preserved)
  1006                              <1> 
  1007                              <1> os_print_horiz_line:
  1008 00001882 60                  <1> 	pusha
  1009                              <1> 
  1010 00001883 89C1                <1> 	mov cx, ax			; Store line type param
  1011 00001885 B0C4                <1> 	mov al, 196			; Default is single-line code
  1012                              <1> 
  1013 00001887 83F901              <1> 	cmp cx, 1			; Was double-line specified in AX?
  1014 0000188A 7502                <1> 	jne .ready
  1015 0000188C B0CD                <1> 	mov al, 205			; If so, here's the code
  1016                              <1> 
  1017                              <1> .ready:
  1018 0000188E B95000              <1> 	mov cx, 80			; Counter
  1019 00001891 B40E                <1> 	mov ah, 0Eh			; BIOS output char routine
  1020 00001893 B700                <1> 	mov bh, 0
  1021                              <1> 	
  1022                              <1> .loop:
  1023 00001895 CD10                <1> 	int 10h
  1024 00001897 E2FC                <1> 	loop .loop
  1025                              <1> 	
  1026 00001899 61                  <1> 	popa
  1027 0000189A C3                  <1> 	ret
  1028                              <1> 
  1029                              <1> 
  1030                              <1> ; ------------------------------------------------------------------
  1031                              <1> ; os_show_cursor -- Turns on cursor in text mode
  1032                              <1> ; IN/OUT: Nothing
  1033                              <1> 
  1034                              <1> os_show_cursor:
  1035 0000189B 60                  <1> 	pusha
  1036                              <1> 
  1037                              <1> 	mov16 cx, 7, 6
    15 0000189C B90706              <2>  mov %1, (%2 + %3 * 256)
  1038                              <1> 	mov16 ax, 3, 1
    15 0000189F B80301              <2>  mov %1, (%2 + %3 * 256)
  1039 000018A2 CD10                <1> 	int 10h
  1040                              <1> 
  1041 000018A4 61                  <1> 	popa
  1042 000018A5 C3                  <1> 	ret
  1043                              <1> 
  1044                              <1> 
  1045                              <1> ; ------------------------------------------------------------------
  1046                              <1> ; os_hide_cursor -- Turns off cursor in text mode
  1047                              <1> ; IN/OUT: Nothing
  1048                              <1> 
  1049                              <1> os_hide_cursor:
  1050 000018A6 60                  <1> 	pusha
  1051                              <1> 
  1052 000018A7 B520                <1> 	mov ch, 32
  1053                              <1> 	mov16 ax, 3, 1	; AL must be video mode for buggy BIOSes!
    15 000018A9 B80301              <2>  mov %1, (%2 + %3 * 256)
  1054 000018AC CD10                <1> 	int 10h
  1055                              <1> 
  1056 000018AE 61                  <1> 	popa
  1057 000018AF C3                  <1> 	ret
  1058                              <1> 
  1059                              <1> 
  1060                              <1> ; ------------------------------------------------------------------
  1061                              <1> ; os_draw_block -- Render block of specified colour
  1062                              <1> ; IN: BL/DL/DH/SI/DI = colour/start X pos/start Y pos/width/finish Y pos
  1063                              <1> 
  1064                              <1> os_draw_block:
  1065 000018B0 60                  <1> 	pusha
  1066                              <1> 
  1067                              <1> .more:
  1068 000018B1 E8B2FF              <1> 	call os_move_cursor		; Move to block starting position
  1069                              <1> 
  1070                              <1> 	mov16 ax, ' ', 09h			; Draw colour section
    15 000018B4 B82009              <2>  mov %1, (%2 + %3 * 256)
  1071 000018B7 B700                <1> 	mov bh, 0
  1072 000018B9 89F1                <1> 	mov cx, si
  1073 000018BB CD10                <1> 	int 10h
  1074                              <1> 
  1075 000018BD FEC6                <1> 	inc dh				; Get ready for next line
  1076                              <1> 
  1077 000018BF 0FB6C6              <1> 	movzx ax, dh		; Get current Y position into DL
  1078 000018C2 39F8                <1> 	cmp ax, di			; Reached finishing point (DI)?
  1079 000018C4 75EB                <1> 	jne .more			; If not, keep drawing
  1080                              <1> 
  1081 000018C6 61                  <1> 	popa
  1082 000018C7 C3                  <1> 	ret
  1083                              <1> 
  1084                              <1> 
  1085                              <1> ; ------------------------------------------------------------------
  1086                              <1> ; os_file_selector -- Show a file selection dialog
  1087                              <1> ; IN: If [0087h] = 1, then BX = location of file extension list
  1088                              <1> ; OUT: AX = location of filename string (or carry set if Esc pressed)
  1089                              <1> 
  1090                              <1> os_file_selector:
  1091                              <1> 	; Get volume name
  1092                              <1> 	
  1093 000018C8 60                  <1> 	pusha
  1094 000018C9 B90100              <1> 	mov cx, 1					; Load first disk sector into RAM
  1095 000018CC 0FB6168400          <1> 	movzx dx, byte [0084h]
  1096 000018D1 BB00E0              <1> 	mov bx, disk_buffer
  1097                              <1> 
  1098                              <1> 	mov16 ax, 1, 2
    15 000018D4 B80102              <2>  mov %1, (%2 + %3 * 256)
  1099 000018D7 F9                  <1> 	stc
  1100 000018D8 CD13                <1> 	int 13h						; BIOS load sector call
  1101                              <1> 
  1102 000018DA BE2BE0              <1> 	mov si, disk_buffer + 2Bh	; Disk label starts here
  1103                              <1> 
  1104 000018DD BF[631B]            <1> 	mov di, .volname
  1105 000018E0 B90B00              <1> 	mov cx, 11					; Copy 11 chars of it
  1106 000018E3 F3A4                <1> 	rep movsb
  1107 000018E5 61                  <1> 	popa
  1108                              <1> 	
  1109 000018E6 60                  <1> 	pusha
  1110 000018E7 C706[481B]0000      <1> 	mov word [.filename], 0		; Terminate string in case user leaves without choosing
  1111                              <1> 
  1112 000018ED E8F9F0              <1> 	call os_report_free_space
  1113 000018F0 D1E8                <1> 	shr ax, 1					; Sectors -> kB
  1114 000018F2 A3[6F1B]            <1> 	mov [.freespace], ax
  1115                              <1> 	
  1116                              <1> 	; Add the filters, if desired
  1117                              <1> 
  1118 000018F5 BF5100              <1> 	mov di, 0051h
  1119 000018F8 C60500              <1> 	mov byte [di], 0
  1120                              <1> 	
  1121 000018FB 803E870001          <1> 	cmp byte [0087h], 1
  1122 00001900 752F                <1> 	jne .no_filter
  1123                              <1> 	
  1124 00001902 891E[711B]          <1> 	mov [.extension_list], bx
  1125                              <1> 
  1126 00001906 BE[121B]            <1> 	mov si, .filter_msg
  1127 00001909 BF5100              <1> 	mov di, 0051h
  1128 0000190C E83B11              <1> 	call os_string_copy
  1129                              <1> 
  1130 0000190F 60                  <1> 	pusha
  1131 00001910 BF5A00              <1> 	mov di, 0051h + 9
  1132 00001913 89DE                <1> 	mov si, bx
  1133 00001915 8A1C                <1> 	mov bl, [si]
  1134 00001917 46                  <1> 	inc si
  1135 00001918 B100                <1> 	mov cl, 0
  1136                              <1> 	
  1137                              <1> .filter_loop:
  1138 0000191A E82D11              <1> 	call os_string_copy
  1139 0000191D C6450320            <1> 	mov byte [di + 3], ' '
  1140 00001921 83C704              <1> 	add di, 4
  1141 00001924 83C604              <1> 	add si, 4
  1142 00001927 FEC1                <1> 	inc cl
  1143 00001929 38D9                <1> 	cmp cl, bl
  1144 0000192B 75ED                <1> 	jne .filter_loop
  1145                              <1> 	
  1146 0000192D C60500              <1> 	mov byte [di], 0
  1147 00001930 61                  <1> 	popa
  1148                              <1> 	
  1149                              <1> .no_filter:
  1150                              <1> 	; Create the filename index list
  1151                              <1> 
  1152 00001931 E8BDF8              <1> 	call disk_read_root_dir		; Get the files into the buffer
  1153                              <1> 
  1154 00001934 BE00E0              <1> 	mov si, disk_buffer			; Raw directory buffer
  1155 00001937 BF00FC              <1> 	mov di, 64512				; Buffer for indexes
  1156 0000193A B90000              <1> 	mov cx, 0					; Number of found files
  1157                              <1> 
  1158                              <1> .index_loop:
  1159 0000193D 81FE00FC            <1> 	cmp si, 64512			; Are we done looping through the directory?
  1160 00001941 744E                <1> 	je .done
  1161                              <1> 
  1162 00001943 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
  1163 00001946 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
  1164 00001948 7442                <1> 	je .skip
  1165                              <1> 
  1166 0000194A A808                <1> 	test al, 08h			; Is this a directory entry or volume label?
  1167 0000194C 753E                <1> 	jnz .skip			; Yes, ignore it
  1168                              <1> 
  1169 0000194E 8A04                <1> 	mov al, [si]
  1170 00001950 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
  1171 00001952 7438                <1> 	je .skip
  1172                              <1> 
  1173 00001954 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
  1174 00001956 7439                <1> 	je .done
  1175                              <1> 
  1176 00001958 60                  <1> 	pusha
  1177                              <1> 
  1178 00001959 803E870001          <1> 	cmp byte [0087h], 1	; Check if we are supposed to filter the filenames
  1179 0000195E 7523                <1> 	jne .no_extension_check
  1180                              <1> 	
  1181 00001960 8B1E[711B]          <1> 	mov bx, [.extension_list]
  1182 00001964 0FB60F              <1> 	movzx cx, byte [bx]
  1183                              <1> 
  1184                              <1> .extension_loop:
  1185 00001967 60                  <1> 	pusha
  1186 00001968 83C608              <1> 	add si, 8
  1187                              <1> 	
  1188 0000196B 49                  <1> 	dec cx
  1189 0000196C 89CF                <1> 	mov di, cx
  1190 0000196E C1E702              <1> 	shl di, 2	; Each entry is 4 bytes long
  1191 00001971 47                  <1> 	inc di		; The entry list starts with a 1-byte header
  1192 00001972 033E[711B]          <1> 	add di, [.extension_list]
  1193                              <1> 	
  1194 00001976 B90300              <1> 	mov cx, 3
  1195 00001979 F3A6                <1> 	rep cmpsb
  1196 0000197B 61                  <1> 	popa
  1197 0000197C 7405                <1> 	je .no_extension_check
  1198                              <1> 	
  1199 0000197E E2E7                <1> 	loop .extension_loop
  1200                              <1> 	
  1201 00001980 61                  <1> 	popa
  1202 00001981 EB09                <1> 	jmp .skip
  1203                              <1> 
  1204                              <1> .no_extension_check:
  1205 00001983 61                  <1> 	popa
  1206                              <1> 
  1207 00001984 41                  <1> 	inc cx				; Increment the number of discovered files
  1208 00001985 89F0                <1> 	mov ax, si			; Store the filename pointer into the buffer
  1209 00001987 AB                  <1> 	stosw
  1210                              <1> 
  1211 00001988 C6440B00            <1> 	mov byte [si+11], 0	; Zero-terminate the string
  1212                              <1> 
  1213                              <1> .skip:
  1214 0000198C 83C620              <1> 	add si, byte 32		; Skip to the next file
  1215 0000198F EBAC                <1> 	jmp .index_loop
  1216                              <1> 
  1217                              <1> .done:
  1218                              <1> 	; Let the user select a file
  1219                              <1> 
  1220 00001991 89C8                <1> 	mov ax, cx			; Pass the number of files
  1221 00001993 BB[341B]            <1> 	mov bx, .root
  1222 00001996 B95100              <1> 	mov cx, 0051h
  1223 00001999 BE[E519]            <1> 	mov si, .callback
  1224                              <1> 
  1225 0000199C C606[731B]01        <1> 	mov byte [.file_selector_calling], 1
  1226 000019A1 E8D301              <1> 	call os_list_dialog_tooltip
  1227 000019A4 C606[731B]00        <1> 	mov byte [.file_selector_calling], 0
  1228                              <1> 
  1229 000019A9 7209                <1> 	jc .esc_pressed
  1230                              <1> 
  1231 000019AB E80900              <1> 	call .get_filename
  1232                              <1> 	
  1233 000019AE 61                  <1> 	popa
  1234 000019AF B8[481B]            <1> 	mov ax, .filename
  1235 000019B2 F8                  <1> 	clc
  1236 000019B3 C3                  <1> 	ret
  1237                              <1> 
  1238                              <1> .esc_pressed:				; Set carry flag if Escape was pressed
  1239 000019B4 61                  <1> 	popa
  1240 000019B5 F9                  <1> 	stc
  1241 000019B6 C3                  <1> 	ret
  1242                              <1> 
  1243                              <1> .get_filename:
  1244 000019B7 48                  <1> 	dec ax				; Result from os_list_dialog starts from 1, but
  1245                              <1> 						; for our file list offset we want to start from 0
  1246                              <1> 	
  1247 000019B8 89C6                <1> 	mov si, ax			; Get the pointer to the string in the index
  1248 000019BA D1E6                <1> 	shl si, 1
  1249 000019BC 81C600FC            <1> 	add si, 64512
  1250                              <1> 
  1251 000019C0 AD                  <1> 	lodsw
  1252 000019C1 89C6                <1> 	mov si, ax			; Our resulting pointer
  1253                              <1> 	clr cx
    11 000019C3 31C9                <2>  xor %1, %1
  1254 000019C5 BF[481B]            <1> 	mov di, .filename
  1255                              <1> 	
  1256                              <1> .loopy:
  1257 000019C8 AC                  <1> 	lodsb
  1258 000019C9 3C20                <1> 	cmp al, ' '
  1259 000019CB 7401                <1> 	je .ignore_space
  1260 000019CD AA                  <1> 	stosb
  1261                              <1> 	
  1262                              <1> .ignore_space:
  1263 000019CE 41                  <1> 	inc cx
  1264 000019CF 83F908              <1> 	cmp cx, 8
  1265 000019D2 7407                <1> 	je .add_dot
  1266 000019D4 83F90B              <1> 	cmp cx, 11
  1267 000019D7 7408                <1> 	je .done_copy
  1268 000019D9 EBED                <1> 	jmp .loopy
  1269                              <1> 
  1270                              <1> .add_dot:
  1271 000019DB C6052E              <1> 	mov byte [di], '.'
  1272 000019DE 47                  <1> 	inc di
  1273 000019DF EBE7                <1> 	jmp .loopy
  1274                              <1> 
  1275                              <1> .done_copy:
  1276 000019E1 C60500              <1> 	mov byte [di], 0
  1277                              <1> 
  1278 000019E4 C3                  <1> 	ret
  1279                              <1> 	
  1280                              <1> .callback:
  1281                              <1> 	; Draw the box on the right
  1282 000019E5 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  1283                              <1> 	mov16 dx, 41, 2		; Start X/Y position
    15 000019E9 BA2902              <2>  mov %1, (%2 + %3 * 256)
  1284 000019EC BE2500              <1> 	mov si, 37			; Width
  1285 000019EF BF1700              <1> 	mov di, 23			; Finish Y position
  1286 000019F2 E8BBFE              <1> 	call os_draw_block	; Draw option selector window
  1287                              <1> 
  1288                              <1> 	; Draw the icon's background
  1289 000019F5 B3F0                <1> 	mov bl, 0F0h
  1290                              <1> 	mov16 dx, 50, 3
    15 000019F7 BA3203              <2>  mov %1, (%2 + %3 * 256)
  1291 000019FA BE1300              <1> 	mov si, 19			; Width
  1292 000019FD BF0D00              <1> 	mov di, 13			; Finish Y position
  1293 00001A00 E8ADFE              <1> 	call os_draw_block	; Draw option selector window	
  1294                              <1> 
  1295                              <1> 	; Draw the icon
  1296                              <1> 	
  1297                              <1> 	mov16 dx, 52, 4
    15 00001A03 BA3404              <2>  mov %1, (%2 + %3 * 256)
  1298 00001A06 E85DFE              <1> 	call os_move_cursor
  1299                              <1> 	
  1300 00001A09 BE[4709]            <1> 	mov si, filelogo
  1301 00001A0C E81A0A              <1> 	call os_draw_icon
  1302                              <1> 
  1303                              <1> 	; Display the filename
  1304                              <1> 
  1305                              <1> 	mov16 dx, 42, 14
    15 00001A0F BA2A0E              <2>  mov %1, (%2 + %3 * 256)
  1306 00001A12 E851FE              <1> 	call os_move_cursor
  1307                              <1> 
  1308 00001A15 50                  <1> 	push ax
  1309 00001A16 E89EFF              <1> 	call .get_filename
  1310                              <1> 	
  1311 00001A19 BE[481B]            <1> 	mov si, .filename
  1312 00001A1C E8D6FD              <1> 	call os_print_string
  1313                              <1> 	
  1314                              <1> 	; Find the correct directory entry for this file
  1315                              <1> 
  1316 00001A1F 58                  <1> 	pop ax
  1317                              <1> 
  1318 00001A20 48                  <1> 	dec ax
  1319 00001A21 89C6                <1> 	mov si, ax
  1320 00001A23 D1E6                <1> 	shl si, 1
  1321 00001A25 81C600FC            <1> 	add si, 64512
  1322 00001A29 8B34                <1> 	mov si, [si]			; Get the pointer to the entry in the index list
  1323                              <1> 
  1324 00001A2B 56                  <1> 	push si
  1325                              <1> 	
  1326                              <1> 	; Display the file size
  1327                              <1> 	
  1328 00001A2C 668B441C            <1> 	mov eax, [si + 28]
  1329 00001A30 E82112              <1> 	call os_32int_to_string
  1330                              <1> 	
  1331 00001A33 89C6                <1> 	mov si, ax
  1332 00001A35 BF[481B]            <1> 	mov di, .filename
  1333 00001A38 E80F10              <1> 	call os_string_copy
  1334                              <1> 	
  1335 00001A3B B8[481B]            <1> 	mov ax, .filename
  1336 00001A3E BB[1C1B]            <1> 	mov bx, .byte_msg
  1337 00001A41 E8640F              <1> 	call os_string_add
  1338                              <1> 	
  1339 00001A44 E8700F              <1> 	call os_string_length
  1340                              <1> 
  1341 00001A47 B24D                <1> 	mov dl, 77
  1342 00001A49 28C2                <1> 	sub dl, al
  1343 00001A4B E818FE              <1> 	call os_move_cursor
  1344                              <1> 	
  1345 00001A4E BE[481B]            <1> 	mov si, .filename
  1346 00001A51 E8A1FD              <1> 	call os_print_string
  1347                              <1> 	
  1348                              <1> 	; Display the file write date/time
  1349                              <1> 	
  1350 00001A54 C606[481B]00        <1> 	mov byte [.filename], 0
  1351                              <1> 	
  1352 00001A59 5E                  <1> 	pop si
  1353 00001A5A 8B5C0E              <1> 	mov bx, [si + 14]
  1354 00001A5D 8B4C10              <1> 	mov cx, [si + 16]
  1355                              <1> 	
  1356 00001A60 53                  <1> 	push bx
  1357 00001A61 89C8                <1> 	mov ax, cx		; Days
  1358 00001A63 83E01F              <1> 	and ax, 11111b
  1359                              <1> 	
  1360 00001A66 BA[2E1B]            <1> 	mov dx, .dateseparator
  1361 00001A69 E88400              <1> 	call .cb_add_num
  1362                              <1> 	
  1363 00001A6C 89C8                <1> 	mov ax, cx		; Months
  1364 00001A6E C1E805              <1> 	shr ax, 5
  1365 00001A71 83E00F              <1> 	and ax, 1111b
  1366                              <1> 	
  1367 00001A74 E87900              <1> 	call .cb_add_num
  1368                              <1> 	
  1369 00001A77 89C8                <1> 	mov ax, cx		; Years
  1370 00001A79 C1E809              <1> 	shr ax, 9
  1371 00001A7C 05BC07              <1> 	add ax, 1980
  1372                              <1> 	
  1373 00001A7F BA[301B]            <1> 	mov dx, .whiteseparator
  1374 00001A82 E86B00              <1> 	call .cb_add_num
  1375                              <1> 	
  1376 00001A85 59                  <1> 	pop cx
  1377                              <1> 	
  1378 00001A86 89C8                <1> 	mov ax, cx		; Hours
  1379 00001A88 C1E80B              <1> 	shr ax, 11
  1380                              <1> 
  1381 00001A8B BA[2C1B]            <1> 	mov dx, .timeseparator
  1382 00001A8E E85F00              <1> 	call .cb_add_num
  1383                              <1> 	
  1384 00001A91 89C8                <1> 	mov ax, cx		; Minutes
  1385 00001A93 C1E805              <1> 	shr ax, 5
  1386 00001A96 83E03F              <1> 	and ax, 111111b
  1387                              <1> 	
  1388 00001A99 E85400              <1> 	call .cb_add_num
  1389                              <1> 
  1390 00001A9C 89C8                <1> 	mov ax, cx		; Seconds
  1391 00001A9E 83E01F              <1> 	and ax, 11111b
  1392 00001AA1 D1E0                <1> 	shl ax, 1
  1393                              <1> 
  1394 00001AA3 BA[111B]            <1> 	mov dx, .help_msg2
  1395 00001AA6 E84700              <1> 	call .cb_add_num
  1396                              <1> 	
  1397                              <1> 	mov16 dx, 42, 16
    15 00001AA9 BA2A10              <2>  mov %1, (%2 + %3 * 256)
  1398 00001AAC E8B7FD              <1> 	call os_move_cursor
  1399                              <1> 
  1400 00001AAF BE[381B]            <1> 	mov si, .time_msg
  1401 00001AB2 E840FD              <1> 	call os_print_string
  1402                              <1> 	
  1403                              <1> 	; Display volume information
  1404                              <1> 	
  1405                              <1> 	mov16 dx, 42, 20
    15 00001AB5 BA2A14              <2>  mov %1, (%2 + %3 * 256)
  1406 00001AB8 E8ABFD              <1> 	call os_move_cursor
  1407                              <1> 
  1408 00001ABB B8C409              <1> 	mov ax, 09C4h
  1409 00001ABE 0FB61EA9DE          <1> 	movzx bx, byte [57001]
  1410 00001AC3 B92300              <1> 	mov cx, 35
  1411 00001AC6 CD10                <1> 	int 10h
  1412                              <1> 	
  1413 00001AC8 FEC6                <1> 	inc dh
  1414 00001ACA E899FD              <1> 	call os_move_cursor
  1415                              <1> 
  1416 00001ACD BE[5C1B]            <1> 	mov si, .vol_msg
  1417 00001AD0 E822FD              <1> 	call os_print_string
  1418                              <1> 	
  1419 00001AD3 A1[6F1B]            <1> 	mov ax, [.freespace]
  1420 00001AD6 E86F10              <1> 	call os_int_to_string
  1421 00001AD9 89C6                <1> 	mov si, ax
  1422 00001ADB E8D90E              <1> 	call os_string_length
  1423                              <1> 	
  1424 00001ADE 80C21B              <1> 	add dl, 27
  1425 00001AE1 28C2                <1> 	sub dl, al
  1426 00001AE3 E880FD              <1> 	call os_move_cursor
  1427                              <1> 		
  1428 00001AE6 E80CFD              <1> 	call os_print_string
  1429                              <1> 		
  1430 00001AE9 BE[231B]            <1> 	mov si, .free_msg
  1431 00001AEC E806FD              <1> 	call os_print_string
  1432 00001AEF C3                  <1> 	ret
  1433                              <1> 	
  1434                              <1> .cb_add_num:
  1435 00001AF0 83F80A              <1> 	cmp ax, 10
  1436 00001AF3 7D0B                <1> 	jge .no_zero
  1437                              <1> 	
  1438 00001AF5 50                  <1> 	push ax
  1439 00001AF6 BB[321B]            <1> 	mov bx, .zerofill
  1440 00001AF9 B8[481B]            <1> 	mov ax, .filename
  1441 00001AFC E8A90E              <1> 	call os_string_add
  1442 00001AFF 58                  <1> 	pop ax
  1443                              <1> 	
  1444                              <1> .no_zero:
  1445 00001B00 E84510              <1> 	call os_int_to_string
  1446 00001B03 89C3                <1> 	mov bx, ax
  1447 00001B05 B8[481B]            <1> 	mov ax, .filename
  1448 00001B08 E89D0E              <1> 	call os_string_add
  1449                              <1> 	
  1450 00001B0B 89D3                <1> 	mov bx, dx
  1451 00001B0D E8980E              <1> 	call os_string_add
  1452                              <1> 
  1453 00001B10 C3                  <1> 	ret
  1454                              <1> 	
  1455 00001B11 00                  <1> 	.help_msg2		db 0
  1456 00001B12 46696C746572733A20- <1> 	.filter_msg		db 'Filters: ', 0
  1456 00001B1B 00                  <1>
  1457 00001B1C 20627974657300      <1> 	.byte_msg		db ' bytes', 0
  1458 00001B23 206B42206672656500  <1> 	.free_msg		db ' kB free', 0
  1459 00001B2C 3A00                <1> 	.timeseparator	db ':', 0
  1460 00001B2E 2F00                <1> 	.dateseparator	db '/', 0
  1461 00001B30 2000                <1> 	.whiteseparator	db ' ', 0
  1462 00001B32 3000                <1> 	.zerofill		db '0', 0
  1463 00001B34 413A2F00            <1> 	.root			db 'A:/', 0
  1464                              <1> 
  1465 00001B38 5772697474656E2074- <1> 	.time_msg		db 'Written to on:  '
  1465 00001B41 6F206F6E3A2020      <1>
  1466 00001B48 00<rep 14h>         <1> 	.filename		times 20 db 0
  1467                              <1> 	
  1468 00001B5C 566F6C756D6520      <1> 	.vol_msg		db 'Volume '
  1469 00001B63 00<rep Ch>          <1> 	.volname		times 12 db 0
  1470 00001B6F 0000                <1> 	.freespace		dw 0
  1471 00001B71 0000                <1> 	.extension_list	dw 0
  1472                              <1> 
  1473 00001B73 00                  <1> 	.file_selector_calling			db 0
  1474 00001B74 00                  <1> 	.file_selector_cursorpos		db 0
  1475 00001B75 00                  <1> 	.file_selector_skipnum			db 0
  1476 00001B76 00                  <1> 	.file_selector_numofentries		db 0
  1477                              <1> 
  1478                              <1> 
  1479                              <1> ; ------------------------------------------------------------------
  1480                              <1> ; os_list_dialog_tooltip -- Show a dialog with a list of options and a tooltip.
  1481                              <1> ; That means, when the user changes the selection, the application will be called back
  1482                              <1> ; to change the tooltip's contents.
  1483                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1484                              <1> ;     BX = first help string, CX = second help string
  1485                              <1> ;     SI = callback pointer
  1486                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1487                              <1> 
  1488                              <1> os_list_dialog_tooltip:
  1489 00001B77 C70689002500        <1> 	mov word [0089h], 37
  1490                              <1> 	
  1491 00001B7D 8936[B21B]          <1> 	mov [.callbackaddr], si
  1492                              <1> 	
  1493 00001B81 C706[6F1E][971B]    <1> 	mov word [os_list_dialog.callback], .callback
  1494 00001B87 E82A00              <1> 	call os_list_dialog
  1495 00001B8A C706[6F1E]0000      <1> 	mov word [os_list_dialog.callback], 0
  1496 00001B90 C70689004C00        <1> 	mov word [0089h], 76
  1497 00001B96 C3                  <1> 	ret
  1498                              <1> 	
  1499                              <1> .callback:
  1500                              <1> 	; Draw the box on the right
  1501 00001B97 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  1502                              <1> 	mov16 dx, 41, 2		; Start X/Y position
    15 00001B9B BA2902              <2>  mov %1, (%2 + %3 * 256)
  1503 00001B9E BE2500              <1> 	mov si, 37			; Width
  1504 00001BA1 BF1700              <1> 	mov di, 23			; Finish Y position
  1505 00001BA4 E809FD              <1> 	call os_draw_block	; Draw option selector window	
  1506                              <1> 
  1507                              <1> 	mov16 dx, 42, 3
    15 00001BA7 BA2A03              <2>  mov %1, (%2 + %3 * 256)
  1508 00001BAA E8B9FC              <1> 	call os_move_cursor
  1509                              <1> 
  1510 00001BAD FF16[B21B]          <1> 	call [.callbackaddr]
  1511 00001BB1 C3                  <1> 	ret
  1512                              <1> 	
  1513 00001BB2 0000                <1> 	.callbackaddr	dw 0
  1514                              <1> 	
  1515                              <1> ; ------------------------------------------------------------------
  1516                              <1> ; os_list_dialog -- Show a dialog with a list of options
  1517                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1518                              <1> ;     BX = first help string, CX = second help string
  1519                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1520                              <1> 
  1521                              <1> os_list_dialog:
  1522 00001BB4 60                  <1> 	pusha
  1523                              <1> 
  1524 00001BB5 50                  <1> 	push ax				; Store string list for now
  1525                              <1> 
  1526 00001BB6 51                  <1> 	push cx				; And help strings
  1527 00001BB7 53                  <1> 	push bx
  1528                              <1> 
  1529 00001BB8 E8EBFC              <1> 	call os_hide_cursor
  1530                              <1> 
  1531                              <1> 	; Are we calling from the file selector?
  1532                              <1> 
  1533 00001BBB 803E[731B]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1534 00001BC0 7509                <1> 	jne .normal_count
  1535                              <1> 
  1536 00001BC2 83F800              <1> 	cmp ax, 0
  1537 00001BC5 740B                <1> 	je .empty_list
  1538                              <1> 
  1539 00001BC7 89C1                <1> 	mov cx, ax
  1540                              <1> 
  1541 00001BC9 EB4B                <1> 	jmp .done_count_f
  1542                              <1> 
  1543                              <1> .normal_count:
  1544 00001BCB 89C6                <1> 	mov si, ax
  1545 00001BCD 803C00              <1> 	cmp byte [si], 0
  1546 00001BD0 7530                <1> 	jne .count_entries
  1547                              <1> 
  1548                              <1> .empty_list:
  1549 00001BD2 83C406              <1> 	add sp, 6
  1550 00001BD5 61                  <1> 	popa
  1551                              <1> 
  1552 00001BD6 B8[E41B]            <1> 	mov ax, .nofilesmsg
  1553                              <1> 	clr bx
    11 00001BD9 31DB                <2>  xor %1, %1
  1554                              <1> 	clr cx
    11 00001BDB 31C9                <2>  xor %1, %1
  1555                              <1> 	clr dx
    11 00001BDD 31D2                <2>  xor %1, %1
  1556 00001BDF E85A04              <1> 	call os_dialog_box
  1557                              <1> 
  1558 00001BE2 F9                  <1> 	stc
  1559 00001BE3 C3                  <1> 	ret
  1560                              <1> 
  1561 00001BE4 546865726520617265- <1> 	.nofilesmsg	db "There are no items to select.", 0
  1561 00001BED 206E6F206974656D73- <1>
  1561 00001BF6 20746F2073656C6563- <1>
  1561 00001BFF 742E00              <1>
  1562                              <1> 	
  1563                              <1> .count_entries:	
  1564 00001C02 B100                <1> 	mov cl, 0			; Count the number of entries in the list
  1565                              <1> 	
  1566                              <1> .count_loop:
  1567 00001C04 268A04              <1> 	mov al, [es:si]
  1568 00001C07 46                  <1> 	inc si
  1569 00001C08 3C00                <1> 	cmp al, 0
  1570 00001C0A 7408                <1> 	je .done_count
  1571 00001C0C 3C2C                <1> 	cmp al, ','
  1572 00001C0E 75F4                <1> 	jne .count_loop
  1573 00001C10 FEC1                <1> 	inc cl
  1574 00001C12 EBF0                <1> 	jmp .count_loop
  1575                              <1> 
  1576                              <1> .done_count:
  1577 00001C14 FEC1                <1> 	inc cl
  1578                              <1> 
  1579                              <1> .done_count_f:
  1580 00001C16 880E[631E]          <1> 	mov byte [.num_of_entries], cl
  1581                              <1> 
  1582                              <1> 
  1583 00001C1A 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  1584                              <1> 	mov16 dx, 2, 2		; Start X/Y position
    15 00001C1E BA0202              <2>  mov %1, (%2 + %3 * 256)
  1585 00001C21 8B368900            <1> 	mov si, [0089h]		; Width
  1586 00001C25 BF1700              <1> 	mov di, 23			; Finish Y position
  1587 00001C28 E885FC              <1> 	call os_draw_block	; Draw option selector window
  1588                              <1> 
  1589                              <1> 	mov16 dx, 3, 3		; Show first line of help text...
    15 00001C2B BA0303              <2>  mov %1, (%2 + %3 * 256)
  1590 00001C2E E835FC              <1> 	call os_move_cursor
  1591                              <1> 
  1592 00001C31 5E                  <1> 	pop si				; Get back first string
  1593 00001C32 E8C0FB              <1> 	call os_print_string
  1594                              <1> 
  1595 00001C35 FEC6                <1> 	inc dh
  1596 00001C37 E82CFC              <1> 	call os_move_cursor
  1597                              <1> 
  1598 00001C3A 5E                  <1> 	pop si				; ...and the second
  1599 00001C3B E8B7FB              <1> 	call os_print_string
  1600                              <1> 
  1601                              <1> 
  1602 00001C3E 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  1603 00001C3F 8936[651E]          <1> 	mov word [.list_string], si
  1604                              <1> 
  1605                              <1> 
  1606                              <1> 	; Now that we've drawn the list, highlight the currently selected
  1607                              <1> 	; entry and let the user move up and down using the cursor keys
  1608                              <1> 
  1609 00001C43 C606[641E]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  1610                              <1> 
  1611                              <1> 	mov16 dx, 25, 6			; Set up starting position for selector
    15 00001C48 BA1906              <2>  mov %1, (%2 + %3 * 256)
  1612                              <1> 
  1613 00001C4B 803E[731B]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1614 00001C50 7510                <1> 	jne .no_load_position
  1615                              <1> 	
  1616 00001C52 3A0E[761B]          <1> 	cmp cl, [os_file_selector.file_selector_numofentries]
  1617 00001C56 750A                <1> 	jne .no_load_position
  1618                              <1> 	
  1619 00001C58 8A36[741B]          <1> 	mov dh, [os_file_selector.file_selector_cursorpos]
  1620 00001C5C A0[751B]            <1> 	mov al, [os_file_selector.file_selector_skipnum]
  1621 00001C5F A2[641E]            <1> 	mov [.skip_num], al
  1622                              <1> 	
  1623                              <1> .no_load_position:
  1624 00001C62 E801FC              <1> 	call os_move_cursor
  1625                              <1> 
  1626                              <1> .more_select:
  1627 00001C65 60                  <1> 	pusha
  1628 00001C66 B3F0                <1> 	mov bl, 11110000b		; Black on white for option list box
  1629                              <1> 	mov16 dx, 3, 5
    15 00001C68 BA0305              <2>  mov %1, (%2 + %3 * 256)
  1630 00001C6B 8B368900            <1> 	mov si, [0089h]
  1631 00001C6F 83EE02              <1> 	sub si, byte 2
  1632 00001C72 BF1600              <1> 	mov di, 22
  1633 00001C75 E838FC              <1> 	call os_draw_block
  1634 00001C78 61                  <1> 	popa
  1635                              <1> 
  1636 00001C79 E8B701              <1> 	call .draw_black_bar
  1637                              <1> 
  1638 00001C7C 8B36[651E]          <1> 	mov word si, [.list_string]
  1639 00001C80 E8FA00              <1>  	call .draw_list
  1640                              <1> 
  1641                              <1> .another_key:
  1642 00001C83 E8F4F5              <1> 	call os_wait_for_key		; Move / select option
  1643 00001C86 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  1644 00001C89 7420                <1> 	je .go_up
  1645 00001C8B 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  1646 00001C8E 742C                <1> 	je .go_down
  1647 00001C90 3C0D                <1> 	cmp al, 13			; Enter pressed?
  1648 00001C92 0F849B00            <1> 	je .option_selected
  1649 00001C96 3C1B                <1> 	cmp al, 27			; Esc pressed?
  1650 00001C98 0F84C400            <1> 	je .esc_pressed
  1651 00001C9C 3C09                <1> 	cmp al, 9			; Tab pressed?
  1652 00001C9E 7402                <1> 	je .tab_pressed
  1653 00001CA0 EBC3                <1> 	jmp .more_select	; If not, wait for another key
  1654                              <1> 
  1655                              <1> .tab_pressed:
  1656 00001CA2 B606                <1> 	mov dh, 6
  1657 00001CA4 C606[641E]00        <1> 	mov byte [.skip_num], 0
  1658 00001CA9 EBBA                <1> 	jmp .more_select
  1659                              <1> 	
  1660                              <1> .go_up:
  1661 00001CAB 80FE06              <1> 	cmp dh, 6			; Already at top?
  1662 00001CAE 7E2F                <1> 	jle .hit_top
  1663                              <1> 
  1664 00001CB0 E89701              <1> 	call .draw_white_bar
  1665                              <1> 
  1666 00001CB3 B219                <1> 	mov dl, 25
  1667 00001CB5 E8AEFB              <1> 	call os_move_cursor
  1668                              <1> 
  1669 00001CB8 FECE                <1> 	dec dh				; Row to select (increasing down)
  1670 00001CBA EBA9                <1> 	jmp .more_select
  1671                              <1> 
  1672                              <1> 
  1673                              <1> .go_down:				; Already at bottom of list?
  1674 00001CBC 80FE14              <1> 	cmp dh, 20
  1675 00001CBF 742E                <1> 	je .hit_bottom
  1676                              <1> 
  1677                              <1> 	clr cx
    11 00001CC1 31C9                <2>  xor %1, %1
  1678 00001CC3 88F1                <1> 	mov byte cl, dh
  1679                              <1> 
  1680 00001CC5 80E905              <1> 	sub cl, 5
  1681 00001CC8 020E[641E]          <1> 	add byte cl, [.skip_num]
  1682                              <1> 
  1683 00001CCC A0[631E]            <1> 	mov byte al, [.num_of_entries]
  1684 00001CCF 38C1                <1> 	cmp cl, al
  1685 00001CD1 741C                <1> 	je .hit_bottom
  1686                              <1> 
  1687 00001CD3 E87401              <1> 	call .draw_white_bar
  1688                              <1> 
  1689 00001CD6 B219                <1> 	mov dl, 25
  1690 00001CD8 E88BFB              <1> 	call os_move_cursor
  1691                              <1> 
  1692 00001CDB FEC6                <1> 	inc dh
  1693 00001CDD EB86                <1> 	jmp .more_select
  1694                              <1> 
  1695                              <1> 
  1696                              <1> .hit_top:
  1697 00001CDF 8A0E[641E]          <1> 	mov byte cl, [.skip_num]	; Any lines to scroll up?
  1698 00001CE3 80F900              <1> 	cmp cl, 0
  1699 00001CE6 742C                <1> 	je .skip_to_bottom			; If not, wait for another key
  1700                              <1> 
  1701 00001CE8 FE0E[641E]          <1> 	dec byte [.skip_num]		; If so, decrement lines to skip
  1702 00001CEC E976FF              <1> 	jmp .more_select
  1703                              <1> 
  1704                              <1> 
  1705                              <1> .hit_bottom:				; See if there's more to scroll
  1706                              <1> 	clr cx
    11 00001CEF 31C9                <2>  xor %1, %1
  1707 00001CF1 88F1                <1> 	mov byte cl, dh
  1708                              <1> 
  1709 00001CF3 80E906              <1> 	sub cl, 6
  1710 00001CF6 FEC1                <1> 	inc cl
  1711 00001CF8 020E[641E]          <1> 	add byte cl, [.skip_num]
  1712                              <1> 
  1713 00001CFC A0[631E]            <1> 	mov byte al, [.num_of_entries]
  1714 00001CFF 38C1                <1> 	cmp cl, al
  1715 00001D01 7407                <1> 	je .skip_to_top
  1716                              <1> 
  1717 00001D03 FE06[641E]          <1> 	inc byte [.skip_num]		; If so, increment lines to skip
  1718 00001D07 E95BFF              <1> 	jmp .more_select
  1719                              <1> 
  1720                              <1> .skip_to_top:
  1721 00001D0A C606[641E]00        <1> 	mov byte [.skip_num], 0
  1722 00001D0F B606                <1> 	mov dh, 6
  1723 00001D11 E951FF              <1> 	jmp .more_select
  1724                              <1> 
  1725                              <1> .skip_to_bottom:
  1726 00001D14 A0[631E]            <1> 	mov al, [.num_of_entries]
  1727 00001D17 3C0F                <1> 	cmp al, 15
  1728 00001D19 7E0A                <1> 	jle .basic_skip
  1729                              <1> 	
  1730                              <1> .no_basic_skip:
  1731 00001D1B B614                <1> 	mov dh, 20
  1732 00001D1D 2C0F                <1> 	sub al, 15
  1733 00001D1F A2[641E]            <1> 	mov [.skip_num], al
  1734                              <1> 
  1735 00001D22 E940FF              <1> 	jmp .more_select
  1736                              <1> 	
  1737                              <1> .basic_skip:
  1738 00001D25 3C00                <1> 	cmp al, 0
  1739 00001D27 7CF2                <1> 	jl .no_basic_skip
  1740 00001D29 88C6                <1> 	mov dh, al
  1741 00001D2B 80C605              <1> 	add dh, 5
  1742 00001D2E E934FF              <1> 	jmp .more_select
  1743                              <1> 	
  1744                              <1> .option_selected:
  1745 00001D31 E867FB              <1> 	call os_show_cursor
  1746                              <1> 
  1747 00001D34 803E[731B]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1748 00001D39 7510                <1> 	jne .no_store_position
  1749                              <1> 	
  1750 00001D3B 8836[741B]          <1> 	mov [os_file_selector.file_selector_cursorpos], dh
  1751 00001D3F A0[641E]            <1> 	mov al, [.skip_num]
  1752 00001D42 A2[751B]            <1> 	mov [os_file_selector.file_selector_skipnum], al
  1753 00001D45 A0[631E]            <1> 	mov al, [.num_of_entries]
  1754 00001D48 A2[761B]            <1> 	mov [os_file_selector.file_selector_numofentries], al
  1755                              <1> 	
  1756                              <1> .no_store_position:
  1757 00001D4B 80EE06              <1> 	sub dh, 6
  1758                              <1> 
  1759 00001D4E 0FB6C6              <1> 	movzx ax, dh
  1760                              <1> 
  1761 00001D51 FEC0                <1> 	inc al				; Options start from 1
  1762 00001D53 0206[641E]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  1763                              <1> 
  1764 00001D57 A3[611E]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  1765                              <1> 
  1766 00001D5A 61                  <1> 	popa
  1767                              <1> 
  1768 00001D5B A1[611E]            <1> 	mov word ax, [.tmp]
  1769 00001D5E F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  1770 00001D5F C3                  <1> 	ret
  1771                              <1> 
  1772                              <1> 
  1773                              <1> 
  1774                              <1> .esc_pressed:
  1775 00001D60 E838FB              <1> 	call os_show_cursor
  1776                              <1> 
  1777 00001D63 803E[731B]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1778 00001D68 7510                <1> 	jne .no_store_position_on_exit
  1779                              <1> 	
  1780 00001D6A 8836[741B]          <1> 	mov [os_file_selector.file_selector_cursorpos], dh
  1781 00001D6E A0[641E]            <1> 	mov al, [.skip_num]
  1782 00001D71 A2[751B]            <1> 	mov [os_file_selector.file_selector_skipnum], al
  1783 00001D74 A0[631E]            <1> 	mov al, [.num_of_entries]
  1784 00001D77 A2[761B]            <1> 	mov [os_file_selector.file_selector_numofentries], al
  1785                              <1> 	
  1786                              <1> .no_store_position_on_exit:
  1787 00001D7A 61                  <1> 	popa
  1788 00001D7B F9                  <1> 	stc				; Set carry for Esc
  1789 00001D7C C3                  <1> 	ret
  1790                              <1> 
  1791                              <1> 
  1792                              <1> 
  1793                              <1> .draw_list:
  1794 00001D7D 60                  <1> 	pusha
  1795                              <1> 
  1796                              <1> 	mov16 dx, 5, 6		; Get into position for option list text
    15 00001D7E BA0506              <2>  mov %1, (%2 + %3 * 256)
  1797 00001D81 E8E2FA              <1> 	call os_move_cursor
  1798                              <1> 
  1799                              <1> 	clr cx				; Skip lines scrolled off the top of the dialog
    11 00001D84 31C9                <2>  xor %1, %1
  1800 00001D86 8A0E[641E]          <1> 	mov byte cl, [.skip_num]
  1801                              <1> 
  1802 00001D8A 803E[731B]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1803 00001D8F 747C                <1> 	je .file_draw_list
  1804                              <1> 
  1805                              <1> .skip_loop:
  1806 00001D91 83F900              <1> 	cmp cx, 0
  1807 00001D94 740B                <1> 	je .skip_loop_finished
  1808                              <1> .more_lodsb:
  1809 00001D96 268A04              <1> 	mov al, [es:si]
  1810 00001D99 46                  <1> 	inc si
  1811 00001D9A 3C2C                <1> 	cmp al, ','
  1812 00001D9C 75F8                <1> 	jne .more_lodsb
  1813 00001D9E 49                  <1> 	dec cx
  1814 00001D9F EBF0                <1> 	jmp .skip_loop
  1815                              <1> 
  1816                              <1> 
  1817                              <1> .skip_loop_finished:
  1818                              <1> 	clr bx				; Counter for total number of options
    11 00001DA1 31DB                <2>  xor %1, %1
  1819                              <1> 
  1820                              <1> 
  1821                              <1> .more:
  1822 00001DA3 268A04              <1> 	mov al, [es:si]		; Get next character in file name, increment pointer
  1823 00001DA6 46                  <1> 	inc si
  1824                              <1> 	
  1825 00001DA7 3C00                <1> 	cmp al, 0			; End of string?
  1826 00001DA9 7417                <1> 	je .done_list
  1827                              <1> 
  1828 00001DAB 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  1829 00001DAD 7406                <1> 	je .newline
  1830                              <1> 
  1831 00001DAF B40E                <1> 	mov ah, 0Eh
  1832 00001DB1 CD10                <1> 	int 10h
  1833 00001DB3 EBEE                <1> 	jmp .more
  1834                              <1> 
  1835                              <1> .newline:
  1836 00001DB5 B205                <1> 	mov dl, 5			; Go back to starting X position
  1837 00001DB7 FEC6                <1> 	inc dh				; But jump down a line
  1838 00001DB9 E8AAFA              <1> 	call os_move_cursor
  1839                              <1> 
  1840 00001DBC 43                  <1> 	inc bx				; Update the number-of-options counter
  1841 00001DBD 83FB0F              <1> 	cmp bx, 15			; Limit to one screen of options
  1842 00001DC0 7CE1                <1> 	jl .more
  1843                              <1> 
  1844                              <1> .done_list:
  1845 00001DC2 61                  <1> 	popa
  1846                              <1> 
  1847 00001DC3 60                  <1> 	pusha
  1848 00001DC4 52                  <1> 	push dx
  1849                              <1> 	mov16 dx, 5, 22
    15 00001DC5 BA0516              <2>  mov %1, (%2 + %3 * 256)
  1850 00001DC8 E89BFA              <1> 	call os_move_cursor
  1851                              <1> 	
  1852 00001DCB BE[671E]            <1> 	mov si, .string1
  1853 00001DCE E824FA              <1> 	call os_print_string
  1854                              <1> 	
  1855 00001DD1 5A                  <1> 	pop dx
  1856 00001DD2 A0[641E]            <1> 	mov al, [.skip_num]
  1857 00001DD5 00F0                <1> 	add al, dh
  1858 00001DD7 2C05                <1> 	sub al, 5
  1859 00001DD9 0FB6C0              <1> 	movzx ax, al
  1860 00001DDC E8690D              <1> 	call os_int_to_string
  1861 00001DDF 89C6                <1> 	mov si, ax
  1862 00001DE1 E811FA              <1> 	call os_print_string
  1863                              <1> 	
  1864 00001DE4 BE[691E]            <1> 	mov si, .string2
  1865 00001DE7 E80BFA              <1> 	call os_print_string
  1866                              <1> 	
  1867 00001DEA 0FB606[631E]        <1> 	movzx ax, byte [.num_of_entries]
  1868 00001DEF E8560D              <1> 	call os_int_to_string
  1869 00001DF2 89C6                <1> 	mov si, ax
  1870 00001DF4 E8FEF9              <1> 	call os_print_string
  1871                              <1> 	
  1872 00001DF7 BE[6B1E]            <1> 	mov si, .string3
  1873 00001DFA E8F8F9              <1> 	call os_print_string
  1874                              <1> 	
  1875                              <1> 	
  1876 00001DFD A0[641E]            <1> 	mov al, [.skip_num]
  1877 00001E00 00F0                <1> 	add al, dh
  1878 00001E02 2C05                <1> 	sub al, 5
  1879 00001E04 0FB6C0              <1> 	movzx ax, al
  1880 00001E07 FF16[6F1E]          <1> 	call [.callback]
  1881                              <1> 	
  1882 00001E0B 61                  <1> 	popa
  1883 00001E0C C3                  <1> 	ret
  1884                              <1> 
  1885                              <1> .file_draw_list:
  1886                              <1> 	clr bx
    11 00001E0D 31DB                <2>  xor %1, %1
  1887                              <1> 
  1888                              <1> .f_more:
  1889 00001E0F 51                  <1> 	push cx
  1890 00001E10 89C8                <1> 	mov ax, cx
  1891 00001E12 40                  <1> 	inc ax
  1892 00001E13 E8A1FB              <1> 	call os_file_selector.get_filename
  1893 00001E16 BE[481B]            <1> 	mov si, os_file_selector.filename
  1894 00001E19 E8D9F9              <1> 	call os_print_string
  1895 00001E1C 59                  <1> 	pop cx
  1896                              <1> 
  1897 00001E1D B205                <1> 	mov dl, 5			; Go back to starting X position
  1898 00001E1F FEC6                <1> 	inc dh				; But jump down a line
  1899 00001E21 E842FA              <1> 	call os_move_cursor
  1900                              <1> 
  1901 00001E24 41                  <1> 	inc cx
  1902 00001E25 3A0E[631E]          <1> 	cmp cl, [.num_of_entries]
  1903 00001E29 7497                <1> 	je .done_list
  1904                              <1> 
  1905 00001E2B 43                  <1> 	inc bx				; Update the number-of-options counter
  1906 00001E2C 83FB0F              <1> 	cmp bx, 15			; Limit to one screen of options
  1907 00001E2F 7CDE                <1> 	jl .f_more
  1908 00001E31 EB8F                <1> 	jmp .done_list
  1909                              <1> 
  1910                              <1> .draw_black_bar:
  1911 00001E33 60                  <1> 	pusha
  1912                              <1> 
  1913 00001E34 B204                <1> 	mov dl, 4
  1914 00001E36 E82DFA              <1> 	call os_move_cursor
  1915                              <1> 
  1916                              <1> 	mov16 ax, ' ', 09h			; Draw white bar at top
    15 00001E39 B82009              <2>  mov %1, (%2 + %3 * 256)
  1917                              <1> 	mov16 bx, 00001111b, 0	; White text on black background
    15 00001E3C BB0F00              <2>  mov %1, (%2 + %3 * 256)
  1918 00001E3F 8B0E8900            <1> 	mov cx, [0089h]
  1919 00001E43 83E904              <1> 	sub cx, byte 4
  1920 00001E46 CD10                <1> 	int 10h
  1921                              <1> 
  1922 00001E48 61                  <1> 	popa
  1923 00001E49 C3                  <1> 	ret
  1924                              <1> 
  1925                              <1> 
  1926                              <1> 
  1927                              <1> .draw_white_bar:
  1928 00001E4A 60                  <1> 	pusha
  1929                              <1> 
  1930 00001E4B B204                <1> 	mov dl, 4
  1931 00001E4D E816FA              <1> 	call os_move_cursor
  1932                              <1> 
  1933                              <1> 	mov16 ax, ' ', 09h			; Draw white bar at top
    15 00001E50 B82009              <2>  mov %1, (%2 + %3 * 256)
  1934                              <1> 	mov16 bx, 11110000b, 0	; White text on black background
    15 00001E53 BBF000              <2>  mov %1, (%2 + %3 * 256)
  1935 00001E56 8B0E8900            <1> 	mov cx, [0089h]
  1936 00001E5A 83E904              <1> 	sub cx, byte 4
  1937 00001E5D CD10                <1> 	int 10h
  1938                              <1> 
  1939 00001E5F 61                  <1> 	popa
  1940 00001E60 C3                  <1> 	ret
  1941                              <1> 
  1942                              <1> 
  1943 00001E61 0000                <1> 	.tmp			dw 0
  1944 00001E63 00                  <1> 	.num_of_entries	db 0
  1945 00001E64 00                  <1> 	.skip_num		db 0
  1946 00001E65 0000                <1> 	.list_string	dw 0
  1947 00001E67 2800                <1> 	.string1		db '(', 0
  1948 00001E69 2F00                <1> 	.string2		db '/', 0
  1949 00001E6B 29202000            <1> 	.string3		db ')  ', 0
  1950 00001E6F 0000                <1> 	.callback		dw 0
  1951                              <1> 	
  1952                              <1> ; ------------------------------------------------------------------
  1953                              <1> ; os_draw_background -- Clear screen with white top and bottom bars
  1954                              <1> ; containing text, and a coloured middle section.
  1955                              <1> ; IN: AX/BX = top/bottom string locations, CX = colour (256 if the app wants to display the default background)
  1956                              <1> 
  1957                              <1> os_draw_background:
  1958 00001E71 60                  <1> 	pusha
  1959                              <1> 	
  1960 00001E72 50                  <1> 	push ax				; Store params to pop out later
  1961 00001E73 53                  <1> 	push bx
  1962 00001E74 51                  <1> 	push cx
  1963                              <1> 
  1964 00001E75 BA0000              <1> 	mov dx, 0
  1965 00001E78 E8EBF9              <1> 	call os_move_cursor
  1966                              <1> 
  1967 00001E7B B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  1968 00001E7E B95000              <1> 	mov cx, 80
  1969 00001E81 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  1970 00001E86 CD10                <1> 	int 10h
  1971                              <1> 
  1972 00001E88 BA0001              <1> 	mov dx, 256
  1973 00001E8B E8D8F9              <1> 	call os_move_cursor
  1974                              <1> 	
  1975 00001E8E 5B                  <1> 	pop bx				; Get colour param (originally in CX)
  1976 00001E8F 81FB0001            <1> 	cmp bx, 256
  1977 00001E93 746B                <1> 	je .draw_default_background
  1978                              <1> 	
  1979 00001E95 B82009              <1> 	mov ax, 0920h			; Draw colour section
  1980 00001E98 B93007              <1> 	mov cx, 1840
  1981 00001E9B B700                <1> 	mov bh, 0
  1982 00001E9D CD10                <1> 	int 10h
  1983                              <1> 
  1984                              <1> .bg_drawn:
  1985                              <1> 	mov16 dx, 0, 24
    15 00001E9F BA0018              <2>  mov %1, (%2 + %3 * 256)
  1986 00001EA2 E8C1F9              <1> 	call os_move_cursor
  1987                              <1> 
  1988 00001EA5 B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  1989 00001EA8 B95000              <1> 	mov cx, 80
  1990 00001EAB 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  1991 00001EB0 CD10                <1> 	int 10h
  1992                              <1> 
  1993                              <1> 	mov16 dx, 1, 24
    15 00001EB2 BA0118              <2>  mov %1, (%2 + %3 * 256)
  1994 00001EB5 E8AEF9              <1> 	call os_move_cursor
  1995 00001EB8 5E                  <1> 	pop si				; Get bottom string param
  1996 00001EB9 E839F9              <1> 	call os_print_string
  1997                              <1> 
  1998 00001EBC BA0100              <1> 	mov dx, 1
  1999 00001EBF E8A4F9              <1> 	call os_move_cursor
  2000 00001EC2 5E                  <1> 	pop si				; Get top string param
  2001 00001EC3 E82FF9              <1> 	call os_print_string
  2002                              <1> 
  2003 00001EC6 BB[331F]            <1> 	mov bx, tmp_string
  2004 00001EC9 E82B0D              <1> 	call os_get_date_string
  2005                              <1> 	
  2006 00001ECC BA4500              <1> 	mov dx, 69			; Display date
  2007 00001ECF E894F9              <1> 	call os_move_cursor
  2008 00001ED2 89DE                <1> 	mov si, bx
  2009 00001ED4 E81EF9              <1> 	call os_print_string
  2010                              <1> 	
  2011 00001ED7 BB[331F]            <1> 	mov bx, tmp_string
  2012 00001EDA E8D30C              <1> 	call os_get_time_string
  2013                              <1> 
  2014 00001EDD BA3F00              <1> 	mov dx, 63			; Display time
  2015 00001EE0 E883F9              <1> 	call os_move_cursor
  2016 00001EE3 89DE                <1> 	mov si, bx
  2017 00001EE5 E80DF9              <1> 	call os_print_string
  2018                              <1> 	
  2019 00001EE8 B24F                <1> 	mov dl, 79			; Print the little speaker icon
  2020 00001EEA E879F9              <1> 	call os_move_cursor
  2021                              <1> 	
  2022 00001EED B8170E              <1> 	mov ax, 0E17h
  2023 00001EF0 2A068300            <1> 	sub al, [0083h]
  2024 00001EF4 B700                <1> 	mov bh, 0
  2025 00001EF6 CD10                <1> 	int 10h
  2026                              <1> 	
  2027                              <1> 	mov16 dx, 0, 1		; Ready for app text
    15 00001EF8 BA0001              <2>  mov %1, (%2 + %3 * 256)
  2028 00001EFB E868F9              <1> 	call os_move_cursor
  2029                              <1> 
  2030 00001EFE 61                  <1> 	popa
  2031 00001EFF C3                  <1> 	ret
  2032                              <1> 
  2033                              <1> .draw_default_background:
  2034 00001F00 64803E000600        <1> 	cmp byte [fs:DESKTOP_BACKGROUND], 0
  2035 00001F06 741B                <1> 	je .fill_color
  2036                              <1> 	
  2037 00001F08 1E                  <1> 	push ds
  2038 00001F09 06                  <1> 	push es
  2039                              <1> 	
  2040 00001F0A 8E1E[F205]          <1> 	mov ds, [driversgmt]
  2041 00001F0E BE0006              <1> 	mov si, DESKTOP_BACKGROUND
  2042                              <1> 
  2043 00001F11 B800B8              <1> 	mov ax, 0B800h
  2044 00001F14 8EC0                <1> 	mov es, ax
  2045 00001F16 BFA000              <1> 	mov di, 160
  2046                              <1> 	
  2047 00001F19 B9600E              <1> 	mov cx, 80 * 23 * 2
  2048                              <1> 	
  2049 00001F1C F3A4                <1> 	rep movsb
  2050                              <1> 	
  2051 00001F1E 07                  <1> 	pop es
  2052 00001F1F 1F                  <1> 	pop ds
  2053 00001F20 E97CFF              <1> 	jmp .bg_drawn
  2054                              <1> 	
  2055                              <1> .fill_color:
  2056 00001F23 0FB61EA8DE          <1> 	movzx bx, byte [57000]
  2057 00001F28 B82009              <1> 	mov ax, 0920h
  2058 00001F2B B93007              <1> 	mov cx, 1840
  2059                              <1> 
  2060 00001F2E CD10                <1> 	int 10h
  2061 00001F30 E96CFF              <1> 	jmp .bg_drawn
  2062                              <1> 
  2063 00001F33 00<rep Fh>          <1> 	tmp_string			times 15 db 0
  2064                              <1> 
  2065                              <1> 
  2066                              <1> ; ------------------------------------------------------------------
  2067                              <1> ; os_print_newline -- Reset cursor to start of next line
  2068                              <1> ; IN/OUT: Nothing (registers preserved)
  2069                              <1> 
  2070                              <1> os_print_newline:
  2071 00001F42 60                  <1> 	pusha
  2072                              <1> 
  2073 00001F43 B40E                <1> 	mov ah, 0Eh			; BIOS output char code
  2074                              <1> 
  2075 00001F45 B00D                <1> 	mov al, 13
  2076 00001F47 CD10                <1> 	int 10h
  2077 00001F49 B00A                <1> 	mov al, 10
  2078 00001F4B CD10                <1> 	int 10h
  2079                              <1> 
  2080 00001F4D 61                  <1> 	popa
  2081 00001F4E C3                  <1> 	ret
  2082                              <1> 
  2083                              <1> 
  2084                              <1> ; ------------------------------------------------------------------
  2085                              <1> ; os_dump_registers -- Displays register contents in hex on the screen
  2086                              <1> ; IN/OUT: EAX/EBX/ECX/EDX/ESI/EDI = registers to show
  2087                              <1> 
  2088                              <1> os_dump_registers:
  2089 00001F4F 6660                <1> 	pushad
  2090                              <1> 
  2091 00001F51 6657                <1> 	push edi
  2092 00001F53 68[A01F]            <1> 	push .di_string
  2093 00001F56 6656                <1> 	push esi
  2094 00001F58 68[9A1F]            <1> 	push .si_string
  2095 00001F5B 6652                <1> 	push edx
  2096 00001F5D 68[941F]            <1> 	push .dx_string
  2097 00001F60 6651                <1> 	push ecx
  2098 00001F62 68[8E1F]            <1> 	push .cx_string
  2099 00001F65 6653                <1> 	push ebx
  2100 00001F67 68[881F]            <1> 	push .bx_string
  2101 00001F6A 6650                <1> 	push eax
  2102 00001F6C 68[831F]            <1> 	push .ax_string
  2103                              <1> 	
  2104 00001F6F B90600              <1> 	mov cx, 6
  2105                              <1> 	
  2106                              <1> .loop:
  2107 00001F72 5E                  <1> 	pop si
  2108 00001F73 E87FF8              <1> 	call os_print_string
  2109 00001F76 6658                <1> 	pop eax
  2110 00001F78 E8B903              <1> 	call os_print_8hex
  2111 00001F7B E2F5                <1> 	loop .loop
  2112                              <1> 	
  2113 00001F7D E8C2FF              <1> 	call os_print_newline
  2114                              <1> 
  2115 00001F80 6661                <1> 	popad
  2116 00001F82 C3                  <1> 	ret
  2117                              <1> 
  2118                              <1> 
  2119 00001F83 4541583A00          <1> 	.ax_string		db 'EAX:', 0
  2120 00001F88 204542583A00        <1> 	.bx_string		db ' EBX:', 0
  2121 00001F8E 204543583A00        <1> 	.cx_string		db ' ECX:', 0
  2122 00001F94 204544583A00        <1> 	.dx_string		db ' EDX:', 0
  2123 00001F9A 204553493A00        <1> 	.si_string		db ' ESI:', 0
  2124 00001FA0 204544493A00        <1> 	.di_string		db ' EDI:', 0
  2125                              <1> 
  2126                              <1> 
  2127                              <1> ; ------------------------------------------------------------------
  2128                              <1> ; os_input_dialog -- Get text string from user via a dialog box
  2129                              <1> ; IN: AX = string location, BX = message to show; OUT: AX = string location
  2130                              <1> 
  2131                              <1> os_input_dialog:
  2132 00001FA6 60                  <1> 	pusha
  2133                              <1> 
  2134 00001FA7 50                  <1> 	push ax				; Save string location
  2135 00001FA8 53                  <1> 	push bx				; Save message to show
  2136                              <1> 
  2137                              <1> 
  2138                              <1> 	mov16 dx, 12, 10			; First, draw red background box
    15 00001FA9 BA0C0A              <2>  mov %1, (%2 + %3 * 256)
  2139                              <1> 
  2140                              <1> .redbox:				; Loop to draw all lines of box
  2141 00001FAC E8B7F8              <1> 	call os_move_cursor
  2142                              <1> 
  2143 00001FAF 60                  <1> 	pusha
  2144                              <1> 	mov16 ax, ' ', 09h
    15 00001FB0 B82009              <2>  mov %1, (%2 + %3 * 256)
  2145 00001FB3 B93700              <1> 	mov cx, 55
  2146 00001FB6 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  2147 00001FBB CD10                <1> 	int 10h
  2148 00001FBD 61                  <1> 	popa
  2149                              <1> 
  2150 00001FBE FEC6                <1> 	inc dh
  2151 00001FC0 80FE10              <1> 	cmp dh, 16
  2152 00001FC3 7402                <1> 	je .boxdone
  2153 00001FC5 EBE5                <1> 	jmp .redbox
  2154                              <1> 
  2155                              <1> 
  2156                              <1> .boxdone:
  2157                              <1> 	mov16 dx, 14, 14
    15 00001FC7 BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2158 00001FCA E899F8              <1> 	call os_move_cursor
  2159                              <1> 
  2160                              <1> 	mov16 ax, ' ', 09h
    15 00001FCD B82009              <2>  mov %1, (%2 + %3 * 256)
  2161 00001FD0 BBF000              <1> 	mov bx, 240
  2162 00001FD3 B93300              <1> 	mov cx, 51
  2163 00001FD6 CD10                <1> 	int 10h
  2164                              <1> 	
  2165                              <1> 	mov16 dx, 14, 11
    15 00001FD8 BA0E0B              <2>  mov %1, (%2 + %3 * 256)
  2166 00001FDB E888F8              <1> 	call os_move_cursor
  2167                              <1> 	
  2168                              <1> 
  2169 00001FDE 5B                  <1> 	pop bx				; Get message back and display it
  2170 00001FDF 89DE                <1> 	mov si, bx
  2171 00001FE1 E811F8              <1> 	call os_print_string
  2172                              <1> 
  2173                              <1> 	mov16 dx, 14, 14
    15 00001FE4 BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2174 00001FE7 E87CF8              <1> 	call os_move_cursor
  2175                              <1> 
  2176                              <1> 
  2177 00001FEA 58                  <1> 	pop ax				; Get input string back
  2178 00001FEB E8C301              <1> 	call os_input_string
  2179                              <1> 
  2180 00001FEE 61                  <1> 	popa
  2181 00001FEF C3                  <1> 	ret
  2182                              <1> 
  2183                              <1> ; ------------------------------------------------------------------
  2184                              <1> ; os_password_dialog -- Get a password from user via a dialog box
  2185                              <1> ; IN: AX = string location, BX = message to show; OUT: AX = string location
  2186                              <1> 
  2187                              <1> os_password_dialog:
  2188 00001FF0 60                  <1> 	pusha
  2189                              <1> 
  2190 00001FF1 50                  <1> 	push ax				; Save string location
  2191 00001FF2 53                  <1> 	push bx				; Save message to show
  2192                              <1> 
  2193                              <1> 
  2194                              <1> 	mov16 dx, 12, 10			; First, draw red background box
    15 00001FF3 BA0C0A              <2>  mov %1, (%2 + %3 * 256)
  2195                              <1> 
  2196                              <1> .redbox:				; Loop to draw all lines of box
  2197 00001FF6 E86DF8              <1> 	call os_move_cursor
  2198                              <1> 
  2199 00001FF9 60                  <1> 	pusha
  2200                              <1> 	mov16 ax, ' ', 09h
    15 00001FFA B82009              <2>  mov %1, (%2 + %3 * 256)
  2201 00001FFD B93700              <1> 	mov cx, 55
  2202 00002000 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  2203 00002005 CD10                <1> 	int 10h
  2204 00002007 61                  <1> 	popa
  2205                              <1> 
  2206 00002008 FEC6                <1> 	inc dh
  2207 0000200A 80FE10              <1> 	cmp dh, 16
  2208 0000200D 7402                <1> 	je .boxdone
  2209 0000200F EBE5                <1> 	jmp .redbox
  2210                              <1> 
  2211                              <1> 
  2212                              <1> .boxdone:
  2213                              <1> 	mov16 dx, 14, 14
    15 00002011 BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2214 00002014 E84FF8              <1> 	call os_move_cursor
  2215                              <1> 
  2216                              <1> 	mov16 ax, ' ', 09h
    15 00002017 B82009              <2>  mov %1, (%2 + %3 * 256)
  2217 0000201A BBF000              <1> 	mov bx, 240
  2218 0000201D B93300              <1> 	mov cx, 51
  2219 00002020 CD10                <1> 	int 10h
  2220                              <1> 	
  2221                              <1> 	mov16 dx, 14, 11
    15 00002022 BA0E0B              <2>  mov %1, (%2 + %3 * 256)
  2222 00002025 E83EF8              <1> 	call os_move_cursor
  2223                              <1> 	
  2224                              <1> 
  2225 00002028 5B                  <1> 	pop bx				; Get message back and display it
  2226 00002029 89DE                <1> 	mov si, bx
  2227 0000202B E8C7F7              <1> 	call os_print_string
  2228                              <1> 
  2229                              <1> 	mov16 dx, 14, 14
    15 0000202E BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2230 00002031 E832F8              <1> 	call os_move_cursor
  2231                              <1> 
  2232                              <1> 
  2233 00002034 58                  <1> 	pop ax				; Get input string back
  2234 00002035 B3F0                <1> 	mov bl, 240
  2235 00002037 E8E101              <1> 	call os_input_password
  2236                              <1> 
  2237 0000203A 61                  <1> 	popa
  2238 0000203B C3                  <1> 	ret
  2239                              <1> 
  2240                              <1> 
  2241                              <1> ; ------------------------------------------------------------------
  2242                              <1> ; os_dialog_box -- Print dialog box in middle of screen, with button(s)
  2243                              <1> ; IN: AX, BX, CX = string locations (set registers to 0 for no display),
  2244                              <1> ; IN: DX = 0 for single 'OK' dialog, 1 for two-button 'OK' and 'Cancel'
  2245                              <1> ; IN: [0085h] = Default button for 2-button dialog (0 or 1)
  2246                              <1> ; OUT: If two-button mode, AX = 0 for OK and 1 for cancel
  2247                              <1> ; NOTE: Each string is limited to 40 characters
  2248                              <1> 
  2249                              <1> os_dialog_box:
  2250 0000203C 60                  <1> 	pusha
  2251                              <1> 
  2252 0000203D 52                  <1> 	push dx
  2253                              <1> 
  2254 0000203E 51                  <1> 	push cx
  2255 0000203F 53                  <1> 	push bx
  2256 00002040 50                  <1> 	push ax
  2257                              <1> 	
  2258 00002041 E862F8              <1> 	call os_hide_cursor
  2259                              <1> 
  2260 00002044 60                  <1> 	pusha
  2261 00002045 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  2262                              <1> 	mov16 dx, 19, 9			; First, draw red background box
    15 00002049 BA1309              <2>  mov %1, (%2 + %3 * 256)
  2263 0000204C BE2A00              <1> 	mov si, 42
  2264 0000204F BF1000              <1> 	mov di, 16
  2265 00002052 E85BF8              <1> 	call os_draw_block
  2266 00002055 61                  <1> 	popa
  2267                              <1> 	
  2268                              <1> 	mov16 dx, 20, 9
    15 00002056 BA1409              <2>  mov %1, (%2 + %3 * 256)
  2269 00002059 B90300              <1> 	mov cx, 3
  2270                              <1> 	
  2271                              <1> .loop:
  2272 0000205C FEC6                <1> 	inc dh
  2273 0000205E E805F8              <1> 	call os_move_cursor
  2274                              <1> 	
  2275 00002061 5E                  <1> 	pop si
  2276 00002062 83FE00              <1> 	cmp si, 0
  2277 00002065 7403                <1> 	je .no_string
  2278                              <1> 	
  2279 00002067 E88BF7              <1> 	call os_print_string
  2280                              <1> 	
  2281                              <1> .no_string:
  2282 0000206A E2F0                <1> 	loop .loop
  2283                              <1> 	
  2284 0000206C 5A                  <1> 	pop dx
  2285 0000206D 83FA01              <1> 	cmp dx, 1
  2286 00002070 7426                <1> 	je .two_button
  2287                              <1> 
  2288                              <1> 	
  2289                              <1> .one_button:
  2290 00002072 B3F0                <1> 	mov bl, 11110000b		; Black on white
  2291                              <1> 	mov16 dx, 35, 14
    15 00002074 BA230E              <2>  mov %1, (%2 + %3 * 256)
  2292 00002077 BE0800              <1> 	mov si, 8
  2293 0000207A BF0F00              <1> 	mov di, 15
  2294 0000207D E830F8              <1> 	call os_draw_block
  2295                              <1> 
  2296                              <1> 	mov16 dx, 38, 14		; OK button, centred at bottom of box
    15 00002080 BA260E              <2>  mov %1, (%2 + %3 * 256)
  2297 00002083 E8E0F7              <1> 	call os_move_cursor
  2298 00002086 BE[6721]            <1> 	mov si, .ok_button_string
  2299 00002089 E869F7              <1> 	call os_print_string
  2300                              <1> 
  2301                              <1> .one_button_wait:
  2302 0000208C E8EBF1              <1> 	call os_wait_for_key
  2303 0000208F 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
  2304 00002091 75F9                <1> 	jne .one_button_wait
  2305                              <1> 
  2306 00002093 E805F8              <1> 	call os_show_cursor
  2307                              <1> 
  2308 00002096 61                  <1> 	popa
  2309 00002097 C3                  <1> 	ret
  2310                              <1> 
  2311                              <1> .two_button:
  2312 00002098 B3F0                <1> 	mov bl, 11110000b		; Black on white
  2313                              <1> 	mov16 dx, 27, 14
    15 0000209A BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  2314 0000209D BE0800              <1> 	mov si, 8
  2315 000020A0 BF0F00              <1> 	mov di, 15
  2316 000020A3 E80AF8              <1> 	call os_draw_block
  2317                              <1> 
  2318                              <1> 	mov16 dx, 30, 14			; OK button
    15 000020A6 BA1E0E              <2>  mov %1, (%2 + %3 * 256)
  2319 000020A9 E8BAF7              <1> 	call os_move_cursor
  2320 000020AC BE[6721]            <1> 	mov si, .ok_button_string
  2321 000020AF E843F7              <1> 	call os_print_string
  2322                              <1> 
  2323                              <1> 	mov16 dx, 44, 14			; Cancel button
    15 000020B2 BA2C0E              <2>  mov %1, (%2 + %3 * 256)
  2324 000020B5 E8AEF7              <1> 	call os_move_cursor
  2325 000020B8 BE[6A21]            <1> 	mov si, .cancel_button_string
  2326 000020BB E837F7              <1> 	call os_print_string
  2327                              <1> 
  2328 000020BE 803E850001          <1> 	cmp byte [0085h], 1
  2329 000020C3 7466                <1> 	je .draw_right
  2330 000020C5 7529                <1> 	jne .draw_left
  2331                              <1> 	
  2332                              <1> .two_button_wait:
  2333 000020C7 E8B0F1              <1> 	call os_wait_for_key
  2334                              <1> 
  2335 000020CA 80FC4B              <1> 	cmp ah, 75			; Left cursor key pressed?
  2336 000020CD 7421                <1> 	je .draw_left
  2337 000020CF 80FC4D              <1> 	cmp ah, 77			; Right cursor key pressed?
  2338 000020D2 7457                <1> 	je .draw_right
  2339                              <1> 	
  2340 000020D4 3C1B                <1> 	cmp al, 27			; Escape, automatically select "Cancel"
  2341 000020D6 7410                <1> 	je .cancel
  2342 000020D8 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
  2343 000020DA 75EB                <1> 	jne .two_button_wait
  2344                              <1> 	
  2345 000020DC E8BCF7              <1> 	call os_show_cursor
  2346                              <1> 
  2347 000020DF 890E[7121]          <1> 	mov [.tmp], cx			; Keep result after restoring all regs
  2348 000020E3 61                  <1> 	popa
  2349 000020E4 A1[7121]            <1> 	mov ax, [.tmp]
  2350                              <1> 
  2351 000020E7 C3                  <1> 	ret
  2352                              <1> 
  2353                              <1> .cancel:
  2354 000020E8 E8B0F7              <1> 	call os_show_cursor
  2355 000020EB 61                  <1> 	popa
  2356 000020EC B80100              <1> 	mov ax, 1
  2357 000020EF C3                  <1> 	ret
  2358                              <1> 
  2359                              <1> .draw_left:
  2360 000020F0 B3F0                <1> 	mov bl, 11110000b		; Black on white
  2361                              <1> 	mov16 dx, 27, 14
    15 000020F2 BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  2362 000020F5 BE0800              <1> 	mov si, 8
  2363 000020F8 BF0F00              <1> 	mov di, 15
  2364 000020FB E8B2F7              <1> 	call os_draw_block
  2365                              <1> 
  2366                              <1> 	mov16 dx, 30, 14		; OK button
    15 000020FE BA1E0E              <2>  mov %1, (%2 + %3 * 256)
  2367 00002101 E862F7              <1> 	call os_move_cursor
  2368 00002104 BE[6721]            <1> 	mov si, .ok_button_string
  2369 00002107 E8EBF6              <1> 	call os_print_string
  2370                              <1> 
  2371 0000210A 8A1EA9DE            <1> 	mov bl, [57001]
  2372                              <1> 	mov16 dx, 42, 14
    15 0000210E BA2A0E              <2>  mov %1, (%2 + %3 * 256)
  2373 00002111 BE0900              <1> 	mov si, 9
  2374 00002114 BF0F00              <1> 	mov di, 15
  2375 00002117 E896F7              <1> 	call os_draw_block
  2376                              <1> 
  2377                              <1> 	mov16 dx, 44, 14		; Cancel button
    15 0000211A BA2C0E              <2>  mov %1, (%2 + %3 * 256)
  2378 0000211D E846F7              <1> 	call os_move_cursor
  2379 00002120 BE[6A21]            <1> 	mov si, .cancel_button_string
  2380 00002123 E8CFF6              <1> 	call os_print_string
  2381                              <1> 
  2382 00002126 B90000              <1> 	mov cx, 0			; And update result we'll return
  2383 00002129 EB9C                <1> 	jmp .two_button_wait
  2384                              <1> 
  2385                              <1> .draw_right:
  2386 0000212B 8A1EA9DE            <1> 	mov bl, [57001]
  2387                              <1> 	mov16 dx, 27, 14
    15 0000212F BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  2388 00002132 BE0800              <1> 	mov si, 8
  2389 00002135 BF0F00              <1> 	mov di, 15
  2390 00002138 E875F7              <1> 	call os_draw_block
  2391                              <1> 
  2392                              <1> 	mov16 dx, 30, 14			; OK button
    15 0000213B BA1E0E              <2>  mov %1, (%2 + %3 * 256)
  2393 0000213E E825F7              <1> 	call os_move_cursor
  2394 00002141 BE[6721]            <1> 	mov si, .ok_button_string
  2395 00002144 E8AEF6              <1> 	call os_print_string
  2396                              <1> 
  2397 00002147 B3F0                <1> 	mov bl, 11110000b
  2398                              <1> 	mov16 dx, 43, 14
    15 00002149 BA2B0E              <2>  mov %1, (%2 + %3 * 256)
  2399 0000214C BE0800              <1> 	mov si, 8
  2400 0000214F BF0F00              <1> 	mov di, 15
  2401 00002152 E85BF7              <1> 	call os_draw_block
  2402                              <1> 
  2403                              <1> 	mov16 dx, 44, 14			; Cancel button
    15 00002155 BA2C0E              <2>  mov %1, (%2 + %3 * 256)
  2404 00002158 E80BF7              <1> 	call os_move_cursor
  2405 0000215B BE[6A21]            <1> 	mov si, .cancel_button_string
  2406 0000215E E894F6              <1> 	call os_print_string
  2407                              <1> 
  2408 00002161 B90100              <1> 	mov cx, 1			; And update result we'll return
  2409 00002164 E960FF              <1> 	jmp .two_button_wait
  2410                              <1> 
  2411                              <1> 
  2412                              <1> 
  2413 00002167 4F4B00              <1> 	.ok_button_string	db 'OK', 0
  2414 0000216A 43616E63656C00      <1> 	.cancel_button_string	db 'Cancel', 0
  2415                              <1> 
  2416 00002171 0000                <1> 	.tmp dw 0
  2417                              <1> 
  2418                              <1> ; ------------------------------------------------------------------
  2419                              <1> ; os_print_space -- Print a space to the screen
  2420                              <1> ; IN/OUT: Nothing
  2421                              <1> 
  2422                              <1> os_print_space:
  2423 00002173 60                  <1> 	pusha
  2424                              <1> 
  2425 00002174 B8200E              <1> 	mov ax, 0E20h			; BIOS teletype function
  2426 00002177 CD10                <1> 	int 10h
  2427                              <1> 
  2428 00002179 61                  <1> 	popa
  2429 0000217A C3                  <1> 	ret
  2430                              <1> 
  2431                              <1> 
  2432                              <1> ; ------------------------------------------------------------------
  2433                              <1> ; os_print_digit -- Displays contents of AX as a single digit
  2434                              <1> ; Works up to base 37, ie digits 0-Z
  2435                              <1> ; IN: AX = "digit" to format and print
  2436                              <1> 
  2437                              <1> os_print_digit:
  2438 0000217B 60                  <1> 	pusha
  2439                              <1> 
  2440 0000217C 83F809              <1> 	cmp ax, 9			; There is a break in ASCII table between 9 and A
  2441 0000217F 7E03                <1> 	jle .digit_format
  2442                              <1> 
  2443 00002181 83C007              <1> 	add ax, 'A'-'9'-1		; Correct for the skipped punctuation
  2444                              <1> 
  2445                              <1> .digit_format:
  2446 00002184 83C030              <1> 	add ax, '0'			; 0 will display as '0', etc.	
  2447                              <1> 
  2448 00002187 B40E                <1> 	mov ah, 0Eh			; May modify other registers
  2449 00002189 CD10                <1> 	int 10h
  2450                              <1> 
  2451 0000218B 61                  <1> 	popa
  2452 0000218C C3                  <1> 	ret
  2453                              <1> 
  2454                              <1> 
  2455                              <1> ; ------------------------------------------------------------------
  2456                              <1> ; os_print_1hex -- Displays low nibble of AL in hex format
  2457                              <1> ; IN: AL = number to format and print
  2458                              <1> 
  2459                              <1> os_print_1hex:
  2460 0000218D 60                  <1> 	pusha
  2461                              <1> 
  2462 0000218E 83E00F              <1> 	and ax, 0Fh			; Mask off data to display
  2463 00002191 E8E7FF              <1> 	call os_print_digit
  2464                              <1> 
  2465 00002194 61                  <1> 	popa
  2466 00002195 C3                  <1> 	ret
  2467                              <1> 
  2468                              <1> 
  2469                              <1> ; ------------------------------------------------------------------
  2470                              <1> ; os_print_2hex -- Displays AL in hex format
  2471                              <1> ; IN: AL = number to format and print
  2472                              <1> 
  2473                              <1> os_print_2hex:
  2474 00002196 60                  <1> 	pusha
  2475                              <1> 
  2476 00002197 50                  <1> 	push ax				; Output high nibble
  2477 00002198 C1E804              <1> 	shr ax, 4
  2478 0000219B E8EFFF              <1> 	call os_print_1hex
  2479                              <1> 
  2480 0000219E 58                  <1> 	pop ax				; Output low nibble
  2481 0000219F E8EBFF              <1> 	call os_print_1hex
  2482                              <1> 
  2483 000021A2 61                  <1> 	popa
  2484 000021A3 C3                  <1> 	ret
  2485                              <1> 
  2486                              <1> 
  2487                              <1> ; ------------------------------------------------------------------
  2488                              <1> ; os_print_4hex -- Displays AX in hex format
  2489                              <1> ; IN: AX = number to format and print
  2490                              <1> 
  2491                              <1> os_print_4hex:
  2492 000021A4 60                  <1> 	pusha
  2493                              <1> 
  2494 000021A5 50                  <1> 	push ax				; Output high byte
  2495 000021A6 88E0                <1> 	mov al, ah
  2496 000021A8 E8EBFF              <1> 	call os_print_2hex
  2497                              <1> 
  2498 000021AB 58                  <1> 	pop ax				; Output low byte
  2499 000021AC E8E7FF              <1> 	call os_print_2hex
  2500                              <1> 
  2501 000021AF 61                  <1> 	popa
  2502 000021B0 C3                  <1> 	ret
  2503                              <1> 
  2504                              <1> 
  2505                              <1> ; ------------------------------------------------------------------
  2506                              <1> ; os_input_string -- Take string from keyboard entry
  2507                              <1> ; IN/OUT: AX = location of string, other regs preserved
  2508                              <1> ; (Location will contain up to [0088h] characters, zero-terminated)
  2509                              <1> 
  2510                              <1> os_input_string:
  2511 000021B1 60                  <1> 	pusha
  2512                              <1> 
  2513 000021B2 E8E6F6              <1> 	call os_show_cursor
  2514                              <1> 	
  2515 000021B5 89C7                <1> 	mov di, ax			; DI is where we'll store input (buffer)
  2516 000021B7 B90000              <1> 	mov cx, 0			; Character received counter for backspace
  2517                              <1> 
  2518                              <1> 
  2519                              <1> .more:					; Now onto string getting
  2520 000021BA E8BDF0              <1> 	call os_wait_for_key
  2521                              <1> 
  2522 000021BD 3C0D                <1> 	cmp al, 13			; If Enter key pressed, finish
  2523 000021BF 7455                <1> 	je .done
  2524                              <1> 
  2525 000021C1 3C08                <1> 	cmp al, 8			; Backspace pressed?
  2526 000021C3 7406                <1> 	je .backspace			; If not, skip following checks
  2527                              <1> 
  2528 000021C5 3C20                <1> 	cmp al, ' '			; In ASCII range (32 - 127)?
  2529 000021C7 7CF1                <1> 	jl .more			; Ignore most non-printing characters
  2530                              <1> 
  2531 000021C9 EB35                <1> 	jmp .nobackspace
  2532                              <1> 
  2533                              <1> 
  2534                              <1> .backspace:
  2535 000021CB 83F900              <1> 	cmp cx, 0			; Backspace at start of string?
  2536 000021CE 74EA                <1> 	je .more			; Ignore it if so
  2537                              <1> 
  2538 000021D0 E89CF6              <1> 	call os_get_cursor_pos		; Backspace at start of screen line?
  2539 000021D3 80FA00              <1> 	cmp dl, 0
  2540 000021D6 7413                <1> 	je .backspace_linestart
  2541                              <1> 
  2542 000021D8 60                  <1> 	pusha
  2543 000021D9 B8080E              <1> 	mov ax, 0E08h		; If not, write space and move cursor back
  2544 000021DC CD10                <1> 	int 10h				; Backspace twice, to clear space
  2545 000021DE B020                <1> 	mov al, 32
  2546 000021E0 CD10                <1> 	int 10h
  2547 000021E2 B008                <1> 	mov al, 8
  2548 000021E4 CD10                <1> 	int 10h
  2549 000021E6 61                  <1> 	popa
  2550                              <1> 
  2551 000021E7 4F                  <1> 	dec di				; Character position will be overwritten by new
  2552                              <1> 						; character or terminator at end
  2553                              <1> 
  2554 000021E8 49                  <1> 	dec cx				; Step back counter
  2555                              <1> 
  2556 000021E9 EBCF                <1> 	jmp .more
  2557                              <1> 
  2558                              <1> 
  2559                              <1> .backspace_linestart:
  2560 000021EB FECE                <1> 	dec dh				; Jump back to end of previous line
  2561 000021ED B24F                <1> 	mov dl, 79
  2562 000021EF E874F6              <1> 	call os_move_cursor
  2563                              <1> 
  2564 000021F2 B8200E              <1> 	mov ax, 0E20h		; Print space there
  2565 000021F5 CD10                <1> 	int 10h
  2566                              <1> 
  2567 000021F7 B24F                <1> 	mov dl, 79			; And jump back before the space
  2568 000021F9 E86AF6              <1> 	call os_move_cursor
  2569                              <1> 
  2570 000021FC 4F                  <1> 	dec di				; Step back position in string
  2571 000021FD 49                  <1> 	dec cx				; Step back counter
  2572                              <1> 
  2573 000021FE EBBA                <1> 	jmp .more
  2574                              <1> 
  2575                              <1> 
  2576                              <1> .nobackspace:
  2577 00002200 0FB61E8800          <1> 	movzx bx, byte [0088h]
  2578 00002205 39D9                <1> 	cmp cx, bx			; Make sure we don't exhaust buffer
  2579 00002207 0F8DAFFF            <1> 	jge near .more
  2580                              <1> 
  2581 0000220B 60                  <1> 	pusha
  2582 0000220C B40E                <1> 	mov ah, 0Eh			; Output entered, printable character
  2583 0000220E CD10                <1> 	int 10h
  2584 00002210 61                  <1> 	popa
  2585                              <1> 
  2586 00002211 AA                  <1> 	stosb				; Store character in designated buffer
  2587 00002212 41                  <1> 	inc cx				; Characters processed += 1
  2588                              <1> 	
  2589 00002213 E9A4FF              <1> 	jmp near .more			; Still room for more
  2590                              <1> 
  2591                              <1> .done:
  2592 00002216 B000                <1> 	mov al, 0
  2593 00002218 AA                  <1> 	stosb
  2594                              <1> 
  2595 00002219 61                  <1> 	popa
  2596 0000221A C3                  <1> 	ret
  2597                              <1> 
  2598                              <1> ; Input password(displays it as *s)
  2599                              <1> ; IN: AX = location of string, other regs preserved, BL = color
  2600                              <1> ; OUT: nothing
  2601                              <1> ; (Location will contain up to [0088h] characters, zero-terminated)
  2602                              <1> 
  2603                              <1> os_input_password:
  2604 0000221B 60                  <1> 	pusha
  2605                              <1> 
  2606 0000221C E850F6              <1> 	call os_get_cursor_pos	; Store the cursor position
  2607 0000221F 8916[8C22]          <1> 	mov [.cursor], dx
  2608                              <1> 	
  2609 00002223 89C7                <1> 	mov di, ax			; DI is where we'll store input (buffer)
  2610 00002225 B90000              <1> 	mov cx, 0			; Character received counter for backspace
  2611                              <1> 
  2612                              <1> .more:					; Now onto string getting
  2613 00002228 E84FF0              <1> 	call os_wait_for_key
  2614                              <1> 
  2615 0000222B 3C0D                <1> 	cmp al, 13			; If Enter key pressed, finish
  2616 0000222D 742E                <1> 	je .done
  2617                              <1> 
  2618 0000222F 3C08                <1> 	cmp al, 8			; Backspace pressed?
  2619 00002231 740A                <1> 	je .backspace			; If not, skip following checks
  2620                              <1> 
  2621 00002233 3C20                <1> 	cmp al, ' '			; In ASCII range (32 - 126)?
  2622 00002235 7D13                <1> 	jge .nobackspace	; Ignore most non-printing characters
  2623                              <1> 	
  2624 00002237 3C00                <1> 	cmp al, 0
  2625 00002239 7C0F                <1> 	jl .nobackspace
  2626                              <1> 	
  2627 0000223B EBEB                <1> 	jmp .more
  2628                              <1> 
  2629                              <1> 
  2630                              <1> .backspace:
  2631 0000223D 83F900              <1> 	cmp cx, 0			; Backspace at start of string?
  2632 00002240 74E6                <1> 	je .more			; Ignore it if so
  2633                              <1> 
  2634 00002242 4F                  <1> 	dec di				; Character position will be overwritten by new
  2635                              <1> 						; character or terminator at end
  2636                              <1> 
  2637 00002243 49                  <1> 	dec cx				; Step back counter
  2638                              <1> 
  2639 00002244 E81C00              <1> 	call .update
  2640                              <1> 	
  2641 00002247 E9DEFF              <1> 	jmp near .more
  2642                              <1> 
  2643                              <1> 
  2644                              <1> .nobackspace:
  2645 0000224A 0FB6168800          <1> 	movzx dx, byte [0088h]
  2646 0000224F 39D1                <1> 	cmp cx, dx			; Make sure we don't exhaust buffer
  2647 00002251 0F8DD3FF            <1> 	jge near .more
  2648                              <1> 
  2649 00002255 AA                  <1> 	stosb				; Store character in designated buffer
  2650 00002256 41                  <1> 	inc cx				; Characters processed += 1
  2651                              <1> 
  2652 00002257 E80900              <1> 	call .update
  2653                              <1> 	
  2654 0000225A E9CBFF              <1> 	jmp near .more		; Still room for more
  2655                              <1> 
  2656                              <1> .done:
  2657 0000225D B000                <1> 	mov al, 0
  2658 0000225F AA                  <1> 	stosb
  2659                              <1> 
  2660 00002260 61                  <1> 	popa
  2661 00002261 F8                  <1> 	clc
  2662 00002262 C3                  <1> 	ret
  2663                              <1> 
  2664                              <1> .update:
  2665 00002263 60                  <1> 	pusha
  2666 00002264 8B16[8C22]          <1> 	mov dx, [.cursor]
  2667 00002268 E8FBF5              <1> 	call os_move_cursor
  2668 0000226B B82009              <1> 	mov ax, 0920h		; Clear the line
  2669 0000226E B700                <1> 	mov bh, 0
  2670 00002270 B92000              <1> 	mov cx, 32
  2671 00002273 CD10                <1> 	int 10h
  2672 00002275 61                  <1> 	popa
  2673                              <1> 
  2674 00002276 60                  <1> 	pusha
  2675 00002277 8B16[8C22]          <1> 	mov dx, [.cursor]
  2676 0000227B E8E8F5              <1> 	call os_move_cursor
  2677 0000227E B82A09              <1> 	mov ax, 092Ah		; Print *s(amount in CX)
  2678 00002281 B700                <1> 	mov bh, 0
  2679 00002283 CD10                <1> 	int 10h
  2680 00002285 00CA                <1> 	add dl, cl
  2681 00002287 E8DCF5              <1> 	call os_move_cursor
  2682 0000228A 61                  <1> 	popa
  2683 0000228B C3                  <1> 	ret
  2684                              <1> 	
  2685 0000228C 0000                <1> 	.cursor			dw 0
  2686                              <1> 	
  2687                              <1> ; Opens up os_list_dialog with color.
  2688                              <1> ; IN: nothing
  2689                              <1> ; OUT: color number(0-15)
  2690                              <1> 
  2691                              <1> os_color_selector:
  2692 0000228E 60                  <1> 	pusha
  2693 0000228F B8[A422]            <1> 	mov ax, .colorlist			; Call os_list_dialog with colors
  2694 00002292 BB[1F23]            <1> 	mov bx, .colormsg0
  2695 00002295 B9[3123]            <1> 	mov cx, .colormsg1
  2696 00002298 E819F9              <1> 	call os_list_dialog
  2697                              <1> 	
  2698 0000229B 48                  <1> 	dec ax						; Output from os_list_dialog starts with 1, so decrement it
  2699 0000229C A3[3223]            <1> 	mov [.tmp_word], ax
  2700 0000229F 61                  <1> 	popa
  2701 000022A0 A0[3223]            <1> 	mov al, [.tmp_word]
  2702 000022A3 C3                  <1> 	ret
  2703                              <1> 	
  2704 000022A4 426C61636B2C426C75- <1> 	.colorlist	db 'Black,Blue,Green,Cyan,Red,Magenta,Brown,Light Gray,Dark Gray,Light Blue,Light Green,Light Cyan,Light Red,Pink,Yellow,White', 0
  2704 000022AD 652C477265656E2C43- <1>
  2704 000022B6 79616E2C5265642C4D- <1>
  2704 000022BF 6167656E74612C4272- <1>
  2704 000022C8 6F776E2C4C69676874- <1>
  2704 000022D1 20477261792C446172- <1>
  2704 000022DA 6B20477261792C4C69- <1>
  2704 000022E3 67687420426C75652C- <1>
  2704 000022EC 4C6967687420477265- <1>
  2704 000022F5 656E2C4C6967687420- <1>
  2704 000022FE 4379616E2C4C696768- <1>
  2704 00002307 74205265642C50696E- <1>
  2704 00002310 6B2C59656C6C6F772C- <1>
  2704 00002319 576869746500        <1>
  2705 0000231F 43686F6F7365206120- <1> 	.colormsg0	db 'Choose a color...', 0
  2705 00002328 636F6C6F722E2E2E00  <1>
  2706 00002331 00                  <1> 	.colormsg1	db 0
  2707 00002332 0000                <1> 	.tmp_word	dw 0
  2708                              <1> 	
  2709                              <1> ; Displays EAX in hex format
  2710                              <1> ; IN: EAX = unsigned integer
  2711                              <1> ; OUT: nothing
  2712                              <1> os_print_8hex:
  2713 00002334 6660                <1> 	pushad
  2714 00002336 6660                <1> 	pushad
  2715 00002338 66C1E810            <1> 	shr eax, 16
  2716 0000233C E865FE              <1> 	call os_print_4hex
  2717 0000233F 6661                <1> 	popad
  2718 00002341 E860FE              <1> 	call os_print_4hex
  2719 00002344 6661                <1> 	popad
  2720 00002346 C3                  <1> 	ret
  2721                              <1> 	
  2722                              <1> ; Displays a dialog similar to os_dialog_box, but without the buttons.
  2723                              <1> ; IN: SI/AX/BX/CX/DX = string locations (or 0 for no display)
  2724                              <1> ; OUT: nothing
  2725                              <1> os_temp_box:
  2726 00002347 60                  <1> 	pusha
  2727                              <1> 
  2728 00002348 52                  <1> 	push dx
  2729 00002349 51                  <1> 	push cx
  2730 0000234A 53                  <1> 	push bx
  2731 0000234B 50                  <1> 	push ax
  2732 0000234C 56                  <1> 	push si
  2733                              <1> 	
  2734 0000234D E856F5              <1> 	call os_hide_cursor
  2735                              <1> 
  2736                              <1> 	mov16 dx, 19, 9			; First, draw red background box
    15 00002350 BA1309              <2>  mov %1, (%2 + %3 * 256)
  2737                              <1> 
  2738                              <1> .redbox:				; Loop to draw all lines of box
  2739 00002353 E810F5              <1> 	call os_move_cursor
  2740                              <1> 
  2741 00002356 60                  <1> 	pusha
  2742 00002357 B82009              <1> 	mov ax, 0920h
  2743 0000235A 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  2744 0000235F B92A00              <1> 	mov cx, 42
  2745 00002362 CD10                <1> 	int 10h
  2746 00002364 61                  <1> 	popa
  2747                              <1> 
  2748 00002365 FEC6                <1> 	inc dh
  2749 00002367 80FE10              <1> 	cmp dh, 16
  2750 0000236A 7402                <1> 	je .boxdone
  2751 0000236C EBE5                <1> 	jmp .redbox
  2752                              <1> 
  2753                              <1> 
  2754                              <1> .boxdone:
  2755                              <1> 	mov16 dx, 20, 9
    15 0000236E BA1409              <2>  mov %1, (%2 + %3 * 256)
  2756 00002371 B90500              <1> 	mov cx, 5
  2757                              <1> 
  2758                              <1> .loop:
  2759 00002374 FEC6                <1> 	inc dh
  2760 00002376 E8EDF4              <1> 	call os_move_cursor
  2761                              <1> 
  2762 00002379 5E                  <1> 	pop si
  2763 0000237A 83FE00              <1> 	cmp si, 0			; Skip string params if zero
  2764 0000237D 7403                <1> 	je .no_string
  2765                              <1> 
  2766 0000237F E873F4              <1> 	call os_print_string
  2767                              <1> 
  2768                              <1> .no_string:
  2769 00002382 E2F0                <1> 	loop .loop
  2770 00002384 61                  <1> 	popa
  2771 00002385 C3                  <1> 	ret
  2772                              <1> 
  2773                              <1> ; Prints a message on the footer.
  2774                              <1> ; IN: SI = Message location(if 0, then it restores the previous message)
  2775                              <1> ; OUT: nothing
  2776                              <1> os_print_footer:
  2777 00002386 60                  <1> 	pusha
  2778 00002387 A08200              <1> 	mov al, [0082h]
  2779 0000238A 3C01                <1> 	cmp al, 1
  2780 0000238C 0F844700            <1> 	je near .exit
  2781                              <1> 	
  2782 00002390 E8DCF4              <1> 	call os_get_cursor_pos
  2783 00002393 52                  <1> 	push dx
  2784                              <1> 	
  2785 00002394 BF0100              <1> 	mov di, 1
  2786 00002397 83FE00              <1> 	cmp si, 0
  2787 0000239A 0F843B00            <1> 	je near .restore
  2788                              <1> 	
  2789                              <1> 	mov16 dx, 0, 24
    15 0000239E BA0018              <2>  mov %1, (%2 + %3 * 256)
  2790                              <1> 	
  2791                              <1> .loop:
  2792 000023A1 E8C2F4              <1> 	call os_move_cursor
  2793                              <1> 	
  2794 000023A4 B408                <1> 	mov ah, 08h
  2795 000023A6 B700                <1> 	mov bh, 0
  2796 000023A8 CD10                <1> 	int 10h
  2797                              <1> 	
  2798 000023AA AA                  <1> 	stosb
  2799                              <1> 	
  2800 000023AB FEC2                <1> 	inc dl
  2801 000023AD 83FF51              <1> 	cmp di, 81
  2802 000023B0 0F8CEDFF            <1> 	jnge near .loop
  2803                              <1> 	
  2804 000023B4 C606500000          <1> 	mov byte [80], 0
  2805                              <1> 	
  2806                              <1> 	mov16 dx, 0, 24
    15 000023B9 BA0018              <2>  mov %1, (%2 + %3 * 256)
  2807 000023BC E8A7F4              <1> 	call os_move_cursor
  2808                              <1> 	
  2809 000023BF B82009              <1> 	mov ax, 0920h
  2810 000023C2 BB7000              <1> 	mov bx, 70h
  2811 000023C5 B95000              <1> 	mov cx, 80
  2812 000023C8 CD10                <1> 	int 10h
  2813                              <1> 	
  2814                              <1> 	mov16 dx, 0, 24
    15 000023CA BA0018              <2>  mov %1, (%2 + %3 * 256)
  2815 000023CD E896F4              <1> 	call os_move_cursor
  2816                              <1> 	
  2817 000023D0 E822F4              <1> 	call os_print_string
  2818                              <1> 	
  2819 000023D3 5A                  <1> 	pop dx
  2820 000023D4 E88FF4              <1> 	call os_move_cursor
  2821                              <1> 
  2822                              <1> .exit:	
  2823 000023D7 61                  <1> 	popa
  2824 000023D8 C3                  <1> 	ret
  2825                              <1> 	
  2826                              <1> .restore:
  2827                              <1> 	mov16 dx, 0, 24
    15 000023D9 BA0018              <2>  mov %1, (%2 + %3 * 256)
  2828 000023DC E887F4              <1> 	call os_move_cursor
  2829 000023DF BE0100              <1> 	mov si, 1
  2830 000023E2 E810F4              <1> 	call os_print_string
  2831                              <1> 	
  2832 000023E5 5A                  <1> 	pop dx
  2833 000023E6 E87DF4              <1> 	call os_move_cursor
  2834                              <1> 	
  2835 000023E9 61                  <1> 	popa
  2836 000023EA C3                  <1> 	ret
  2837                              <1> 	
  2838                              <1> ; Resets the font to the selected default.
  2839                              <1> ; IN = nothing
  2840                              <1> ; OUT = nothing
  2841                              <1> os_reset_font:
  2842 000023EB 60                  <1> 	pusha
  2843                              <1> 	
  2844 000023EC 803EF1DE01          <1> 	cmp byte [57073], 1
  2845 000023F1 0F841800            <1> 	je near .bios
  2846                              <1> 	
  2847 000023F5 06                  <1> 	push es
  2848 000023F6 B80011              <1> 	mov ax, 1100h
  2849 000023F9 BB0010              <1> 	mov bx, 1000h
  2850 000023FC B90001              <1> 	mov cx, 0100h
  2851                              <1> 	clr dx
    11 000023FF 31D2                <2>  xor %1, %1
  2852 00002401 8E06[F205]          <1> 	mov es, [driversgmt]
  2853 00002405 BD0016              <1> 	mov bp, SYSTEM_FONT
  2854 00002408 CD10                <1> 	int 10h
  2855 0000240A 07                  <1> 	pop es
  2856 0000240B 61                  <1> 	popa
  2857 0000240C C3                  <1> 	ret
  2858                              <1> 	
  2859                              <1> .bios:
  2860 0000240D 61                  <1> 	popa
  2861 0000240E C3                  <1> 	ret
  2862                              <1> 
  2863                              <1> ; Draws the crepeOS logo.
  2864                              <1> ; IN: nothing
  2865                              <1> ; OUT: a very beautiful logo :-)
  2866                              <1> os_draw_logo:
  2867 0000240F 60                  <1> 	pusha
  2868                              <1> 	
  2869                              <1> 	mov16 dx, 0, 2
    15 00002410 BA0002              <2>  mov %1, (%2 + %3 * 256)
  2870 00002413 E850F4              <1> 	call os_move_cursor
  2871                              <1> 
  2872 00002416 B82009              <1> 	mov ax, 0920h
  2873 00002419 BB0400              <1> 	mov bx, 00000100b
  2874 0000241C B93002              <1> 	mov cx, 560
  2875 0000241F CD10                <1> 	int 10h
  2876                              <1> 
  2877 00002421 BE[6909]            <1> 	mov si, logo
  2878 00002424 E80200              <1> 	call os_draw_icon
  2879 00002427 61                  <1> 	popa
  2880 00002428 C3                  <1> 	ret
  2881                              <1> 
  2882                              <1> ; Draws an icon (in the crepeOS format).
  2883                              <1> ; IN: SI = address of the icon
  2884                              <1> ; OUT: nothing
  2885                              <1> os_draw_icon:
  2886 00002429 60                  <1> 	pusha
  2887                              <1> 	
  2888 0000242A E842F4              <1> 	call os_get_cursor_pos
  2889 0000242D 8916[9624]          <1> 	mov [.cursor], dx
  2890                              <1> 	
  2891 00002431 AD                  <1> 	lodsw
  2892 00002432 A3[9C24]            <1> 	mov [.size], ax
  2893                              <1> 	
  2894                              <1> 	clr cx
    11 00002435 31C9                <2>  xor %1, %1
  2895                              <1> 	
  2896                              <1> .loop:
  2897 00002437 AC                  <1> 	lodsb
  2898                              <1> 	
  2899 00002438 B40E                <1> 	mov ah, 0Eh
  2900                              <1> 	
  2901 0000243A 51                  <1> 	push cx
  2902 0000243B 88C1                <1> 	mov cl, al
  2903 0000243D 0FB6D9              <1> 	movzx bx, cl
  2904 00002440 80E3C0              <1> 	and bl, 11000000b
  2905 00002443 C0EB06              <1> 	shr bl, 6
  2906 00002446 8A87[9824]          <1> 	mov al, [.chars + bx]
  2907 0000244A CD10                <1> 	int 10h
  2908                              <1> 	
  2909 0000244C 0FB6D9              <1> 	movzx bx, cl
  2910 0000244F 80E330              <1> 	and bl, 110000b
  2911 00002452 C0EB04              <1> 	shr bl, 4
  2912 00002455 8A87[9824]          <1> 	mov al, [.chars + bx]
  2913 00002459 CD10                <1> 	int 10h
  2914                              <1> 	
  2915 0000245B 0FB6D9              <1> 	movzx bx, cl
  2916 0000245E 80E30C              <1> 	and bl, 1100b
  2917 00002461 C0EB02              <1> 	shr bl, 2
  2918 00002464 8A87[9824]          <1> 	mov al, [.chars + bx]
  2919 00002468 CD10                <1> 	int 10h
  2920                              <1> 	
  2921 0000246A 0FB6D9              <1> 	movzx bx, cl
  2922 0000246D 80E303              <1> 	and bl, 11b
  2923 00002470 8A87[9824]          <1> 	mov al, [.chars + bx]
  2924 00002474 CD10                <1> 	int 10h
  2925 00002476 59                  <1> 	pop cx
  2926                              <1> 	
  2927 00002477 FEC1                <1> 	inc cl
  2928 00002479 3A0E[9C24]          <1> 	cmp cl, [.size]
  2929 0000247D 75B8                <1> 	jne .loop
  2930                              <1> 
  2931 0000247F FE06[9724]          <1> 	inc byte [.cursor + 1]
  2932 00002483 8B16[9624]          <1> 	mov dx, [.cursor]
  2933 00002487 E8DCF3              <1> 	call os_move_cursor
  2934                              <1> 	
  2935 0000248A B100                <1> 	mov cl, 0
  2936 0000248C FEC5                <1> 	inc ch
  2937 0000248E 3A2E[9D24]          <1> 	cmp ch, [.size + 1]
  2938 00002492 75A3                <1> 	jne .loop
  2939                              <1> 	
  2940 00002494 61                  <1> 	popa
  2941 00002495 C3                  <1> 	ret
  2942                              <1> 
  2943 00002496 0000                <1> 	.cursor		dw 0
  2944 00002498 20DCDFDB            <1> 	.chars		db 32, 220, 223, 219
  2945 0000249C 0000                <1> 	.size		dw 0
  2946                              <1> 	
  2947                              <1> ; ------------------------------------------------------------------
  2948                              <1> ; os_option_menu -- Show a menu with a list of options
  2949                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated), BX = menu width
  2950                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc, left or right pressed
  2951                              <1> 
  2952                              <1> os_option_menu:
  2953 0000249E 60                  <1> 	pusha
  2954                              <1> 
  2955 0000249F 803EEFDE00          <1> 	cmp byte [57071], 0
  2956 000024A4 741C                <1> 	je .skip
  2957                              <1> 	
  2958                              <1> 	mov16 dx, 0, 1
    15 000024A6 BA0001              <2>  mov %1, (%2 + %3 * 256)
  2959                              <1> 
  2960 000024A9 E8BAF3              <1> 	call os_move_cursor
  2961                              <1> 	
  2962 000024AC B408                <1> 	mov ah, 08h
  2963 000024AE B700                <1> 	mov bh, 0
  2964 000024B0 CD10                <1> 	int 10h				; Get the character's attribute (X = 0, Y = 1)
  2965                              <1> 	
  2966 000024B2 80E4F0              <1> 	and ah, 0F0h		; Keep only the background, set foreground to 0
  2967                              <1> 	
  2968 000024B5 0FB6DC              <1> 	movzx bx, ah
  2969 000024B8 B8B109              <1> 	mov ax, 09B1h
  2970 000024BB B93007              <1> 	mov cx, 1840
  2971 000024BE CD10                <1> 	int 10h
  2972                              <1> 	
  2973 000024C0 61                  <1> 	popa
  2974 000024C1 60                  <1> 	pusha
  2975                              <1> 
  2976                              <1> .skip:
  2977 000024C2 891E[2C26]          <1> 	mov [.width], bx
  2978                              <1> 
  2979 000024C6 50                  <1> 	push ax				; Store string list for now
  2980                              <1> 
  2981 000024C7 E8DCF3              <1> 	call os_hide_cursor
  2982                              <1> 
  2983 000024CA B100                <1> 	mov cl, 0			; Count the number of entries in the list
  2984 000024CC 89C6                <1> 	mov si, ax
  2985                              <1> 	
  2986                              <1> .count_loop:
  2987 000024CE AC                  <1> 	lodsb
  2988 000024CF 3C00                <1> 	cmp al, 0
  2989 000024D1 7408                <1> 	je .done_count
  2990 000024D3 3C2C                <1> 	cmp al, ','
  2991 000024D5 75F7                <1> 	jne .count_loop
  2992 000024D7 FEC1                <1> 	inc cl
  2993 000024D9 EBF3                <1> 	jmp .count_loop
  2994                              <1> 
  2995                              <1> .done_count:
  2996 000024DB FEC1                <1> 	inc cl
  2997 000024DD 880E[2826]          <1> 	mov byte [.num_of_entries], cl
  2998                              <1> 
  2999                              <1> 
  3000 000024E1 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  3001 000024E2 8936[2A26]          <1> 	mov word [.list_string], si
  3002                              <1> 
  3003                              <1> 
  3004                              <1> 	; Now that we've drawn the list, highlight the currently selected
  3005                              <1> 	; entry and let the user move up and down using the cursor keys
  3006                              <1> 
  3007 000024E6 C606[2926]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  3008                              <1> 
  3009                              <1> 	mov16 dx, 25, 2			; Set up starting position for selector
    15 000024EB BA1902              <2>  mov %1, (%2 + %3 * 256)
  3010                              <1> 
  3011 000024EE E875F3              <1> 	call os_move_cursor
  3012                              <1> 
  3013                              <1> .more_select:
  3014 000024F1 60                  <1> 	pusha
  3015 000024F2 8A1EF0DE            <1> 	mov bl, [57072]		; Black on white for option list box
  3016                              <1> 	mov16 dx, 1, 1
    15 000024F6 BA0101              <2>  mov %1, (%2 + %3 * 256)
  3017                              <1> 
  3018 000024F9 8B36[2C26]          <1> 	mov si, [.width]
  3019 000024FD 0FB63E[2826]        <1> 	movzx di, [.num_of_entries]
  3020 00002502 83C703              <1> 	add di, 3
  3021 00002505 E8A8F3              <1> 	call os_draw_block
  3022 00002508 61                  <1> 	popa
  3023                              <1> 
  3024 00002509 E8EA00              <1> 	call .draw_black_bar
  3025                              <1> 
  3026 0000250C 8B36[2A26]          <1> 	mov word si, [.list_string]
  3027 00002510 E8A000              <1> 	call .draw_list
  3028                              <1> 
  3029                              <1> .another_key:
  3030 00002513 E864ED              <1> 	call os_wait_for_key		; Move / select option
  3031 00002516 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  3032 00002519 7419                <1> 	je .go_up
  3033 0000251B 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  3034 0000251E 7425                <1> 	je .go_down
  3035 00002520 3C0D                <1> 	cmp al, 13			; Enter pressed?
  3036 00002522 745A                <1> 	je .option_selected
  3037 00002524 3C1B                <1> 	cmp al, 27			; Esc pressed?
  3038 00002526 7470                <1> 	je .esc_pressed
  3039 00002528 80FC4B              <1> 	cmp ah, 75			; Left pressed?
  3040 0000252B 7474                <1> 	je .left_pressed
  3041 0000252D 80FC4D              <1> 	cmp ah, 77			; Right pressed?
  3042 00002530 7478                <1> 	je .right_pressed
  3043 00002532 EBDF                <1> 	jmp .another_key		; If not, wait for another key
  3044                              <1> 
  3045                              <1> 
  3046                              <1> .go_up:
  3047 00002534 80FE02              <1> 	cmp dh, 2			; Already at top?
  3048 00002537 7E37                <1> 	jle .hit_top
  3049                              <1> 
  3050 00002539 E8D100              <1> 	call .draw_white_bar
  3051                              <1> 
  3052 0000253C B219                <1> 	mov dl, 25
  3053 0000253E E825F3              <1> 	call os_move_cursor
  3054                              <1> 
  3055 00002541 FECE                <1> 	dec dh				; Row to select (increasing down)
  3056 00002543 EBAC                <1> 	jmp .more_select
  3057                              <1> 
  3058                              <1> 
  3059                              <1> .go_down:				; Already at bottom of list?
  3060 00002545 8A1E[2826]          <1> 	mov bl, [.num_of_entries]
  3061 00002549 FEC3                <1> 	inc bl
  3062 0000254B 38DE                <1> 	cmp dh, bl
  3063 0000254D 742A                <1> 	je .hit_bottom
  3064                              <1> 
  3065 0000254F B90000              <1> 	mov cx, 0
  3066 00002552 88F1                <1> 	mov byte cl, dh
  3067                              <1> 
  3068 00002554 80E906              <1> 	sub cl, 6
  3069 00002557 FEC1                <1> 	inc cl
  3070 00002559 020E[2926]          <1> 	add byte cl, [.skip_num]
  3071                              <1> 
  3072 0000255D A0[2826]            <1> 	mov byte al, [.num_of_entries]
  3073 00002560 38C1                <1> 	cmp cl, al
  3074 00002562 74AF                <1> 	je .another_key
  3075                              <1> 
  3076 00002564 E8A600              <1> 	call .draw_white_bar
  3077                              <1> 
  3078 00002567 B219                <1> 	mov dl, 25
  3079 00002569 E8FAF2              <1> 	call os_move_cursor
  3080                              <1> 
  3081 0000256C FEC6                <1> 	inc dh
  3082 0000256E EB81                <1> 	jmp .more_select
  3083                              <1> 
  3084                              <1> 
  3085                              <1> .hit_top:
  3086 00002570 B601                <1> 	mov dh, 1
  3087 00002572 0236[2826]          <1> 	add dh, [.num_of_entries]
  3088 00002576 E978FF              <1> 	jmp .more_select
  3089                              <1> 
  3090                              <1> 
  3091                              <1> .hit_bottom:
  3092 00002579 B602                <1> 	mov dh, 2
  3093 0000257B E973FF              <1> 	jmp .more_select
  3094                              <1> 
  3095                              <1> 
  3096                              <1> 
  3097                              <1> .option_selected:
  3098 0000257E E81AF3              <1> 	call os_show_cursor
  3099                              <1> 
  3100 00002581 80EE02              <1> 	sub dh, 2
  3101                              <1> 
  3102 00002584 B80000              <1> 	mov ax, 0
  3103 00002587 88F0                <1> 	mov al, dh
  3104                              <1> 
  3105 00002589 FEC0                <1> 	inc al				; Options start from 1
  3106 0000258B 0206[2926]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  3107                              <1> 
  3108 0000258F A3[2626]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  3109                              <1> 
  3110 00002592 61                  <1> 	popa
  3111                              <1> 
  3112 00002593 A1[2626]            <1> 	mov word ax, [.tmp]
  3113 00002596 F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  3114 00002597 C3                  <1> 	ret
  3115                              <1> 
  3116                              <1> 
  3117                              <1> 
  3118                              <1> .esc_pressed:
  3119 00002598 E800F3              <1> 	call os_show_cursor
  3120 0000259B 61                  <1> 	popa
  3121 0000259C B80000              <1> 	mov ax, 0
  3122 0000259F F9                  <1> 	stc
  3123 000025A0 C3                  <1> 	ret
  3124                              <1> 
  3125                              <1> .left_pressed:
  3126 000025A1 E8F7F2              <1> 	call os_show_cursor
  3127 000025A4 61                  <1> 	popa
  3128 000025A5 B80100              <1> 	mov ax, 1
  3129 000025A8 F9                  <1> 	stc
  3130 000025A9 C3                  <1> 	ret
  3131                              <1> 
  3132                              <1> .right_pressed:
  3133 000025AA E8EEF2              <1> 	call os_show_cursor
  3134 000025AD 61                  <1> 	popa
  3135 000025AE B80200              <1> 	mov ax, 2
  3136 000025B1 F9                  <1> 	stc
  3137 000025B2 C3                  <1> 	ret
  3138                              <1> 
  3139                              <1> .draw_list:
  3140 000025B3 60                  <1> 	pusha
  3141                              <1> 
  3142                              <1> 	mov16 dx, 3, 2			; Get into position for option list text
    15 000025B4 BA0302              <2>  mov %1, (%2 + %3 * 256)
  3143 000025B7 E8ACF2              <1> 	call os_move_cursor
  3144                              <1> 
  3145                              <1> 
  3146 000025BA B90000              <1> 	mov cx, 0			; Skip lines scrolled off the top of the dialog
  3147 000025BD 8A0E[2926]          <1> 	mov byte cl, [.skip_num]
  3148                              <1> 
  3149                              <1> .skip_loop:
  3150 000025C1 83F900              <1> 	cmp cx, 0
  3151 000025C4 7408                <1> 	je .skip_loop_finished
  3152                              <1> 	
  3153                              <1> .more_lodsb:
  3154 000025C6 AC                  <1> 	lodsb
  3155 000025C7 3C2C                <1> 	cmp al, ','
  3156 000025C9 75FB                <1> 	jne .more_lodsb
  3157 000025CB 49                  <1> 	dec cx
  3158 000025CC EBF3                <1> 	jmp .skip_loop
  3159                              <1> 
  3160                              <1> 
  3161                              <1> .skip_loop_finished:
  3162 000025CE BB0000              <1> 	mov bx, 0			; Counter for total number of options
  3163                              <1> 
  3164                              <1> 
  3165                              <1> .more:
  3166 000025D1 AC                  <1> 	lodsb				; Get next character in file name, increment pointer
  3167                              <1> 
  3168 000025D2 3C00                <1> 	cmp al, 0			; End of string?
  3169 000025D4 741B                <1> 	je .done_list
  3170                              <1> 
  3171 000025D6 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  3172 000025D8 7406                <1> 	je .newline
  3173                              <1> 
  3174 000025DA B40E                <1> 	mov ah, 0Eh
  3175 000025DC CD10                <1> 	int 10h
  3176 000025DE EBF1                <1> 	jmp .more
  3177                              <1> 
  3178                              <1> .newline:
  3179 000025E0 B203                <1> 	mov dl, 3			; Go back to starting X position
  3180 000025E2 FEC6                <1> 	inc dh				; But jump down a line
  3181 000025E4 E87FF2              <1> 	call os_move_cursor
  3182                              <1> 
  3183 000025E7 43                  <1> 	inc bx				; Update the number-of-options counter
  3184 000025E8 0FB63E[2826]        <1> 	movzx di, [.num_of_entries]	; Low 8 bits of DI = [.items], high 8 bits = 0
  3185 000025ED 39FB                <1> 	cmp bx, di			; Limit to one screen of options
  3186 000025EF 7CE0                <1> 	jl .more
  3187                              <1> 
  3188                              <1> .done_list:
  3189 000025F1 61                  <1> 	popa
  3190 000025F2 E871F2              <1> 	call os_move_cursor
  3191                              <1> 
  3192 000025F5 C3                  <1> 	ret
  3193                              <1> 
  3194                              <1> 
  3195                              <1> 
  3196                              <1> .draw_black_bar:
  3197 000025F6 60                  <1> 	pusha
  3198                              <1> 
  3199 000025F7 B202                <1> 	mov dl, 2
  3200 000025F9 E86AF2              <1> 	call os_move_cursor
  3201                              <1> 
  3202 000025FC B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  3203 000025FF 8B0E[2C26]          <1> 	mov cx, [.width]
  3204 00002603 83E902              <1> 	sub cx, 2
  3205 00002606 BB0F00              <1> 	mov bx, 00001111b		; White text on black background
  3206 00002609 CD10                <1> 	int 10h
  3207                              <1> 
  3208 0000260B 61                  <1> 	popa
  3209 0000260C C3                  <1> 	ret
  3210                              <1> 
  3211                              <1> .draw_white_bar:
  3212 0000260D 60                  <1> 	pusha
  3213                              <1> 
  3214 0000260E B202                <1> 	mov dl, 2
  3215 00002610 E853F2              <1> 	call os_move_cursor
  3216                              <1> 
  3217 00002613 B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  3218 00002616 8B0E[2C26]          <1> 	mov cx, [.width]
  3219 0000261A 83E902              <1> 	sub cx, 2
  3220 0000261D 0FB61EF0DE          <1> 	movzx bx, byte [57072]	; Black text on white background
  3221 00002622 CD10                <1> 	int 10h
  3222                              <1> 
  3223 00002624 61                  <1> 	popa
  3224 00002625 C3                  <1> 	ret
  3225                              <1> 
  3226 00002626 0000                <1> 	.tmp					dw 0
  3227 00002628 00                  <1> 	.num_of_entries			db 0
  3228 00002629 00                  <1> 	.skip_num				db 0
  3229 0000262A 0000                <1> 	.list_string			dw 0
  3230 0000262C 0000                <1> 	.width					dw 0
  3231                              <1> 	
  3232                              <1> ; ==================================================================
   816                                  	%INCLUDE "drivers/sound.asm"
   817                              <1> ; ==================================================================
   818                              <1> ; PC SPEAKER/ADLIB SOUND ROUTINES
   819                              <1> ; ==================================================================
   820                              <1> 
   821                              <1> ; ------------------------------------------------------------------
   822                              <1> ; os_speaker_tone -- Generate PC speaker tone (call os_speaker_off to turn off)
   823                              <1> ; IN: AX = note frequency; OUT: Nothing (registers preserved)
   824                              <1> 
   825                              <1> os_speaker_tone:
   826 0000262E 60                  <1> 	pusha
   827 0000262F 803E830000          <1> 	cmp byte [0083h], 0
   828 00002634 0F842600            <1> 	je near .exit
   829 00002638 61                  <1> 	popa
   830                              <1> 	
   831 00002639 60                  <1> 	pusha
   832 0000263A 83F800              <1> 	cmp ax, 0
   833 0000263D 0F841D00            <1> 	je near .exit
   834                              <1> 	
   835 00002641 E82A00              <1> 	call os_speaker_off
   836 00002644 89C1                <1> 	mov cx, ax			; Store note value for now
   837                              <1> 
   838 00002646 B0B6                <1> 	mov al, 10110110b
   839 00002648 E643                <1> 	out 43h, al
   840 0000264A BA1200              <1> 	mov dx, 12h			; Set up frequency
   841 0000264D B8DC34              <1> 	mov ax, 34DCh
   842 00002650 F7F1                <1> 	div cx
   843 00002652 E642                <1> 	out 42h, al
   844 00002654 88E0                <1> 	mov al, ah
   845 00002656 E642                <1> 	out 42h, al
   846                              <1> 
   847 00002658 E461                <1> 	in al, 61h			; Switch PC speaker on
   848 0000265A 0C03                <1> 	or al, 03h
   849 0000265C E661                <1> 	out 61h, al
   850                              <1> 
   851                              <1> .exit:
   852 0000265E 61                  <1> 	popa
   853 0000265F C3                  <1> 	ret
   854                              <1> 
   855                              <1> ; ------------------------------------------------------------------
   856                              <1> ; os_speaker_note_length -- Generate PC speaker tone for a set amount of time and then stop
   857                              <1> ; IN: AX = note frequency, CX = length (in ticks)
   858                              <1> 
   859                              <1> os_speaker_note_length:
   860 00002660 60                  <1> 	pusha
   861 00002661 E8CAFF              <1> 	call os_speaker_tone
   862                              <1> 	
   863 00002664 89C8                <1> 	mov ax, cx
   864 00002666 E863EE              <1> 	call os_pause
   865                              <1> 	
   866 00002669 E80200              <1> 	call os_speaker_off
   867 0000266C 61                  <1> 	popa
   868 0000266D C3                  <1> 	ret
   869                              <1> 
   870                              <1> ; ------------------------------------------------------------------
   871                              <1> ; os_speaker_off -- Turn off PC speaker
   872                              <1> ; IN/OUT: Nothing (registers preserved)
   873                              <1> 
   874                              <1> os_speaker_off:
   875 0000266E 60                  <1> 	pusha
   876                              <1> 
   877 0000266F E461                <1> 	in al, 61h
   878 00002671 24FC                <1> 	and al, 0FCh
   879 00002673 E661                <1> 	out 61h, al
   880                              <1> 
   881 00002675 61                  <1> 	popa
   882 00002676 C3                  <1> 	ret
   883                              <1> 
   884                              <1> ; ------------------------------------------------------------------
   885                              <1> ; os_start_adlib -- Starts the selected Adlib driver
   886                              <1> ; IN: SI = interrupt handler, CX = prescaler, BL = number of channels
   887                              <1> ; The interrupt will fire at 33144 Hz (the closest possible to 32768 Hz) divided by CX.
   888                              <1> ; Common prescaler values:
   889                              <1> ;		33 = ~1 kHz (1004.362 Hz)
   890                              <1> ;		663 = ~50 Hz (49.991 Hz)
   891                              <1> ;		1820 = ~18.2 Hz (18.211 Hz)
   892                              <1> 
   893                              <1> os_start_adlib:
   894 00002677 60                  <1> 	pusha
   895 00002678 C606[4D28]01        <1> 	mov byte [adlib_running], 1
   896                              <1> 
   897 0000267D 803EEEDE01          <1> 	cmp byte [57070], 1
   898 00002682 7D16                <1> 	jge .pcspk
   899                              <1> 	
   900 00002684 B80000              <1> 	mov ax, 0
   901                              <1> 	
   902                              <1> .loop:
   903 00002687 E8C700              <1> 	call int_adlib_regwrite
   904 0000268A FEC4                <1> 	inc ah
   905 0000268C 75F9                <1> 	jnz .loop
   906                              <1> 	
   907 0000268E B82400              <1> 	mov ax, 36
   908 00002691 F7E1                <1> 	mul cx
   909                              <1> 	
   910 00002693 89C1                <1> 	mov cx, ax
   911 00002695 E81421              <1> 	call os_attach_app_timer
   912                              <1> 	
   913 00002698 61                  <1> 	popa
   914 00002699 C3                  <1> 	ret
   915                              <1> 	
   916                              <1> .pcspk:
   917 0000269A B82400              <1> 	mov ax, 36
   918 0000269D F6F3                <1> 	div bl
   919                              <1> 	
   920 0000269F A2[E828]            <1> 	mov [pwm_channel_amplitude], al
   921                              <1> 
   922 000026A2 8936[E128]          <1> 	mov [pwm_callback], si
   923 000026A6 890E[E328]          <1> 	mov [pwm_callback_ctr], cx
   924 000026AA 890E[E528]          <1> 	mov [pwm_callback_ctr_def], cx
   925                              <1> 
   926                              <1> 	; Set up the PC speaker
   927 000026AE E461                <1> 	in al, 0x61
   928 000026B0 0C03                <1> 	or al, 3
   929 000026B2 E661                <1> 	out 0x61, al
   930                              <1> 
   931                              <1> 	; Enable the callback
   932 000026B4 BE[4E28]            <1> 	mov si, pwm_handler
   933 000026B7 8CCF                <1> 	mov di, cs
   934 000026B9 B11C                <1> 	mov cl, 01Ch
   935 000026BB E8A820              <1> 	call os_modify_int_handler
   936                              <1> 
   937 000026BE B92400              <1> 	mov cx, 36
   938 000026C1 E80F21              <1> 	call os_set_timer_speed
   939                              <1> 	
   940 000026C4 61                  <1> 	popa
   941 000026C5 C3                  <1> 	ret
   942                              <1> 	
   943                              <1> ; ------------------------------------------------------------------
   944                              <1> ; os_stop_adlib -- Stops the Adlib driver
   945                              <1> 
   946                              <1> os_stop_adlib:
   947 000026C6 60                  <1> 	pusha
   948 000026C7 803EEEDE01          <1> 	cmp byte [57070], 1
   949 000026CC 7D1D                <1> 	jge .pcspk
   950                              <1> 	
   951 000026CE E8EA20              <1> 	call os_return_app_timer
   952                              <1> 
   953 000026D1 B400                <1> 	mov ah, 0
   954                              <1> 	
   955                              <1> .loop:
   956 000026D3 0FB6DC              <1> 	movzx bx, ah
   957 000026D6 C1EB05              <1> 	shr bx, 5
   958 000026D9 8A87[0E27]          <1> 	mov al, [adlib_clear_regs + bx]
   959                              <1> 
   960 000026DD E87100              <1> 	call int_adlib_regwrite
   961                              <1> 	
   962 000026E0 FEC4                <1> 	inc ah
   963 000026E2 75EF                <1> 	jnz .loop
   964                              <1> 	
   965 000026E4 C606[4D28]00        <1> 	mov byte [adlib_running], 0
   966 000026E9 61                  <1> 	popa
   967 000026EA C3                  <1> 	ret
   968                              <1> 	
   969                              <1> .pcspk:
   970                              <1> 	; Turn off the PC speaker
   971 000026EB E461                <1> 	in al, 0x61
   972 000026ED 24FC                <1> 	and al, 0xfc
   973 000026EF E661                <1> 	out 0x61, al
   974                              <1> 
   975 000026F1 B90000              <1> 	mov cx, 0
   976 000026F4 E8DC20              <1> 	call os_set_timer_speed
   977                              <1> 	
   978                              <1> 	; Reset the RTC handler
   979 000026F7 B11C                <1> 	mov cl, 1Ch
   980 000026F9 BE[7C48]            <1> 	mov si, os_compat_int1C
   981 000026FC 8CCF                <1> 	mov di, cs
   982 000026FE E86520              <1> 	call os_modify_int_handler
   983                              <1> 	
   984                              <1> 	; Turn off all of the channels
   985 00002701 B91200              <1> 	mov cx, 18		; Not only nuke pwm_freq, but also pwm_cntr!
   986 00002704 BF[BC28]            <1> 	mov di, pwm_freq
   987 00002707 B80000              <1> 	mov ax, 0
   988 0000270A F3AB                <1> 	rep stosw
   989                              <1> 	
   990 0000270C 61                  <1> 	popa
   991 0000270D C3                  <1> 	ret
   992                              <1> 	
   993                              <1> 	; Registers:    	   0x00  0x20  0x40  0x60  0x80  0xA0  0xC0  0xE0
   994 0000270E 00003FFFFF000000    <1> 	adlib_clear_regs	db 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0x00, 0x00, 0x00
   995                              <1> 	
   996                              <1> ; ------------------------------------------------------------------
   997                              <1> ; os_check_adlib -- Checks if YM3812 is present in the system
   998                              <1> ; OUT: CF clear if YM3812 is present
   999                              <1> 
  1000                              <1> os_check_adlib:
  1001 00002716 60                  <1> 	pusha
  1002 00002717 803EEEDE01          <1> 	cmp byte [57070], 1
  1003 0000271C 7D14                <1> 	jge .ok
  1004                              <1> 
  1005 0000271E B86004              <1> 	mov ax, 0460h
  1006 00002721 E82D00              <1> 	call int_adlib_regwrite
  1007                              <1> 	
  1008 00002724 B88004              <1> 	mov ax, 0480h
  1009 00002727 E82700              <1> 	call int_adlib_regwrite
  1010                              <1> 	
  1011 0000272A BA8803              <1> 	mov dx, 388h
  1012 0000272D EC                  <1> 	in al, dx
  1013 0000272E 3C00                <1> 	cmp al, 0
  1014 00002730 7503                <1> 	jne .error
  1015                              <1> 	
  1016                              <1> .ok:
  1017 00002732 61                  <1> 	popa
  1018 00002733 F8                  <1> 	clc
  1019 00002734 C3                  <1> 	ret
  1020                              <1> 	
  1021                              <1> .error:
  1022 00002735 61                  <1> 	popa
  1023 00002736 F9                  <1> 	stc
  1024 00002737 C3                  <1> 	ret
  1025                              <1> 	
  1026                              <1> ; ------------------------------------------------------------------
  1027                              <1> ; os_adlib_regwrite -- Write to a YM3812 register
  1028                              <1> ; IN: AH/AL - register address/value to write
  1029                              <1> 
  1030                              <1> os_adlib_regwrite:
  1031 00002738 60                  <1> 	pusha
  1032                              <1> 	
  1033 00002739 0FB6DC              <1> 	movzx bx, ah		; Store the value in the buffer first
  1034 0000273C 6488870005          <1> 	mov [fs:ADLIB_BUFFER + bx], al
  1035                              <1> 	
  1036 00002741 E80D00              <1> 	call int_adlib_regwrite
  1037                              <1> 	
  1038 00002744 61                  <1> 	popa
  1039 00002745 C3                  <1> 	ret
  1040                              <1> 	
  1041                              <1> ; ------------------------------------------------------------------
  1042                              <1> ; os_adlib_regread -- Read from a YM3812 register
  1043                              <1> ; IN: AH - register address; OUT: AL - value
  1044                              <1> 
  1045                              <1> os_adlib_regread:
  1046 00002746 53                  <1> 	push bx
  1047                              <1> 	
  1048 00002747 0FB6DC              <1> 	movzx bx, ah		; Store the value in the buffer first
  1049 0000274A 648A870005          <1> 	mov al, [fs:ADLIB_BUFFER + bx]
  1050                              <1> 	
  1051 0000274F 5B                  <1> 	pop bx
  1052 00002750 C3                  <1> 	ret
  1053                              <1> 	
  1054                              <1> ; ------------------------------------------------------------------
  1055                              <1> ; int_adlib_regwrite -- Internal kernel function - not available to user programs
  1056                              <1> ; IN: AH/AL - register address/value to write
  1057                              <1> 	
  1058                              <1> int_adlib_regwrite:
  1059 00002751 60                  <1> 	pusha
  1060                              <1> 
  1061 00002752 803EEEDE01          <1> 	cmp byte [57070], 1
  1062 00002757 7D21                <1> 	jge .pcspk
  1063                              <1> 
  1064 00002759 803E[4D28]00        <1> 	cmp byte [adlib_running], 0
  1065 0000275E 7418                <1> 	je .no_write
  1066                              <1> 
  1067 00002760 BA8803              <1> 	mov dx, 388h
  1068 00002763 50                  <1> 	push ax
  1069 00002764 88E0                <1> 	mov al, ah
  1070 00002766 EE                  <1> 	out dx, al
  1071                              <1> 
  1072 00002767 EC                  <1> 	in al, dx
  1073 00002768 EC                  <1> 	in al, dx
  1074 00002769 EC                  <1> 	in al, dx
  1075 0000276A EC                  <1> 	in al, dx
  1076 0000276B EC                  <1> 	in al, dx
  1077 0000276C EC                  <1> 	in al, dx
  1078                              <1> 	
  1079 0000276D 58                  <1> 	pop ax
  1080 0000276E 42                  <1> 	inc dx
  1081 0000276F EE                  <1> 	out dx, al
  1082                              <1> 
  1083 00002770 4A                  <1> 	dec	dx
  1084 00002771 B422                <1> 	mov	ah, 22h
  1085                              <1> 
  1086                              <1> .wait:
  1087 00002773 EC                  <1> 	in al,dx
  1088 00002774 FECC                <1> 	dec ah
  1089 00002776 75FB                <1> 	jnz .wait
  1090                              <1> 	
  1091                              <1> .no_write:
  1092 00002778 61                  <1> 	popa
  1093 00002779 C3                  <1> 	ret
  1094                              <1> 
  1095                              <1> .pcspk:
  1096 0000277A 80FCA0              <1> 	cmp ah, 0A0h
  1097 0000277D 7CF9                <1> 	jl .no_write
  1098                              <1> 
  1099 0000277F 80FCB8              <1> 	cmp ah, 0B8h
  1100 00002782 7FF4                <1> 	jg .no_write
  1101                              <1> 
  1102 00002784 80E40F              <1> 	and ah, 0Fh
  1103 00002787 0FB6DC              <1> 	movzx bx, ah
  1104                              <1> 	
  1105 0000278A 648A87A005          <1> 	mov al, [fs:ADLIB_BUFFER + 0A0h + bx]
  1106 0000278F 648AA7B005          <1> 	mov ah, [fs:ADLIB_BUFFER + 0B0h + bx]
  1107                              <1> 	
  1108 00002794 F6C420              <1> 	test ah, 20h
  1109 00002797 7439                <1> 	jz .pcspk_clear
  1110                              <1> 	
  1111 00002799 88E2                <1> 	mov dl, ah		; Get the block number
  1112 0000279B C0EA02              <1> 	shr dl, 2
  1113 0000279E 80E207              <1> 	and dl, 7
  1114                              <1> 	
  1115 000027A1 25FF03              <1> 	and ax, 3FFh	; Get the FNum
  1116                              <1> 	
  1117                              <1> 	; WARNING! Due to the 16-bit integer limit (for speed), the maximum is block = 7, FNum = 511.
  1118                              <1> 	; Quick and dirty formula: freq = (fnum << block) / 21
  1119                              <1> 
  1120 000027A4 8816[AA27]          <1> 	mov [.shift + 2], dl
  1121                              <1> 	
  1122 000027A8 C1E000              <1> 	.shift: db 0C1h, 0E0h, 0	; Shift AX left by the block number
  1123                              <1> 
  1124 000027AB 53                  <1> 	push bx
  1125                              <1> 	
  1126 000027AC 31D2                <1> 	xor dx, dx
  1127 000027AE BB1500              <1> 	mov bx, 21
  1128 000027B1 F7F3                <1> 	div bx						; Calculate the frequency
  1129                              <1> 
  1130 000027B3 5B                  <1> 	pop bx
  1131                              <1> 
  1132 000027B4 53                  <1> 	push bx						; Apply the frequency multiplier
  1133 000027B5 B700                <1> 	mov bh, 0
  1134 000027B7 8A9F[EC27]          <1> 	mov bl, [adlib_fmul_registers + bx]
  1135 000027BB 648A9F0005          <1> 	mov bl, [fs:ADLIB_BUFFER + bx]
  1136 000027C0 80E30F              <1> 	and bl, 0Fh
  1137 000027C3 8A9F[DC27]          <1> 	mov bl, [adlib_fmul_values + bx]
  1138                              <1> 	
  1139 000027C7 F7E3                <1> 	mul bx
  1140 000027C9 5B                  <1> 	pop bx
  1141                              <1> 	
  1142 000027CA D1E3                <1> 	shl bx, 1		; Words
  1143 000027CC 8987[BC28]          <1> 	mov word [pwm_freq + bx], ax
  1144                              <1> 
  1145 000027D0 61                  <1> 	popa
  1146 000027D1 C3                  <1> 	ret
  1147                              <1> 	
  1148                              <1> .pcspk_clear:
  1149 000027D2 D1E3                <1> 	shl bx, 1		; Words
  1150 000027D4 C787[BC28]0000      <1> 	mov word [pwm_freq + bx], 0
  1151                              <1> 	
  1152 000027DA 61                  <1> 	popa
  1153 000027DB C3                  <1> 	ret
  1154                              <1> 	
  1155 000027DC 01020406080A0C0E10- <1> 	adlib_fmul_values		db 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 20, 24, 24, 30, 30
  1155 000027E5 12141418181E1E      <1>
  1156 000027EC 2324252B2C2D333435  <1> 	adlib_fmul_registers	db 23h, 24h, 25h, 2Bh, 2Ch, 2Dh, 33h, 34h, 35h
  1157                              <1> 	
  1158                              <1> ; ------------------------------------------------------------------
  1159                              <1> ; os_adlib_mute -- Mute the YM3812's current state
  1160                              <1> ; IN: nothing
  1161                              <1> 
  1162                              <1> os_adlib_mute:
  1163 000027F5 60                  <1> 	pusha
  1164                              <1> 	
  1165 000027F6 803EEEDE01          <1> 	cmp byte [57070], 1
  1166 000027FB 7D15                <1> 	jge .pcspk
  1167                              <1> 	
  1168 000027FD BE[3B28]            <1> 	mov si, adlib_volume_registers
  1169 00002800 B91200              <1> 	mov cx, 18
  1170                              <1> 	
  1171                              <1> .loop:
  1172 00002803 AC                  <1> 	lodsb
  1173 00002804 88C4                <1> 	mov ah, al
  1174                              <1> 	
  1175 00002806 E83DFF              <1> 	call os_adlib_regread
  1176 00002809 0C3F                <1> 	or al, 3Fh
  1177 0000280B E843FF              <1> 	call int_adlib_regwrite
  1178                              <1> 	
  1179 0000280E E2F3                <1> 	loop .loop
  1180 00002810 61                  <1> 	popa
  1181 00002811 C3                  <1> 	ret
  1182                              <1> 
  1183                              <1> .pcspk:
  1184 00002812 C606[E028]01        <1> 	mov byte [pwm_muted], 1
  1185 00002817 61                  <1> 	popa
  1186 00002818 C3                  <1> 	ret
  1187                              <1> 	
  1188                              <1> ; ------------------------------------------------------------------
  1189                              <1> ; os_adlib_unmute -- Unmute the YM3812's current state
  1190                              <1> ; IN: nothing
  1191                              <1> 
  1192                              <1> os_adlib_unmute:
  1193 00002819 60                  <1> 	pusha
  1194                              <1> 
  1195 0000281A 803EEEDE01          <1> 	cmp byte [57070], 1
  1196 0000281F 7D13                <1> 	jge .pcspk
  1197                              <1> 	
  1198 00002821 BE[3B28]            <1> 	mov si, adlib_volume_registers
  1199 00002824 B91200              <1> 	mov cx, 18
  1200                              <1> 	
  1201                              <1> .loop:
  1202 00002827 AC                  <1> 	lodsb
  1203 00002828 88C4                <1> 	mov ah, al
  1204                              <1> 	
  1205 0000282A E819FF              <1> 	call os_adlib_regread
  1206 0000282D E821FF              <1> 	call int_adlib_regwrite
  1207                              <1> 	
  1208 00002830 E2F5                <1> 	loop .loop
  1209 00002832 61                  <1> 	popa
  1210 00002833 C3                  <1> 	ret
  1211                              <1> 	
  1212                              <1> .pcspk:
  1213 00002834 C606[E028]00        <1> 	mov byte [pwm_muted], 0
  1214 00002839 61                  <1> 	popa
  1215 0000283A C3                  <1> 	ret
  1216                              <1> 
  1217 0000283B 40414243444548494A- <1> 	adlib_volume_registers	db 40h, 41h, 42h, 43h, 44h, 45h, 48h, 49h, 4Ah, 4Bh, 4Ch, 4Dh, 50h, 51h, 52h, 53h, 54h, 55h
  1217 00002844 4B4C4D505152535455  <1>
  1218 0000284D 00                  <1> 	adlib_running			db 0
  1219                              <1> 
  1220                              <1> ; ------------------------------------------------------------------
  1221                              <1> ; PWM DRIVER
  1222                              <1> ; What is emulated: FNum, block number, carrier frequency multiplier
  1223                              <1> ; What is NOT emulated: literally everything else - amplitude, ADSR, waveforms, modulator
  1224                              <1> 
  1225                              <1> pwm_handler:
  1226 0000284E FA                  <1> 	cli
  1227 0000284F 60                  <1> 	pusha
  1228 00002850 1E                  <1> 	push ds
  1229                              <1> 	
  1230 00002851 8CC8                <1> 	mov ax, cs
  1231 00002853 8ED8                <1> 	mov ds, ax
  1232                              <1> 	
  1233 00002855 803E[E028]01        <1> 	cmp byte [pwm_muted], 1
  1234 0000285A 744D                <1> 	je .no_spk
  1235                              <1> 
  1236                              <1> 	; Send the PWM value to the PC speaker
  1237 0000285C B0B0                <1> 	mov al, 10110000b
  1238 0000285E E643                <1> 	out 0x43, al
  1239 00002860 A0[E728]            <1> 	mov al, [pwm_val]
  1240 00002863 E642                <1> 	out 0x42, al
  1241 00002865 B000                <1> 	mov al, 0
  1242 00002867 E642                <1> 	out 0x42, al
  1243                              <1> 
  1244                              <1> 	; Calculate the next value
  1245 00002869 B90900              <1> 	mov cx, 9
  1246 0000286C BE[BC28]            <1> 	mov si, pwm_freq
  1247 0000286F BF[CC28]            <1> 	mov di, pwm_cntr - 2
  1248 00002872 B300                <1> 	mov bl, 0
  1249                              <1> 	
  1250 00002874 8A16[E828]          <1> 	mov dl, [pwm_channel_amplitude]
  1251                              <1> 	
  1252 00002878 803EEEDE02          <1> 	cmp byte [57070], 2
  1253 0000287D 7513                <1> 	jne .handler_loop
  1254                              <1> 	
  1255                              <1> 	; Max volume mode, count the number of active channels
  1256 0000287F 56                  <1> 	push si
  1257 00002880 51                  <1> 	push cx
  1258                              <1> 	
  1259                              <1> 	clr bx
    11 00002881 31DB                <2>  xor %1, %1
  1260                              <1> 	
  1261                              <1> .channel_count_loop:
  1262 00002883 AD                  <1> 	lodsw
  1263                              <1> 	
  1264 00002884 83F800              <1> 	cmp ax, 0
  1265 00002887 7401                <1> 	je .channel_count_loop_no_inc
  1266                              <1> 	
  1267 00002889 43                  <1> 	inc bx
  1268                              <1> 	
  1269                              <1> .channel_count_loop_no_inc:
  1270 0000288A E2F7                <1> 	loop .channel_count_loop
  1271                              <1> 	
  1272 0000288C 59                  <1> 	pop cx
  1273 0000288D 5E                  <1> 	pop si
  1274                              <1> 	
  1275 0000288E 8A97[E928]          <1> 	mov dl, [pwm_fixed_amplitudes + bx]
  1276                              <1> 
  1277                              <1> 	; Add all of the channels together
  1278                              <1> .handler_loop:
  1279 00002892 AD                  <1> 	lodsw
  1280                              <1> 	
  1281 00002893 83F800              <1> 	cmp ax, 0
  1282 00002896 7409                <1> 	je .handler_loop_no_inc
  1283                              <1> 	
  1284 00002898 83C702              <1> 	add di, 2
  1285 0000289B 0105                <1> 	add [di], ax
  1286                              <1> 	
  1287 0000289D 7902                <1> 	jns .handler_loop_no_inc
  1288                              <1> 	
  1289 0000289F 00D3                <1> 	add	bl, dl
  1290                              <1> 
  1291                              <1> .handler_loop_no_inc:
  1292 000028A1 E2EF                <1> 	loop .handler_loop
  1293                              <1> 	
  1294 000028A3 FEC3                <1> 	inc bl
  1295 000028A5 881E[E728]          <1> 	mov [pwm_val], bl
  1296                              <1> 	
  1297                              <1> .no_spk:
  1298                              <1> 	; Have we reached the callback value?	
  1299 000028A9 FF0E[E328]          <1> 	dec word [pwm_callback_ctr]
  1300 000028AD 750A                <1> 	jnz .exit
  1301                              <1> 
  1302                              <1> 	; Yes, reset it
  1303 000028AF A1[E528]            <1> 	mov ax, [pwm_callback_ctr_def]
  1304 000028B2 A3[E328]            <1> 	mov [pwm_callback_ctr], ax
  1305                              <1> 	
  1306                              <1> 	; Call the callback
  1307 000028B5 FF16[E128]          <1> 	call [pwm_callback]
  1308                              <1> 	
  1309                              <1> .exit:
  1310 000028B9 1F                  <1> 	pop ds
  1311 000028BA 61                  <1> 	popa
  1312 000028BB CF                  <1> 	iret
  1313                              <1> 
  1314 000028BC 0000<rep 9h>        <1> 	pwm_freq				times 9 dw 0
  1315 000028CE 0000<rep 9h>        <1> 	pwm_cntr				times 9 dw 0
  1316 000028E0 00                  <1> 	pwm_muted				db 0
  1317 000028E1 0000                <1> 	pwm_callback			dw 0
  1318 000028E3 0000                <1> 	pwm_callback_ctr		dw 0
  1319 000028E5 0000                <1> 	pwm_callback_ctr_def	dw 0
  1320 000028E7 00                  <1> 	pwm_val					db 0
  1321 000028E8 00                  <1> 	pwm_channel_amplitude	db 0
  1322 000028E9 0024120C0907060504- <1> 	pwm_fixed_amplitudes	db 0, 36, 18, 12, 9, 7, 6, 5, 4, 4
  1322 000028F2 04                  <1>
  1323                              <1> 	
  1324                              <1> ; ------------------------------------------------------------------
  1325                              <1> ; os_adlib_calcfreq -- Play a frequency
  1326                              <1> ; IN: AX - frequency, CL = channel; OUT: nothing
  1327                              <1> 
  1328                              <1> os_adlib_calcfreq:
  1329 000028F3 6660                <1> 	pushad
  1330                              <1> 
  1331 000028F5 803EEEDE01          <1> 	cmp byte [57070], 1
  1332 000028FA 7D54                <1> 	jge .pcspk
  1333                              <1> 
  1334 000028FC 880E[5E29]          <1> 	mov [.channel], cl
  1335                              <1> 	
  1336 00002900 660FB7C0            <1> 	movzx eax, ax
  1337 00002904 B100                <1> 	mov cl, 0		; Block number
  1338                              <1> 	
  1339 00002906 6650                <1> 	push eax
  1340                              <1> 
  1341                              <1> .block_loop:		; f-num = freq * 2^(20 - block) / 49716
  1342 00002908 6658                <1> 	pop eax
  1343 0000290A 6650                <1> 	push eax
  1344                              <1> 	
  1345 0000290C B314                <1> 	mov bl, 20
  1346 0000290E 28CB                <1> 	sub bl, cl
  1347                              <1> 	
  1348 00002910 881E[1729]          <1> 	mov [.shift + 3], bl
  1349 00002914 66C1E000            <1> .shift: db 0x66, 0xc1, 0xe0, 0		; shl eax, XX
  1350                              <1> 
  1351                              <1> 	clr edx
    11 00002918 6631D2              <2>  xor %1, %1
  1352 0000291B 66BB34C20000        <1> 	mov ebx, 49716	; Divide by the sample rate
  1353 00002921 66F7F3              <1> 	div ebx
  1354                              <1> 
  1355 00002924 FEC1                <1> 	inc cl
  1356                              <1> 	
  1357 00002926 3D0004              <1> 	cmp ax, 1024	; Is the result too large?
  1358 00002929 7DDD                <1> 	jge .block_loop
  1359                              <1> 	
  1360 0000292B FEC9                <1> 	dec cl
  1361                              <1> 	
  1362 0000292D C0E102              <1> 	shl cl, 2		; Write the block number
  1363 00002930 00CC                <1> 	add ah, cl
  1364                              <1> 
  1365 00002932 80CC20              <1> 	or ah, 20h		; Note on
  1366                              <1> 	
  1367 00002935 50                  <1> 	push ax
  1368 00002936 B4A0                <1> 	mov ah, 0A0h
  1369 00002938 0226[5E29]          <1> 	add ah, [.channel]
  1370 0000293C E8F9FD              <1> 	call os_adlib_regwrite
  1371 0000293F 58                  <1> 	pop ax
  1372                              <1> 	
  1373 00002940 88E0                <1> 	mov al, ah
  1374 00002942 B4B0                <1> 	mov ah, 0B0h
  1375 00002944 0226[5E29]          <1> 	add ah, [.channel]
  1376 00002948 E8EDFD              <1> 	call os_adlib_regwrite
  1377                              <1> 	
  1378 0000294B 6658                <1> 	pop eax
  1379 0000294D 6661                <1> 	popad
  1380 0000294F C3                  <1> 	ret
  1381                              <1> 	
  1382                              <1> .pcspk:
  1383 00002950 0FB6D9              <1> 	movzx bx, cl
  1384 00002953 D1E3                <1> 	shl bx, 1
  1385 00002955 D1E0                <1> 	shl ax, 1
  1386 00002957 8987[BC28]          <1> 	mov [pwm_freq + bx], ax
  1387 0000295B 6661                <1> 	popad
  1388 0000295D C3                  <1> 	ret
  1389                              <1> 	
  1390 0000295E 00                  <1> 	.channel	db 0
  1391                              <1> 	
  1392                              <1> ; ------------------------------------------------------------------
  1393                              <1> ; os_adlib_noteoff -- Turns off a note
  1394                              <1> ; IN: CL = channel; OUT: nothing
  1395                              <1> 
  1396                              <1> os_adlib_noteoff:
  1397 0000295F 803EEEDE01          <1> 	cmp byte [57070], 1
  1398 00002964 7D0F                <1> 	jge .pcspk
  1399                              <1> 	
  1400 00002966 60                  <1> 	pusha
  1401                              <1> 
  1402 00002967 B4B0                <1> 	mov ah, 0B0h
  1403 00002969 00CC                <1> 	add ah, cl
  1404 0000296B E8D8FD              <1> 	call os_adlib_regread
  1405                              <1> 	
  1406 0000296E 24DF                <1> 	and al, 11011111b
  1407 00002970 E8C5FD              <1> 	call os_adlib_regwrite
  1408                              <1> 	
  1409 00002973 61                  <1> 	popa
  1410 00002974 C3                  <1> 	ret
  1411                              <1> 	
  1412                              <1> .pcspk:
  1413 00002975 60                  <1> 	pusha
  1414 00002976 0FB6D9              <1> 	movzx bx, cl
  1415 00002979 D1E3                <1> 	shl bx, 1
  1416 0000297B C787[BC28]0000      <1> 	mov word [pwm_freq + bx], 0
  1417 00002981 61                  <1> 	popa
  1418 00002982 C3                  <1> 	ret	
  1419                              <1> 	
  1420                              <1> ; ==================================================================
  1421                              <1> 
   817                                  	%INCLUDE "drivers/string.asm"
   818                              <1> ; ==================================================================
   819                              <1> ; STRING MANIPULATION ROUTINES
   820                              <1> ; ==================================================================
   821                              <1> 
   822                              <1> ; os_string_encrypt -- Encrypts a string using a totally military-grade encryption algorithm
   823                              <1> ; IN: SI = Input string/Output string
   824                              <1> 
   825                              <1> os_string_encrypt:
   826 00002983 60                  <1> 	pusha
   827 00002984 89F7                <1> 	mov di, si
   828                              <1> 
   829 00002986 89F0                <1> 	mov ax, si
   830 00002988 E82C00              <1> 	call os_string_length
   831 0000298B C0E002              <1> 	shl al, 2
   832 0000298E 347B                <1> 	xor al, 123
   833                              <1> 	
   834 00002990 B17B                <1> 	mov cl, 123
   835 00002992 00C1                <1> 	add cl, al
   836 00002994 80F1DB              <1> 	xor cl, 219
   837                              <1> 	
   838                              <1> .loop:
   839 00002997 AC                  <1> 	lodsb
   840 00002998 3C00                <1> 	cmp al, 0
   841 0000299A 740A                <1> 	je .exit
   842                              <1> 	
   843 0000299C 00C8                <1> 	add al, cl
   844 0000299E 34AA                <1> 	xor al, 10101010b
   845 000029A0 AA                  <1> 	stosb
   846                              <1> 	
   847 000029A1 80C14D              <1> 	add cl, 77
   848 000029A4 EBF1                <1> 	jmp .loop
   849                              <1> 	
   850                              <1> .exit:
   851 000029A6 61                  <1> 	popa
   852 000029A7 C3                  <1> 	ret
   853                              <1> 	
   854                              <1> ; os_string_add -- Add a string on top of another string
   855                              <1> ; IN: AX/BX = Main string/Added string
   856                              <1> 
   857                              <1> os_string_add:
   858 000029A8 60                  <1> 	pusha
   859 000029A9 50                  <1> 	push ax
   860 000029AA E80A00              <1> 	call os_string_length		; Get the length of the main string
   861 000029AD 5F                  <1> 	pop di
   862 000029AE 01C7                <1> 	add di, ax					; Add it to the pointer
   863 000029B0 89DE                <1> 	mov si, bx
   864 000029B2 E89500              <1>  	call os_string_copy			; Copy the string
   865 000029B5 61                  <1>  	popa
   866 000029B6 C3                  <1>  	ret
   867                              <1> 	
   868                              <1> ; ------------------------------------------------------------------
   869                              <1> ; os_string_length -- Return length of a string
   870                              <1> ; IN: AX = string location
   871                              <1> ; OUT AX = length (other regs preserved)
   872                              <1> 
   873                              <1> os_string_length:
   874 000029B7 60                  <1> 	pusha
   875                              <1> 
   876 000029B8 89C3                <1> 	mov bx, ax			; Move location of string to BX
   877                              <1> 
   878 000029BA 31C9                <1> 	xor cx, cx			; Counter
   879                              <1> 
   880                              <1> .more:
   881 000029BC 803F00              <1> 	cmp byte [bx], 0		; Zero (end of string) yet?
   882 000029BF 7404                <1> 	je .done
   883 000029C1 43                  <1> 	inc bx				; If not, keep adding
   884 000029C2 41                  <1> 	inc cx
   885 000029C3 EBF7                <1> 	jmp .more
   886                              <1> 
   887                              <1> 
   888                              <1> .done:
   889 000029C5 890E[CE29]          <1> 	mov word [.tmp_counter], cx	; Store count before restoring other registers
   890 000029C9 61                  <1> 	popa
   891                              <1> 
   892 000029CA A1[CE29]            <1> 	mov ax, [.tmp_counter]		; Put count back into AX before returning
   893 000029CD C3                  <1> 	ret
   894                              <1> 
   895                              <1> 
   896 000029CE 0000                <1> 	.tmp_counter	dw 0
   897                              <1> 
   898                              <1> 
   899                              <1> ; ------------------------------------------------------------------
   900                              <1> ; os_string_reverse -- Reverse the characters in a string
   901                              <1> ; IN: SI = string location
   902                              <1> 
   903                              <1> os_string_reverse:
   904 000029D0 60                  <1> 	pusha
   905                              <1> 
   906 000029D1 803C00              <1> 	cmp byte [si], 0		; Don't attempt to reverse empty string
   907 000029D4 7418                <1> 	je .end
   908                              <1> 
   909 000029D6 89F0                <1> 	mov ax, si
   910 000029D8 E8DCFF              <1> 	call os_string_length
   911                              <1> 
   912 000029DB 89F7                <1> 	mov di, si
   913 000029DD 01C7                <1> 	add di, ax
   914 000029DF 4F                  <1> 	dec di				; DI now points to last char in string
   915                              <1> 
   916                              <1> .loop:
   917 000029E0 8A04                <1> 	mov byte al, [si]		; Swap bytes
   918 000029E2 8A1D                <1> 	mov byte bl, [di]
   919                              <1> 
   920 000029E4 881C                <1> 	mov byte [si], bl
   921 000029E6 8805                <1> 	mov byte [di], al
   922                              <1> 
   923 000029E8 46                  <1> 	inc si				; Move towards string centre
   924 000029E9 4F                  <1> 	dec di
   925                              <1> 
   926 000029EA 39F7                <1> 	cmp di, si			; Both reached the centre?
   927 000029EC 77F2                <1> 	ja .loop
   928                              <1> 
   929                              <1> .end:
   930 000029EE 61                  <1> 	popa
   931 000029EF C3                  <1> 	ret
   932                              <1> 
   933                              <1> 
   934                              <1> ; ------------------------------------------------------------------
   935                              <1> ; os_find_char_in_string -- Find location of character in a string
   936                              <1> ; IN: SI = string location, AL = character to find
   937                              <1> ; OUT: AX = location in string, or 0 if char not present
   938                              <1> 
   939                              <1> os_find_char_in_string:
   940 000029F0 60                  <1> 	pusha
   941                              <1> 
   942 000029F1 B90100              <1> 	mov cx, 1			; Counter -- start at first char (we count
   943                              <1> 					; from 1 in chars here, so that we can
   944                              <1> 					; return 0 if the source char isn't found)
   945                              <1> 
   946                              <1> .more:
   947 000029F4 3804                <1> 	cmp byte [si], al
   948 000029F6 7409                <1> 	je .done
   949 000029F8 803C00              <1> 	cmp byte [si], 0
   950 000029FB 740D                <1> 	je .notfound
   951 000029FD 46                  <1> 	inc si
   952 000029FE 41                  <1> 	inc cx
   953 000029FF EBF3                <1> 	jmp .more
   954                              <1> 
   955                              <1> .done:
   956 00002A01 890E[0E2A]          <1> 	mov [.tmp], cx
   957 00002A05 61                  <1> 	popa
   958 00002A06 A1[0E2A]            <1> 	mov ax, [.tmp]
   959 00002A09 C3                  <1> 	ret
   960                              <1> 
   961                              <1> .notfound:
   962 00002A0A 61                  <1> 	popa
   963 00002A0B 31C0                <1> 	xor ax, ax
   964 00002A0D C3                  <1> 	ret
   965                              <1> 
   966                              <1> 
   967 00002A0E 0000                <1> 	.tmp	dw 0
   968                              <1> 
   969                              <1> 
   970                              <1> ; ------------------------------------------------------------------
   971                              <1> ; os_string_uppercase -- Convert zero-terminated string to upper case
   972                              <1> ; IN/OUT: AX = string location
   973                              <1> 
   974                              <1> os_string_uppercase:
   975 00002A10 60                  <1> 	pusha
   976                              <1> 
   977 00002A11 89C6                <1> 	mov si, ax			; Use SI to access string
   978                              <1> 
   979                              <1> .more:
   980 00002A13 803C00              <1> 	cmp byte [si], 0		; Zero-termination of string?
   981 00002A16 7413                <1> 	je .done			; If so, quit
   982                              <1> 
   983 00002A18 803C61              <1> 	cmp byte [si], 'a'		; In the lower case A to Z range?
   984 00002A1B 720B                <1> 	jb .noatoz
   985 00002A1D 803C7A              <1> 	cmp byte [si], 'z'
   986 00002A20 7706                <1> 	ja .noatoz
   987                              <1> 
   988 00002A22 802C20              <1> 	sub byte [si], 20h		; If so, convert input char to upper case
   989                              <1> 
   990 00002A25 46                  <1> 	inc si
   991 00002A26 EBEB                <1> 	jmp .more
   992                              <1> 
   993                              <1> .noatoz:
   994 00002A28 46                  <1> 	inc si
   995 00002A29 EBE8                <1> 	jmp .more
   996                              <1> 
   997                              <1> .done:
   998 00002A2B 61                  <1> 	popa
   999 00002A2C C3                  <1> 	ret
  1000                              <1> 
  1001                              <1> 
  1002                              <1> ; ------------------------------------------------------------------
  1003                              <1> ; os_string_lowercase -- Convert zero-terminated string to lower case
  1004                              <1> ; IN/OUT: AX = string location
  1005                              <1> 
  1006                              <1> os_string_lowercase:
  1007 00002A2D 60                  <1> 	pusha
  1008                              <1> 
  1009 00002A2E 89C6                <1> 	mov si, ax			; Use SI to access string
  1010                              <1> 
  1011                              <1> .more:
  1012 00002A30 803C00              <1> 	cmp byte [si], 0		; Zero-termination of string?
  1013 00002A33 7413                <1> 	je .done			; If so, quit
  1014                              <1> 
  1015 00002A35 803C41              <1> 	cmp byte [si], 'A'		; In the upper case A to Z range?
  1016 00002A38 720B                <1> 	jb .noatoz
  1017 00002A3A 803C5A              <1> 	cmp byte [si], 'Z'
  1018 00002A3D 7706                <1> 	ja .noatoz
  1019                              <1> 
  1020 00002A3F 800420              <1> 	add byte [si], 20h		; If so, convert input char to lower case
  1021                              <1> 
  1022 00002A42 46                  <1> 	inc si
  1023 00002A43 EBEB                <1> 	jmp .more
  1024                              <1> 
  1025                              <1> .noatoz:
  1026 00002A45 46                  <1> 	inc si
  1027 00002A46 EBE8                <1> 	jmp .more
  1028                              <1> 
  1029                              <1> .done:
  1030 00002A48 61                  <1> 	popa
  1031 00002A49 C3                  <1> 	ret
  1032                              <1> 
  1033                              <1> 
  1034                              <1> ; ------------------------------------------------------------------
  1035                              <1> ; os_string_copy -- Copy one string into another
  1036                              <1> ; IN/OUT: SI = source, DI = destination (programmer ensure sufficient room)
  1037                              <1> 
  1038                              <1> os_string_copy:
  1039 00002A4A 60                  <1> 	pusha
  1040                              <1> 
  1041                              <1> .more:
  1042 00002A4B AC                  <1> 	lodsb
  1043 00002A4C AA                  <1> 	stosb
  1044 00002A4D 3C00                <1> 	cmp byte al, 0			; If source string is empty, quit out
  1045 00002A4F 75FA                <1> 	jne .more
  1046 00002A51 61                  <1> 	popa
  1047 00002A52 C3                  <1> 	ret
  1048                              <1> 
  1049                              <1> 
  1050                              <1> ; ------------------------------------------------------------------
  1051                              <1> ; os_string_join -- Join two strings into a third string
  1052                              <1> ; IN/OUT: AX = string one, BX = string two, CX = destination string
  1053                              <1> 
  1054                              <1> os_string_join:
  1055 00002A53 60                  <1> 	pusha
  1056                              <1> 
  1057 00002A54 89C6                <1> 	mov si, ax
  1058 00002A56 89CF                <1> 	mov di, cx
  1059 00002A58 E8EFFF              <1> 	call os_string_copy
  1060                              <1> 
  1061 00002A5B E859FF              <1> 	call os_string_length		; Get length of first string
  1062                              <1> 
  1063 00002A5E 01C1                <1> 	add cx, ax			; Position at end of first string
  1064                              <1> 
  1065 00002A60 89DE                <1> 	mov si, bx			; Add second string onto it
  1066 00002A62 89CF                <1> 	mov di, cx
  1067 00002A64 E8E3FF              <1> 	call os_string_copy
  1068                              <1> 
  1069 00002A67 61                  <1> 	popa
  1070 00002A68 C3                  <1> 	ret
  1071                              <1> 
  1072                              <1> 
  1073                              <1> ; ------------------------------------------------------------------
  1074                              <1> ; os_string_chomp -- Strip leading and trailing spaces from a string
  1075                              <1> ; IN: AX = string location
  1076                              <1> 
  1077                              <1> os_string_chomp:
  1078 00002A69 60                  <1> 	pusha
  1079                              <1> 
  1080 00002A6A 89C2                <1> 	mov dx, ax			; Save string location
  1081                              <1> 
  1082 00002A6C 89C7                <1> 	mov di, ax			; Put location into DI
  1083 00002A6E 31C9                <1> 	xor cx, cx			; Space counter
  1084                              <1> 
  1085                              <1> .keepcounting:				; Get number of leading spaces into BX
  1086 00002A70 803D20              <1> 	cmp byte [di], ' '
  1087 00002A73 7504                <1> 	jne .counted
  1088 00002A75 41                  <1> 	inc cx
  1089 00002A76 47                  <1> 	inc di
  1090 00002A77 EBF7                <1> 	jmp .keepcounting
  1091                              <1> 
  1092                              <1> .counted:
  1093 00002A79 83F900              <1> 	cmp cx, 0			; No leading spaces?
  1094 00002A7C 7410                <1> 	je .finished_copy
  1095                              <1> 
  1096 00002A7E 89FE                <1> 	mov si, di			; Address of first non-space character
  1097 00002A80 89D7                <1> 	mov di, dx			; DI = original string start
  1098                              <1> 
  1099                              <1> .keep_copying:
  1100 00002A82 8A04                <1> 	mov al, [si]			; Copy SI into DI
  1101 00002A84 8805                <1> 	mov [di], al			; Including terminator
  1102 00002A86 3C00                <1> 	cmp al, 0
  1103 00002A88 7404                <1> 	je .finished_copy
  1104 00002A8A 46                  <1> 	inc si
  1105 00002A8B 47                  <1> 	inc di
  1106 00002A8C EBF4                <1> 	jmp .keep_copying
  1107                              <1> 
  1108                              <1> .finished_copy:
  1109 00002A8E 89D0                <1> 	mov ax, dx			; AX = original string start
  1110                              <1> 
  1111 00002A90 E824FF              <1> 	call os_string_length
  1112 00002A93 83F800              <1> 	cmp ax, 0			; If empty or all blank, done, return 'null'
  1113 00002A96 740F                <1> 	je .done
  1114                              <1> 
  1115 00002A98 89D6                <1> 	mov si, dx
  1116 00002A9A 01C6                <1> 	add si, ax			; Move to end of string
  1117                              <1> 
  1118                              <1> .more:
  1119 00002A9C 4E                  <1> 	dec si
  1120 00002A9D 803C20              <1> 	cmp byte [si], ' '
  1121 00002AA0 7505                <1> 	jne .done
  1122 00002AA2 C60400              <1> 	mov byte [si], 0		; Fill end spaces with 0s
  1123 00002AA5 EBF5                <1> 	jmp .more			; (First 0 will be the string terminator)
  1124                              <1> 
  1125                              <1> .done:
  1126 00002AA7 61                  <1> 	popa
  1127 00002AA8 C3                  <1> 	ret
  1128                              <1> 
  1129                              <1> 
  1130                              <1> ; ------------------------------------------------------------------
  1131                              <1> ; os_string_compare -- See if two strings match
  1132                              <1> ; IN: SI = string one, DI = string two
  1133                              <1> ; OUT: carry set if same, clear if different
  1134                              <1> 
  1135                              <1> os_string_compare:
  1136 00002AA9 60                  <1> 	pusha
  1137                              <1> 
  1138                              <1> .more:
  1139 00002AAA 8A04                <1> 	mov al, [si]			; Retrieve string contents
  1140 00002AAC 8A1D                <1> 	mov bl, [di]
  1141                              <1> 
  1142 00002AAE 38D8                <1> 	cmp al, bl			; Compare characters at current location
  1143 00002AB0 7508                <1> 	jne .not_same
  1144                              <1> 
  1145 00002AB2 3C00                <1> 	cmp al, 0			; End of first string? Must also be end of second
  1146 00002AB4 7407                <1> 	je .terminated
  1147                              <1> 
  1148 00002AB6 46                  <1> 	inc si
  1149 00002AB7 47                  <1> 	inc di
  1150 00002AB8 EBF0                <1> 	jmp .more
  1151                              <1> 
  1152                              <1> 
  1153                              <1> .not_same:				; If unequal lengths with same beginning, the byte
  1154 00002ABA 61                  <1> 	popa				; comparison fails at shortest string terminator
  1155 00002ABB F8                  <1> 	clc				; Clear carry flag
  1156 00002ABC C3                  <1> 	ret
  1157                              <1> 
  1158                              <1> 
  1159                              <1> .terminated:				; Both strings terminated at the same position
  1160 00002ABD 61                  <1> 	popa
  1161 00002ABE F9                  <1> 	stc				; Set carry flag
  1162 00002ABF C3                  <1> 	ret
  1163                              <1> 
  1164                              <1> 
  1165                              <1> ; ------------------------------------------------------------------
  1166                              <1> ; os_string_parse -- Take string (eg "run foo bar baz") and return
  1167                              <1> ; pointers to zero-terminated strings (eg AX = "run", BX = "foo" etc.)
  1168                              <1> ; IN: SI = string; OUT: AX, BX, CX, DX = individual strings
  1169                              <1> 
  1170                              <1> os_string_parse:
  1171 00002AC0 56                  <1> 	push si
  1172                              <1> 
  1173 00002AC1 89F0                <1> 	mov ax, si			; AX = start of first string
  1174                              <1> 
  1175 00002AC3 31DB                <1> 	xor bx, bx			; By default, other strings start empty
  1176 00002AC5 31C9                <1> 	xor cx, cx
  1177 00002AC7 31D2                <1> 	xor dx, dx
  1178                              <1> 
  1179 00002AC9 50                  <1> 	push ax				; Save to retrieve at end
  1180                              <1> 
  1181                              <1> .loop1:
  1182 00002ACA AC                  <1> 	lodsb				; Get a byte
  1183 00002ACB 3C00                <1> 	cmp al, 0			; End of string?
  1184 00002ACD 742B                <1> 	je .finish
  1185 00002ACF 3C20                <1> 	cmp al, ' '			; A space?
  1186 00002AD1 75F7                <1> 	jne .loop1
  1187 00002AD3 4E                  <1> 	dec si
  1188 00002AD4 C60400              <1> 	mov byte [si], 0		; If so, zero-terminate this bit of the string
  1189                              <1> 
  1190 00002AD7 46                  <1> 	inc si				; Store start of next string in BX
  1191 00002AD8 89F3                <1> 	mov bx, si
  1192                              <1> 
  1193                              <1> .loop2:					; Repeat the above for CX and DX...
  1194 00002ADA AC                  <1> 	lodsb
  1195 00002ADB 3C00                <1> 	cmp al, 0
  1196 00002ADD 741B                <1> 	je .finish
  1197 00002ADF 3C20                <1> 	cmp al, ' '
  1198 00002AE1 75F7                <1> 	jne .loop2
  1199 00002AE3 4E                  <1> 	dec si
  1200 00002AE4 C60400              <1> 	mov byte [si], 0
  1201                              <1> 
  1202 00002AE7 46                  <1> 	inc si
  1203 00002AE8 89F1                <1> 	mov cx, si
  1204                              <1> 
  1205                              <1> .loop3:
  1206 00002AEA AC                  <1> 	lodsb
  1207 00002AEB 3C00                <1> 	cmp al, 0
  1208 00002AED 740B                <1> 	je .finish
  1209 00002AEF 3C20                <1> 	cmp al, ' '
  1210 00002AF1 75F7                <1> 	jne .loop3
  1211 00002AF3 4E                  <1> 	dec si
  1212 00002AF4 C60400              <1> 	mov byte [si], 0
  1213                              <1> 
  1214 00002AF7 46                  <1> 	inc si
  1215 00002AF8 89F2                <1> 	mov dx, si
  1216                              <1> 
  1217                              <1> .finish:
  1218 00002AFA 58                  <1> 	pop ax
  1219                              <1> 
  1220 00002AFB 5E                  <1> 	pop si
  1221 00002AFC C3                  <1> 	ret
  1222                              <1> 
  1223                              <1> 
  1224                              <1> ; ------------------------------------------------------------------
  1225                              <1> ; os_string_to_int -- Convert decimal string to integer value
  1226                              <1> ; IN: SI = string location (max 5 chars, up to '65535')
  1227                              <1> ; OUT: AX = number
  1228                              <1> 
  1229                              <1> os_string_to_int:
  1230 00002AFD E88E01              <1> 	call os_string_to_32int		; This function only exists for compatibility reasons
  1231 00002B00 C3                  <1> 	ret
  1232                              <1> 
  1233                              <1> ; ------------------------------------------------------------------
  1234                              <1> ; os_string_to_hex -- Convert hexadecimal string to integer value
  1235                              <1> ; IN: SI = string location (max 8 chars, up to 'FFFFFFFF')
  1236                              <1> ; OUT: EAX = number
  1237                              <1> 
  1238                              <1> os_string_to_hex:
  1239 00002B01 6660                <1> 	pushad
  1240                              <1> 	
  1241 00002B03 89F0                <1> 	mov ax, si			; First, uppercase the string
  1242 00002B05 E808FF              <1> 	call os_string_uppercase
  1243                              <1> 
  1244 00002B08 6631C0              <1> 	xor eax, eax				; Temporary 32-bit integer
  1245                              <1> 	
  1246                              <1> .loop:
  1247 00002B0B 6650                <1> 	push eax
  1248 00002B0D AC                  <1> 	lodsb					; Load a byte from SI
  1249 00002B0E 88C1                <1> 	mov cl, al
  1250 00002B10 6658                <1> 	pop eax
  1251 00002B12 80F900              <1> 	cmp cl, 0				; Have we reached the end?
  1252 00002B15 0F842000            <1> 	je near .exit			; If we have, exit
  1253                              <1> 	
  1254 00002B19 80F939              <1> 	cmp cl, '9'
  1255 00002B1C 7E03                <1> 	jle .no_change
  1256                              <1> 	
  1257 00002B1E 80E907              <1> 	sub cl, 7
  1258                              <1> 	
  1259                              <1> .no_change:
  1260 00002B21 80E930              <1> 	sub cl, '0'				; Convert the value to decimal
  1261 00002B24 6681E1FF000000      <1> 	and ecx, 255			; Keep the low 8 bits only
  1262 00002B2B 66BB10000000        <1> 	mov ebx, 16 
  1263 00002B31 66F7E3              <1> 	mul ebx					; Multiply EAX by 16
  1264 00002B34 6601C8              <1> 	add eax, ecx			; Add the value to the integer
  1265 00002B37 EBD2                <1> 	jmp .loop				; Loop again
  1266                              <1> 	
  1267                              <1> .exit:
  1268 00002B39 66A3[442B]          <1> 	mov [.tmp_dword], eax
  1269 00002B3D 6661                <1> 	popad
  1270 00002B3F 66A1[442B]          <1> 	mov eax, [.tmp_dword]
  1271 00002B43 C3                  <1> 	ret
  1272                              <1> 	
  1273 00002B44 00000000            <1> 	.tmp_dword	dd 0
  1274                              <1> 
  1275                              <1> ; ------------------------------------------------------------------
  1276                              <1> ; os_int_to_string -- Convert unsigned integer to string
  1277                              <1> ; IN: AX = unsigned int
  1278                              <1> ; OUT: AX = string location
  1279                              <1> 
  1280                              <1> os_int_to_string:
  1281 00002B48 60                  <1> 	pusha
  1282                              <1> 
  1283 00002B49 31C9                <1> 	xor cx, cx
  1284 00002B4B BB0A00              <1> 	mov bx, 10			; Set BX 10, for division and mod
  1285 00002B4E BF[6F2B]            <1> 	mov di, .t			; Get our pointer ready
  1286                              <1> 
  1287                              <1> .push:
  1288 00002B51 31D2                <1> 	xor dx, dx
  1289 00002B53 F7F3                <1> 	div bx				; Remainder in DX, quotient in AX
  1290 00002B55 41                  <1> 	inc cx				; Increase pop loop counter
  1291 00002B56 52                  <1> 	push dx				; Push remainder, so as to reverse order when popping
  1292 00002B57 85C0                <1> 	test ax, ax			; Is quotient zero?
  1293 00002B59 75F6                <1> 	jnz .push			; If not, loop again
  1294                              <1> .pop:
  1295 00002B5B 5A                  <1> 	pop dx				; Pop off values in reverse order, and add 48 to make them digits
  1296 00002B5C 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
  1297 00002B5F 2E8815              <1> 	mov [cs:di], dl
  1298 00002B62 47                  <1> 	inc di
  1299 00002B63 49                  <1> 	dec cx
  1300 00002B64 75F5                <1> 	jnz .pop
  1301                              <1> 
  1302 00002B66 2EC60500            <1> 	mov byte [cs:di], 0		; Zero-terminate string
  1303                              <1> 
  1304 00002B6A 61                  <1> 	popa
  1305 00002B6B B8[6F2B]            <1> 	mov ax, .t			; Return location of string
  1306 00002B6E C3                  <1> 	ret
  1307                              <1> 
  1308                              <1> 
  1309 00002B6F 00<rep 7h>          <1> 	.t times 7 db 0
  1310                              <1> 
  1311                              <1> 
  1312                              <1> ; ------------------------------------------------------------------
  1313                              <1> ; os_sint_to_string -- Convert signed integer to string
  1314                              <1> ; IN: AX = signed int
  1315                              <1> ; OUT: AX = string location
  1316                              <1> 
  1317                              <1> os_sint_to_string:
  1318 00002B76 60                  <1> 	pusha
  1319                              <1> 
  1320 00002B77 31C9                <1> 	xor cx, cx
  1321 00002B79 BB0A00              <1> 	mov bx, 10			; Set BX 10, for division and mod
  1322 00002B7C BF[A92B]            <1> 	mov di, .t			; Get our pointer ready
  1323                              <1> 
  1324 00002B7F 85C0                <1> 	test ax, ax			; Find out if X > 0 or not, force a sign
  1325 00002B81 7802                <1> 	js .neg				; If negative...
  1326 00002B83 EB08                <1> 	jmp .push			; ...or if positive
  1327                              <1> .neg:
  1328 00002B85 F7D8                <1> 	neg ax				; Make AX positive
  1329 00002B87 C606[A92B]2D        <1> 	mov byte [.t], '-'		; Add a minus sign to our string
  1330 00002B8C 47                  <1> 	inc di				; Update the index
  1331                              <1> .push:
  1332 00002B8D 31D2                <1> 	xor dx, dx
  1333 00002B8F F7F3                <1> 	div bx				; Remainder in DX, quotient in AX
  1334 00002B91 41                  <1> 	inc cx				; Increase pop loop counter
  1335 00002B92 52                  <1> 	push dx				; Push remainder, so as to reverse order when popping
  1336 00002B93 85C0                <1> 	test ax, ax			; Is quotient zero?
  1337 00002B95 75F6                <1> 	jnz .push			; If not, loop again
  1338                              <1> .pop:
  1339 00002B97 5A                  <1> 	pop dx				; Pop off values in reverse order, and add 48 to make them digits
  1340 00002B98 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
  1341 00002B9B 8815                <1> 	mov [di], dl
  1342 00002B9D 47                  <1> 	inc di
  1343 00002B9E 49                  <1> 	dec cx
  1344 00002B9F 75F6                <1> 	jnz .pop
  1345                              <1> 
  1346 00002BA1 C60500              <1> 	mov byte [di], 0		; Zero-terminate string
  1347                              <1> 
  1348 00002BA4 61                  <1> 	popa
  1349 00002BA5 B8[A92B]            <1> 	mov ax, .t			; Return location of string
  1350 00002BA8 C3                  <1> 	ret
  1351                              <1> 
  1352                              <1> 
  1353 00002BA9 00<rep 7h>          <1> 	.t times 7 db 0
  1354                              <1> 
  1355                              <1> ; ------------------------------------------------------------------
  1356                              <1> ; os_get_time_string -- Get current time in a string (eg '10:25')
  1357                              <1> ; IN/OUT: BX = string location
  1358                              <1> 
  1359                              <1> os_get_time_string:
  1360 00002BB0 60                  <1> 	pusha
  1361                              <1> 	
  1362 00002BB1 89DF                <1> 	mov di, bx			; Location to place the string
  1363                              <1> 
  1364 00002BB3 B402                <1> 	mov ah, 02h			; Get the current time
  1365 00002BB5 E801EB              <1> 	call os_int_1Ah
  1366                              <1> 	
  1367 00002BB8 723B                <1> 	jc .exit
  1368                              <1> 
  1369 00002BBA 51                  <1> 	push cx	
  1370                              <1> 
  1371 00002BBB 88E8                <1> 	mov al, ch
  1372 00002BBD E843E8              <1> 	call os_bcd_to_int
  1373 00002BC0 83F80A              <1> 	cmp ax, 10
  1374 00002BC3 7D05                <1> 	jge .hour_10
  1375                              <1> 	
  1376 00002BC5 50                  <1> 	push ax
  1377 00002BC6 B030                <1> 	mov al, '0'
  1378 00002BC8 AA                  <1> 	stosb
  1379 00002BC9 58                  <1> 	pop ax
  1380                              <1> 	
  1381                              <1> .hour_10:
  1382 00002BCA E87BFF              <1> 	call os_int_to_string
  1383 00002BCD 89C6                <1> 	mov si, ax
  1384                              <1> 	
  1385                              <1> .hour_loop:	
  1386 00002BCF AC                  <1> 	lodsb
  1387 00002BD0 3C00                <1> 	cmp al, 0
  1388 00002BD2 7403                <1> 	je .hour_loop_end
  1389 00002BD4 AA                  <1> 	stosb
  1390 00002BD5 EBF8                <1> 	jmp .hour_loop
  1391                              <1> 	
  1392                              <1> .hour_loop_end:
  1393 00002BD7 B03A                <1> 	mov al, ':'			; Insert the time separator (or whatever it's called)
  1394 00002BD9 AA                  <1> 	stosb
  1395                              <1> 		
  1396 00002BDA 59                  <1> 	pop cx
  1397 00002BDB 88C8                <1> 	mov al, cl
  1398 00002BDD E823E8              <1> 	call os_bcd_to_int
  1399 00002BE0 83F80A              <1> 	cmp ax, 10
  1400 00002BE3 7D05                <1> 	jge .minute_10
  1401                              <1> 	
  1402 00002BE5 50                  <1> 	push ax
  1403 00002BE6 B030                <1> 	mov al, '0'
  1404 00002BE8 AA                  <1> 	stosb
  1405 00002BE9 58                  <1> 	pop ax
  1406                              <1> 	
  1407                              <1> .minute_10:
  1408 00002BEA E85BFF              <1> 	call os_int_to_string
  1409 00002BED 89C6                <1> 	mov si, ax
  1410                              <1> 		
  1411                              <1> .minute_loop:	
  1412 00002BEF AC                  <1> 	lodsb
  1413 00002BF0 AA                  <1> 	stosb
  1414                              <1> 	
  1415 00002BF1 3C00                <1> 	cmp al, 0
  1416 00002BF3 75FA                <1> 	jne .minute_loop
  1417                              <1> 
  1418                              <1> .exit:
  1419 00002BF5 61                  <1> 	popa
  1420 00002BF6 C3                  <1> 	ret
  1421                              <1> 
  1422                              <1> ; ------------------------------------------------------------------
  1423                              <1> ; os_get_date_string -- Get current date in a string (eg '12/31/2007')
  1424                              <1> ; IN/OUT: BX = string location
  1425                              <1> 
  1426                              <1> os_get_date_string:
  1427 00002BF7 60                  <1> 	pusha
  1428                              <1> 
  1429 00002BF8 89DF                <1> 	mov di, bx
  1430                              <1> 	
  1431 00002BFA F8                  <1> 	clc				; For buggy BIOSes
  1432 00002BFB B404                <1> 	mov ah, 4			; Get date data from BIOS in BCD format
  1433 00002BFD E8B9EA              <1> 	call os_int_1Ah
  1434 00002C00 7306                <1> 	jnc .fmt1_day
  1435                              <1> 
  1436 00002C02 F8                  <1> 	clc
  1437 00002C03 B404                <1> 	mov ah, 4			; BIOS was updating (~1 in 500 chance), so try again
  1438 00002C05 E8B1EA              <1> 	call os_int_1Ah
  1439                              <1> 
  1440                              <1> .fmt1_day:
  1441 00002C08 88D4                <1> 	mov ah, dl			; Day
  1442 00002C0A E81A00              <1> 	call .add_2digits
  1443                              <1> 
  1444 00002C0D B02F                <1> 	mov al, '/'
  1445 00002C0F AA                  <1> 	stosb				; Day-month separator
  1446                              <1> 
  1447                              <1> .fmt1_month:
  1448 00002C10 88F4                <1> 	mov ah,	dh			; Month
  1449 00002C12 E81200              <1> 	call .add_2digits
  1450                              <1> 
  1451 00002C15 B02F                <1> 	mov al, '/'
  1452 00002C17 AA                  <1> 	stosb
  1453                              <1> 
  1454                              <1> .fmt1_century:
  1455 00002C18 88EC                <1> 	mov ah,	ch			; Century
  1456 00002C1A E80A00              <1> 	call .add_2digits
  1457                              <1> 
  1458                              <1> .fmt1_year:
  1459 00002C1D 88CC                <1> 	mov ah, cl			; Year
  1460 00002C1F E80500              <1> 	call .add_2digits
  1461                              <1> 
  1462 00002C22 B000                <1> 	mov al, 0			; Terminate date string
  1463 00002C24 AA                  <1> 	stosb
  1464                              <1> 
  1465 00002C25 61                  <1> 	popa
  1466 00002C26 C3                  <1> 	ret
  1467                              <1> 
  1468                              <1> .add_2digits:
  1469 00002C27 88E0                <1> 	mov al, ah			; Convert AH to 2 ASCII digits
  1470 00002C29 C0E804              <1> 	shr al, 4
  1471 00002C2C E80800              <1> 	call .add_digit
  1472 00002C2F 88E0                <1> 	mov al, ah
  1473 00002C31 240F                <1> 	and al, 0Fh
  1474 00002C33 E80100              <1> 	call .add_digit
  1475 00002C36 C3                  <1> 	ret
  1476                              <1> 
  1477                              <1> .add_digit:
  1478 00002C37 0430                <1> 	add al, '0'			; Convert AL to ASCII
  1479 00002C39 AA                  <1> 	stosb				; Put into string buffer
  1480 00002C3A C3                  <1> 	ret
  1481                              <1> 	
  1482                              <1> 	
  1483                              <1> ; ------------------------------------------------------------------
  1484                              <1> ; os_string_tokenize -- Reads tokens separated by specified char from
  1485                              <1> ; a string. Returns pointer to next token, or 0 if none left
  1486                              <1> ; IN: AL = separator char, SI = beginning; OUT: DI = next token or 0 if none
  1487                              <1> 
  1488                              <1> os_string_tokenize:
  1489 00002C3B 56                  <1> 	push si
  1490                              <1> 
  1491                              <1> .next_char:
  1492 00002C3C 3804                <1> 	cmp byte [si], al
  1493 00002C3E 7408                <1> 	je .return_token
  1494 00002C40 803C00              <1> 	cmp byte [si], 0
  1495 00002C43 740B                <1> 	jz .no_more
  1496 00002C45 46                  <1> 	inc si
  1497 00002C46 EBF4                <1> 	jmp .next_char
  1498                              <1> 
  1499                              <1> .return_token:
  1500 00002C48 C60400              <1> 	mov byte [si], 0
  1501 00002C4B 46                  <1> 	inc si
  1502 00002C4C 89F7                <1> 	mov di, si
  1503 00002C4E 5E                  <1> 	pop si
  1504 00002C4F C3                  <1> 	ret
  1505                              <1> 
  1506                              <1> .no_more:
  1507 00002C50 31FF                <1> 	xor di, di
  1508 00002C52 5E                  <1> 	pop si
  1509 00002C53 C3                  <1> 	ret
  1510                              <1> 
  1511                              <1> ; Converts an unsigned 32-bit integer into a string.
  1512                              <1> ; IN: EAX = unsigned int
  1513                              <1> ; OUT: AX = string location
  1514                              <1> 
  1515                              <1> os_32int_to_string:
  1516 00002C54 6660                <1> 	pushad
  1517                              <1> 
  1518 00002C56 31C9                <1> 	xor cx, cx
  1519 00002C58 66BB0A000000        <1> 	mov ebx, 10			; Set BX 10, for division and mod
  1520 00002C5E BF[832C]            <1> 	mov di, .t			; Get our pointer ready
  1521                              <1> 
  1522                              <1> .push:
  1523 00002C61 6631D2              <1> 	xor edx, edx
  1524 00002C64 66F7F3              <1> 	div ebx				; Remainder in DX, quotient in AX
  1525 00002C67 41                  <1> 	inc cx				; Increase pop loop counter
  1526 00002C68 6652                <1> 	push edx			; Push remainder, so as to reverse order when popping
  1527 00002C6A 6685C0              <1> 	test eax, eax		; Is quotient zero?
  1528 00002C6D 75F2                <1> 	jnz .push			; If not, loop again
  1529                              <1> 
  1530                              <1> .pop:
  1531 00002C6F 665A                <1> 	pop edx				; Pop off values in reverse order, and add 48 to make them digits
  1532 00002C71 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
  1533 00002C74 8815                <1> 	mov [di], dl
  1534 00002C76 47                  <1> 	inc di
  1535 00002C77 49                  <1> 	dec cx
  1536 00002C78 75F5                <1> 	jnz .pop
  1537                              <1> 
  1538 00002C7A C60500              <1> 	mov byte [di], 0		; Zero-terminate string
  1539                              <1> 
  1540 00002C7D 6661                <1> 	popad
  1541 00002C7F B8[832C]            <1> 	mov ax, .t			; Return location of string
  1542 00002C82 C3                  <1> 	ret
  1543                              <1> 
  1544                              <1> 
  1545 00002C83 00<rep Bh>          <1> 	.t times 11 db 0
  1546                              <1> 
  1547                              <1> ; Converts a string into a 32-bit integer.
  1548                              <1> ; IN: SI = string location
  1549                              <1> ; OUT: EAX = unsigned integer
  1550                              <1> 
  1551                              <1> os_string_to_32int:
  1552 00002C8E 6660                <1> 	pushad
  1553 00002C90 6631C0              <1> 	xor eax, eax				; Temporary 32-bit integer
  1554                              <1> 	
  1555                              <1> .loop:
  1556 00002C93 6650                <1> 	push eax
  1557 00002C95 AC                  <1> 	lodsb					; Load a byte from SI
  1558 00002C96 88C1                <1> 	mov cl, al
  1559 00002C98 6658                <1> 	pop eax
  1560 00002C9A 80F900              <1> 	cmp cl, 0				; Have we reached the end?
  1561 00002C9D 0F841400            <1> 	je near .exit			; If we have, exit
  1562 00002CA1 80E930              <1> 	sub cl, '0'				; Convert the value to decimal
  1563 00002CA4 6681E1FF000000      <1> 	and ecx, 255			; Keep the low 8 bits only
  1564 00002CAB 66F726[C42C]        <1> 	mul dword [.divisor]	; Multiply EAX by 10
  1565 00002CB0 6601C8              <1> 	add eax, ecx			; Add the value to the integer
  1566 00002CB3 EBDE                <1> 	jmp .loop				; Loop again
  1567                              <1> 	
  1568                              <1> .exit:
  1569 00002CB5 66A3[C02C]          <1> 	mov [.tmp_dword], eax
  1570 00002CB9 6661                <1> 	popad
  1571 00002CBB 66A1[C02C]          <1> 	mov eax, [.tmp_dword]
  1572 00002CBF C3                  <1> 	ret
  1573                              <1> 	
  1574 00002CC0 00000000            <1> 	.tmp_dword	dd 0
  1575 00002CC4 0A000000            <1> 	.divisor	dd 10
  1576                              <1> 	
  1577                              <1> ; Prints a 32 bit integer in decimal.
  1578                              <1> ; IN: EAX = unsigned integer
  1579                              <1> ; OUT: nothing
  1580                              <1> 
  1581                              <1> os_print_32int:
  1582 00002CC8 6660                <1> 	pushad
  1583 00002CCA E887FF              <1> 	call os_32int_to_string
  1584 00002CCD 89C6                <1> 	mov si, ax
  1585 00002CCF E823EB              <1> 	call os_print_string
  1586 00002CD2 6661                <1> 	popad
  1587 00002CD4 C3                  <1> 	ret
  1588                              <1> 	
  1589                              <1> ; ==================================================================
  1590                              <1> 
   818                                  	%INCLUDE "drivers/basic.asm"
   819                              <1> ; ==================================================================
   820                              <1> ; BASIC CODE INTERPRETER (4.5)
   821                              <1> ; ==================================================================
   822                              <1> 
   823                              <1> ; ------------------------------------------------------------------
   824                              <1> ; Token types
   825                              <1> 
   826                              <1> %DEFINE VARIABLE 1
   827                              <1> %DEFINE STRING_VAR 2
   828                              <1> %DEFINE NUMBER 3
   829                              <1> %DEFINE STRING 4
   830                              <1> %DEFINE QUOTE 5
   831                              <1> %DEFINE CHAR 6
   832                              <1> %DEFINE UNKNOWN 7
   833                              <1> %DEFINE LABEL 8
   834                              <1> 
   835                              <1> ; ------------------------------------------------------------------
   836                              <1> ; The BASIC interpreter execution starts here -- a parameter string
   837                              <1> ; is passed in SI and copied into the first string, unless SI = 0
   838                              <1> 
   839                              <1> os_run_basic:
   840 00002CD5 C606820001          <1> 	mov byte [0082h], 1
   841                              <1> 	
   842 00002CDA 8926[EC45]          <1> 	mov word [orig_stack], sp		; Save stack pointer -- we might jump to the
   843                              <1> 						; error printing code and quit in the middle
   844                              <1> 						; some nested loops, and we want to preserve
   845                              <1> 						; the stack
   846                              <1> 
   847 00002CDE A3[F245]            <1> 	mov word [load_point], ax		; AX was passed as starting location of code
   848                              <1> 
   849 00002CE1 A3[EE45]            <1> 	mov word [prog], ax			; prog = pointer to current execution point in code
   850                              <1> 
   851 00002CE4 01C3                <1> 	add bx, ax				; We were passed the .BAS byte size in BX
   852 00002CE6 4B                  <1> 	dec bx
   853 00002CE7 4B                  <1> 	dec bx
   854 00002CE8 891E[F045]          <1> 	mov word [prog_end], bx			; Make note of program end point
   855                              <1> 
   856                              <1> 
   857 00002CEC E81D02              <1> 	call clear_ram				; Clear variables etc. from previous run
   858                              <1> 						; of a BASIC program
   859                              <1> 
   860 00002CEF 83FE00              <1> 	cmp si, 0				; Passed a parameter string?
   861 00002CF2 7406                <1> 	je mainloop
   862                              <1> 
   863 00002CF4 BF007C              <1> 	mov di, string_vars			; If so, copy it into $1
   864 00002CF7 E850FD              <1> 	call os_string_copy
   865                              <1> 
   866                              <1> 
   867                              <1> 
   868                              <1> mainloop:
   869 00002CFA E86D17              <1> 	call get_token				; Get a token from the start of the line
   870                              <1> 
   871 00002CFD 83F804              <1> 	cmp ax, STRING				; Is the type a string of characters?
   872 00002D00 7418                <1> 	je .keyword				; If so, let's see if it's a keyword to process
   873                              <1> 
   874 00002D02 83F801              <1> 	cmp ax, VARIABLE			; If it's a variable at the start of the line,
   875 00002D05 0F844702            <1> 	je near assign				; this is an assign (eg "X = Y + 5")
   876                              <1> 
   877 00002D09 83F802              <1> 	cmp ax, STRING_VAR			; Same for a string variable (eg $1)
   878 00002D0C 0F844002            <1> 	je near assign
   879                              <1> 
   880 00002D10 83F808              <1> 	cmp ax, LABEL				; Don't need to do anything here - skip
   881 00002D13 74E5                <1> 	je mainloop
   882                              <1> 
   883 00002D15 B314                <1> 	mov bl, err_syntax			; Otherwise show an error and quit
   884 00002D17 E96918              <1> 	jmp error
   885                              <1> 
   886                              <1> 
   887                              <1> .keyword:
   888 00002D1A BE007B              <1> 	mov si, token				; Start trying to match commands
   889                              <1> 
   890 00002D1D BF[FA45]            <1> 	mov di, alert_cmd
   891 00002D20 E886FD              <1> 	call os_string_compare
   892 00002D23 0F82CD04            <1> 	jc near do_alert
   893                              <1> 
   894 00002D27 BF[0046]            <1> 	mov di, askfile_cmd
   895 00002D2A E87CFD              <1> 	call os_string_compare
   896 00002D2D 0F820005            <1> 	jc near do_askfile
   897                              <1> 
   898 00002D31 BF[0846]            <1> 	mov di, break_cmd
   899 00002D34 E872FD              <1> 	call os_string_compare
   900 00002D37 0F823105            <1> 	jc near do_break
   901                              <1> 
   902 00002D3B BF[1346]            <1> 	mov di, case_cmd
   903 00002D3E E868FD              <1> 	call os_string_compare
   904 00002D41 0F825305            <1> 	jc near do_case
   905                              <1> 
   906 00002D45 BF[0E46]            <1> 	mov di, call_cmd
   907 00002D48 E85EFD              <1> 	call os_string_compare
   908 00002D4B 0F822205            <1> 	jc near do_call
   909                              <1> 
   910 00002D4F BF[1846]            <1> 	mov di, cls_cmd
   911 00002D52 E854FD              <1> 	call os_string_compare
   912 00002D55 0F829105            <1> 	jc near do_cls
   913                              <1> 
   914 00002D59 BF[1C46]            <1> 	mov di, cursor_cmd
   915 00002D5C E84AFD              <1> 	call os_string_compare
   916 00002D5F 0F829B05            <1> 	jc near do_cursor
   917                              <1> 
   918 00002D63 BF[2346]            <1> 	mov di, curschar_cmd
   919 00002D66 E840FD              <1> 	call os_string_compare
   920 00002D69 0F82C205            <1> 	jc near do_curschar
   921                              <1> 
   922 00002D6D BF[2C46]            <1> 	mov di, curscol_cmd
   923 00002D70 E836FD              <1> 	call os_string_compare
   924 00002D73 0F82E005            <1> 	jc near do_curscol
   925                              <1> 
   926 00002D77 BF[3446]            <1> 	mov di, curspos_cmd
   927 00002D7A E82CFD              <1> 	call os_string_compare
   928 00002D7D 0F82FE05            <1> 	jc near do_curspos
   929                              <1> 	
   930 00002D81 BF[3C46]            <1> 	mov di, delete_cmd
   931 00002D84 E822FD              <1> 	call os_string_compare
   932 00002D87 0F822C06            <1> 	jc near do_delete
   933                              <1> 	
   934 00002D8B BF[4346]            <1> 	mov di, do_cmd
   935 00002D8E E818FD              <1> 	call os_string_compare
   936 00002D91 0F827906            <1> 	jc near do_do
   937                              <1> 
   938 00002D95 BF[4B46]            <1> 	mov di, end_cmd
   939 00002D98 E80EFD              <1> 	call os_string_compare
   940 00002D9B 0F82B606            <1> 	jc near do_end
   941                              <1> 
   942 00002D9F BF[4646]            <1> 	mov di, else_cmd
   943 00002DA2 E804FD              <1> 	call os_string_compare
   944 00002DA5 0F828D06            <1> 	jc near do_else
   945                              <1> 
   946 00002DA9 BF[4F46]            <1> 	mov di, files_cmd
   947 00002DAC E8FAFC              <1> 	call os_string_compare
   948 00002DAF 0F82B706            <1> 	jc near do_files
   949                              <1> 
   950 00002DB3 BF[5546]            <1> 	mov di, for_cmd
   951 00002DB6 E8F0FC              <1> 	call os_string_compare
   952 00002DB9 0F821107            <1> 	jc near do_for
   953                              <1> 
   954 00002DBD BF[6446]            <1> 	mov di, getkey_cmd
   955 00002DC0 E8E6FC              <1> 	call os_string_compare
   956 00002DC3 0F82B507            <1> 	jc near do_getkey
   957                              <1> 
   958 00002DC7 BF[5946]            <1> 	mov di, gosub_cmd
   959 00002DCA E8DCFC              <1> 	call os_string_compare
   960 00002DCD 0F82F307            <1> 	jc near do_gosub
   961                              <1> 
   962 00002DD1 BF[5F46]            <1> 	mov di, goto_cmd
   963 00002DD4 E8D2FC              <1> 	call os_string_compare
   964 00002DD7 0F828608            <1> 	jc near do_goto
   965                              <1> 
   966 00002DDB BF[6B46]            <1> 	mov di, if_cmd
   967 00002DDE E8C8FC              <1> 	call os_string_compare
   968 00002DE1 0F82FC08            <1> 	jc near do_if
   969                              <1> 
   970 00002DE5 BF[6E46]            <1> 	mov di, include_cmd
   971 00002DE8 E8BEFC              <1> 	call os_string_compare
   972 00002DEB 0F82490A            <1> 	jc near do_include
   973                              <1> 
   974 00002DEF BF[7646]            <1> 	mov di, ink_cmd
   975 00002DF2 E8B4FC              <1> 	call os_string_compare
   976 00002DF5 0F826E0A            <1> 	jc near do_ink
   977                              <1> 
   978 00002DF9 BF[7A46]            <1> 	mov di, input_cmd
   979 00002DFC E8AAFC              <1> 	call os_string_compare
   980 00002DFF 0F82870A            <1> 	jc near do_input
   981                              <1> 	
   982 00002E03 BF[8046]            <1> 	mov di, len_cmd
   983 00002E06 E8A0FC              <1> 	call os_string_compare
   984 00002E09 0F82E90A            <1> 	jc near do_len
   985                              <1> 
   986 00002E0D BF[8446]            <1> 	mov di, listbox_cmd
   987 00002E10 E896FC              <1> 	call os_string_compare
   988 00002E13 0F82270B            <1> 	jc near do_listbox
   989                              <1> 
   990 00002E17 BF[8C46]            <1> 	mov di, load_cmd
   991 00002E1A E88CFC              <1> 	call os_string_compare
   992 00002E1D 0F82B60B            <1> 	jc near do_load
   993                              <1> 
   994 00002E21 BF[9146]            <1> 	mov di, loop_cmd
   995 00002E24 E882FC              <1> 	call os_string_compare
   996 00002E27 0F821E0C            <1> 	jc near do_loop
   997                              <1> 
   998 00002E2B BF[9646]            <1> 	mov di, move_cmd
   999 00002E2E E878FC              <1> 	call os_string_compare
  1000 00002E31 0F82080D            <1> 	jc near do_move
  1001                              <1> 
  1002 00002E35 BF[9B46]            <1> 	mov di, next_cmd
  1003 00002E38 E86EFC              <1> 	call os_string_compare
  1004 00002E3B 0F82410D            <1> 	jc near do_next
  1005                              <1> 
  1006 00002E3F BF[A046]            <1> 	mov di, number_cmd
  1007 00002E42 E864FC              <1> 	call os_string_compare
  1008 00002E45 0F82840D            <1> 	jc near do_number
  1009                              <1> 
  1010 00002E49 BF[A746]            <1> 	mov di, page_cmd
  1011 00002E4C E85AFC              <1> 	call os_string_compare
  1012 00002E4F 0F82E50D            <1> 	jc near do_page
  1013                              <1> 
  1014 00002E53 BF[AC46]            <1> 	mov di, pause_cmd
  1015 00002E56 E850FC              <1> 	call os_string_compare
  1016 00002E59 0F820A0E            <1> 	jc near do_pause
  1017                              <1> 
  1018 00002E5D BF[B246]            <1> 	mov di, peek_cmd
  1019 00002E60 E846FC              <1> 	call os_string_compare
  1020 00002E63 0F821E0E            <1> 	jc near do_peek
  1021                              <1> 
  1022 00002E67 BF[B746]            <1> 	mov di, peekint_cmd
  1023 00002E6A E83CFC              <1> 	call os_string_compare
  1024 00002E6D 0F82560E            <1> 	jc near do_peekint
  1025                              <1> 	
  1026 00002E71 BF[BF46]            <1> 	mov di, poke_cmd
  1027 00002E74 E832FC              <1> 	call os_string_compare
  1028 00002E77 0F82860E            <1> 	jc near do_poke
  1029                              <1> 	
  1030 00002E7B BF[C446]            <1> 	mov di, pokeint_cmd
  1031 00002E7E E828FC              <1> 	call os_string_compare
  1032 00002E81 0F82D40E            <1> 	jc near do_pokeint
  1033                              <1> 
  1034 00002E85 BF[CC46]            <1> 	mov di, port_cmd
  1035 00002E88 E81EFC              <1> 	call os_string_compare
  1036 00002E8B 0F820F0F            <1> 	jc near do_port
  1037                              <1> 
  1038 00002E8F BF[D146]            <1> 	mov di, print_cmd
  1039 00002E92 E814FC              <1> 	call os_string_compare
  1040 00002E95 0F82870F            <1> 	jc near do_print
  1041                              <1> 
  1042 00002E99 BF[D746]            <1> 	mov di, rand_cmd
  1043 00002E9C E80AFC              <1> 	call os_string_compare
  1044 00002E9F 0F82AA10            <1> 	jc near do_rand
  1045                              <1> 
  1046 00002EA3 BF[DC46]            <1> 	mov di, read_cmd
  1047 00002EA6 E800FC              <1> 	call os_string_compare
  1048 00002EA9 0F82F210            <1> 	jc near do_read
  1049                              <1> 
  1050 00002EAD BF[E146]            <1> 	mov di, rem_cmd
  1051 00002EB0 E8F6FB              <1> 	call os_string_compare
  1052 00002EB3 0F82BE11            <1> 	jc near do_rem
  1053                              <1> 
  1054 00002EB7 BF[E546]            <1> 	mov di, rename_cmd
  1055 00002EBA E8ECFB              <1> 	call os_string_compare
  1056 00002EBD 0F82C511            <1> 	jc near do_rename
  1057                              <1> 
  1058 00002EC1 BF[EC46]            <1> 	mov di, return_cmd
  1059 00002EC4 E8E2FB              <1> 	call os_string_compare
  1060 00002EC7 0F827012            <1> 	jc near do_return
  1061                              <1> 
  1062 00002ECB BF[F346]            <1> 	mov di, save_cmd
  1063 00002ECE E8D8FB              <1> 	call os_string_compare
  1064 00002ED1 0F828712            <1> 	jc near do_save
  1065                              <1> 
  1066 00002ED5 BF[F846]            <1> 	mov di, serial_cmd
  1067 00002ED8 E8CEFB              <1> 	call os_string_compare
  1068 00002EDB 0F823C13            <1> 	jc near do_serial
  1069                              <1> 
  1070 00002EDF BF[FF46]            <1> 	mov di, size_cmd
  1071 00002EE2 E8C4FB              <1> 	call os_string_compare
  1072 00002EE5 0F82D613            <1> 	jc near do_size
  1073                              <1> 
  1074 00002EE9 BF[0447]            <1> 	mov di, sound_cmd
  1075 00002EEC E8BAFB              <1> 	call os_string_compare
  1076 00002EEF 0F822114            <1> 	jc near do_sound
  1077                              <1> 	
  1078 00002EF3 BF[0A47]            <1> 	mov di, string_cmd
  1079 00002EF6 E8B0FB              <1> 	call os_string_compare
  1080 00002EF9 0F825314            <1> 	jc near do_string
  1081                              <1> 
  1082 00002EFD BF[1147]            <1> 	mov di, waitkey_cmd
  1083 00002F00 E8A6FB              <1> 	call os_string_compare
  1084 00002F03 0F82FE14            <1> 	jc near do_waitkey
  1085                              <1> 
  1086 00002F07 B301                <1> 	mov bl, err_cmd_unknown			; Command not found?
  1087 00002F09 E97716              <1> 	jmp error
  1088                              <1> 
  1089                              <1> 
  1090                              <1> ; ------------------------------------------------------------------
  1091                              <1> ; CLEAR RAM
  1092                              <1> 
  1093                              <1> clear_ram:
  1094 00002F0C 60                  <1> 	pusha
  1095 00002F0D B000                <1> 	mov al, 0
  1096                              <1> 
  1097 00002F0F BF4C7A              <1> 	mov di, variables
  1098 00002F12 B93400              <1> 	mov cx, 52
  1099 00002F15 F3AA                <1> 	rep stosb
  1100                              <1> 
  1101 00002F17 BF187A              <1> 	mov di, for_variables
  1102 00002F1A B93400              <1> 	mov cx, 52
  1103 00002F1D F3AA                <1> 	rep stosb
  1104                              <1> 
  1105 00002F1F BFE479              <1> 	mov di, for_code_points
  1106 00002F22 B93400              <1> 	mov cx, 52
  1107 00002F25 F3AA                <1> 	rep stosb
  1108                              <1> 	
  1109 00002F27 BFD079              <1> 	mov di, do_loop_store
  1110 00002F2A B90A00              <1> 	mov cx, 10
  1111 00002F2D F3AA                <1> 	rep stosb
  1112                              <1> 
  1113 00002F2F C606[6547]00        <1> 	mov byte [gosub_depth], 0
  1114 00002F34 C606[F545]00        <1> 	mov byte [loop_in], 0
  1115                              <1> 
  1116 00002F39 BFBC79              <1> 	mov di, gosub_points
  1117 00002F3C B91400              <1> 	mov cx, 20
  1118 00002F3F F3AA                <1> 	rep stosb
  1119                              <1> 
  1120 00002F41 BF007C              <1> 	mov di, string_vars
  1121 00002F44 B90004              <1> 	mov cx, 1024
  1122 00002F47 F3AA                <1> 	rep stosb
  1123                              <1> 
  1124 00002F49 C606[F745]07        <1> 	mov byte [ink_colour], 7		; White ink
  1125                              <1> 
  1126 00002F4E 61                  <1> 	popa
  1127 00002F4F C3                  <1> 	ret
  1128                              <1> 
  1129                              <1> 
  1130                              <1> ; ------------------------------------------------------------------
  1131                              <1> ; ASSIGNMENT
  1132                              <1> 
  1133                              <1> assign:
  1134 00002F50 83F801              <1> 	cmp ax, VARIABLE			; Are we starting with a number var?
  1135 00002F53 0F84A700            <1> 	je .do_num_var
  1136                              <1> 
  1137 00002F57 BF007C              <1> 	mov di, string_vars			; Otherwise it's a string var
  1138 00002F5A B88000              <1> 	mov ax, 128
  1139 00002F5D F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
  1140 00002F5F 01C7                <1> 	add di, ax
  1141                              <1> 
  1142 00002F61 57                  <1> 	push di
  1143                              <1> 
  1144 00002F62 E80515              <1> 	call get_token
  1145 00002F65 A0007B              <1> 	mov byte al, [token]
  1146 00002F68 3C3D                <1> 	cmp al, '='
  1147 00002F6A 0F857D02            <1> 	jne near .error
  1148                              <1> 
  1149 00002F6E E8F914              <1> 	call get_token				; See if second is quote
  1150 00002F71 83F805              <1> 	cmp ax, QUOTE
  1151 00002F74 7417                <1> 	je .second_is_quote
  1152                              <1> 
  1153 00002F76 83F802              <1> 	cmp ax, STRING_VAR
  1154 00002F79 0F856E02            <1> 	jne near .error
  1155                              <1> 
  1156 00002F7D BE007C              <1> 	mov si, string_vars			; Otherwise it's a string var
  1157 00002F80 B88000              <1> 	mov ax, 128
  1158 00002F83 F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
  1159 00002F85 01C6                <1> 	add si, ax
  1160                              <1> 
  1161 00002F87 5F                  <1> 	pop di
  1162 00002F88 E8BFFA              <1> 	call os_string_copy
  1163                              <1> 
  1164 00002F8B EB07                <1> 	jmp .string_check_for_more
  1165                              <1> 
  1166                              <1> 
  1167                              <1> .second_is_quote:
  1168 00002F8D BE007B              <1> 	mov si, token
  1169 00002F90 5F                  <1> 	pop di
  1170 00002F91 E8B6FA              <1> 	call os_string_copy
  1171                              <1> 
  1172                              <1> 
  1173                              <1> .string_check_for_more:
  1174 00002F94 57                  <1> 	push di
  1175 00002F95 A1[EE45]            <1> 	mov word ax, [prog]			; Save code location in case there's no delimiter
  1176 00002F98 A3[F131]            <1> 	mov word [.tmp_loc], ax
  1177                              <1> 
  1178 00002F9B E8CC14              <1> 	call get_token				; Any more to deal with in this assignment?
  1179 00002F9E A0007B              <1> 	mov byte al, [token]
  1180 00002FA1 3C2B                <1> 	cmp al, '+'
  1181 00002FA3 740A                <1> 	je .string_theres_more
  1182                              <1> 
  1183 00002FA5 A1[F131]            <1> 	mov word ax, [.tmp_loc]			; Not a delimiter, so step back before the token
  1184 00002FA8 A3[EE45]            <1> 	mov word [prog], ax			; that we just grabbed
  1185                              <1> 
  1186 00002FAB 5F                  <1> 	pop di
  1187 00002FAC E94BFD              <1> 	jmp mainloop				; And go back to the code interpreter!
  1188                              <1> 
  1189                              <1> 
  1190                              <1> .string_theres_more:
  1191 00002FAF E8B814              <1> 	call get_token
  1192 00002FB2 83F802              <1> 	cmp ax, STRING_VAR
  1193 00002FB5 740D                <1> 	je .another_string_var
  1194 00002FB7 83F805              <1> 	cmp ax, QUOTE
  1195 00002FBA 741E                <1> 	je .another_quote
  1196 00002FBC 83F801              <1> 	cmp ax, VARIABLE
  1197 00002FBF 7426                <1> 	je .add_number_var
  1198 00002FC1 E92702              <1> 	jmp .error
  1199                              <1> 
  1200                              <1> 
  1201                              <1> .another_string_var:
  1202 00002FC4 5F                  <1> 	pop di
  1203                              <1> 
  1204 00002FC5 BE007C              <1> 	mov si, string_vars
  1205 00002FC8 B88000              <1> 	mov ax, 128
  1206 00002FCB F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
  1207 00002FCD 01C6                <1> 	add si, ax
  1208                              <1> 
  1209 00002FCF 89F8                <1> 	mov ax, di
  1210 00002FD1 89F9                <1> 	mov cx, di
  1211 00002FD3 89F3                <1> 	mov bx, si
  1212 00002FD5 E87BFA              <1> 	call os_string_join
  1213                              <1> 
  1214 00002FD8 EBBA                <1> 	jmp .string_check_for_more
  1215                              <1> 
  1216                              <1> 
  1217                              <1> 
  1218                              <1> .another_quote:
  1219 00002FDA 5F                  <1> 	pop di
  1220                              <1> 
  1221 00002FDB 89F8                <1> 	mov ax, di
  1222 00002FDD 89F9                <1> 	mov cx, di
  1223 00002FDF BB007B              <1> 	mov bx, token
  1224 00002FE2 E86EFA              <1> 	call os_string_join
  1225                              <1> 
  1226 00002FE5 EBAD                <1> 	jmp .string_check_for_more
  1227                              <1> 
  1228                              <1> 
  1229                              <1> .add_number_var:
  1230 00002FE7 31C0                <1> 	xor ax, ax
  1231 00002FE9 A0007B              <1> 	mov byte al, [token]
  1232 00002FEC E85F14              <1> 	call get_var
  1233 00002FEF E856FB              <1> 	call os_int_to_string
  1234                              <1> 
  1235 00002FF2 89C3                <1> 	mov bx, ax
  1236 00002FF4 5F                  <1> 	pop di
  1237 00002FF5 89F8                <1> 	mov ax, di
  1238 00002FF7 89F9                <1> 	mov cx, di
  1239 00002FF9 E857FA              <1> 	call os_string_join
  1240                              <1> 
  1241 00002FFC EB96                <1> 	jmp .string_check_for_more
  1242                              <1> 	
  1243                              <1> 
  1244                              <1> 
  1245                              <1> 
  1246                              <1> .do_num_var:
  1247 00002FFE 31C0                <1> 	xor ax, ax
  1248 00003000 A0007B              <1> 	mov byte al, [token]
  1249 00003003 A2[F031]            <1> 	mov byte [.tmp], al
  1250                              <1> 
  1251 00003006 E86114              <1> 	call get_token
  1252 00003009 A0007B              <1> 	mov byte al, [token]
  1253 0000300C 3C3D                <1> 	cmp al, '='
  1254 0000300E 0F85D901            <1> 	jne near .error
  1255                              <1> 
  1256 00003012 E85514              <1> 	call get_token
  1257 00003015 83F803              <1> 	cmp ax, NUMBER
  1258 00003018 744D                <1> 	je .second_is_num
  1259                              <1> 
  1260 0000301A 83F801              <1> 	cmp ax, VARIABLE
  1261 0000301D 7436                <1> 	je .second_is_variable
  1262                              <1> 
  1263 0000301F 83F804              <1> 	cmp ax, STRING
  1264 00003022 0F842F01            <1> 	je near .second_is_string
  1265                              <1> 
  1266 00003026 83F807              <1> 	cmp ax, UNKNOWN
  1267 00003029 0F85BE01            <1> 	jne near .error
  1268                              <1> 
  1269 0000302D A0007B              <1> 	mov byte al, [token]			; Address of string var?
  1270 00003030 3C26                <1> 	cmp al, '&'
  1271 00003032 0F85B501            <1> 	jne near .error
  1272                              <1> 
  1273 00003036 E83114              <1> 	call get_token				; Let's see if there's a string var
  1274 00003039 83F802              <1> 	cmp ax, STRING_VAR
  1275 0000303C 0F85AB01            <1> 	jne near .error
  1276                              <1> 
  1277 00003040 BF007C              <1> 	mov di, string_vars
  1278 00003043 B88000              <1> 	mov ax, 128
  1279 00003046 F7E3                <1> 	mul bx
  1280 00003048 01C7                <1> 	add di, ax
  1281                              <1> 
  1282 0000304A 89FB                <1> 	mov bx, di
  1283                              <1> 
  1284 0000304C A0[F031]            <1> 	mov byte al, [.tmp]
  1285 0000304F E80914              <1> 	call set_var
  1286                              <1> 
  1287 00003052 E9A5FC              <1> 	jmp mainloop
  1288                              <1> 
  1289                              <1> 
  1290                              <1> .second_is_variable:
  1291 00003055 31C0                <1> 	xor ax, ax
  1292 00003057 A0007B              <1> 	mov byte al, [token]
  1293                              <1> 
  1294 0000305A E8F113              <1> 	call get_var
  1295 0000305D 89C3                <1> 	mov bx, ax
  1296 0000305F A0[F031]            <1> 	mov byte al, [.tmp]
  1297 00003062 E8F613              <1> 	call set_var
  1298                              <1> 
  1299 00003065 EB10                <1> 	jmp .check_for_more
  1300                              <1> 
  1301                              <1> 
  1302                              <1> .second_is_num:
  1303 00003067 BE007B              <1> 	mov si, token
  1304 0000306A E890FA              <1> 	call os_string_to_int
  1305                              <1> 
  1306 0000306D 89C3                <1> 	mov bx, ax				; Number to insert in variable table
  1307                              <1> 
  1308 0000306F 31C0                <1> 	xor ax, ax
  1309 00003071 A0[F031]            <1> 	mov byte al, [.tmp]
  1310                              <1> 
  1311 00003074 E8E413              <1> 	call set_var
  1312                              <1> 
  1313                              <1> 
  1314                              <1> 	; The assignment could be simply "X = 5" etc. Or it could be
  1315                              <1> 	; "X = Y + 5" -- ie more complicated. So here we check to see if
  1316                              <1> 	; there's a delimiter...
  1317                              <1> 
  1318                              <1> .check_for_more:
  1319 00003077 A1[EE45]            <1> 	mov word ax, [prog]			; Save code location in case there's no delimiter
  1320 0000307A A3[F131]            <1> 	mov word [.tmp_loc], ax
  1321                              <1> 
  1322 0000307D E8EA13              <1> 	call get_token				; Any more to deal with in this assignment?
  1323 00003080 A0007B              <1> 	mov byte al, [token]
  1324 00003083 3C2B                <1> 	cmp al, '+'
  1325 00003085 7419                <1> 	je .theres_more
  1326 00003087 3C2D                <1> 	cmp al, '-'
  1327 00003089 7415                <1> 	je .theres_more
  1328 0000308B 3C2A                <1> 	cmp al, '*'
  1329 0000308D 7411                <1> 	je .theres_more
  1330 0000308F 3C2F                <1> 	cmp al, '/'
  1331 00003091 740D                <1> 	je .theres_more
  1332 00003093 3C25                <1> 	cmp al, '%'
  1333 00003095 7409                <1> 	je .theres_more
  1334                              <1> 
  1335 00003097 A1[F131]            <1> 	mov word ax, [.tmp_loc]			; Not a delimiter, so step back before the token
  1336 0000309A A3[EE45]            <1> 	mov word [prog], ax			; that we just grabbed
  1337                              <1> 
  1338 0000309D E95AFC              <1> 	jmp mainloop				; And go back to the code interpreter!
  1339                              <1> 
  1340                              <1> 
  1341                              <1> .theres_more:
  1342 000030A0 A2[F331]            <1> 	mov byte [.delim], al
  1343                              <1> 
  1344 000030A3 E8C413              <1> 	call get_token
  1345 000030A6 83F801              <1> 	cmp ax, VARIABLE
  1346 000030A9 7459                <1> 	je .handle_variable
  1347                              <1> 
  1348 000030AB BE007B              <1> 	mov si, token
  1349 000030AE E84CFA              <1> 	call os_string_to_int
  1350 000030B1 89C3                <1> 	mov bx, ax
  1351                              <1> 
  1352 000030B3 31C0                <1> 	xor ax, ax
  1353 000030B5 A0[F031]            <1> 	mov byte al, [.tmp]
  1354                              <1> 
  1355 000030B8 E89313              <1> 	call get_var				; This also points SI at right place in variable table
  1356                              <1> 
  1357 000030BB 803E[F331]2B        <1> 	cmp byte [.delim], '+'
  1358 000030C0 7504                <1> 	jne .not_plus
  1359                              <1> 
  1360 000030C2 01D8                <1> 	add ax, bx
  1361 000030C4 EB2E                <1> 	jmp .finish
  1362                              <1> 
  1363                              <1> .not_plus:
  1364 000030C6 803E[F331]2D        <1> 	cmp byte [.delim], '-'
  1365 000030CB 7504                <1> 	jne .not_minus
  1366                              <1> 
  1367 000030CD 29D8                <1> 	sub ax, bx
  1368 000030CF EB23                <1> 	jmp .finish
  1369                              <1> 
  1370                              <1> .not_minus:
  1371 000030D1 803E[F331]2A        <1> 	cmp byte [.delim], '*'
  1372 000030D6 7504                <1> 	jne .not_times
  1373                              <1> 
  1374 000030D8 F7E3                <1> 	mul bx
  1375 000030DA EB18                <1> 	jmp .finish
  1376                              <1> 
  1377                              <1> .not_times:
  1378 000030DC 803E[F331]2F        <1> 	cmp byte [.delim], '/'
  1379 000030E1 750B                <1> 	jne .not_divide
  1380                              <1> 
  1381 000030E3 83FB00              <1> 	cmp bx, 0
  1382 000030E6 7417                <1> 	je .divide_zero
  1383                              <1> 	
  1384 000030E8 31D2                <1> 	xor dx, dx
  1385 000030EA F7F3                <1> 	div bx
  1386 000030EC EB06                <1> 	jmp .finish
  1387                              <1> 
  1388                              <1> .not_divide:
  1389 000030EE 31D2                <1> 	xor dx, dx
  1390 000030F0 F7F3                <1> 	div bx
  1391 000030F2 89D0                <1> 	mov ax, dx				; Get remainder
  1392                              <1> 
  1393                              <1> .finish:
  1394 000030F4 89C3                <1> 	mov bx, ax
  1395 000030F6 A0[F031]            <1> 	mov byte al, [.tmp]
  1396 000030F9 E85F13              <1> 	call set_var
  1397                              <1> 
  1398 000030FC E978FF              <1> 	jmp .check_for_more
  1399                              <1> 
  1400                              <1> .divide_zero:
  1401 000030FF B302                <1> 	mov bl, err_divide_by_zero
  1402 00003101 E97F14              <1> 	jmp error
  1403                              <1> 	
  1404                              <1> .handle_variable:
  1405 00003104 31C0                <1> 	xor ax, ax
  1406 00003106 A0007B              <1> 	mov byte al, [token]
  1407                              <1> 
  1408 00003109 E84213              <1> 	call get_var
  1409                              <1> 
  1410 0000310C 89C3                <1> 	mov bx, ax
  1411                              <1> 
  1412 0000310E 31C0                <1> 	xor ax, ax
  1413 00003110 A0[F031]            <1> 	mov byte al, [.tmp]
  1414                              <1> 
  1415 00003113 E83813              <1> 	call get_var
  1416                              <1> 
  1417 00003116 803E[F331]2B        <1> 	cmp byte [.delim], '+'
  1418 0000311B 7504                <1> 	jne .vnot_plus
  1419                              <1> 
  1420 0000311D 01D8                <1> 	add ax, bx
  1421 0000311F EB29                <1> 	jmp .vfinish
  1422                              <1> 
  1423                              <1> .vnot_plus:
  1424 00003121 803E[F331]2D        <1> 	cmp byte [.delim], '-'
  1425 00003126 7504                <1> 	jne .vnot_minus
  1426                              <1> 
  1427 00003128 29D8                <1> 	sub ax, bx
  1428 0000312A EB1E                <1> 	jmp .vfinish
  1429                              <1> 
  1430                              <1> .vnot_minus:
  1431 0000312C 803E[F331]2A        <1> 	cmp byte [.delim], '*'
  1432 00003131 7504                <1> 	jne .vnot_times
  1433                              <1> 
  1434 00003133 F7E3                <1> 	mul bx
  1435 00003135 EB13                <1> 	jmp .vfinish
  1436                              <1> 
  1437                              <1> .vnot_times:
  1438 00003137 803E[F331]2F        <1> 	cmp byte [.delim], '/'
  1439 0000313C 7506                <1> 	jne .vnot_divide
  1440                              <1> 
  1441 0000313E 31D2                <1> 	xor dx, dx
  1442 00003140 F7F3                <1> 	div bx
  1443 00003142 EBB0                <1> 	jmp .finish
  1444                              <1> 
  1445                              <1> .vnot_divide:
  1446 00003144 31D2                <1> 	xor dx, dx
  1447 00003146 F7F3                <1> 	div bx
  1448 00003148 89D0                <1> 	mov ax, dx				; Get remainder
  1449                              <1> 
  1450                              <1> .vfinish:
  1451 0000314A 89C3                <1> 	mov bx, ax
  1452 0000314C A0[F031]            <1> 	mov byte al, [.tmp]
  1453 0000314F E80913              <1> 	call set_var
  1454                              <1> 
  1455 00003152 E922FF              <1> 	jmp .check_for_more
  1456                              <1> 
  1457                              <1> 
  1458                              <1> .second_is_string:				; These are "X = word" functions
  1459 00003155 BF007B              <1> 	mov di, token
  1460                              <1> 	
  1461 00003158 BE[3647]            <1> 	mov si, ink_keyword
  1462 0000315B E84BF9              <1> 	call os_string_compare
  1463 0000315E 742A                <1> 	je .is_ink
  1464                              <1> 	
  1465 00003160 BE[3A47]            <1> 	mov si, progstart_keyword
  1466 00003163 E843F9              <1> 	call os_string_compare
  1467 00003166 7433                <1> 	je .is_progstart
  1468                              <1> 
  1469 00003168 BE[4447]            <1> 	mov si, ramstart_keyword
  1470 0000316B E83BF9              <1> 	call os_string_compare
  1471 0000316E 743A                <1> 	je .is_ramstart
  1472                              <1> 
  1473 00003170 BE[4D47]            <1> 	mov si, timer_keyword
  1474 00003173 E833F9              <1> 	call os_string_compare
  1475 00003176 7444                <1> 	je .is_timer
  1476                              <1> 	
  1477 00003178 BE[5347]            <1> 	mov si, variables_keyword
  1478 0000317B E82BF9              <1> 	call os_string_compare
  1479 0000317E 744E                <1> 	je .is_variables
  1480                              <1> 	
  1481 00003180 BE[5D47]            <1> 	mov si, version_keyword
  1482 00003183 E823F9              <1> 	call os_string_compare
  1483 00003186 7454                <1> 	je .is_version
  1484                              <1> 
  1485 00003188 EB61                <1> 	jmp .error
  1486                              <1> 
  1487                              <1> 
  1488                              <1> .is_ink:
  1489 0000318A 0FB606[F031]        <1> 	movzx ax, byte [.tmp]
  1490                              <1> 	
  1491 0000318F 31C0                <1> 	xor ax, ax
  1492 00003191 8A1E[F745]          <1> 	mov byte bl, [ink_colour]
  1493 00003195 E8C312              <1> 	call set_var
  1494                              <1> 	
  1495 00003198 E95FFB              <1> 	jmp mainloop
  1496                              <1> 
  1497                              <1> 
  1498                              <1> .is_progstart:
  1499 0000319B 0FB606[F031]        <1> 	movzx ax, byte [.tmp]
  1500                              <1> 
  1501 000031A0 8B1E[F245]          <1> 	mov word bx, [load_point]
  1502 000031A4 E8B412              <1> 	call set_var
  1503                              <1> 
  1504 000031A7 E950FB              <1> 	jmp mainloop
  1505                              <1> 
  1506                              <1> 
  1507                              <1> .is_ramstart:
  1508 000031AA 31C0                <1> 	xor ax, ax
  1509 000031AC A0[F031]            <1> 	mov byte al, [.tmp]
  1510                              <1> 
  1511 000031AF 8B1E[F045]          <1> 	mov word bx, [prog_end]
  1512 000031B3 43                  <1> 	inc bx
  1513 000031B4 43                  <1> 	inc bx
  1514 000031B5 43                  <1> 	inc bx
  1515 000031B6 E8A212              <1> 	call set_var
  1516                              <1> 
  1517 000031B9 E93EFB              <1> 	jmp mainloop
  1518                              <1> 
  1519                              <1> 
  1520                              <1> .is_timer:
  1521 000031BC B400                <1> 	mov ah, 0
  1522 000031BE E8F8E4              <1> 	call os_int_1Ah
  1523 000031C1 89D3                <1> 	mov bx, dx
  1524                              <1> 
  1525 000031C3 31C0                <1> 	xor ax, ax
  1526 000031C5 A0[F031]            <1> 	mov byte al, [.tmp]
  1527 000031C8 E89012              <1> 	call set_var
  1528                              <1> 
  1529 000031CB E92CFB              <1> 	jmp mainloop
  1530                              <1> 
  1531                              <1> 
  1532                              <1> .is_variables:
  1533 000031CE BB[F545]            <1> 	mov bx, vars_loc
  1534 000031D1 31C0                <1> 	xor ax, ax
  1535 000031D3 A0[F031]            <1> 	mov byte al, [.tmp]
  1536 000031D6 E88212              <1> 	call set_var
  1537                              <1> 
  1538 000031D9 E91EFB              <1> 	jmp mainloop
  1539                              <1> 
  1540                              <1> 
  1541                              <1> .is_version:
  1542 000031DC B0FF                <1> 	mov al, 255
  1543                              <1> 	
  1544 000031DE B700                <1> 	mov bh, 0
  1545 000031E0 88C3                <1> 	mov bl, al
  1546 000031E2 A0[F031]            <1> 	mov al, [.tmp]
  1547 000031E5 E87312              <1> 	call set_var
  1548                              <1> 	
  1549 000031E8 E90FFB              <1> 	jmp mainloop 
  1550                              <1> 
  1551                              <1> 
  1552                              <1> .error:
  1553 000031EB B314                <1> 	mov bl, err_syntax
  1554 000031ED E99313              <1> 	jmp error
  1555                              <1> 
  1556                              <1> 
  1557 000031F0 00                  <1> 	.tmp		db 0
  1558 000031F1 0000                <1> 	.tmp_loc	dw 0
  1559 000031F3 00                  <1> 	.delim		db 0
  1560                              <1> 
  1561                              <1> 
  1562                              <1> ; ==================================================================
  1563                              <1> ; SPECIFIC COMMAND CODE STARTS HERE
  1564                              <1> 
  1565                              <1> ; ------------------------------------------------------------------
  1566                              <1> ; ALERT
  1567                              <1> 
  1568                              <1> do_alert:
  1569 000031F4 8A3E[F845]          <1> 	mov bh, [work_page]			; Store the cursor position
  1570 000031F8 B403                <1> 	mov ah, 03h
  1571 000031FA CD10                <1> 	int 10h
  1572                              <1> 
  1573 000031FC E86B12              <1> 	call get_token
  1574                              <1> 
  1575 000031FF 83F805              <1> 	cmp ax, QUOTE
  1576 00003202 7416                <1> 	je .is_quote
  1577                              <1> 	
  1578 00003204 83F802              <1> 	cmp ax, STRING_VAR
  1579 00003207 7405                <1> 	je .is_string
  1580                              <1> 
  1581 00003209 B314                <1> 	mov bl, err_syntax
  1582 0000320B E97513              <1> 	jmp error
  1583                              <1> 
  1584                              <1> .is_string:
  1585 0000320E BE007C              <1> 	mov si, string_vars
  1586 00003211 B88000              <1> 	mov ax, 128
  1587 00003214 F7E3                <1> 	mul bx
  1588 00003216 01F0                <1> 	add ax, si
  1589 00003218 EB03                <1> 	jmp .display_message
  1590                              <1> 	
  1591                              <1> .is_quote:
  1592 0000321A B8007B              <1> 	mov ax, token				; First string for alert box
  1593                              <1> 	
  1594                              <1> .display_message:
  1595 0000321D 31DB                <1> 	xor bx, bx				; Others are blank
  1596 0000321F 31C9                <1> 	xor cx, cx
  1597 00003221 31D2                <1> 	xor dx, dx				; One-choice box
  1598 00003223 E816EE              <1> 	call os_dialog_box
  1599                              <1> 	
  1600 00003226 8A3E[F845]          <1> 	mov bh, [work_page]			; Move the cursor back
  1601 0000322A B402                <1> 	mov ah, 02h
  1602 0000322C CD10                <1> 	int 10h
  1603                              <1> 	
  1604 0000322E E9C9FA              <1> 	jmp mainloop
  1605                              <1> 
  1606                              <1> 
  1607                              <1> ;-------------------------------------------------------------------
  1608                              <1> ; ASKFILE
  1609                              <1> 
  1610                              <1> do_askfile:
  1611 00003231 8A3E[F845]          <1> 	mov bh, [work_page]			; Store the cursor position
  1612 00003235 B403                <1> 	mov ah, 03h
  1613 00003237 CD10                <1> 	int 10h
  1614                              <1> 	
  1615 00003239 E82E12              <1> 	call get_token
  1616                              <1> 	
  1617 0000323C 83F802              <1> 	cmp ax, STRING_VAR
  1618 0000323F 7524                <1> 	jne .error
  1619                              <1> 	
  1620 00003241 BE007C              <1> 	mov si, string_vars			; Get the string location
  1621 00003244 B88000              <1> 	mov ax, 128
  1622 00003247 F7E3                <1> 	mul bx
  1623 00003249 01F0                <1> 	add ax, si
  1624 0000324B A3[6A32]            <1> 	mov word [.tmp], ax
  1625                              <1> 	
  1626 0000324E E877E6              <1> 	call os_file_selector			; Present the selector
  1627                              <1> 	
  1628 00003251 8B3E[6A32]          <1> 	mov word di, [.tmp]			; Copy the string
  1629 00003255 89C6                <1> 	mov si, ax
  1630 00003257 E8F0F7              <1> 	call os_string_copy
  1631                              <1> 
  1632 0000325A 8A3E[F845]          <1> 	mov bh, [work_page]			; Move the cursor back
  1633 0000325E B402                <1> 	mov ah, 02h
  1634 00003260 CD10                <1> 	int 10h
  1635                              <1> 	
  1636 00003262 E995FA              <1> 	jmp mainloop
  1637                              <1> 	
  1638                              <1> .error:
  1639 00003265 B314                <1> 	mov bl, err_syntax
  1640 00003267 E91913              <1> 	jmp error
  1641                              <1> 
  1642                              <1> .data:
  1643 0000326A 0000                <1> 	.tmp					dw 0
  1644                              <1> 
  1645                              <1> 
  1646                              <1> ; ------------------------------------------------------------------
  1647                              <1> ; BREAK
  1648                              <1> 
  1649                              <1> do_break:
  1650 0000326C B3[D6]              <1> 	mov bl, err_break
  1651 0000326E E91213              <1> 	jmp error
  1652                              <1> 
  1653                              <1> 
  1654                              <1> ; ------------------------------------------------------------------
  1655                              <1> ; CALL
  1656                              <1> 
  1657                              <1> do_call:
  1658 00003271 E8F611              <1> 	call get_token
  1659 00003274 83F803              <1> 	cmp ax, NUMBER
  1660 00003277 740A                <1> 	je .is_number
  1661                              <1> 
  1662 00003279 31C0                <1> 	xor ax, ax
  1663 0000327B A0007B              <1> 	mov byte al, [token]
  1664 0000327E E8CD11              <1> 	call get_var
  1665 00003281 EB06                <1> 	jmp .execute_call
  1666                              <1> 
  1667                              <1> .is_number:
  1668 00003283 BE007B              <1> 	mov si, token
  1669 00003286 E874F8              <1> 	call os_string_to_int
  1670                              <1> 
  1671                              <1> .execute_call:
  1672 00003289 31DB                <1> 	xor bx, bx
  1673 0000328B 31C9                <1> 	xor cx, cx
  1674 0000328D 31D2                <1> 	xor dx, dx
  1675 0000328F 31FF                <1> 	xor di, di
  1676 00003291 31F6                <1> 	xor si, si
  1677                              <1> 
  1678 00003293 FFD0                <1> 	call ax
  1679                              <1> 
  1680 00003295 E962FA              <1> 	jmp mainloop
  1681                              <1> 
  1682                              <1> 
  1683                              <1> ; ------------------------------------------------------------------
  1684                              <1> ; CASE
  1685                              <1> 
  1686                              <1> do_case:
  1687 00003298 E8CF11              <1> 	call get_token
  1688 0000329B 83F804              <1> 	cmp ax, STRING
  1689 0000329E 7545                <1> 	jne .error
  1690                              <1> 	
  1691 000032A0 BE007B              <1> 	mov si, token
  1692                              <1> 
  1693 000032A3 BF[3047]            <1> 	mov di, upper_keyword
  1694 000032A6 E800F8              <1> 	call os_string_compare
  1695 000032A9 720A                <1> 	jc .uppercase
  1696                              <1> 	
  1697 000032AB BF[2A47]            <1> 	mov di, lower_keyword
  1698 000032AE E8F8F7              <1> 	call os_string_compare
  1699 000032B1 721A                <1> 	jc .lowercase
  1700                              <1> 	
  1701 000032B3 EB30                <1> 	jmp .error
  1702                              <1> 	
  1703                              <1> .uppercase:
  1704 000032B5 E8B211              <1> 	call get_token
  1705 000032B8 83F802              <1> 	cmp ax, STRING_VAR
  1706 000032BB 7528                <1> 	jne .error
  1707                              <1> 	
  1708 000032BD BE007C              <1> 	mov si, string_vars
  1709 000032C0 B88000              <1> 	mov ax, 128
  1710 000032C3 F7E3                <1> 	mul bx
  1711 000032C5 01F0                <1> 	add ax, si
  1712                              <1> 	
  1713 000032C7 E846F7              <1> 	call os_string_uppercase
  1714                              <1> 	
  1715 000032CA E92DFA              <1> 	jmp mainloop
  1716                              <1> 	
  1717                              <1> .lowercase:
  1718 000032CD E89A11              <1> 	call get_token
  1719 000032D0 83F802              <1> 	cmp ax, STRING_VAR
  1720 000032D3 7510                <1> 	jne .error
  1721                              <1> 	
  1722 000032D5 BE007C              <1> 	mov si, string_vars
  1723 000032D8 B88000              <1> 	mov ax, 128
  1724 000032DB F7E3                <1> 	mul bx
  1725 000032DD 01F0                <1> 	add ax, si
  1726                              <1> 	
  1727 000032DF E84BF7              <1> 	call os_string_lowercase
  1728                              <1> 	
  1729 000032E2 E915FA              <1> 	jmp mainloop
  1730                              <1> 	
  1731                              <1> .error:
  1732 000032E5 B314                <1> 	mov bl, err_syntax
  1733 000032E7 E99912              <1> 	jmp error
  1734                              <1> 
  1735                              <1> 
  1736                              <1> ; ------------------------------------------------------------------
  1737                              <1> ; CLS
  1738                              <1> 
  1739                              <1> do_cls:
  1740 000032EA B405                <1> 	mov ah, 5
  1741 000032EC A0[F845]            <1> 	mov byte al, [work_page]
  1742 000032EF CD10                <1> 	int 10h
  1743                              <1> 
  1744 000032F1 E85CE5              <1> 	call os_clear_screen
  1745                              <1> 
  1746 000032F4 B405                <1> 	mov ah, 5
  1747 000032F6 A0[F945]            <1> 	mov byte al, [disp_page]
  1748 000032F9 CD10                <1> 	int 10h
  1749                              <1> 
  1750 000032FB E9FCF9              <1> 	jmp mainloop
  1751                              <1> 
  1752                              <1> 
  1753                              <1> 
  1754                              <1> ; ------------------------------------------------------------------
  1755                              <1> ; CURSOR
  1756                              <1> 
  1757                              <1> do_cursor:
  1758 000032FE E86911              <1> 	call get_token
  1759                              <1> 
  1760 00003301 BE007B              <1> 	mov si, token
  1761 00003304 BF[2833]            <1> 	mov di, .on_str
  1762 00003307 E89FF7              <1> 	call os_string_compare
  1763 0000330A 7210                <1> 	jc .turn_on
  1764                              <1> 
  1765 0000330C BE007B              <1> 	mov si, token
  1766 0000330F BF[2B33]            <1> 	mov di, .off_str
  1767 00003312 E894F7              <1> 	call os_string_compare
  1768 00003315 720B                <1> 	jc .turn_off
  1769                              <1> 
  1770 00003317 B314                <1> 	mov bl, err_syntax
  1771 00003319 E96712              <1> 	jmp error
  1772                              <1> 
  1773                              <1> .turn_on:
  1774 0000331C E87CE5              <1> 	call os_show_cursor
  1775 0000331F E9D8F9              <1> 	jmp mainloop
  1776                              <1> 
  1777                              <1> .turn_off:
  1778 00003322 E881E5              <1> 	call os_hide_cursor
  1779 00003325 E9D2F9              <1> 	jmp mainloop
  1780                              <1> 
  1781                              <1> 
  1782 00003328 4F4E00              <1> 	.on_str db "ON", 0
  1783 0000332B 4F464600            <1> 	.off_str db "OFF", 0
  1784                              <1> 
  1785                              <1> 
  1786                              <1> ; ------------------------------------------------------------------
  1787                              <1> ; CURSCHAR
  1788                              <1> 
  1789                              <1> do_curschar:
  1790 0000332F E83811              <1> 	call get_token
  1791                              <1> 
  1792 00003332 83F801              <1> 	cmp ax, VARIABLE
  1793 00003335 7405                <1> 	je .is_variable
  1794                              <1> 
  1795 00003337 B314                <1> 	mov bl, err_syntax
  1796 00003339 E94712              <1> 	jmp error
  1797                              <1> 
  1798                              <1> .is_variable:
  1799 0000333C 31C0                <1> 	xor ax, ax
  1800 0000333E A0007B              <1> 	mov byte al, [token]
  1801                              <1> 
  1802 00003341 50                  <1> 	push ax				; Store variable we're going to use
  1803                              <1> 
  1804 00003342 B408                <1> 	mov ah, 08h
  1805 00003344 31DB                <1> 	xor bx, bx
  1806 00003346 8A3E[F845]          <1> 	mov byte bh, [work_page]
  1807 0000334A CD10                <1> 	int 10h				; Get char at current cursor location
  1808                              <1> 
  1809 0000334C 31DB                <1> 	xor bx, bx			; We only want the lower byte (the char, not attribute)
  1810 0000334E 88C3                <1> 	mov bl, al
  1811                              <1> 
  1812 00003350 58                  <1> 	pop ax				; Get the variable back
  1813                              <1> 
  1814 00003351 E80711              <1> 	call set_var			; And store the value
  1815                              <1> 
  1816 00003354 E9A3F9              <1> 	jmp mainloop
  1817                              <1> 
  1818                              <1> 
  1819                              <1> ; ------------------------------------------------------------------
  1820                              <1> ; CURSCOL
  1821                              <1> 
  1822                              <1> do_curscol:
  1823 00003357 E81011              <1> 	call get_token
  1824                              <1> 
  1825 0000335A 83F801              <1> 	cmp ax, VARIABLE
  1826 0000335D 751B                <1> 	jne .error
  1827                              <1> 
  1828 0000335F B400                <1> 	mov ah, 0
  1829 00003361 A0007B              <1> 	mov byte al, [token]
  1830 00003364 50                  <1> 	push ax
  1831                              <1> 
  1832 00003365 B408                <1> 	mov ah, 8
  1833 00003367 31DB                <1> 	xor bx, bx
  1834 00003369 8A3E[F845]          <1> 	mov byte bh, [work_page]
  1835 0000336D CD10                <1> 	int 10h
  1836 0000336F B700                <1> 	mov bh, 0
  1837 00003371 88E3                <1> 	mov bl, ah			; Get colour for higher byte; ignore lower byte (char)
  1838                              <1> 
  1839 00003373 58                  <1> 	pop ax
  1840 00003374 E8E410              <1> 	call set_var
  1841                              <1> 
  1842 00003377 E980F9              <1> 	jmp mainloop
  1843                              <1> 
  1844                              <1> .error:
  1845 0000337A B314                <1> 	mov bl, err_syntax
  1846 0000337C E90412              <1> 	jmp error
  1847                              <1> 
  1848                              <1> 
  1849                              <1> ; ------------------------------------------------------------------
  1850                              <1> ; CURSPOS
  1851                              <1> 
  1852                              <1> do_curspos:
  1853 0000337F 8A3E[F845]          <1> 	mov byte bh, [work_page]
  1854 00003383 B403                <1> 	mov ah, 3
  1855 00003385 CD10                <1> 	int 10h
  1856                              <1> 
  1857 00003387 E8E010              <1> 	call get_token
  1858 0000338A 83F801              <1> 	cmp ax, VARIABLE
  1859 0000338D 7523                <1> 	jne .error
  1860                              <1> 
  1861 0000338F 0FB606007B          <1> 	movzx ax, byte [token]
  1862 00003394 31DB                <1> 	xor bx, bx
  1863 00003396 88D3                <1> 	mov bl, dl
  1864 00003398 E8C010              <1> 	call set_var
  1865                              <1> 
  1866 0000339B E8CC10              <1> 	call get_token
  1867 0000339E 83F801              <1> 	cmp ax, VARIABLE
  1868 000033A1 750F                <1> 	jne .error
  1869                              <1> 
  1870 000033A3 0FB606007B          <1> 	movzx ax, byte [token]
  1871 000033A8 31DB                <1> 	xor bx, bx
  1872 000033AA 88F3                <1> 	mov bl, dh
  1873 000033AC E8AC10              <1> 	call set_var
  1874                              <1> 
  1875 000033AF E948F9              <1> 	jmp mainloop
  1876                              <1> 
  1877                              <1> .error:
  1878 000033B2 B314                <1> 	mov bl, err_syntax
  1879 000033B4 E9CC11              <1> 	jmp error
  1880                              <1> 
  1881                              <1> 
  1882                              <1> ; ------------------------------------------------------------------
  1883                              <1> ; DELETE
  1884                              <1> 
  1885                              <1> do_delete:
  1886 000033B7 E8B010              <1> 	call get_token
  1887 000033BA 83F805              <1> 	cmp ax, QUOTE
  1888 000033BD 7413                <1> 	je .is_quote
  1889                              <1> 
  1890 000033BF 83F802              <1> 	cmp ax, STRING_VAR
  1891 000033C2 0F854300            <1> 	jne near .error
  1892                              <1> 
  1893 000033C6 BE007C              <1> 	mov si, string_vars
  1894 000033C9 B88000              <1> 	mov ax, 128
  1895 000033CC F7E3                <1> 	mul bx
  1896 000033CE 01C6                <1> 	add si, ax
  1897 000033D0 EB03                <1> 	jmp .get_filename
  1898                              <1> 
  1899                              <1> .is_quote:
  1900 000033D2 BE007B              <1> 	mov si, token
  1901                              <1> 
  1902                              <1> .get_filename:
  1903 000033D5 89F0                <1> 	mov ax, si
  1904 000033D7 E8F7DA              <1> 	call os_file_exists
  1905 000033DA 7207                <1> 	jc .no_file
  1906                              <1> 
  1907 000033DC E8F1DB              <1> 	call os_remove_file
  1908 000033DF 721B                <1> 	jc .del_fail
  1909                              <1> 
  1910 000033E1 EB0D                <1> 	jmp .returngood
  1911                              <1> 
  1912                              <1> .no_file:
  1913 000033E3 31C0                <1> 	xor ax, ax
  1914 000033E5 B052                <1> 	mov byte al, 'R'
  1915 000033E7 BB0200              <1> 	mov bx, 2
  1916 000033EA E86E10              <1> 	call set_var
  1917 000033ED E90AF9              <1> 	jmp mainloop
  1918                              <1> 
  1919                              <1> .returngood:
  1920 000033F0 31C0                <1> 	xor ax, ax
  1921 000033F2 B052                <1> 	mov byte al, 'R'
  1922 000033F4 31DB                <1> 	xor bx, bx
  1923 000033F6 E86210              <1> 	call set_var
  1924 000033F9 E9FEF8              <1> 	jmp mainloop
  1925                              <1> 
  1926                              <1> .del_fail:
  1927 000033FC 31C0                <1> 	xor ax, ax
  1928 000033FE B052                <1> 	mov byte al, 'R'
  1929 00003400 BB0100              <1> 	mov bx, 1
  1930 00003403 E85510              <1> 	call set_var
  1931 00003406 E9F1F8              <1> 	jmp mainloop
  1932                              <1> 
  1933                              <1> .error:
  1934 00003409 B314                <1> 	mov bl, err_syntax
  1935 0000340B E97511              <1> 	jmp error
  1936                              <1> 	
  1937                              <1> 
  1938                              <1> ; ------------------------------------------------------------------
  1939                              <1> ; DO
  1940                              <1> 
  1941                              <1> do_do:
  1942 0000340E 803E[F545]14        <1> 	cmp byte [loop_in], 20
  1943 00003413 741C                <1> 	je .loop_max
  1944 00003415 BFD079              <1> 	mov word di, do_loop_store
  1945 00003418 A0[F545]            <1> 	mov byte al, [loop_in]
  1946 0000341B B400                <1> 	mov ah, 0
  1947 0000341D 01C7                <1> 	add di, ax
  1948 0000341F A1[EE45]            <1> 	mov word ax, [prog]
  1949 00003422 83E803              <1> 	sub ax, 3
  1950 00003425 AB                  <1> 	stosw
  1951 00003426 FE06[F545]          <1> 	inc byte [loop_in]
  1952 0000342A FE06[F545]          <1> 	inc byte [loop_in]
  1953 0000342E E9C9F8              <1> 	jmp mainloop
  1954                              <1> 
  1955                              <1> .loop_max:
  1956 00003431 B303                <1> 	mov bl, err_doloop_maximum
  1957 00003433 E94D11              <1> 	jmp error
  1958                              <1> 
  1959                              <1> 	
  1960                              <1> ;-------------------------------------------------------------------
  1961                              <1> ; ELSE
  1962                              <1> 
  1963                              <1> do_else:
  1964 00003436 803E[F645]01        <1> 	cmp byte [last_if_true], 1
  1965 0000343B 7407                <1> 	je .last_true
  1966                              <1> 	
  1967 0000343D FF06[EE45]          <1> 	inc word [prog]
  1968 00003441 E9B6F8              <1> 	jmp mainloop
  1969                              <1> 	
  1970                              <1> .last_true:
  1971 00003444 8B36[EE45]          <1> 	mov word si, [prog]
  1972                              <1> 	
  1973                              <1> .next_line:
  1974 00003448 AC                  <1> 	lodsb
  1975 00003449 3C0A                <1> 	cmp al, 10
  1976 0000344B 75FB                <1> 	jne .next_line
  1977                              <1> 	
  1978 0000344D 4E                  <1> 	dec si
  1979 0000344E 8936[EE45]          <1> 	mov word [prog], si
  1980                              <1> 	
  1981 00003452 E9A5F8              <1> 	jmp mainloop
  1982                              <1> 
  1983                              <1> 
  1984                              <1> ; ------------------------------------------------------------------
  1985                              <1> ; END
  1986                              <1> 
  1987                              <1> do_end:
  1988 00003455 B405                <1> 	mov ah, 5				; Restore active page
  1989 00003457 B000                <1> 	mov al, 0
  1990 00003459 CD10                <1> 	int 10h
  1991                              <1> 
  1992 0000345B C606[F845]00        <1> 	mov byte [work_page], 0
  1993 00003460 C606[F945]00        <1> 	mov byte [disp_page], 0
  1994                              <1> 
  1995 00003465 8B26[EC45]          <1> 	mov word sp, [orig_stack]
  1996 00003469 C3                  <1> 	ret
  1997                              <1> 
  1998                              <1> 
  1999                              <1> ; ------------------------------------------------------------------
  2000                              <1> ; FILES
  2001                              <1> 
  2002                              <1> do_files:
  2003 0000346A B800FA              <1> 	mov ax, .filelist			; get a copy of the filelist
  2004 0000346D E8F0D5              <1> 	call os_get_file_list
  2005                              <1> 	
  2006 00003470 89C6                <1> 	mov si, ax
  2007                              <1> 
  2008 00003472 E8FAE3              <1> 	call os_get_cursor_pos			; move cursor to start of line
  2009 00003475 B200                <1> 	mov dl, 0
  2010 00003477 E8ECE3              <1> 	call os_move_cursor
  2011                              <1> 	
  2012 0000347A B409                <1> 	mov ah, 9				; print character function
  2013 0000347C 8A3E[F845]          <1> 	mov bh, [work_page]			; define parameters (page, colour, times)
  2014 00003480 8A1E[F745]          <1> 	mov bl, [ink_colour]
  2015 00003484 B90100              <1> 	mov cx, 1
  2016                              <1> .file_list_loop:
  2017 00003487 AC                  <1> 	lodsb					; get a byte from the list
  2018 00003488 3C2C                <1> 	cmp al, ','				; a comma means the next file, so create a new line for it
  2019 0000348A 7410                <1> 	je .nextfile
  2020                              <1> 	
  2021 0000348C 3C00                <1> 	cmp al, 0				; the list is null terminated
  2022 0000348E 7438                <1> 	je .end_of_list
  2023                              <1> 	
  2024 00003490 CD10                <1> 	int 10h					; okay, it's not a comma or a null so print it
  2025                              <1> 
  2026 00003492 E8DAE3              <1> 	call os_get_cursor_pos			; find the location of the cursor
  2027 00003495 FEC2                <1> 	inc dl					; move the cursor forward
  2028 00003497 E8CCE3              <1> 	call os_move_cursor
  2029                              <1> 
  2030 0000349A EBEB                <1> 	jmp .file_list_loop			; keep going until the list is finished
  2031                              <1> 	
  2032                              <1> .nextfile:
  2033 0000349C E8D0E3              <1> 	call os_get_cursor_pos			; if the column is over 60 we need a new line
  2034 0000349F 80FA3C              <1> 	cmp dl, 60
  2035 000034A2 7D1F                <1> 	jge .newline
  2036                              <1> 
  2037                              <1> .next_column:					; print spaces until the next column
  2038 000034A4 B020                <1> 	mov al, ' '
  2039 000034A6 CD10                <1> 	int 10h
  2040                              <1> 	
  2041 000034A8 FEC2                <1> 	inc dl
  2042 000034AA E8B9E3              <1> 	call os_move_cursor
  2043                              <1> 	
  2044 000034AD 80FA0F              <1> 	cmp dl, 15
  2045 000034B0 74D5                <1> 	je .file_list_loop
  2046                              <1> 	
  2047 000034B2 80FA1E              <1> 	cmp dl, 30
  2048 000034B5 74D0                <1> 	je .file_list_loop
  2049                              <1> 	
  2050 000034B7 80FA2D              <1> 	cmp dl, 45
  2051 000034BA 74CB                <1> 	je .file_list_loop
  2052                              <1> 	
  2053 000034BC 80FA3C              <1> 	cmp dl, 60
  2054 000034BF 74C6                <1> 	je .file_list_loop
  2055                              <1> 	
  2056 000034C1 EBE1                <1> 	jmp .next_column
  2057                              <1> 	
  2058                              <1> .newline:
  2059 000034C3 E87CEA              <1> 	call os_print_newline			; create a new line
  2060 000034C6 EBBF                <1> 	jmp .file_list_loop
  2061                              <1> 	
  2062                              <1> .end_of_list:
  2063 000034C8 E877EA              <1> 	call os_print_newline
  2064 000034CB E92CF8              <1> 	jmp mainloop				; preform next command
  2065                              <1> 	
  2066                              <1> .data:
  2067                              <1> 	.filelist		equ 64000
  2068                              <1> 	
  2069                              <1> 
  2070                              <1> 
  2071                              <1> ; ------------------------------------------------------------------
  2072                              <1> ; FOR
  2073                              <1> 
  2074                              <1> do_for:
  2075 000034CE E8990F              <1> 	call get_token				; Get the variable we're using in this loop
  2076                              <1> 
  2077 000034D1 83F801              <1> 	cmp ax, VARIABLE
  2078 000034D4 0F859B00            <1> 	jne near .error
  2079                              <1> 
  2080 000034D8 0FB606007B          <1> 	movzx ax, byte [token]
  2081 000034DD A2[7835]            <1> 	mov byte [.tmp_var], al			; Store it in a temporary location for now
  2082                              <1> 
  2083 000034E0 E8870F              <1> 	call get_token
  2084                              <1> 
  2085 000034E3 0FB606007B          <1> 	movzx ax, byte [token]
  2086 000034E8 3C3D                <1> 	cmp al, '='
  2087 000034EA 0F858500            <1> 	jne .error
  2088                              <1> 
  2089 000034EE E8790F              <1> 	call get_token				; Next we want a number
  2090                              <1> 
  2091 000034F1 83F801              <1> 	cmp ax, VARIABLE
  2092 000034F4 740D                <1> 	je .first_is_var
  2093                              <1> 
  2094 000034F6 83F803              <1> 	cmp ax, NUMBER
  2095 000034F9 7578                <1> 	jne .error
  2096                              <1> 
  2097 000034FB BE007B              <1> 	mov si, token				; Convert it
  2098 000034FE E8FCF5              <1> 	call os_string_to_int
  2099 00003501 EB08                <1> 	jmp .continue
  2100                              <1> 
  2101                              <1> .first_is_var:
  2102 00003503 0FB606007B          <1> 	movzx ax, byte [token]
  2103 00003508 E8430F              <1> 	call get_var
  2104                              <1> 	
  2105                              <1> 	; At this stage, we've read something like "FOR X = 1"
  2106                              <1> 	; so let's store that 1 in the variable table
  2107                              <1> 
  2108                              <1> .continue:
  2109 0000350B 89C3                <1> 	mov bx, ax
  2110 0000350D 0FB606[7835]        <1> 	movzx ax, byte [.tmp_var]
  2111 00003512 E8460F              <1> 	call set_var
  2112                              <1> 
  2113                              <1> 
  2114 00003515 E8520F              <1> 	call get_token				; Next we're looking for "TO"
  2115                              <1> 
  2116 00003518 83F804              <1> 	cmp ax, STRING
  2117 0000351B 7556                <1> 	jne .error
  2118                              <1> 
  2119 0000351D B8007B              <1> 	mov ax, token
  2120 00003520 E8EDF4              <1> 	call os_string_uppercase
  2121                              <1> 
  2122 00003523 BE007B              <1> 	mov si, token
  2123 00003526 BF[7935]            <1> 	mov di, .to_string
  2124 00003529 E87DF5              <1> 	call os_string_compare
  2125 0000352C 7345                <1> 	jnc .error
  2126                              <1> 
  2127                              <1> 
  2128                              <1> 	; So now we're at "FOR X = 1 TO"
  2129                              <1> 
  2130 0000352E E8390F              <1> 	call get_token
  2131                              <1> 
  2132 00003531 83F801              <1> 	cmp ax, VARIABLE
  2133 00003534 740D                <1> 	je .second_is_var
  2134                              <1> 
  2135 00003536 83F803              <1> 	cmp ax, NUMBER
  2136 00003539 7538                <1> 	jne .error
  2137                              <1> 
  2138                              <1> .second_is_number:
  2139 0000353B BE007B              <1> 	mov si, token					; Get target number
  2140 0000353E E8BCF5              <1> 	call os_string_to_int
  2141 00003541 EB08                <1> 	jmp .continue2
  2142                              <1> 
  2143                              <1> .second_is_var:
  2144 00003543 0FB606007B          <1> 	movzx ax, byte [token]
  2145 00003548 E8030F              <1> 	call get_var
  2146                              <1> 
  2147                              <1> .continue2:
  2148 0000354B 89C3                <1> 	mov bx, ax
  2149                              <1> 
  2150 0000354D 0FB606[7835]        <1> 	movzx ax, byte [.tmp_var]
  2151                              <1> 
  2152 00003552 2C41                <1> 	sub al, 65					; Store target number in table
  2153 00003554 BF187A              <1> 	mov di, for_variables
  2154 00003557 01C7                <1> 	add di, ax
  2155 00003559 01C7                <1> 	add di, ax
  2156 0000355B 89D8                <1> 	mov ax, bx
  2157 0000355D AB                  <1> 	stosw
  2158                              <1> 
  2159                              <1> 
  2160                              <1> 	; So we've got the variable, assigned it the starting number, and put into
  2161                              <1> 	; our table the limit it should reach. But we also need to store the point in
  2162                              <1> 	; code after the FOR line we should return to if NEXT X doesn't complete the loop...
  2163                              <1> 
  2164 0000355E 0FB606[7835]        <1> 	movzx ax, byte [.tmp_var]
  2165                              <1> 
  2166 00003563 2C41                <1> 	sub al, 65					; Store code position to return to in table
  2167 00003565 BFE479              <1> 	mov di, for_code_points
  2168 00003568 01C7                <1> 	add di, ax
  2169 0000356A 01C7                <1> 	add di, ax
  2170 0000356C A1[EE45]            <1> 	mov word ax, [prog]
  2171 0000356F AB                  <1> 	stosw
  2172                              <1> 
  2173 00003570 E987F7              <1> 	jmp mainloop
  2174                              <1> 
  2175                              <1> 
  2176                              <1> .error:
  2177 00003573 B314                <1> 	mov bl, err_syntax
  2178 00003575 E90B10              <1> 	jmp error
  2179                              <1> 
  2180                              <1> 
  2181 00003578 00                  <1> 	.tmp_var	db 0
  2182 00003579 544F00              <1> 	.to_string	db 'TO', 0
  2183                              <1> 
  2184                              <1> 
  2185                              <1> ; ------------------------------------------------------------------
  2186                              <1> ; GETKEY
  2187                              <1> 
  2188                              <1> do_getkey:
  2189 0000357C E8EB0E              <1> 	call get_token
  2190 0000357F 83F801              <1> 	cmp ax, VARIABLE
  2191 00003582 7405                <1> 	je .is_variable
  2192                              <1> 
  2193 00003584 B314                <1> 	mov bl, err_syntax
  2194 00003586 E9FA0F              <1> 	jmp error
  2195                              <1> 
  2196                              <1> .is_variable:
  2197 00003589 0FB606007B          <1> 	movzx ax, byte [token]
  2198                              <1> 
  2199 0000358E 50                  <1> 	push ax
  2200                              <1> 
  2201 0000358F E88BDD              <1> 	call os_check_for_key
  2202                              <1> 
  2203 00003592 3DE048              <1> 	cmp ax, 48E0h
  2204 00003595 7419                <1> 	je .up_pressed
  2205                              <1> 
  2206 00003597 3DE050              <1> 	cmp ax, 50E0h
  2207 0000359A 7419                <1> 	je .down_pressed
  2208                              <1> 
  2209 0000359C 3DE04B              <1> 	cmp ax, 4BE0h
  2210 0000359F 7419                <1> 	je .left_pressed
  2211                              <1> 
  2212 000035A1 3DE04D              <1> 	cmp ax, 4DE0h
  2213 000035A4 7419                <1> 	je .right_pressed
  2214                              <1> 
  2215                              <1> .store:	
  2216 000035A6 0FB6D8              <1> 	movzx bx, al
  2217                              <1> 	
  2218 000035A9 58                  <1> 	pop ax
  2219                              <1> 
  2220 000035AA E8AE0E              <1> 	call set_var
  2221                              <1> 
  2222 000035AD E94AF7              <1> 	jmp mainloop
  2223                              <1> 
  2224                              <1> .up_pressed:
  2225 000035B0 B80100              <1> 	mov ax, 1
  2226 000035B3 EBF1                <1> 	jmp .store
  2227                              <1> 
  2228                              <1> .down_pressed:
  2229 000035B5 B80200              <1> 	mov ax, 2
  2230 000035B8 EBEC                <1> 	jmp .store
  2231                              <1> 
  2232                              <1> .left_pressed:
  2233 000035BA B80300              <1> 	mov ax, 3
  2234 000035BD EBE7                <1> 	jmp .store
  2235                              <1> 
  2236                              <1> .right_pressed:
  2237 000035BF B80400              <1> 	mov ax, 4
  2238 000035C2 EBE2                <1> 	jmp .store
  2239                              <1> 
  2240                              <1> ; ------------------------------------------------------------------
  2241                              <1> ; GOSUB
  2242                              <1> 
  2243                              <1> do_gosub:
  2244 000035C4 E8A30E              <1> 	call get_token				; Get the number (label)
  2245                              <1> 
  2246 000035C7 83F804              <1> 	cmp ax, STRING
  2247 000035CA 7405                <1> 	je .is_ok
  2248                              <1> 
  2249 000035CC B305                <1> 	mov bl, err_goto_notlabel
  2250 000035CE E9B20F              <1> 	jmp error
  2251                              <1> 
  2252                              <1> .is_ok:
  2253 000035D1 BE007B              <1> 	mov si, token				; Back up this label
  2254 000035D4 BF[4336]            <1> 	mov di, .tmp_token
  2255 000035D7 E870F4              <1> 	call os_string_copy
  2256                              <1> 
  2257 000035DA B8[4336]            <1> 	mov ax, .tmp_token
  2258 000035DD E8D7F3              <1> 	call os_string_length
  2259                              <1> 
  2260 000035E0 BF[4336]            <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  2261 000035E3 01C7                <1> 	add di, ax
  2262 000035E5 B03A                <1> 	mov al, ':'
  2263 000035E7 AA                  <1> 	stosb
  2264 000035E8 B000                <1> 	mov al, 0
  2265 000035EA AA                  <1> 	stosb	
  2266                              <1> 
  2267                              <1> 
  2268 000035EB FE06[6547]          <1> 	inc byte [gosub_depth]
  2269                              <1> 
  2270 000035EF 0FB606[6547]        <1> 	movzx ax, byte [gosub_depth]		; Get current GOSUB nest level
  2271                              <1> 
  2272 000035F4 3C09                <1> 	cmp al, 9
  2273 000035F6 7E05                <1> 	jle .within_limit
  2274                              <1> 
  2275 000035F8 B307                <1> 	mov bl, err_nest_limit
  2276 000035FA E9860F              <1> 	jmp error
  2277                              <1> 
  2278                              <1> 
  2279                              <1> .within_limit:
  2280 000035FD BFBC79              <1> 	mov di, gosub_points			; Move into our table of pointers
  2281 00003600 01C7                <1> 	add di, ax				; Table is words (not bytes)
  2282 00003602 01C7                <1> 	add di, ax
  2283 00003604 A1[EE45]            <1> 	mov word ax, [prog]
  2284 00003607 AB                  <1> 	stosw					; Store current location before jump
  2285                              <1> 
  2286                              <1> 
  2287 00003608 A1[F245]            <1> 	mov word ax, [load_point]
  2288 0000360B A3[EE45]            <1> 	mov word [prog], ax			; Return to start of program to find label
  2289                              <1> 
  2290                              <1> .loop:
  2291 0000360E E8590E              <1> 	call get_token
  2292                              <1> 
  2293 00003611 83F808              <1> 	cmp ax, LABEL
  2294 00003614 750D                <1> 	jne .line_loop
  2295                              <1> 
  2296 00003616 BE007B              <1> 	mov si, token
  2297 00003619 BF[4336]            <1> 	mov di, .tmp_token
  2298 0000361C E88AF4              <1> 	call os_string_compare
  2299 0000361F 0F82D7F6            <1> 	jc mainloop
  2300                              <1> 
  2301                              <1> 
  2302                              <1> .line_loop:					; Go to end of line
  2303 00003623 8B36[EE45]          <1> 	mov word si, [prog]
  2304 00003627 8A04                <1> 	mov byte al, [si]
  2305 00003629 FF06[EE45]          <1> 	inc word [prog]
  2306 0000362D 3C0A                <1> 	cmp al, 10
  2307 0000362F 75F2                <1> 	jne .line_loop
  2308                              <1> 
  2309 00003631 A1[EE45]            <1> 	mov word ax, [prog]
  2310 00003634 8B1E[F045]          <1> 	mov word bx, [prog_end]
  2311 00003638 39D8                <1> 	cmp ax, bx
  2312 0000363A 7F02                <1> 	jg .past_end
  2313                              <1> 
  2314 0000363C EBD0                <1> 	jmp .loop
  2315                              <1> 
  2316                              <1> 
  2317                              <1> .past_end:
  2318 0000363E B306                <1> 	mov bl, err_label_notfound
  2319 00003640 E9400F              <1> 	jmp error
  2320                              <1> 
  2321                              <1> 
  2322 00003643 00<rep 1Eh>         <1> 	.tmp_token	times 30 db 0
  2323                              <1> 
  2324                              <1> 
  2325                              <1> ; ------------------------------------------------------------------
  2326                              <1> ; GOTO
  2327                              <1> 
  2328                              <1> do_goto:
  2329 00003661 E8060E              <1> 	call get_token				; Get the next token
  2330                              <1> 
  2331 00003664 83F804              <1> 	cmp ax, STRING
  2332 00003667 7405                <1> 	je .is_ok
  2333                              <1> 
  2334 00003669 B305                <1> 	mov bl, err_goto_notlabel
  2335 0000366B E9150F              <1> 	jmp error
  2336                              <1> 
  2337                              <1> .is_ok:
  2338 0000366E BE007B              <1> 	mov si, token				; Back up this label
  2339 00003671 BF[C336]            <1> 	mov di, .tmp_token
  2340 00003674 E8D3F3              <1> 	call os_string_copy
  2341                              <1> 
  2342 00003677 B8[C336]            <1> 	mov ax, .tmp_token
  2343 0000367A E83AF3              <1> 	call os_string_length
  2344                              <1> 
  2345 0000367D BF[C336]            <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  2346 00003680 01C7                <1> 	add di, ax
  2347 00003682 B03A                <1> 	mov al, ':'
  2348 00003684 AA                  <1> 	stosb
  2349 00003685 B000                <1> 	mov al, 0
  2350 00003687 AA                  <1> 	stosb	
  2351                              <1> 
  2352 00003688 A1[F245]            <1> 	mov word ax, [load_point]
  2353 0000368B A3[EE45]            <1> 	mov word [prog], ax			; Return to start of program to find label
  2354                              <1> 
  2355                              <1> .loop:
  2356 0000368E E8D90D              <1> 	call get_token
  2357                              <1> 
  2358 00003691 83F808              <1> 	cmp ax, LABEL
  2359 00003694 750D                <1> 	jne .line_loop
  2360                              <1> 
  2361 00003696 BE007B              <1> 	mov si, token
  2362 00003699 BF[C336]            <1> 	mov di, .tmp_token
  2363 0000369C E80AF4              <1> 	call os_string_compare
  2364 0000369F 0F8257F6            <1> 	jc mainloop
  2365                              <1> 
  2366                              <1> .line_loop:					; Go to end of line
  2367 000036A3 8B36[EE45]          <1> 	mov word si, [prog]
  2368 000036A7 8A04                <1> 	mov byte al, [si]
  2369 000036A9 FF06[EE45]          <1> 	inc word [prog]
  2370                              <1> 
  2371 000036AD 3C0A                <1> 	cmp al, 10
  2372 000036AF 75F2                <1> 	jne .line_loop
  2373                              <1> 
  2374 000036B1 A1[EE45]            <1> 	mov word ax, [prog]
  2375 000036B4 8B1E[F045]          <1> 	mov word bx, [prog_end]
  2376 000036B8 39D8                <1> 	cmp ax, bx
  2377 000036BA 7F02                <1> 	jg .past_end
  2378                              <1> 
  2379 000036BC EBD0                <1> 	jmp .loop
  2380                              <1> 
  2381                              <1> .past_end:
  2382 000036BE B306                <1> 	mov bl, err_label_notfound
  2383 000036C0 E9C00E              <1> 	jmp error
  2384                              <1> 
  2385                              <1> 
  2386 000036C3 00<rep 1Eh>         <1> 	.tmp_token 	times 30 db 0
  2387                              <1> 
  2388                              <1> 
  2389                              <1> ; ------------------------------------------------------------------
  2390                              <1> ; IF
  2391                              <1> 
  2392                              <1> do_if:
  2393 000036E1 E8860D              <1> 	call get_token
  2394                              <1> 
  2395 000036E4 83F801              <1> 	cmp ax, VARIABLE			; If can only be followed by a variable
  2396 000036E7 740C                <1> 	je .num_var
  2397                              <1> 
  2398 000036E9 83F802              <1> 	cmp ax, STRING_VAR
  2399 000036EC 0F84B300            <1> 	je near .string_var
  2400                              <1> 
  2401 000036F0 B314                <1> 	mov bl, err_syntax
  2402 000036F2 E98E0E              <1> 	jmp error
  2403                              <1> 
  2404                              <1> .num_var:
  2405 000036F5 0FB606007B          <1> 	movzx ax, byte [token]
  2406 000036FA E8510D              <1> 	call get_var
  2407                              <1> 
  2408 000036FD 89C2                <1> 	mov dx, ax				; Store value of first part of comparison
  2409                              <1> 
  2410 000036FF E8680D              <1> 	call get_token				; Get the delimiter
  2411 00003702 A0007B              <1> 	mov byte al, [token]
  2412 00003705 3C3D                <1> 	cmp al, '='
  2413 00003707 740D                <1> 	je .equals
  2414 00003709 3C3E                <1> 	cmp al, '>'
  2415 0000370B 7447                <1> 	je .greater
  2416 0000370D 3C3C                <1> 	cmp al, '<'
  2417 0000370F 746C                <1> 	je .less
  2418                              <1> 
  2419 00003711 B314                <1> 	mov bl, err_syntax			; If not one of the above, error out
  2420 00003713 E96D0E              <1> 	jmp error
  2421                              <1> 
  2422                              <1> .equals:
  2423 00003716 E8510D              <1> 	call get_token				; Is this 'X = Y' (equals another variable?)
  2424                              <1> 
  2425 00003719 83F806              <1> 	cmp ax, CHAR
  2426 0000371C 7417                <1> 	je .equals_char
  2427                              <1> 
  2428 0000371E A0007B              <1> 	mov byte al, [token]
  2429 00003721 E8530E              <1> 	call is_letter
  2430 00003724 721D                <1> 	jc .equals_var
  2431                              <1> 
  2432 00003726 BE007B              <1> 	mov si, token				; Otherwise it's, eg 'X = 1' (a number)
  2433 00003729 E8D1F3              <1> 	call os_string_to_int
  2434                              <1> 
  2435 0000372C 39D0                <1> 	cmp ax, dx				; On to the THEN bit if 'X = num' matches
  2436 0000372E 0F84C200            <1> 	je near .on_to_then
  2437                              <1> 
  2438 00003732 E9E700              <1> 	jmp .finish_line			; Otherwise skip the rest of the line
  2439                              <1> 
  2440                              <1> 
  2441                              <1> .equals_char:
  2442 00003735 0FB606007B          <1> 	movzx ax, byte [token]
  2443                              <1> 
  2444 0000373A 39D0                <1> 	cmp ax, dx
  2445 0000373C 0F84B400            <1> 	je near .on_to_then
  2446                              <1> 
  2447 00003740 E9D900              <1> 	jmp .finish_line
  2448                              <1> 
  2449                              <1> 
  2450                              <1> .equals_var:
  2451 00003743 0FB606007B          <1> 	movzx ax, byte [token]
  2452                              <1> 
  2453 00003748 E8030D              <1> 	call get_var
  2454                              <1> 
  2455 0000374B 39D0                <1> 	cmp ax, dx				; Do the variables match?
  2456 0000374D 0F84A300            <1> 	je near .on_to_then				; On to the THEN bit if so
  2457                              <1> 
  2458 00003751 E9C800              <1> 	jmp .finish_line			; Otherwise skip the rest of the line
  2459                              <1> 
  2460                              <1> 
  2461                              <1> .greater:
  2462 00003754 E8130D              <1> 	call get_token				; Greater than a variable or number?
  2463 00003757 A0007B              <1> 	mov byte al, [token]
  2464 0000375A E81A0E              <1> 	call is_letter
  2465 0000375D 720F                <1> 	jc .greater_var
  2466                              <1> 
  2467 0000375F BE007B              <1> 	mov si, token				; Must be a number here...
  2468 00003762 E898F3              <1> 	call os_string_to_int
  2469                              <1> 
  2470 00003765 39D0                <1> 	cmp ax, dx
  2471 00003767 0F8C8900            <1> 	jl near .on_to_then
  2472                              <1> 
  2473 0000376B E9AE00              <1> 	jmp .finish_line
  2474                              <1> 
  2475                              <1> .greater_var:					; Variable in this case
  2476 0000376E 0FB606007B          <1> 	movzx ax, byte [token]
  2477                              <1> 
  2478 00003773 E8D80C              <1> 	call get_var
  2479                              <1> 
  2480 00003776 39D0                <1> 	cmp ax, dx				; Make the comparison!
  2481 00003778 7C7A                <1> 	jl .on_to_then
  2482                              <1> 
  2483 0000377A E99F00              <1> 	jmp .finish_line
  2484                              <1> 
  2485                              <1> .less:
  2486 0000377D E8EA0C              <1> 	call get_token
  2487 00003780 A0007B              <1> 	mov byte al, [token]
  2488 00003783 E8F10D              <1> 	call is_letter
  2489 00003786 720D                <1> 	jc .less_var
  2490                              <1> 
  2491 00003788 BE007B              <1> 	mov si, token
  2492 0000378B E86FF3              <1> 	call os_string_to_int
  2493                              <1> 
  2494 0000378E 39D0                <1> 	cmp ax, dx
  2495 00003790 7F62                <1> 	jg .on_to_then
  2496                              <1> 
  2497 00003792 E98700              <1> 	jmp .finish_line
  2498                              <1> 
  2499                              <1> .less_var:
  2500 00003795 0FB606007B          <1> 	movzx ax, byte [token]
  2501                              <1> 
  2502 0000379A E8B10C              <1> 	call get_var
  2503                              <1> 
  2504 0000379D 39D0                <1> 	cmp ax, dx
  2505 0000379F 7F53                <1> 	jg .on_to_then
  2506                              <1> 
  2507 000037A1 EB79                <1> 	jmp .finish_line
  2508                              <1> 
  2509                              <1> 
  2510                              <1> 
  2511                              <1> .string_var:
  2512 000037A3 881E[3738]          <1> 	mov byte [.tmp_string_var], bl
  2513                              <1> 
  2514 000037A7 E8C00C              <1> 	call get_token
  2515                              <1> 
  2516 000037AA A0007B              <1> 	mov byte al, [token]
  2517 000037AD 3C3D                <1> 	cmp al, '='
  2518 000037AF 0F857F00            <1> 	jne .error
  2519                              <1> 
  2520 000037B3 E8B40C              <1> 	call get_token
  2521 000037B6 83F802              <1> 	cmp ax, STRING_VAR
  2522 000037B9 7419                <1> 	je .second_is_string_var
  2523                              <1> 
  2524 000037BB 83F805              <1> 	cmp ax, QUOTE
  2525 000037BE 7572                <1> 	jne .error
  2526                              <1> 
  2527 000037C0 BE007C              <1> 	mov si, string_vars
  2528 000037C3 B88000              <1> 	mov ax, 128
  2529 000037C6 F7E3                <1> 	mul bx
  2530 000037C8 01C6                <1> 	add si, ax
  2531 000037CA BF007B              <1> 	mov di, token
  2532 000037CD E8D9F2              <1> 	call os_string_compare
  2533 000037D0 7422                <1> 	je .on_to_then
  2534                              <1> 
  2535 000037D2 EB48                <1> 	jmp .finish_line
  2536                              <1> 
  2537                              <1> 
  2538                              <1> .second_is_string_var:
  2539 000037D4 BE007C              <1> 	mov si, string_vars
  2540 000037D7 B88000              <1> 	mov ax, 128
  2541 000037DA F7E3                <1> 	mul bx
  2542 000037DC 01C6                <1> 	add si, ax
  2543                              <1> 
  2544 000037DE BF007C              <1> 	mov di, string_vars
  2545 000037E1 0FB61E[3738]        <1> 	movzx bx, byte [.tmp_string_var]
  2546 000037E6 B88000              <1> 	mov ax, 128
  2547 000037E9 F7E3                <1> 	mul bx
  2548 000037EB 01C7                <1> 	add di, ax
  2549                              <1> 
  2550 000037ED E8B9F2              <1> 	call os_string_compare
  2551 000037F0 7202                <1> 	jc .on_to_then
  2552                              <1> 
  2553 000037F2 EB28                <1> 	jmp .finish_line
  2554                              <1> 
  2555                              <1> 
  2556                              <1> .on_to_then:
  2557 000037F4 E8730C              <1> 	call get_token
  2558                              <1> 
  2559 000037F7 BE007B              <1> 	mov si, token			; Look for AND for more comparison
  2560 000037FA BF[1947]            <1> 	mov di, and_keyword
  2561 000037FD E8A9F2              <1> 	call os_string_compare
  2562 00003800 0F82DDFE            <1> 	jc do_if
  2563                              <1> 
  2564 00003804 BE007B              <1> 	mov si, token			; Look for THEN to perform more operations
  2565 00003807 BF[1D47]            <1> 	mov di, then_keyword
  2566 0000380A E89CF2              <1> 	call os_string_compare
  2567 0000380D 7205                <1> 	jc .then_present
  2568                              <1> 
  2569 0000380F B314                <1> 	mov bl, err_syntax
  2570 00003811 E96F0D              <1> 	jmp error
  2571                              <1> 
  2572                              <1> .then_present:				; Continue rest of line like any other command!
  2573 00003814 C606[F645]01        <1> 	mov byte [last_if_true], 1
  2574 00003819 E9DEF4              <1> 	jmp mainloop
  2575                              <1> 
  2576                              <1> 
  2577                              <1> .finish_line:				; IF wasn't fulfilled, so skip rest of line
  2578 0000381C 8B36[EE45]          <1> 	mov word si, [prog]
  2579 00003820 8A04                <1> 	mov byte al, [si]
  2580 00003822 FF06[EE45]          <1> 	inc word [prog]
  2581 00003826 3C0A                <1> 	cmp al, 10
  2582 00003828 75F2                <1> 	jne .finish_line
  2583                              <1> 
  2584 0000382A C606[F645]00        <1> 	mov byte [last_if_true], 0
  2585 0000382F E9C8F4              <1> 	jmp mainloop
  2586                              <1> 
  2587                              <1> 
  2588                              <1> .error:
  2589 00003832 B314                <1> 	mov bl, err_syntax
  2590 00003834 E94C0D              <1> 	jmp error
  2591                              <1> 
  2592                              <1> 
  2593 00003837 00                  <1> 	.tmp_string_var		db 0
  2594                              <1> 
  2595                              <1> 
  2596                              <1> ; ------------------------------------------------------------------
  2597                              <1> ; INCLUDE
  2598                              <1> 
  2599                              <1> do_include:
  2600 00003838 E82F0C              <1> 	call get_token
  2601 0000383B 83F805              <1> 	cmp ax, QUOTE
  2602 0000383E 7406                <1> 	je .is_ok
  2603                              <1> 
  2604 00003840 BE1400              <1> 	mov si, err_syntax
  2605 00003843 E93D0D              <1> 	jmp error
  2606                              <1> 
  2607                              <1> .is_ok:
  2608 00003846 B8007B              <1> 	mov ax, token
  2609 00003849 8B0E[F045]          <1> 	mov word cx, [prog_end]
  2610 0000384D 41                  <1> 	inc cx				; Add a bit of space after original code
  2611 0000384E 41                  <1> 	inc cx
  2612 0000384F 41                  <1> 	inc cx
  2613 00003850 51                  <1> 	push cx
  2614 00003851 E839D3              <1> 	call os_load_file
  2615 00003854 720A                <1> 	jc .load_fail
  2616                              <1> 
  2617 00003856 59                  <1> 	pop cx
  2618 00003857 01D9                <1> 	add cx, bx
  2619 00003859 890E[F045]          <1> 	mov word [prog_end], cx
  2620                              <1> 
  2621 0000385D E99AF4              <1> 	jmp mainloop
  2622                              <1> 
  2623                              <1> 
  2624                              <1> .load_fail:
  2625 00003860 59                  <1> 	pop cx
  2626 00003861 BE0400              <1> 	mov si, err_file_notfound
  2627 00003864 E91C0D              <1> 	jmp error
  2628                              <1> 
  2629                              <1> 
  2630                              <1> ; ------------------------------------------------------------------
  2631                              <1> ; INK
  2632                              <1> 
  2633                              <1> do_ink:
  2634 00003867 E8000C              <1> 	call get_token				; Get column
  2635                              <1> 
  2636 0000386A 83F801              <1> 	cmp ax, VARIABLE
  2637 0000386D 740C                <1> 	je .first_is_var
  2638                              <1> 
  2639 0000386F BE007B              <1> 	mov si, token
  2640 00003872 E888F2              <1> 	call os_string_to_int
  2641 00003875 A2[F745]            <1> 	mov byte [ink_colour], al
  2642 00003878 E97FF4              <1> 	jmp mainloop
  2643                              <1> 
  2644                              <1> .first_is_var:
  2645 0000387B B80000              <1> 	mov ax, 0
  2646 0000387E A0007B              <1> 	mov byte al, [token]
  2647 00003881 E8CA0B              <1> 	call get_var
  2648 00003884 A2[F745]            <1> 	mov byte [ink_colour], al
  2649 00003887 E970F4              <1> 	jmp mainloop
  2650                              <1> 
  2651                              <1> 
  2652                              <1> ; ------------------------------------------------------------------
  2653                              <1> ; INPUT
  2654                              <1> 
  2655                              <1> do_input:
  2656 0000388A B000                <1> 	mov al, 0				; Clear string from previous usage
  2657 0000388C BF807A              <1> 	mov di, .tmpstring
  2658 0000388F B98000              <1> 	mov cx, 128
  2659 00003892 F3AA                <1> 	rep stosb
  2660                              <1> 
  2661 00003894 E8D30B              <1> 	call get_token
  2662                              <1> 
  2663 00003897 83F801              <1> 	cmp ax, VARIABLE			; We can only INPUT to variables!
  2664 0000389A 740B                <1> 	je .number_var
  2665                              <1> 
  2666 0000389C 83F802              <1> 	cmp ax, STRING_VAR
  2667 0000389F 7437                <1> 	je .string_var
  2668                              <1> 
  2669 000038A1 BE1400              <1> 	mov si, err_syntax
  2670 000038A4 E9DC0C              <1> 	jmp error
  2671                              <1> 
  2672                              <1> .number_var:
  2673 000038A7 B8807A              <1> 	mov ax, .tmpstring			; Get input from the user
  2674 000038AA E804E9              <1> 	call os_input_string
  2675                              <1> 
  2676 000038AD B8807A              <1> 	mov ax, .tmpstring
  2677 000038B0 E804F1              <1> 	call os_string_length
  2678 000038B3 83F800              <1> 	cmp ax, 0
  2679 000038B6 750A                <1> 	jne .char_entered
  2680                              <1> 
  2681 000038B8 C606807A30          <1> 	mov byte [.tmpstring], '0'		; If enter hit, fill variable with zero
  2682 000038BD C606817A00          <1> 	mov byte [.tmpstring + 1], 0
  2683                              <1> 
  2684                              <1> .char_entered:
  2685 000038C2 BE807A              <1> 	mov si, .tmpstring			; Convert to integer format
  2686 000038C5 E835F2              <1> 	call os_string_to_int
  2687 000038C8 89C3                <1> 	mov bx, ax
  2688                              <1> 
  2689 000038CA 0FB606007B          <1> 	movzx ax, byte [token]
  2690 000038CF E8890B              <1> 	call set_var				; ...and store it!
  2691                              <1> 
  2692 000038D2 E86DE6              <1> 	call os_print_newline
  2693                              <1> 
  2694 000038D5 E922F4              <1> 	jmp mainloop
  2695                              <1> 
  2696                              <1> 
  2697                              <1> .string_var:
  2698 000038D8 53                  <1> 	push bx
  2699                              <1> 
  2700 000038D9 B8807A              <1> 	mov ax, .tmpstring
  2701 000038DC E8D2E8              <1> 	call os_input_string
  2702                              <1> 
  2703 000038DF BE807A              <1> 	mov si, .tmpstring
  2704 000038E2 BF007C              <1> 	mov di, string_vars
  2705                              <1> 
  2706 000038E5 5B                  <1> 	pop bx
  2707                              <1> 
  2708 000038E6 B88000              <1> 	mov ax, 128
  2709 000038E9 F7E3                <1> 	mul bx
  2710                              <1> 
  2711 000038EB 01C7                <1> 	add di, ax
  2712 000038ED E85AF1              <1> 	call os_string_copy
  2713                              <1> 
  2714 000038F0 E84FE6              <1> 	call os_print_newline
  2715                              <1> 
  2716 000038F3 E904F4              <1> 	jmp mainloop
  2717                              <1> 
  2718                              <1> 
  2719                              <1> ;	.tmpstring	times 128 db 0
  2720                              <1> 	.tmpstring	equ 32768-1024-256-128
  2721                              <1> 
  2722                              <1> ; -----------------------------------------------------------
  2723                              <1> ; LEN
  2724                              <1> 
  2725                              <1> do_len:
  2726 000038F6 E8710B              <1> 	call get_token
  2727 000038F9 83F802              <1> 	cmp ax, STRING_VAR
  2728 000038FC 7538                <1> 	jne .error
  2729                              <1>  
  2730 000038FE BE007C              <1> 	mov si, string_vars
  2731 00003901 B88000              <1> 	mov ax, 128
  2732 00003904 F7E3                <1> 	mul bx
  2733 00003906 01C6                <1> 	add si, ax
  2734                              <1> 
  2735 00003908 89F0                <1> 	mov ax, si
  2736 0000390A E8AAF0              <1> 	call os_string_length
  2737 0000390D A3[3C39]            <1> 	mov word [.num1], ax
  2738                              <1> 
  2739 00003910 E8570B              <1> 	call get_token
  2740 00003913 83F801              <1> 	cmp ax, VARIABLE
  2741 00003916 7406                <1> 	je .is_ok
  2742                              <1> 	
  2743 00003918 BE1400              <1> 	mov si, err_syntax
  2744 0000391B E9650C              <1> 	jmp error
  2745                              <1> 
  2746                              <1> .is_ok:
  2747 0000391E 0FB606007B          <1> 	movzx ax, byte [token]
  2748 00003923 88C3                <1> 	mov bl, al
  2749 00003925 EB00                <1> 	jmp .finish
  2750                              <1> 
  2751                              <1> .finish:	
  2752 00003927 8B1E[3C39]          <1> 	mov bx, [.num1]
  2753 0000392B A0007B              <1> 	mov byte al, [token]
  2754 0000392E E82A0B              <1> 	call set_var
  2755 00003931 31C0                <1> 	xor ax, ax
  2756 00003933 E9C4F3              <1> 	jmp mainloop
  2757                              <1>  
  2758                              <1> .error:
  2759 00003936 BE1400              <1> 	mov si, err_syntax
  2760 00003939 E9470C              <1> 	jmp error
  2761                              <1> 
  2762                              <1> 
  2763 0000393C 0000                <1> 	.num1 dw 0
  2764                              <1> 
  2765                              <1> 
  2766                              <1> ; ------------------------------------------------------------------
  2767                              <1> ; LISTBOX
  2768                              <1> 
  2769                              <1> do_listbox:
  2770 0000393E 8A3E[F845]          <1> 	mov bh, [work_page]			; Store the cursor position
  2771 00003942 B403                <1> 	mov ah, 03h
  2772 00003944 CD10                <1> 	int 10h
  2773                              <1> 	
  2774 00003946 E8210B              <1> 	call get_token
  2775 00003949 83F802              <1> 	cmp ax, STRING_VAR
  2776 0000394C 757C                <1> 	jne .error
  2777                              <1> 
  2778 0000394E BE007C              <1> 	mov si, string_vars
  2779 00003951 B88000              <1> 	mov ax, 128
  2780 00003954 F7E3                <1> 	mul bx
  2781 00003956 01C6                <1> 	add si, ax
  2782                              <1> 
  2783 00003958 8936[D039]          <1> 	mov word [.s1], si
  2784                              <1> 
  2785 0000395C E80B0B              <1> 	call get_token
  2786 0000395F 83F802              <1> 	cmp ax, STRING_VAR
  2787 00003962 7566                <1> 	jne .error
  2788                              <1> 
  2789 00003964 BE007C              <1> 	mov si, string_vars
  2790 00003967 B88000              <1> 	mov ax, 128
  2791 0000396A F7E3                <1> 	mul bx
  2792 0000396C 01C6                <1> 	add si, ax
  2793                              <1> 
  2794 0000396E 8936[D239]          <1> 	mov word [.s2], si
  2795                              <1> 
  2796 00003972 E8F50A              <1> 	call get_token
  2797 00003975 83F802              <1> 	cmp ax, STRING_VAR
  2798 00003978 7550                <1> 	jne .error
  2799                              <1> 
  2800 0000397A BE007C              <1> 	mov si, string_vars
  2801 0000397D B88000              <1> 	mov ax, 128
  2802 00003980 F7E3                <1> 	mul bx
  2803 00003982 01C6                <1> 	add si, ax
  2804                              <1> 
  2805 00003984 8936[D439]          <1> 	mov word [.s3], si
  2806                              <1> 
  2807                              <1> 
  2808 00003988 E8DF0A              <1> 	call get_token
  2809 0000398B 83F801              <1> 	cmp ax, VARIABLE
  2810 0000398E 753A                <1> 	jne .error
  2811                              <1> 
  2812 00003990 A0007B              <1> 	mov byte al, [token]
  2813 00003993 A2[D639]            <1> 	mov byte [.var], al
  2814                              <1> 
  2815 00003996 A1[D039]            <1> 	mov word ax, [.s1]
  2816 00003999 8B1E[D239]          <1> 	mov word bx, [.s2]
  2817 0000399D 8B0E[D439]          <1> 	mov word cx, [.s3]
  2818                              <1> 
  2819 000039A1 E810E2              <1> 	call os_list_dialog
  2820 000039A4 7217                <1> 	jc .esc_pressed
  2821                              <1> 
  2822 000039A6 60                  <1> 	pusha
  2823 000039A7 8A3E[F845]          <1> 	mov bh, [work_page]			; Move the cursor back
  2824 000039AB B402                <1> 	mov ah, 02h
  2825 000039AD CD10                <1> 	int 10h
  2826 000039AF 61                  <1> 	popa
  2827                              <1> 
  2828 000039B0 89C3                <1> 	mov bx, ax
  2829 000039B2 0FB606[D639]        <1> 	movzx ax, byte [.var]
  2830 000039B7 E8A10A              <1> 	call set_var
  2831                              <1> 
  2832 000039BA E93DF3              <1> 	jmp mainloop
  2833                              <1> 
  2834                              <1> 
  2835                              <1> .esc_pressed:
  2836 000039BD 0FB606[D639]        <1> 	movzx ax, byte [.var]
  2837 000039C2 31DB                <1> 	xor bx, bx
  2838 000039C4 E8940A              <1> 	call set_var
  2839 000039C7 E930F3              <1> 	jmp mainloop
  2840                              <1> 
  2841                              <1> 
  2842                              <1> .error:
  2843 000039CA BE1400              <1> 	mov si, err_syntax
  2844 000039CD E9B30B              <1> 	jmp error
  2845                              <1> 
  2846 000039D0 0000                <1> 	.s1 dw 0
  2847 000039D2 0000                <1> 	.s2 dw 0
  2848 000039D4 0000                <1> 	.s3 dw 0
  2849 000039D6 00                  <1> 	.var db 0
  2850                              <1> 
  2851                              <1> 
  2852                              <1> ; ------------------------------------------------------------------
  2853                              <1> ; LOAD
  2854                              <1> 
  2855                              <1> do_load:
  2856 000039D7 E8900A              <1> 	call get_token
  2857 000039DA 83F805              <1> 	cmp ax, QUOTE
  2858 000039DD 7411                <1> 	je .is_quote
  2859                              <1> 
  2860 000039DF 83F802              <1> 	cmp ax, STRING_VAR
  2861 000039E2 755F                <1> 	jne .error
  2862                              <1> 
  2863 000039E4 BE007C              <1> 	mov si, string_vars
  2864 000039E7 B88000              <1> 	mov ax, 128
  2865 000039EA F7E3                <1> 	mul bx
  2866 000039EC 01C6                <1> 	add si, ax
  2867 000039EE EB03                <1> 	jmp .get_position
  2868                              <1> 
  2869                              <1> .is_quote:
  2870 000039F0 BE007B              <1> 	mov si, token
  2871                              <1> 
  2872                              <1> .get_position:
  2873 000039F3 89F0                <1> 	mov ax, si
  2874 000039F5 E8D9D4              <1> 	call os_file_exists
  2875 000039F8 7239                <1> 	jc .file_not_exists
  2876                              <1> 
  2877 000039FA 89C2                <1> 	mov dx, ax			; Store for now
  2878                              <1> 
  2879 000039FC E86B0A              <1> 	call get_token
  2880                              <1> 
  2881 000039FF 83F801              <1> 	cmp ax, VARIABLE
  2882 00003A02 7425                <1> 	je .second_is_var
  2883                              <1> 
  2884 00003A04 83F803              <1> 	cmp ax, NUMBER
  2885 00003A07 753A                <1> 	jne .error
  2886                              <1> 
  2887 00003A09 BE007B              <1> 	mov si, token
  2888 00003A0C E8EEF0              <1> 	call os_string_to_int
  2889                              <1> 
  2890                              <1> .load_part:
  2891 00003A0F 89C1                <1> 	mov cx, ax
  2892                              <1> 
  2893 00003A11 89D0                <1> 	mov ax, dx
  2894                              <1> 
  2895 00003A13 E877D1              <1> 	call os_load_file
  2896                              <1> 
  2897 00003A16 31C0                <1> 	xor ax, ax
  2898 00003A18 B053                <1> 	mov byte al, 'S'
  2899 00003A1A E83E0A              <1> 	call set_var
  2900                              <1> 
  2901 00003A1D 31C0                <1> 	xor ax, ax
  2902 00003A1F B052                <1> 	mov byte al, 'R'
  2903 00003A21 31DB                <1> 	xor bx, bx
  2904 00003A23 E8350A              <1> 	call set_var
  2905                              <1> 
  2906 00003A26 E9D1F2              <1> 	jmp mainloop
  2907                              <1> 
  2908                              <1> 
  2909                              <1> .second_is_var:
  2910 00003A29 0FB606007B          <1> 	movzx ax, byte [token]
  2911 00003A2E E81D0A              <1> 	call get_var
  2912 00003A31 EBDC                <1> 	jmp .load_part
  2913                              <1> 
  2914                              <1> 
  2915                              <1> .file_not_exists:
  2916 00003A33 31C0                <1> 	xor ax, ax
  2917 00003A35 B052                <1> 	mov byte al, 'R'
  2918 00003A37 BB0100              <1> 	mov bx, 1
  2919 00003A3A E81E0A              <1> 	call set_var
  2920                              <1> 
  2921 00003A3D E82A0A              <1> 	call get_token				; Skip past the loading point -- unnecessary now
  2922                              <1> 
  2923 00003A40 E9B7F2              <1> 	jmp mainloop
  2924                              <1> 
  2925                              <1> 
  2926                              <1> .error:
  2927 00003A43 BE1400              <1> 	mov si, err_syntax
  2928 00003A46 E93A0B              <1> 	jmp error
  2929                              <1> 
  2930                              <1> 
  2931                              <1> ; ------------------------------------------------------------------
  2932                              <1> ; LOOP
  2933                              <1> 
  2934                              <1> do_loop:
  2935 00003A49 803E[F545]00        <1> 	cmp byte [loop_in], 0
  2936 00003A4E 0F84CA00            <1> 	je .no_do
  2937                              <1> 
  2938 00003A52 802E[F545]02        <1> 	sub byte [loop_in], 2
  2939                              <1> 
  2940 00003A57 31D2                <1> 	xor dx, dx
  2941                              <1> 
  2942 00003A59 E80E0A              <1> 	call get_token
  2943 00003A5C BF007B              <1> 	mov di, token
  2944                              <1> 	
  2945 00003A5F BE[343B]            <1> 	mov si, .endless_word
  2946 00003A62 E844F0              <1> 	call os_string_compare
  2947 00003A65 0F829C00            <1> 	jc .loop_back
  2948                              <1> 	
  2949 00003A69 BE[283B]            <1> 	mov si, .while_word
  2950 00003A6C E83AF0              <1> 	call os_string_compare
  2951 00003A6F 0F82A300            <1> 	jc .while_set
  2952                              <1> 	
  2953 00003A73 BE[2E3B]            <1> 	mov si, .until_word
  2954 00003A76 E830F0              <1> 	call os_string_compare
  2955 00003A79 0F83A500            <1> 	jnc .error
  2956                              <1> 	
  2957                              <1> .get_first_var:
  2958 00003A7D E8EA09              <1> 	call get_token
  2959 00003A80 83F801              <1> 	cmp ax, VARIABLE
  2960 00003A83 0F859B00            <1> 	jne .error
  2961                              <1> 	
  2962 00003A87 A0007B              <1> 	mov al, [token]
  2963 00003A8A E8C109              <1> 	call get_var
  2964 00003A8D 89C1                <1> 	mov cx, ax
  2965                              <1> 	
  2966                              <1> .check_equals:
  2967 00003A8F E8D809              <1> 	call get_token
  2968 00003A92 83F807              <1> 	cmp ax, UNKNOWN
  2969 00003A95 0F858900            <1> 	jne .error
  2970                              <1> 
  2971 00003A99 A1007B              <1> 	mov ax, [token]
  2972 00003A9C 3C3D                <1> 	cmp al, '='
  2973 00003A9E 740A                <1> 	je .sign_ok
  2974 00003AA0 3C3E                <1> 	cmp al, '>'
  2975 00003AA2 7406                <1> 	je .sign_ok
  2976 00003AA4 3C3C                <1> 	cmp al, '<'
  2977 00003AA6 7402                <1> 	je .sign_ok
  2978 00003AA8 EB78                <1> 	jmp .error
  2979                              <1> 	.sign_ok:
  2980 00003AAA A2[3C3B]            <1> 	mov byte [.sign], al
  2981                              <1> 	
  2982                              <1> .get_second_var:
  2983 00003AAD E8BA09              <1>  	call get_token
  2984                              <1> 
  2985 00003AB0 83F803              <1> 	cmp ax, NUMBER
  2986 00003AB3 7419                <1> 	je .second_is_num
  2987                              <1> 
  2988 00003AB5 83F801              <1> 	cmp ax, VARIABLE
  2989 00003AB8 740C                <1> 	je .second_is_var
  2990                              <1> 
  2991 00003ABA 83F806              <1> 	cmp ax, CHAR
  2992 00003ABD 7563                <1> 	jne .error
  2993                              <1> 
  2994                              <1> .second_is_char:
  2995 00003ABF B400                <1> 	mov ah, 0
  2996 00003AC1 A0007B              <1> 	mov al, [token]
  2997 00003AC4 EB0E                <1> 	jmp .check_true
  2998                              <1> 	
  2999                              <1> .second_is_var:
  3000 00003AC6 A0007B              <1> 	mov al, [token]
  3001 00003AC9 E88209              <1> 	call get_var
  3002 00003ACC EB06                <1> 	jmp .check_true
  3003                              <1> 	
  3004                              <1> .second_is_num:
  3005 00003ACE BE007B              <1> 	mov si, token
  3006 00003AD1 E829F0              <1> 	call os_string_to_int
  3007                              <1> 	
  3008                              <1> .check_true:
  3009 00003AD4 8A1E[3C3B]          <1> 	mov byte bl, [.sign]
  3010 00003AD8 80FB3D              <1> 	cmp bl, '='
  3011 00003ADB 7407                <1> 	je .sign_equals
  3012                              <1> 	
  3013 00003ADD 80FB3E              <1> 	cmp bl, '>'
  3014 00003AE0 7408                <1> 	je .sign_greater
  3015                              <1> 	
  3016 00003AE2 EB0C                <1> 	jmp .sign_lesser
  3017                              <1> 	
  3018                              <1> .sign_equals:
  3019 00003AE4 39C8                <1> 	cmp ax, cx
  3020 00003AE6 7516                <1> 	jne .false
  3021 00003AE8 EB0C                <1> 	jmp .true
  3022                              <1> 	
  3023                              <1> .sign_greater:
  3024 00003AEA 39C8                <1> 	cmp ax, cx
  3025 00003AEC 7D10                <1> 	jge .false
  3026 00003AEE EB06                <1> 	jmp .true
  3027                              <1> 	
  3028                              <1> .sign_lesser:
  3029 00003AF0 39C8                <1> 	cmp ax, cx
  3030 00003AF2 7E0A                <1> 	jle .false
  3031 00003AF4 EB00                <1> 	jmp .true
  3032                              <1> .true:
  3033 00003AF6 83FA01              <1> 	cmp dx, 1
  3034 00003AF9 740A                <1> 	je .loop_back
  3035 00003AFB E9FCF1              <1> 	jmp mainloop
  3036                              <1> .false:
  3037 00003AFE 83FA01              <1> 	cmp dx, 1
  3038 00003B01 0F84F5F1            <1> 	je mainloop
  3039                              <1> 	
  3040                              <1> .loop_back:	
  3041 00003B05 BED079              <1> 	mov word si, do_loop_store
  3042 00003B08 A0[F545]            <1> 	mov byte al, [loop_in]
  3043 00003B0B B400                <1> 	mov ah, 0
  3044 00003B0D 01C6                <1> 	add si, ax
  3045 00003B0F AD                  <1> 	lodsw
  3046 00003B10 A3[EE45]            <1> 	mov word [prog], ax
  3047 00003B13 E9E4F1              <1> 	jmp mainloop
  3048                              <1> 	
  3049                              <1> .while_set:
  3050 00003B16 BA0100              <1> 	mov dx, 1
  3051 00003B19 E961FF              <1> 	jmp .get_first_var
  3052                              <1> 	
  3053                              <1> .no_do:
  3054 00003B1C BE0900              <1> 	mov si, err_loop
  3055 00003B1F E9610A              <1> 	jmp error
  3056                              <1> 
  3057                              <1> .error:
  3058 00003B22 BE1400              <1> 	mov si, err_syntax
  3059 00003B25 E95B0A              <1> 	jmp error
  3060                              <1> 	
  3061                              <1> .data:
  3062 00003B28 5748494C4500        <1> 	.while_word			db "WHILE", 0
  3063 00003B2E 554E54494C00        <1> 	.until_word			db "UNTIL", 0
  3064 00003B34 454E444C45535300    <1> 	.endless_word			db "ENDLESS", 0
  3065 00003B3C 00                  <1> 	.sign				db 0
  3066                              <1> 	
  3067                              <1> 	
  3068                              <1> ; ------------------------------------------------------------------
  3069                              <1> ; MOVE
  3070                              <1> 
  3071                              <1> do_move:
  3072 00003B3D E82A09              <1> 	call get_token
  3073                              <1> 
  3074 00003B40 83F801              <1> 	cmp ax, VARIABLE
  3075 00003B43 740A                <1> 	je .first_is_var
  3076                              <1> 
  3077 00003B45 BE007B              <1> 	mov si, token
  3078 00003B48 E8B2EF              <1> 	call os_string_to_int
  3079 00003B4B 88C2                <1> 	mov dl, al
  3080 00003B4D EB0A                <1> 	jmp .onto_second
  3081                              <1> 
  3082                              <1> .first_is_var:
  3083 00003B4F 0FB606007B          <1> 	movzx ax, byte [token]
  3084 00003B54 E8F708              <1> 	call get_var
  3085 00003B57 88C2                <1> 	mov dl, al
  3086                              <1> 
  3087                              <1> .onto_second:
  3088 00003B59 E80E09              <1> 	call get_token
  3089                              <1> 
  3090 00003B5C 83F801              <1> 	cmp ax, VARIABLE
  3091 00003B5F 740A                <1> 	je .second_is_var
  3092                              <1> 
  3093 00003B61 BE007B              <1> 	mov si, token
  3094 00003B64 E896EF              <1> 	call os_string_to_int
  3095 00003B67 88C6                <1> 	mov dh, al
  3096 00003B69 EB0A                <1> 	jmp .finish
  3097                              <1> 
  3098                              <1> .second_is_var:
  3099 00003B6B 0FB606007B          <1> 	movzx ax, byte [token]
  3100 00003B70 E8DB08              <1> 	call get_var
  3101 00003B73 88C6                <1> 	mov dh, al
  3102                              <1> 
  3103                              <1> .finish:
  3104 00003B75 8A3E[F845]          <1> 	mov byte bh, [work_page]
  3105 00003B79 B402                <1> 	mov ah, 2
  3106 00003B7B CD10                <1> 	int 10h
  3107                              <1> 
  3108 00003B7D E97AF1              <1> 	jmp mainloop
  3109                              <1> 
  3110                              <1> 
  3111                              <1> ; ------------------------------------------------------------------
  3112                              <1> ; NEXT
  3113                              <1> 
  3114                              <1> do_next:
  3115 00003B80 E8E708              <1> 	call get_token
  3116                              <1> 
  3117 00003B83 83F801              <1> 	cmp ax, VARIABLE			; NEXT must be followed by a variable
  3118 00003B86 753F                <1> 	jne .error
  3119                              <1> 
  3120 00003B88 0FB606007B          <1> 	movzx ax, byte [token]
  3121 00003B8D E8BE08              <1> 	call get_var
  3122                              <1> 
  3123 00003B90 40                  <1> 	inc ax					; NEXT increments the variable, of course!
  3124                              <1> 
  3125 00003B91 89C3                <1> 	mov bx, ax
  3126                              <1> 
  3127 00003B93 0FB606007B          <1> 	movzx ax, byte [token]
  3128                              <1> 
  3129 00003B98 2C41                <1> 	sub al, 65
  3130 00003B9A BE187A              <1> 	mov si, for_variables
  3131 00003B9D 01C6                <1> 	add si, ax
  3132 00003B9F 01C6                <1> 	add si, ax
  3133 00003BA1 AD                  <1> 	lodsw					; Get the target number from the table
  3134                              <1> 
  3135 00003BA2 40                  <1> 	inc ax					; (Make the loop inclusive of target number)
  3136 00003BA3 39D8                <1> 	cmp ax, bx				; Do the variable and target match?
  3137 00003BA5 741D                <1> 	je .loop_finished
  3138                              <1> 
  3139 00003BA7 0FB606007B          <1> 	movzx ax, byte [token]
  3140 00003BAC E8AC08              <1> 	call set_var
  3141                              <1> 
  3142 00003BAF 0FB606007B          <1> 	movzx ax, byte [token]
  3143 00003BB4 2C41                <1> 	sub al, 65
  3144 00003BB6 BEE479              <1> 	mov si, for_code_points
  3145 00003BB9 01C6                <1> 	add si, ax
  3146 00003BBB 01C6                <1> 	add si, ax
  3147 00003BBD AD                  <1> 	lodsw
  3148                              <1> 
  3149 00003BBE A3[EE45]            <1> 	mov word [prog], ax
  3150 00003BC1 E936F1              <1> 	jmp mainloop
  3151                              <1> 
  3152                              <1> 
  3153                              <1> .loop_finished:
  3154 00003BC4 E933F1              <1> 	jmp mainloop
  3155                              <1> 
  3156                              <1> .error:
  3157 00003BC7 BE1400              <1> 	mov si, err_syntax
  3158 00003BCA E9B609              <1> 	jmp error
  3159                              <1> 
  3160                              <1> 
  3161                              <1> 
  3162                              <1> ;-------------------------------------------------------------------
  3163                              <1> ; NUMBER
  3164                              <1> 
  3165                              <1> do_number:
  3166 00003BCD E89A08              <1> 	call get_token			; Check if it's string to number, or number to string
  3167                              <1> 
  3168 00003BD0 83F802              <1> 	cmp ax, STRING_VAR
  3169 00003BD3 7407                <1> 	je .is_string
  3170                              <1> 
  3171 00003BD5 83F801              <1> 	cmp ax, VARIABLE
  3172 00003BD8 742C                <1> 	je .is_variable
  3173                              <1> 
  3174 00003BDA EB54                <1> 	jmp .error
  3175                              <1> 
  3176                              <1> .is_string:
  3177                              <1> 
  3178 00003BDC BE007C              <1> 	mov si, string_vars
  3179 00003BDF B88000              <1> 	mov ax, 128
  3180 00003BE2 F7E3                <1> 	mul bx
  3181 00003BE4 01C6                <1> 	add si, ax
  3182 00003BE6 8936[363C]          <1> 	mov [.tmp], si
  3183                              <1> 
  3184 00003BEA E87D08              <1> 	call get_token
  3185                              <1> 
  3186 00003BED 8B36[363C]          <1> 	mov si, [.tmp]
  3187                              <1> 
  3188 00003BF1 83F801              <1> 	cmp ax, VARIABLE
  3189 00003BF4 753A                <1> 	jne .error
  3190                              <1> 
  3191 00003BF6 E804EF              <1> 	call os_string_to_int
  3192 00003BF9 89C3                <1> 	mov bx, ax
  3193                              <1> 
  3194 00003BFB 0FB606007B          <1> 	movzx ax, byte [token]
  3195 00003C00 E85808              <1> 	call set_var
  3196                              <1> 
  3197 00003C03 E9F4F0              <1> 	jmp mainloop
  3198                              <1> 
  3199                              <1> .is_variable:
  3200 00003C06 0FB606007B          <1> 	movzx ax, byte [token]
  3201 00003C0B E84008              <1> 	call get_var
  3202                              <1> 
  3203 00003C0E E837EF              <1> 	call os_int_to_string		; Convert to a string
  3204 00003C11 A3[363C]            <1> 	mov [.tmp], ax
  3205                              <1> 
  3206 00003C14 E85308              <1> 	call get_token			; Get the second parameter
  3207                              <1> 
  3208 00003C17 8B36[363C]          <1> 	mov si, [.tmp]
  3209                              <1> 
  3210 00003C1B 83F802              <1> 	cmp ax, STRING_VAR		; Make sure it's a string variable
  3211 00003C1E 7510                <1> 	jne .error
  3212                              <1> 
  3213 00003C20 BF007C              <1> 	mov di, string_vars		; Locate string variable
  3214 00003C23 B88000              <1> 	mov ax, 128
  3215 00003C26 F7E3                <1> 	mul bx
  3216 00003C28 01C7                <1> 	add di, ax
  3217                              <1> 
  3218 00003C2A E81DEE              <1> 	call os_string_copy		; Save converted string
  3219                              <1> 
  3220 00003C2D E9CAF0              <1> 	jmp mainloop
  3221                              <1> 
  3222                              <1> .error:
  3223 00003C30 BE1400              <1> 	mov si, err_syntax
  3224 00003C33 E94D09              <1> 	jmp error
  3225                              <1> 
  3226                              <1> 
  3227 00003C36 0000                <1> 	.tmp		dw 	0
  3228                              <1> 
  3229                              <1> 
  3230                              <1> ;-------------------------------------------------------------------
  3231                              <1> ; PAGE
  3232                              <1> 
  3233                              <1> do_page:
  3234 00003C38 E82F08              <1> 	call get_token
  3235 00003C3B 83F803              <1> 	cmp ax, NUMBER
  3236 00003C3E 7521                <1> 	jne .error
  3237                              <1> 
  3238 00003C40 BE007B              <1> 	mov si, token
  3239 00003C43 E8B7EE              <1> 	call os_string_to_int
  3240 00003C46 A2[F845]            <1> 	mov byte [work_page], al	; Set work page variable
  3241                              <1> 
  3242 00003C49 E81E08              <1> 	call get_token
  3243 00003C4C 83F803              <1> 	cmp ax, NUMBER
  3244 00003C4F 7510                <1> 	jne .error
  3245                              <1> 
  3246 00003C51 BE007B              <1> 	mov si, token
  3247 00003C54 E8A6EE              <1> 	call os_string_to_int
  3248 00003C57 A2[F945]            <1> 	mov byte [disp_page], al	; Set display page variable
  3249                              <1> 
  3250                              <1> 	; Change display page -- AL should already be present from the os_string_to_int
  3251 00003C5A B405                <1> 	mov ah, 5
  3252 00003C5C CD10                <1> 	int 10h
  3253                              <1> 
  3254 00003C5E E999F0              <1> 	jmp mainloop
  3255                              <1> 
  3256                              <1> .error:
  3257 00003C61 BE1400              <1> 	mov si, err_syntax
  3258 00003C64 E91C09              <1> 	jmp error
  3259                              <1> 
  3260                              <1> 
  3261                              <1> ; ------------------------------------------------------------------
  3262                              <1> ; PAUSE
  3263                              <1> 
  3264                              <1> do_pause:
  3265 00003C67 E80008              <1> 	call get_token
  3266                              <1> 
  3267 00003C6A 83F801              <1> 	cmp ax, VARIABLE
  3268 00003C6D 7408                <1> 	je .is_var
  3269                              <1> 
  3270 00003C6F BE007B              <1> 	mov si, token
  3271 00003C72 E888EE              <1> 	call os_string_to_int
  3272 00003C75 EB08                <1> 	jmp .finish
  3273                              <1> 
  3274                              <1> .is_var:
  3275 00003C77 0FB606007B          <1> 	movzx ax, byte [token]
  3276 00003C7C E8CF07              <1> 	call get_var
  3277                              <1> 
  3278                              <1> .finish:
  3279 00003C7F E84AD8              <1> 	call os_pause
  3280 00003C82 E975F0              <1> 	jmp mainloop
  3281                              <1> 
  3282                              <1> 
  3283                              <1> ; ------------------------------------------------------------------
  3284                              <1> ; PEEK
  3285                              <1> 
  3286                              <1> do_peek:
  3287 00003C85 E8E207              <1> 	call get_token
  3288                              <1> 
  3289 00003C88 83F801              <1> 	cmp ax, VARIABLE
  3290 00003C8B 7533                <1> 	jne .error
  3291                              <1> 
  3292 00003C8D 0FB606007B          <1> 	movzx ax, byte [token]
  3293 00003C92 A2[C63C]            <1> 	mov byte [.tmp_var], al
  3294                              <1> 
  3295 00003C95 E8D207              <1> 	call get_token
  3296                              <1> 
  3297 00003C98 83F801              <1> 	cmp ax, VARIABLE
  3298 00003C9B 741B                <1> 	je .dereference
  3299                              <1> 
  3300 00003C9D 83F803              <1> 	cmp ax, NUMBER
  3301 00003CA0 751E                <1> 	jne .error
  3302                              <1> 
  3303 00003CA2 BE007B              <1> 	mov si, token
  3304 00003CA5 E855EE              <1> 	call os_string_to_int
  3305                              <1> 
  3306                              <1> .store:
  3307 00003CA8 89C6                <1> 	mov si, ax
  3308 00003CAA 0FB61C              <1> 	movzx bx, byte [si]
  3309 00003CAD 0FB606[C63C]        <1> 	movzx ax, byte [.tmp_var]
  3310 00003CB2 E8A607              <1> 	call set_var
  3311                              <1> 
  3312 00003CB5 E942F0              <1> 	jmp mainloop
  3313                              <1> 
  3314                              <1> .dereference:
  3315 00003CB8 A0007B              <1> 	mov byte al, [token]
  3316 00003CBB E89007              <1> 	call get_var
  3317 00003CBE EBE8                <1> 	jmp .store
  3318                              <1> 
  3319                              <1> .error:
  3320 00003CC0 BE1400              <1> 	mov si, err_syntax
  3321 00003CC3 E9BD08              <1> 	jmp error
  3322                              <1> 
  3323                              <1> 
  3324 00003CC6 00                  <1> 	.tmp_var	db 0
  3325                              <1> 	
  3326                              <1> 	
  3327                              <1> 	
  3328                              <1> ; ------------------------------------------------------------------
  3329                              <1> ; PEEKINT
  3330                              <1> 
  3331                              <1> do_peekint:
  3332 00003CC7 E8A007              <1> 	call get_token
  3333                              <1> 	
  3334 00003CCA 83F801              <1> 	cmp ax, VARIABLE
  3335 00003CCD 752C                <1> 	jne .error
  3336                              <1> 
  3337                              <1> .get_second:
  3338 00003CCF A0007B              <1> 	mov al, [token]
  3339 00003CD2 89C1                <1> 	mov cx, ax
  3340                              <1> 	
  3341 00003CD4 E89307              <1> 	call get_token
  3342                              <1> 	
  3343 00003CD7 83F801              <1> 	cmp ax, VARIABLE
  3344 00003CDA 740D                <1> 	je .address_is_var
  3345                              <1> 	
  3346 00003CDC 83F803              <1> 	cmp ax, NUMBER
  3347 00003CDF 751A                <1> 	jne .error
  3348                              <1> 	
  3349                              <1> .address_is_number:
  3350 00003CE1 BE007B              <1> 	mov si, token
  3351 00003CE4 E816EE              <1> 	call os_string_to_int
  3352 00003CE7 EB06                <1> 	jmp .load_data
  3353                              <1> 	
  3354                              <1> .address_is_var:
  3355 00003CE9 A0007B              <1> 	mov al, [token]
  3356 00003CEC E85F07              <1> 	call get_var
  3357                              <1> 	
  3358                              <1> .load_data:
  3359 00003CEF 89C6                <1> 	mov si, ax
  3360 00003CF1 8B1C                <1> 	mov bx, [si]
  3361 00003CF3 89C8                <1> 	mov ax, cx
  3362 00003CF5 E86307              <1> 	call set_var
  3363                              <1> 	
  3364 00003CF8 E9FFEF              <1> 	jmp mainloop
  3365                              <1> 	
  3366                              <1> .error:
  3367 00003CFB BE1400              <1> 	mov si, err_syntax
  3368 00003CFE E98208              <1> 	jmp error
  3369                              <1> 
  3370                              <1> 
  3371                              <1> 
  3372                              <1> ; ------------------------------------------------------------------
  3373                              <1> ; POKE
  3374                              <1> 
  3375                              <1> do_poke:
  3376 00003D01 E86607              <1> 	call get_token
  3377                              <1> 
  3378 00003D04 83F801              <1> 	cmp ax, VARIABLE
  3379 00003D07 7415                <1> 	je .first_is_var
  3380                              <1> 
  3381 00003D09 83F803              <1> 	cmp ax, NUMBER
  3382 00003D0C 7544                <1> 	jne .error
  3383                              <1> 
  3384 00003D0E BE007B              <1> 	mov si, token
  3385 00003D11 E8E9ED              <1> 	call os_string_to_int
  3386                              <1> 
  3387 00003D14 3DFF00              <1> 	cmp ax, 255
  3388 00003D17 7F39                <1> 	jg .error
  3389                              <1> 
  3390 00003D19 A2[583D]            <1> 	mov byte [.first_value], al
  3391 00003D1C EB0B                <1> 	jmp .onto_second
  3392                              <1> 
  3393                              <1> 
  3394                              <1> .first_is_var:
  3395 00003D1E 0FB606007B          <1> 	movzx ax, byte [token]
  3396 00003D23 E82807              <1> 	call get_var
  3397                              <1> 
  3398 00003D26 A2[583D]            <1> 	mov byte [.first_value], al
  3399                              <1> 
  3400                              <1> .onto_second:
  3401 00003D29 E83E07              <1> 	call get_token
  3402                              <1> 
  3403 00003D2C 83F801              <1> 	cmp ax, VARIABLE
  3404 00003D2F 7417                <1> 	je .second_is_var
  3405                              <1> 
  3406 00003D31 83F803              <1> 	cmp ax, NUMBER
  3407 00003D34 751C                <1> 	jne .error
  3408                              <1> 
  3409 00003D36 BE007B              <1> 	mov si, token
  3410 00003D39 E8C1ED              <1> 	call os_string_to_int
  3411                              <1> 
  3412                              <1> .got_value:
  3413 00003D3C 89C7                <1> 	mov di, ax
  3414 00003D3E 0FB606[583D]        <1> 	movzx ax, byte [.first_value]
  3415 00003D43 8805                <1> 	mov byte [di], al
  3416                              <1> 
  3417 00003D45 E9B2EF              <1> 	jmp mainloop
  3418                              <1> 
  3419                              <1> .second_is_var:
  3420 00003D48 0FB606007B          <1> 	movzx ax, byte [token]
  3421 00003D4D E8FE06              <1> 	call get_var
  3422 00003D50 EBEA                <1> 	jmp .got_value
  3423                              <1> 
  3424                              <1> .error:
  3425 00003D52 BE1400              <1> 	mov si, err_syntax
  3426 00003D55 E92B08              <1> 	jmp error
  3427                              <1> 
  3428                              <1> 
  3429 00003D58 00                  <1> 	.first_value	db 0
  3430                              <1> 
  3431                              <1> 
  3432                              <1> 
  3433                              <1> 
  3434                              <1> ; ------------------------------------------------------------------
  3435                              <1> ; POKEINT
  3436                              <1> 
  3437                              <1> do_pokeint:
  3438 00003D59 E80E07              <1> 	call get_token
  3439                              <1> 	
  3440 00003D5C 83F801              <1> 	cmp ax, VARIABLE
  3441 00003D5F 740D                <1> 	je .data_is_var
  3442                              <1> 	
  3443 00003D61 83F803              <1> 	cmp ax, NUMBER
  3444 00003D64 7532                <1> 	jne .error
  3445                              <1> 
  3446                              <1> .data_is_num:
  3447 00003D66 BE007B              <1> 	mov si, token
  3448 00003D69 E891ED              <1> 	call os_string_to_int
  3449 00003D6C EB06                <1> 	jmp .get_second
  3450                              <1> 	
  3451                              <1> .data_is_var:
  3452 00003D6E A0007B              <1> 	mov al, [token]
  3453 00003D71 E8DA06              <1> 	call get_var
  3454                              <1> 	
  3455                              <1> .get_second:
  3456 00003D74 89C1                <1> 	mov cx, ax
  3457                              <1> 	
  3458 00003D76 E8F106              <1> 	call get_token
  3459                              <1> 	
  3460 00003D79 83F801              <1> 	cmp ax, VARIABLE
  3461 00003D7C 740D                <1> 	je .address_is_var
  3462                              <1> 	
  3463 00003D7E 83F803              <1> 	cmp ax, NUMBER
  3464 00003D81 7515                <1> 	jne .error
  3465                              <1> 	
  3466                              <1> .address_is_num:
  3467 00003D83 BE007B              <1> 	mov si, token
  3468 00003D86 E874ED              <1> 	call os_string_to_int
  3469 00003D89 EB06                <1> 	jmp .save_data
  3470                              <1> 	
  3471                              <1> .address_is_var:
  3472 00003D8B A0007B              <1> 	mov al, [token]
  3473 00003D8E E8BD06              <1> 	call get_var
  3474                              <1> 	
  3475                              <1> .save_data:
  3476 00003D91 89C6                <1> 	mov si, ax
  3477 00003D93 890C                <1> 	mov [si], cx
  3478                              <1> 	
  3479 00003D95 E962EF              <1> 	jmp mainloop
  3480                              <1> 	
  3481                              <1> .error:
  3482 00003D98 BE1400              <1> 	mov si, err_syntax
  3483 00003D9B E9E507              <1> 	jmp error
  3484                              <1> 
  3485                              <1> 
  3486                              <1> 
  3487                              <1> 
  3488                              <1> ; ------------------------------------------------------------------
  3489                              <1> ; PORT
  3490                              <1> 
  3491                              <1> do_port:
  3492 00003D9E E8C906              <1> 	call get_token
  3493 00003DA1 BE007B              <1> 	mov si, token
  3494                              <1> 
  3495 00003DA4 BF[193E]            <1> 	mov di, .out_cmd
  3496 00003DA7 E8FFEC              <1> 	call os_string_compare
  3497 00003DAA 720A                <1> 	jc .do_out_cmd
  3498                              <1> 
  3499 00003DAC BF[1D3E]            <1> 	mov di, .in_cmd
  3500 00003DAF E8F7EC              <1> 	call os_string_compare
  3501 00003DB2 7237                <1> 	jc .do_in_cmd
  3502                              <1> 
  3503 00003DB4 EB5D                <1> 	jmp .error
  3504                              <1> 
  3505                              <1> 
  3506                              <1> .do_out_cmd:
  3507 00003DB6 E8B106              <1> 	call get_token
  3508 00003DB9 83F803              <1> 	cmp ax, NUMBER
  3509 00003DBC 7555                <1> 	jne .error
  3510                              <1> 
  3511 00003DBE BE007B              <1> 	mov si, token
  3512 00003DC1 E839ED              <1> 	call os_string_to_int		; Now AX = port number
  3513 00003DC4 89C2                <1> 	mov dx, ax
  3514                              <1> 
  3515 00003DC6 E8A106              <1> 	call get_token
  3516 00003DC9 83F803              <1> 	cmp ax, NUMBER
  3517 00003DCC 7407                <1> 	je .out_is_num
  3518                              <1> 
  3519 00003DCE 83F801              <1> 	cmp ax, VARIABLE
  3520 00003DD1 740C                <1> 	je .out_is_var
  3521                              <1> 
  3522 00003DD3 EB3E                <1> 	jmp .error
  3523                              <1> 
  3524                              <1> .out_is_num:
  3525 00003DD5 BE007B              <1> 	mov si, token
  3526 00003DD8 E822ED              <1> 	call os_string_to_int
  3527 00003DDB EE                  <1> 	out dx, al
  3528 00003DDC E91BEF              <1> 	jmp mainloop
  3529                              <1> 
  3530                              <1> .out_is_var:
  3531 00003DDF 0FB606007B          <1> 	movzx ax, byte [token]
  3532 00003DE4 E86706              <1> 	call get_var
  3533                              <1> 
  3534 00003DE7 EE                  <1> 	out dx, al
  3535 00003DE8 E90FEF              <1> 	jmp mainloop
  3536                              <1> 
  3537                              <1> 
  3538                              <1> .do_in_cmd:
  3539 00003DEB E87C06              <1> 	call get_token
  3540 00003DEE 83F803              <1> 	cmp ax, NUMBER
  3541 00003DF1 7520                <1> 	jne .error
  3542                              <1> 
  3543 00003DF3 BE007B              <1> 	mov si, token
  3544 00003DF6 E804ED              <1> 	call os_string_to_int
  3545 00003DF9 89C2                <1> 	mov dx, ax
  3546                              <1> 
  3547 00003DFB E86C06              <1> 	call get_token
  3548 00003DFE 83F801              <1> 	cmp ax, VARIABLE
  3549 00003E01 7510                <1> 	jne .error
  3550                              <1> 
  3551 00003E03 8A0E007B            <1> 	mov byte cl, [token]
  3552                              <1> 
  3553 00003E07 EC                  <1> 	in al, dx
  3554 00003E08 0FB6D8              <1> 	movzx bx, al
  3555                              <1> 
  3556 00003E0B 88C8                <1> 	mov al, cl
  3557 00003E0D E84B06              <1> 	call set_var
  3558                              <1> 
  3559 00003E10 E9E7EE              <1> 	jmp mainloop
  3560                              <1> 
  3561                              <1> 
  3562                              <1> .error:
  3563 00003E13 BE1400              <1> 	mov si, err_syntax
  3564 00003E16 E96A07              <1> 	jmp error
  3565                              <1> 
  3566                              <1> 
  3567 00003E19 4F555400            <1> 	.out_cmd	db "OUT", 0
  3568 00003E1D 494E00              <1> 	.in_cmd		db "IN", 0
  3569                              <1> 
  3570                              <1> 
  3571                              <1> ; ------------------------------------------------------------------
  3572                              <1> ; PRINT
  3573                              <1> 
  3574                              <1> do_print:
  3575 00003E20 E84706              <1> 	call get_token				; Get part after PRINT
  3576                              <1> 
  3577 00003E23 83F805              <1> 	cmp ax, QUOTE				; What type is it?
  3578 00003E26 7428                <1> 	je .print_quote
  3579                              <1> 
  3580 00003E28 83F801              <1> 	cmp ax, VARIABLE			; Numerical variable (eg X)
  3581 00003E2B 7410                <1> 	je .print_var
  3582                              <1> 
  3583 00003E2D 83F802              <1> 	cmp ax, STRING_VAR			; String variable (eg $1)
  3584 00003E30 7457                <1> 	je .print_string_var
  3585                              <1> 
  3586 00003E32 83F804              <1> 	cmp ax, STRING				; Special keyword (eg CHR or HEX)
  3587 00003E35 745E                <1> 	je .print_keyword
  3588                              <1> 
  3589 00003E37 BE1000              <1> 	mov si, err_print_type			; We only print quoted strings and vars!
  3590 00003E3A E94607              <1> 	jmp error
  3591                              <1> 
  3592                              <1> 
  3593                              <1> .print_var:
  3594 00003E3D 0FB606007B          <1> 	movzx ax, byte [token]
  3595 00003E42 E80906              <1> 	call get_var				; Get its value
  3596                              <1> 
  3597 00003E45 E800ED              <1> 	call os_int_to_string			; Convert to string
  3598 00003E48 89C6                <1> 	mov si, ax
  3599 00003E4A E8A8D9              <1> 	call os_print_string
  3600                              <1> 
  3601 00003E4D E9C500              <1> 	jmp .newline_or_not
  3602                              <1> 
  3603                              <1> 
  3604                              <1> .print_quote:					; If it's quoted text, print it
  3605 00003E50 BE007B              <1> 	mov si, token
  3606                              <1> .print_quote_loop:
  3607 00003E53 AC                  <1> 	lodsb
  3608 00003E54 3C00                <1> 	cmp al, 0
  3609 00003E56 0F84BB00            <1> 	je .newline_or_not
  3610                              <1> 
  3611 00003E5A B409                <1> 	mov ah, 09h
  3612 00003E5C 8A1E[F745]          <1> 	mov byte bl, [ink_colour]
  3613 00003E60 8A3E[F845]          <1> 	mov byte bh, [work_page]
  3614 00003E64 B90100              <1> 	mov cx, 1
  3615 00003E67 CD10                <1> 	int 10h
  3616                              <1> 
  3617 00003E69 B403                <1> 	mov ah, 3
  3618 00003E6B CD10                <1> 	int 10h
  3619                              <1> 
  3620 00003E6D 80FA4F              <1> 	cmp dl, 79
  3621 00003E70 7D0C                <1> 	jge .quote_newline
  3622 00003E72 FEC2                <1> 	inc dl
  3623                              <1> 
  3624                              <1> .move_cur_quote:
  3625 00003E74 8A3E[F845]          <1> 	mov byte bh, [work_page]
  3626 00003E78 B402                <1> 	mov ah, 02h
  3627 00003E7A CD10                <1> 	int 10h
  3628 00003E7C EBD5                <1> 	jmp .print_quote_loop
  3629                              <1> 
  3630                              <1> 
  3631                              <1> .quote_newline:
  3632 00003E7E 80FE18              <1> 	cmp dh, 24
  3633 00003E81 74F1                <1> 	je .move_cur_quote
  3634 00003E83 B200                <1> 	mov dl, 0
  3635 00003E85 FEC6                <1> 	inc dh
  3636 00003E87 EBEB                <1> 	jmp .move_cur_quote
  3637                              <1> 
  3638                              <1> .print_string_var:
  3639 00003E89 BE007C              <1> 	mov si, string_vars
  3640 00003E8C B88000              <1> 	mov ax, 128
  3641 00003E8F F7E3                <1> 	mul bx
  3642 00003E91 01C6                <1> 	add si, ax
  3643                              <1> 
  3644 00003E93 EBBE                <1> 	jmp .print_quote_loop
  3645                              <1> 
  3646                              <1> 
  3647                              <1> .print_keyword:
  3648 00003E95 BE007B              <1> 	mov si, token
  3649 00003E98 BF[2247]            <1> 	mov di, chr_keyword
  3650 00003E9B E80BEC              <1> 	call os_string_compare
  3651 00003E9E 720E                <1> 	jc .is_chr
  3652                              <1> 
  3653 00003EA0 BF[2647]            <1> 	mov di, hex_keyword
  3654 00003EA3 E803EC              <1> 	call os_string_compare
  3655 00003EA6 7243                <1> 	jc .is_hex
  3656                              <1> 
  3657 00003EA8 BE1400              <1> 	mov si, err_syntax
  3658 00003EAB E9D506              <1> 	jmp error
  3659                              <1> 
  3660                              <1> .is_chr:
  3661 00003EAE E8B905              <1> 	call get_token
  3662                              <1> 
  3663 00003EB1 83F801              <1> 	cmp ax, VARIABLE
  3664 00003EB4 7405                <1> 	je .is_chr_variable
  3665                              <1> 	
  3666 00003EB6 83F803              <1> 	cmp ax, NUMBER
  3667 00003EB9 740A                <1> 	je .is_chr_number
  3668                              <1> 
  3669                              <1> .is_chr_variable:
  3670 00003EBB 0FB606007B          <1> 	movzx ax, byte [token]
  3671 00003EC0 E88B05              <1> 	call get_var
  3672 00003EC3 EB06                <1> 	jmp .print_chr
  3673                              <1> 	
  3674                              <1> .is_chr_number:
  3675 00003EC5 BE007B              <1> 	mov si, token
  3676 00003EC8 E832EC              <1> 	call os_string_to_int
  3677                              <1> 
  3678                              <1> .print_chr:
  3679 00003ECB B409                <1> 	mov ah, 09h
  3680 00003ECD 8A1E[F745]          <1> 	mov byte bl, [ink_colour]
  3681 00003ED1 8A3E[F845]          <1> 	mov byte bh, [work_page]
  3682 00003ED5 B90100              <1> 	mov cx, 1
  3683 00003ED8 CD10                <1> 	int 10h
  3684                              <1> 
  3685 00003EDA B403                <1> 	mov ah, 3		; Move the cursor forward
  3686 00003EDC CD10                <1> 	int 10h
  3687 00003EDE FEC2                <1> 	inc dl
  3688 00003EE0 80FA4F              <1> 	cmp dl, 79
  3689 00003EE3 7F1B                <1> 	jg .end_line		; If it's over the end of the line
  3690                              <1> .move_cur:
  3691 00003EE5 B402                <1> 	mov ah, 2
  3692 00003EE7 CD10                <1> 	int 10h
  3693                              <1> 
  3694 00003EE9 EB2A                <1> 	jmp .newline_or_not
  3695                              <1> 
  3696                              <1> 
  3697                              <1> .is_hex:
  3698 00003EEB E87C05              <1> 	call get_token
  3699                              <1> 
  3700 00003EEE 83F801              <1> 	cmp ax, VARIABLE
  3701 00003EF1 751C                <1> 	jne .error
  3702                              <1> 
  3703 00003EF3 0FB606007B          <1> 	movzx ax, byte [token]
  3704 00003EF8 E85305              <1> 	call get_var
  3705                              <1> 
  3706 00003EFB E898E2              <1> 	call os_print_2hex
  3707                              <1> 
  3708 00003EFE EB15                <1> 	jmp .newline_or_not
  3709                              <1> 
  3710                              <1> .end_line:
  3711 00003F00 B200                <1> 	mov dl, 0
  3712 00003F02 FEC6                <1> 	inc dh
  3713 00003F04 80FE19              <1> 	cmp dh, 25
  3714 00003F07 7CDC                <1> 	jl .move_cur
  3715 00003F09 B618                <1> 	mov dh, 24
  3716 00003F0B B24F                <1> 	mov dl, 79
  3717 00003F0D EBD6                <1> 	jmp .move_cur
  3718                              <1> 
  3719                              <1> .error:
  3720 00003F0F BE1400              <1> 	mov si, err_syntax
  3721 00003F12 E96E06              <1> 	jmp error
  3722                              <1> 	
  3723                              <1> 
  3724                              <1> 
  3725                              <1> .newline_or_not:
  3726                              <1> 	; We want to see if the command ends with ';' -- which means that
  3727                              <1> 	; we shouldn't print a newline after it finishes. So we store the
  3728                              <1> 	; current program location to pop ahead and see if there's the ';'
  3729                              <1> 	; character -- otherwise we put the program location back and resume
  3730                              <1> 	; the main loop
  3731                              <1> 
  3732 00003F15 A1[EE45]            <1> 	mov word ax, [prog]
  3733 00003F18 A3[4B3F]            <1> 	mov word [.tmp_loc], ax
  3734                              <1> 
  3735 00003F1B E84C05              <1> 	call get_token
  3736 00003F1E 83F807              <1> 	cmp ax, UNKNOWN
  3737 00003F21 750C                <1> 	jne .ignore
  3738                              <1> 
  3739 00003F23 0FB606007B          <1> 	movzx ax, byte [token]
  3740 00003F28 3C3B                <1> 	cmp al, ';'
  3741 00003F2A 7503                <1> 	jne .ignore
  3742                              <1> 
  3743 00003F2C E9CBED              <1> 	jmp mainloop				; And go back to interpreting the code!
  3744                              <1> 
  3745                              <1> .ignore:
  3746 00003F2F B405                <1> 	mov ah, 5
  3747 00003F31 A0[F845]            <1> 	mov al, [work_page]
  3748 00003F34 CD10                <1> 	int 10h
  3749                              <1> 
  3750 00003F36 8A3E[F845]          <1> 	mov bh, [work_page]
  3751 00003F3A E805E0              <1> 	call os_print_newline
  3752                              <1> 
  3753 00003F3D B405                <1> 	mov ah, 5
  3754 00003F3F A0[F945]            <1> 	mov al, [disp_page]
  3755                              <1> 
  3756 00003F42 A1[4B3F]            <1> 	mov word ax, [.tmp_loc]
  3757 00003F45 A3[EE45]            <1> 	mov word [prog], ax
  3758                              <1> 
  3759 00003F48 E9AFED              <1> 	jmp mainloop
  3760                              <1> 
  3761                              <1> 
  3762 00003F4B 0000                <1> 	.tmp_loc	dw 0
  3763                              <1> 
  3764                              <1> 
  3765                              <1> ; ------------------------------------------------------------------
  3766                              <1> ; RAND
  3767                              <1> 
  3768                              <1> do_rand:
  3769 00003F4D E81A05              <1> 	call get_token
  3770 00003F50 83F801              <1> 	cmp ax, VARIABLE
  3771 00003F53 7544                <1> 	jne .error
  3772                              <1> 
  3773 00003F55 A0007B              <1> 	mov byte al, [token]
  3774 00003F58 A2[943F]            <1> 	mov byte [.tmp], al
  3775                              <1> 
  3776 00003F5B E80C05              <1> 	call get_token
  3777 00003F5E 83F803              <1> 	cmp ax, NUMBER
  3778 00003F61 7536                <1> 	jne .error
  3779                              <1> 
  3780 00003F63 BE007B              <1> 	mov si, token
  3781 00003F66 E894EB              <1> 	call os_string_to_int
  3782 00003F69 A3[953F]            <1> 	mov word [.num1], ax
  3783                              <1> 
  3784 00003F6C E8FB04              <1> 	call get_token
  3785 00003F6F 83F803              <1> 	cmp ax, NUMBER
  3786 00003F72 7525                <1> 	jne .error
  3787                              <1> 
  3788 00003F74 BE007B              <1> 	mov si, token
  3789 00003F77 E883EB              <1> 	call os_string_to_int
  3790 00003F7A A3[973F]            <1> 	mov word [.num2], ax
  3791                              <1> 
  3792 00003F7D A1[953F]            <1> 	mov word ax, [.num1]
  3793 00003F80 8B1E[973F]          <1> 	mov word bx, [.num2]
  3794 00003F84 E857D4              <1> 	call os_get_random
  3795                              <1> 
  3796 00003F87 89CB                <1> 	mov bx, cx
  3797 00003F89 0FB606[943F]        <1> 	movzx ax, byte [.tmp]
  3798 00003F8E E8CA04              <1> 	call set_var
  3799                              <1> 
  3800 00003F91 E966ED              <1> 	jmp mainloop
  3801                              <1> 
  3802                              <1> 
  3803 00003F94 00                  <1> 	.tmp	db 0
  3804 00003F95 0000                <1> 	.num1	dw 0
  3805 00003F97 0000                <1> 	.num2	dw 0
  3806                              <1> 
  3807                              <1> 
  3808                              <1> .error:
  3809 00003F99 BE1400              <1> 	mov si, err_syntax
  3810 00003F9C E9E405              <1> 	jmp error
  3811                              <1> 
  3812                              <1> 
  3813                              <1> ; ------------------------------------------------------------------
  3814                              <1> ; READ
  3815                              <1> 
  3816                              <1> do_read:
  3817 00003F9F E8C804              <1> 	call get_token				; Get the next token
  3818                              <1> 
  3819 00003FA2 83F804              <1> 	cmp ax, STRING				; Check for a label
  3820 00003FA5 7406                <1> 	je .is_ok
  3821                              <1> 
  3822 00003FA7 BE0500              <1> 	mov si, err_goto_notlabel
  3823 00003FAA E9D605              <1> 	jmp error
  3824                              <1> 
  3825                              <1> .is_ok:
  3826 00003FAD BE007B              <1> 	mov si, token				; Back up this label
  3827 00003FB0 BFE27A              <1> 	mov di, .tmp_token
  3828 00003FB3 E894EA              <1> 	call os_string_copy
  3829                              <1> 
  3830 00003FB6 B8E27A              <1> 	mov ax, .tmp_token
  3831 00003FB9 E8FBE9              <1> 	call os_string_length
  3832                              <1> 
  3833 00003FBC BFE27A              <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  3834 00003FBF 01C7                <1> 	add di, ax
  3835 00003FC1 B03A                <1> 	mov al, ':'
  3836 00003FC3 AA                  <1> 	stosb
  3837 00003FC4 B000                <1> 	mov al, 0
  3838 00003FC6 AA                  <1> 	stosb
  3839                              <1> 
  3840 00003FC7 E8A004              <1> 	call get_token				; Now get the offset variable
  3841 00003FCA 83F801              <1> 	cmp ax, VARIABLE
  3842 00003FCD 7406                <1> 	je .second_part_is_var
  3843                              <1> 
  3844 00003FCF BE1400              <1> 	mov si, err_syntax
  3845 00003FD2 E9AE05              <1> 	jmp error
  3846                              <1> 
  3847                              <1> 
  3848                              <1> .second_part_is_var:
  3849 00003FD5 0FB606007B          <1> 	movzx ax, byte [token]
  3850 00003FDA E87104              <1> 	call get_var
  3851                              <1> 
  3852 00003FDD 83F800              <1> 	cmp ax, 0				; Want to be searching for at least the first byte!
  3853 00003FE0 7F06                <1> 	jg .var_bigger_than_zero
  3854                              <1> 
  3855 00003FE2 BE1400              <1> 	mov si, err_syntax
  3856 00003FE5 E99B05              <1> 	jmp error
  3857                              <1> 
  3858                              <1> 
  3859                              <1> .var_bigger_than_zero:
  3860 00003FE8 A3[7240]            <1> 	mov word [.to_skip], ax
  3861                              <1> 
  3862                              <1> 
  3863 00003FEB E87C04              <1> 	call get_token				; And now the var to store result into
  3864 00003FEE 83F801              <1> 	cmp ax, VARIABLE
  3865 00003FF1 7406                <1> 	je .third_part_is_var
  3866                              <1> 
  3867 00003FF3 BE1400              <1> 	mov si, err_syntax
  3868 00003FF6 E98A05              <1> 	jmp error
  3869                              <1> 
  3870                              <1> 
  3871                              <1> .third_part_is_var:				; Keep it for later
  3872 00003FF9 0FB606007B          <1> 	movzx ax, byte [token]
  3873 00003FFE A2[7440]            <1> 	mov byte [.var_to_use], al
  3874                              <1> 
  3875                              <1> 
  3876                              <1> 
  3877                              <1> 	; OK, so now we have all the stuff we need. Let's search for the label
  3878                              <1> 
  3879 00004001 A1[EE45]            <1> 	mov word ax, [prog]			; Store current location
  3880 00004004 A3[7040]            <1> 	mov word [.curr_location], ax
  3881                              <1> 
  3882 00004007 A1[F245]            <1> 	mov word ax, [load_point]
  3883 0000400A A3[EE45]            <1> 	mov word [prog], ax			; Return to start of program to find label
  3884                              <1> 
  3885                              <1> .loop:
  3886 0000400D E85A04              <1> 	call get_token
  3887                              <1> 
  3888 00004010 83F808              <1> 	cmp ax, LABEL
  3889 00004013 750B                <1> 	jne .line_loop
  3890                              <1> 
  3891 00004015 BE007B              <1> 	mov si, token
  3892 00004018 BFE27A              <1> 	mov di, .tmp_token
  3893 0000401B E88BEA              <1> 	call os_string_compare
  3894 0000401E 7221                <1> 	jc .found_label
  3895                              <1> 
  3896                              <1> .line_loop:					; Go to end of line
  3897 00004020 8B36[EE45]          <1> 	mov word si, [prog]
  3898 00004024 8A04                <1> 	mov byte al, [si]
  3899 00004026 FF06[EE45]          <1> 	inc word [prog]
  3900                              <1> 
  3901 0000402A 3C0A                <1> 	cmp al, 10
  3902 0000402C 75F2                <1> 	jne .line_loop
  3903                              <1> 
  3904 0000402E A1[EE45]            <1> 	mov word ax, [prog]
  3905 00004031 8B1E[F045]          <1> 	mov word bx, [prog_end]
  3906 00004035 39D8                <1> 	cmp ax, bx
  3907 00004037 7F02                <1> 	jg .past_end
  3908                              <1> 
  3909 00004039 EBD2                <1> 	jmp .loop
  3910                              <1> 
  3911                              <1> .past_end:
  3912 0000403B BE0600              <1> 	mov si, err_label_notfound
  3913 0000403E E94205              <1> 	jmp error
  3914                              <1> 
  3915                              <1> 
  3916                              <1> .found_label:
  3917 00004041 8B0E[7240]          <1> 	mov word cx, [.to_skip]			; Skip requested number of data entries
  3918                              <1> 
  3919                              <1> .data_skip_loop:
  3920 00004045 51                  <1> 	push cx
  3921 00004046 E82104              <1> 	call get_token
  3922 00004049 59                  <1> 	pop cx
  3923 0000404A E2F9                <1> 	loop .data_skip_loop
  3924                              <1> 
  3925 0000404C 83F803              <1> 	cmp ax, NUMBER
  3926 0000404F 7406                <1> 	je .data_is_num
  3927                              <1> 
  3928 00004051 BE1400              <1> 	mov si, err_syntax
  3929 00004054 E92C05              <1> 	jmp error
  3930                              <1> 
  3931                              <1> .data_is_num:
  3932 00004057 BE007B              <1> 	mov si, token
  3933 0000405A E8A0EA              <1> 	call os_string_to_int
  3934                              <1> 
  3935 0000405D 89C3                <1> 	mov bx, ax
  3936 0000405F 0FB606[7440]        <1> 	movzx ax, byte [.var_to_use]
  3937 00004064 E8F403              <1> 	call set_var
  3938                              <1> 
  3939 00004067 A1[7040]            <1> 	mov word ax, [.curr_location]
  3940 0000406A A3[EE45]            <1> 	mov word [prog], ax
  3941                              <1> 
  3942 0000406D E98AEC              <1> 	jmp mainloop
  3943                              <1> 
  3944                              <1> 
  3945 00004070 0000                <1> 	.curr_location	dw 0
  3946                              <1> 
  3947 00004072 0000                <1> 	.to_skip	dw 0
  3948 00004074 00                  <1> 	.var_to_use	db 0
  3949                              <1> ;	.tmp_token 	times 30 db 0
  3950                              <1> 	.tmp_token 	equ 32768-1024-256-30
  3951                              <1> 
  3952                              <1> 
  3953                              <1> ; ------------------------------------------------------------------
  3954                              <1> ; REM
  3955                              <1> 
  3956                              <1> do_rem:
  3957 00004075 8B36[EE45]          <1> 	mov word si, [prog]
  3958 00004079 8A04                <1> 	mov byte al, [si]
  3959 0000407B FF06[EE45]          <1> 	inc word [prog]
  3960 0000407F 3C0A                <1> 	cmp al, 10			; Find end of line after REM
  3961 00004081 75F2                <1> 	jne do_rem
  3962                              <1> 
  3963 00004083 E974EC              <1> 	jmp mainloop
  3964                              <1> 
  3965                              <1> 
  3966                              <1> ; ------------------------------------------------------------------
  3967                              <1> ; RENAME
  3968                              <1> 
  3969                              <1> do_rename:
  3970 00004086 E8E103              <1> 	call get_token
  3971                              <1> 
  3972 00004089 83F802              <1> 	cmp ax, STRING_VAR		; Is it a string or a quote?
  3973 0000408C 7407                <1> 	je .first_is_string
  3974                              <1> 
  3975 0000408E 83F805              <1> 	cmp ax, QUOTE
  3976 00004091 740E                <1> 	je .first_is_quote
  3977                              <1> 
  3978 00004093 EB61                <1> 	jmp .error
  3979                              <1> 
  3980                              <1> .first_is_string:
  3981 00004095 BE007C              <1> 	mov si, string_vars		; Locate string
  3982 00004098 B88000              <1> 	mov ax, 128
  3983 0000409B F7E3                <1> 	mul bx
  3984 0000409D 01C6                <1> 	add si, ax
  3985                              <1> 
  3986 0000409F EB03                <1> 	jmp .save_file1
  3987                              <1> 
  3988                              <1> .first_is_quote:
  3989 000040A1 BE007B              <1> 	mov si, token			; The location of quotes is provided
  3990                              <1> 
  3991                              <1> .save_file1:
  3992 000040A4 BF[2341]            <1> 	mov word di, .file1		; The filename is saved to temporary strings because
  3993 000040A7 E8A0E9              <1> 	call os_string_copy		; getting a second quote will overwrite the previous
  3994                              <1> 	
  3995                              <1> .get_second:
  3996 000040AA E8BD03              <1> 	call get_token
  3997                              <1> 
  3998 000040AD 83F802              <1> 	cmp ax, STRING_VAR
  3999 000040B0 7407                <1> 	je .second_is_string
  4000                              <1> 
  4001 000040B2 83F805              <1> 	cmp ax, QUOTE
  4002 000040B5 740E                <1> 	je .second_is_quote
  4003                              <1> 
  4004 000040B7 EB3D                <1> 	jmp .error
  4005                              <1> 
  4006                              <1> .second_is_string:
  4007 000040B9 BE007C              <1> 	mov si, string_vars		; Locate second string
  4008 000040BC B88000              <1> 	mov ax, 128
  4009 000040BF F7E3                <1> 	mul bx
  4010 000040C1 01C6                <1> 	add si, ax
  4011                              <1> 
  4012 000040C3 EB03                <1> 	jmp .save_file2
  4013                              <1> 
  4014                              <1> .second_is_quote:
  4015 000040C5 BE007B              <1> 	mov si, token
  4016                              <1> 
  4017                              <1> .save_file2:
  4018 000040C8 BF[2F41]            <1> 	mov word di, .file2
  4019 000040CB E87CE9              <1> 	call os_string_copy
  4020                              <1> 	
  4021                              <1> .check_exists:
  4022 000040CE B8[2341]            <1> 	mov word ax, .file1		; Check if the source file exists
  4023 000040D1 E8FDCD              <1> 	call os_file_exists
  4024 000040D4 7226                <1> 	jc .file_not_found		; If it doesn't exists set "R = 1"
  4025                              <1> 
  4026 000040D6 F8                  <1> 	clc
  4027 000040D7 B8[2F41]            <1> 	mov ax, .file2			; The second file is the destination and should not exist
  4028 000040DA E8F4CD              <1> 	call os_file_exists
  4029 000040DD 7337                <1> 	jnc .file_exists		; If it exists set "R = 3"
  4030                              <1> 	
  4031                              <1> .rename:
  4032 000040DF B8[2341]            <1> 	mov word ax, .file1		; Seem to be okay, lets rename
  4033 000040E2 BB[2F41]            <1> 	mov word bx, .file2
  4034 000040E5 E86ACF              <1> 	call os_rename_file
  4035                              <1> 
  4036 000040E8 721F                <1> 	jc .rename_failed		; If it failed set "R = 2", usually caused by a read-only disk
  4037                              <1> 
  4038 000040EA 31C0                <1> 	xor ax, ax			; It worked sucessfully, so set "R = 0" to indicate no error
  4039 000040EC B052                <1> 	mov byte al, 'R'
  4040 000040EE 31DB                <1> 	xor bx, bx
  4041 000040F0 E86803              <1> 	call set_var
  4042                              <1> 
  4043 000040F3 E904EC              <1> 	jmp mainloop
  4044                              <1> 
  4045                              <1> .error:
  4046 000040F6 BE1400              <1> 	mov si, err_syntax
  4047 000040F9 E98704              <1> 	jmp error
  4048                              <1> 
  4049                              <1> .file_not_found:
  4050 000040FC 31C0                <1> 	xor ax, ax			; Set R variable to 1
  4051 000040FE B052                <1> 	mov byte al, 'R'
  4052 00004100 BB0100              <1> 	mov bx, 1
  4053 00004103 E85503              <1> 	call set_var
  4054                              <1> 
  4055 00004106 E9F1EB              <1> 	jmp mainloop
  4056                              <1> 
  4057                              <1> .rename_failed:
  4058 00004109 31C0                <1> 	xor ax, ax			; Set R variable to 2
  4059 0000410B B052                <1> 	mov byte al, 'R'
  4060 0000410D BB0200              <1> 	mov bx, 2
  4061 00004110 E84803              <1> 	call set_var
  4062                              <1> 
  4063 00004113 E9E4EB              <1> 	jmp mainloop
  4064                              <1> 
  4065                              <1> .file_exists:
  4066 00004116 31C0                <1> 	xor ax, ax
  4067 00004118 B052                <1> 	mov byte al, 'R'		; Set R variable to 3
  4068 0000411A BB0300              <1> 	mov bx, 3
  4069 0000411D E83B03              <1> 	call set_var
  4070                              <1> 
  4071 00004120 E9D7EB              <1> 	jmp mainloop
  4072                              <1> 
  4073                              <1> .data:
  4074 00004123 00<rep Ch>          <1> 	.file1				times 12 db 0
  4075 0000412F 00<rep Ch>          <1> 	.file2				times 12 db 0
  4076                              <1> 
  4077                              <1> 
  4078                              <1> ; ------------------------------------------------------------------
  4079                              <1> ; RETURN
  4080                              <1> 
  4081                              <1> do_return:
  4082 0000413B 0FB606[6547]        <1> 	movzx ax, byte [gosub_depth]
  4083 00004140 3C00                <1> 	cmp al, 0
  4084 00004142 7506                <1> 	jne .is_ok
  4085                              <1> 
  4086 00004144 BE1200              <1> 	mov si, err_return
  4087 00004147 E93904              <1> 	jmp error
  4088                              <1> 
  4089                              <1> .is_ok:
  4090 0000414A BEBC79              <1> 	mov si, gosub_points
  4091 0000414D 01C6                <1> 	add si, ax				; Table is words (not bytes)
  4092 0000414F 01C6                <1> 	add si, ax
  4093 00004151 AD                  <1> 	lodsw
  4094 00004152 A3[EE45]            <1> 	mov word [prog], ax
  4095 00004155 FE0E[6547]          <1> 	dec byte [gosub_depth]
  4096                              <1> 
  4097 00004159 E99EEB              <1> 	jmp mainloop	
  4098                              <1> 
  4099                              <1> 
  4100                              <1> ; ------------------------------------------------------------------
  4101                              <1> ; SAVE
  4102                              <1> 
  4103                              <1> do_save:
  4104 0000415C E80B03              <1> 	call get_token
  4105 0000415F 83F805              <1> 	cmp ax, QUOTE
  4106 00004162 7413                <1> 	je .is_quote
  4107                              <1> 
  4108 00004164 83F802              <1> 	cmp ax, STRING_VAR
  4109 00004167 0F859500            <1> 	jne near .error
  4110                              <1> 
  4111 0000416B BE007C              <1> 	mov si, string_vars
  4112 0000416E B88000              <1> 	mov ax, 128
  4113 00004171 F7E3                <1> 	mul bx
  4114 00004173 01C6                <1> 	add si, ax
  4115 00004175 EB03                <1> 	jmp .get_position
  4116                              <1> 
  4117                              <1> .is_quote:
  4118 00004177 BE007B              <1> 	mov si, token
  4119                              <1> 
  4120                              <1> .get_position:
  4121 0000417A BF[0C42]            <1> 	mov di, .tmp_filename
  4122 0000417D E8CAE8              <1> 	call os_string_copy
  4123                              <1> 
  4124 00004180 E8E702              <1> 	call get_token
  4125                              <1> 
  4126 00004183 83F801              <1> 	cmp ax, VARIABLE
  4127 00004186 744A                <1> 	je .second_is_var
  4128                              <1> 
  4129 00004188 83F803              <1> 	cmp ax, NUMBER
  4130 0000418B 7573                <1> 	jne .error
  4131                              <1> 
  4132 0000418D BE007B              <1> 	mov si, token
  4133 00004190 E86AE9              <1> 	call os_string_to_int
  4134                              <1> 
  4135                              <1> .set_data_loc:
  4136 00004193 A3[0842]            <1> 	mov word [.data_loc], ax
  4137                              <1> 
  4138 00004196 E8D102              <1> 	call get_token
  4139                              <1> 
  4140 00004199 83F801              <1> 	cmp ax, VARIABLE
  4141 0000419C 743E                <1> 	je .third_is_var
  4142                              <1> 
  4143 0000419E 83F803              <1> 	cmp ax, NUMBER
  4144 000041A1 755D                <1> 	jne .error
  4145                              <1> 
  4146 000041A3 BE007B              <1> 	mov si, token
  4147 000041A6 E854E9              <1> 	call os_string_to_int
  4148                              <1> 
  4149                              <1> .check_exists:
  4150 000041A9 A3[0A42]            <1> 	mov word [.data_size], ax
  4151 000041AC B8[0C42]            <1> 	mov word ax, .tmp_filename
  4152 000041AF E81FCD              <1> 	call os_file_exists
  4153 000041B2 7202                <1> 	jc .write_file
  4154 000041B4 EB30                <1> 	jmp .file_exists_fail
  4155                              <1> 	
  4156                              <1> .write_file:
  4157                              <1> 
  4158 000041B6 B8[0C42]            <1> 	mov word ax, .tmp_filename
  4159 000041B9 8B1E[0842]          <1> 	mov word bx, [.data_loc]
  4160 000041BD 8B0E[0A42]          <1> 	mov word cx, [.data_size]
  4161                              <1> 	
  4162 000041C1 E82BCB              <1> 	call os_write_file
  4163 000041C4 722D                <1> 	jc .save_failure
  4164                              <1> 
  4165 000041C6 31C0                <1> 	xor ax, ax
  4166 000041C8 B052                <1> 	mov byte al, 'R'
  4167 000041CA 31DB                <1> 	xor bx, bx
  4168 000041CC E88C02              <1> 	call set_var
  4169                              <1> 
  4170 000041CF E928EB              <1> 	jmp mainloop
  4171                              <1> 
  4172                              <1> 
  4173                              <1> .second_is_var:
  4174 000041D2 0FB606007B          <1> 	movzx ax, byte [token]
  4175 000041D7 E87402              <1> 	call get_var
  4176 000041DA EBB7                <1> 	jmp .set_data_loc
  4177                              <1> 
  4178                              <1> 
  4179                              <1> .third_is_var:
  4180 000041DC 0FB606007B          <1> 	movzx ax, byte [token]
  4181 000041E1 E86A02              <1> 	call get_var
  4182 000041E4 EBC3                <1> 	jmp .check_exists
  4183                              <1> 
  4184                              <1> .file_exists_fail:
  4185 000041E6 31C0                <1> 	xor ax, ax
  4186 000041E8 B052                <1> 	mov byte al, 'R'
  4187 000041EA BB0200              <1> 	mov bx, 2
  4188 000041ED E86B02              <1> 	call set_var
  4189 000041F0 E907EB              <1> 	jmp mainloop
  4190                              <1> 	
  4191                              <1> .save_failure:
  4192 000041F3 31C0                <1> 	xor ax, ax
  4193 000041F5 B052                <1> 	mov byte al, 'R'
  4194 000041F7 BB0100              <1> 	mov bx, 1
  4195 000041FA E85E02              <1> 	call set_var
  4196                              <1> 
  4197 000041FD E9FAEA              <1> 	jmp mainloop
  4198                              <1> 
  4199                              <1> .error:
  4200 00004200 BE1400              <1> 	mov si, err_syntax
  4201 00004203 E97D03              <1> 	jmp error
  4202                              <1> 
  4203                              <1> 
  4204 00004206 0000                <1> 	.filename_loc	dw 0
  4205 00004208 0000                <1> 	.data_loc	dw 0
  4206 0000420A 0000                <1> 	.data_size	dw 0
  4207                              <1> 
  4208 0000420C 00<rep Fh>          <1> 	.tmp_filename	times 15 db 0
  4209                              <1> 
  4210                              <1> 
  4211                              <1> ; ------------------------------------------------------------------
  4212                              <1> ; SERIAL
  4213                              <1> 
  4214                              <1> do_serial:
  4215 0000421B E84C02              <1> 	call get_token
  4216 0000421E BE007B              <1> 	mov si, token
  4217                              <1> 
  4218 00004221 BF[B342]            <1> 	mov di, .on_cmd
  4219 00004224 E882E8              <1> 	call os_string_compare
  4220 00004227 7212                <1> 	jc .do_on_cmd
  4221                              <1> 
  4222 00004229 BF[B642]            <1> 	mov di, .send_cmd
  4223 0000422C E87AE8              <1> 	call os_string_compare
  4224 0000422F 7237                <1> 	jc .do_send_cmd
  4225                              <1> 
  4226 00004231 BF[BB42]            <1> 	mov di, .rec_cmd
  4227 00004234 E872E8              <1> 	call os_string_compare
  4228 00004237 7258                <1> 	jc .do_rec_cmd
  4229                              <1> 
  4230 00004239 EB72                <1> 	jmp .error
  4231                              <1> 
  4232                              <1> .do_on_cmd:
  4233 0000423B E82C02              <1> 	call get_token
  4234 0000423E 83F803              <1> 	cmp ax, NUMBER
  4235 00004241 7402                <1> 	je .do_on_cmd_ok
  4236 00004243 EB68                <1> 	jmp .error
  4237                              <1> 
  4238                              <1> .do_on_cmd_ok:
  4239 00004245 BE007B              <1> 	mov si, token
  4240 00004248 E8B2E8              <1> 	call os_string_to_int
  4241 0000424B 3DB004              <1> 	cmp ax, 1200
  4242 0000424E 740F                <1> 	je .on_cmd_slow_mode
  4243 00004250 3D8025              <1> 	cmp ax, 9600
  4244 00004253 7402                <1> 	je .on_cmd_fast_mode
  4245                              <1> 
  4246 00004255 EB56                <1> 	jmp .error
  4247                              <1> 
  4248                              <1> .on_cmd_fast_mode:
  4249 00004257 31C0                <1> 	xor ax, ax
  4250 00004259 E84ED5              <1> 	call os_serial_port_enable
  4251 0000425C E99BEA              <1> 	jmp mainloop
  4252                              <1> 
  4253                              <1> .on_cmd_slow_mode:
  4254 0000425F B80100              <1> 	mov ax, 1
  4255 00004262 E845D5              <1> 	call os_serial_port_enable
  4256 00004265 E992EA              <1> 	jmp mainloop
  4257                              <1> 
  4258                              <1> 
  4259                              <1> .do_send_cmd:
  4260 00004268 E8FF01              <1> 	call get_token
  4261 0000426B 83F803              <1> 	cmp ax, NUMBER
  4262 0000426E 7407                <1> 	je .send_number
  4263                              <1> 
  4264 00004270 83F801              <1> 	cmp ax, VARIABLE
  4265 00004273 740E                <1> 	je .send_variable
  4266                              <1> 
  4267 00004275 EB36                <1> 	jmp .error
  4268                              <1> 
  4269                              <1> .send_number:
  4270 00004277 BE007B              <1> 	mov si, token
  4271 0000427A E880E8              <1> 	call os_string_to_int
  4272 0000427D E83ED5              <1> 	call os_send_via_serial
  4273 00004280 E977EA              <1> 	jmp mainloop
  4274                              <1> 
  4275                              <1> .send_variable:
  4276 00004283 0FB606007B          <1> 	movzx ax, byte [token]
  4277 00004288 E8C301              <1> 	call get_var
  4278 0000428B E830D5              <1> 	call os_send_via_serial
  4279 0000428E E969EA              <1> 	jmp mainloop
  4280                              <1> 
  4281                              <1> 
  4282                              <1> .do_rec_cmd:
  4283 00004291 E8D601              <1> 	call get_token
  4284 00004294 83F801              <1> 	cmp ax, VARIABLE
  4285 00004297 7514                <1> 	jne .error
  4286                              <1> 
  4287 00004299 A0007B              <1> 	mov byte al, [token]
  4288                              <1> 
  4289 0000429C 0FB6C8              <1> 	movzx cx, al
  4290 0000429F E82ED5              <1> 	call os_get_via_serial
  4291                              <1> 
  4292 000042A2 0FB6D8              <1> 	movzx bx, al
  4293 000042A5 88C8                <1> 	mov al, cl
  4294 000042A7 E8B101              <1> 	call set_var
  4295                              <1> 
  4296 000042AA E94DEA              <1> 	jmp mainloop
  4297                              <1> 
  4298                              <1> 
  4299                              <1> .error:
  4300 000042AD BE1400              <1> 	mov si, err_syntax
  4301 000042B0 E9D002              <1> 	jmp error
  4302                              <1> 
  4303                              <1> 
  4304 000042B3 4F4E00              <1> 	.on_cmd		db "ON", 0
  4305 000042B6 53454E4400          <1> 	.send_cmd	db "SEND", 0
  4306 000042BB 52454300            <1> 	.rec_cmd	db "REC", 0
  4307                              <1> 
  4308                              <1> 
  4309                              <1> ; ------------------------------------------------------------------
  4310                              <1> ; SIZE
  4311                              <1> 
  4312                              <1> do_size:
  4313 000042BF E8A801              <1> 	call get_token
  4314                              <1> 
  4315 000042C2 83F802              <1> 	cmp ax, STRING_VAR
  4316 000042C5 7407                <1> 	je .is_string
  4317                              <1> 
  4318 000042C7 83F805              <1> 	cmp ax, QUOTE
  4319 000042CA 7410                <1> 	je .is_quote
  4320                              <1> 
  4321 000042CC EB29                <1> 	jmp .error
  4322                              <1> 
  4323                              <1> .is_string:
  4324 000042CE BE007C              <1> 	mov si, string_vars
  4325 000042D1 B88000              <1> 	mov ax, 128
  4326 000042D4 F7E3                <1> 	mul bx
  4327 000042D6 01C6                <1> 	add si, ax
  4328                              <1> 
  4329 000042D8 89F0                <1> 	mov ax, si
  4330 000042DA EB03                <1> 	jmp .get_size
  4331                              <1> 
  4332                              <1> .is_quote:
  4333 000042DC B8007B              <1> 	mov ax, token
  4334                              <1> 
  4335                              <1> .get_size:
  4336 000042DF E8A5CD              <1> 	call os_get_file_size
  4337 000042E2 7219                <1> 	jc .file_not_found
  4338                              <1> 
  4339 000042E4 31C0                <1> 	xor ax, ax
  4340 000042E6 B053                <1> 	mov al, 'S'
  4341 000042E8 E87001              <1> 	call set_var
  4342                              <1> 
  4343 000042EB 31C0                <1> 	xor ax, ax
  4344 000042ED B052                <1> 	mov al, 'R'
  4345 000042EF 31DB                <1> 	xor bx, bx
  4346 000042F1 E86701              <1> 	call set_var
  4347                              <1> 
  4348 000042F4 E903EA              <1> 	jmp mainloop
  4349                              <1> 
  4350                              <1> .error:
  4351 000042F7 BE1400              <1> 	mov si, err_syntax
  4352 000042FA E98602              <1> 	jmp error
  4353                              <1> 
  4354                              <1> .file_not_found:
  4355 000042FD 0FB606007B          <1> 	movzx ax, byte [token]
  4356 00004302 89DB                <1> 	mov bx, bx
  4357 00004304 E85401              <1> 	call set_var
  4358                              <1> 
  4359 00004307 31C0                <1> 	xor ax, ax
  4360 00004309 B052                <1> 	mov al, 'R'
  4361 0000430B BB0100              <1> 	mov bx, 1
  4362 0000430E E84A01              <1>  	call set_var
  4363                              <1>  	
  4364 00004311 E9E6E9              <1> 	jmp mainloop
  4365                              <1> 
  4366                              <1> 
  4367                              <1> 
  4368                              <1> ; ------------------------------------------------------------------
  4369                              <1> ; SOUND
  4370                              <1> 
  4371                              <1> do_sound:
  4372 00004314 E85301              <1> 	call get_token
  4373                              <1> 
  4374 00004317 83F801              <1> 	cmp ax, VARIABLE
  4375 0000431A 7408                <1> 	je .first_is_var
  4376                              <1> 
  4377 0000431C BE007B              <1> 	mov si, token
  4378 0000431F E8DBE7              <1> 	call os_string_to_int
  4379 00004322 EB08                <1> 	jmp .done_first
  4380                              <1> 
  4381                              <1> .first_is_var:
  4382 00004324 0FB606007B          <1> 	movzx ax, byte [token]
  4383 00004329 E82201              <1> 	call get_var
  4384                              <1> 
  4385                              <1> .done_first:
  4386 0000432C E8FFE2              <1> 	call os_speaker_tone
  4387                              <1> 
  4388 0000432F E83801              <1> 	call get_token
  4389                              <1> 
  4390 00004332 83F801              <1> 	cmp ax, VARIABLE
  4391 00004335 7408                <1> 	je .second_is_var
  4392                              <1> 
  4393 00004337 BE007B              <1> 	mov si, token
  4394 0000433A E8C0E7              <1> 	call os_string_to_int
  4395 0000433D EB08                <1> 	jmp .finish
  4396                              <1> 
  4397                              <1> .second_is_var:
  4398 0000433F 0FB606007B          <1> 	movzx ax, byte [token]
  4399 00004344 E80701              <1> 	call get_var
  4400                              <1> 
  4401                              <1> .finish:
  4402 00004347 E882D1              <1> 	call os_pause
  4403 0000434A E821E3              <1> 	call os_speaker_off
  4404                              <1> 
  4405 0000434D E9AAE9              <1> 	jmp mainloop
  4406                              <1> 
  4407                              <1> 
  4408                              <1> ;-------------------------------------------------------------------
  4409                              <1> ; STRING
  4410                              <1> do_string:
  4411 00004350 E81701              <1> 	call get_token			; The first parameter is the word 'GET' or 'SET'
  4412 00004353 BE007B              <1> 	mov si, token
  4413                              <1> 	
  4414 00004356 BF[FA43]            <1> 	mov di, .get_cmd
  4415 00004359 E84DE7              <1> 	call os_string_compare
  4416 0000435C 720B                <1> 	jc .set_str
  4417                              <1> 		
  4418 0000435E BF[FE43]            <1> 	mov di, .set_cmd
  4419 00004361 E845E7              <1> 	call os_string_compare
  4420 00004364 7208                <1> 	jc .get_str
  4421                              <1> 	
  4422 00004366 E98500              <1> 	jmp .error
  4423                              <1> 	
  4424                              <1> 	.set_str:
  4425 00004369 B90100              <1> 	mov cx, 1
  4426 0000436C EB03                <1> 	jmp .check_second
  4427                              <1> 	.get_str:
  4428 0000436E B90200              <1> 	mov cx, 2
  4429                              <1> 
  4430                              <1> .check_second:
  4431 00004371 E8F600              <1> 	call get_token			; The next should be a string variable, locate it
  4432                              <1> 	
  4433 00004374 83F802              <1> 	cmp ax, STRING_VAR
  4434 00004377 7575                <1> 	jne .error
  4435                              <1> 	
  4436 00004379 BE007C              <1> 	mov si, string_vars
  4437 0000437C B88000              <1> 	mov ax, 128
  4438 0000437F F7E3                <1> 	mul bx
  4439 00004381 01C6                <1> 	add si, ax
  4440 00004383 8936[0244]          <1> 	mov word [.string_loc], si
  4441                              <1> 	
  4442                              <1> .check_third:
  4443 00004387 E8E000              <1> 	call get_token			; Now there should be a number
  4444                              <1> 	
  4445 0000438A 83F803              <1> 	cmp ax, NUMBER
  4446 0000438D 7407                <1> 	je .third_is_number
  4447                              <1> 	
  4448 0000438F 83F801              <1> 	cmp ax, VARIABLE
  4449 00004392 740A                <1> 	je .third_is_variable
  4450                              <1> 	
  4451 00004394 EB58                <1> 	jmp .error
  4452                              <1> 	
  4453                              <1> .third_is_number:	
  4454 00004396 BE007B              <1> 	mov si, token
  4455 00004399 E861E7              <1> 	call os_string_to_int
  4456 0000439C EB0A                <1> 	jmp .got_number	
  4457                              <1> 
  4458                              <1> .third_is_variable:
  4459 0000439E B400                <1> 	mov ah, 0
  4460 000043A0 A0007B              <1> 	mov al, [token]
  4461 000043A3 E8A800              <1> 	call get_var
  4462 000043A6 EB00                <1> 	jmp .got_number
  4463                              <1> 
  4464                              <1> .got_number:
  4465 000043A8 3D8000              <1> 	cmp ax, 128
  4466 000043AB 7F47                <1> 	jg .outrange
  4467 000043AD 83F800              <1> 	cmp ax, 0
  4468 000043B0 7442                <1> 	je .outrange
  4469 000043B2 83E801              <1> 	sub ax, 1
  4470 000043B5 89C2                <1> 	mov dx, ax
  4471                              <1> 	
  4472                              <1> .check_forth:
  4473 000043B7 E8B000              <1> 	call get_token			; Next a numerical variable
  4474                              <1> 	
  4475 000043BA 83F801              <1> 	cmp ax, VARIABLE
  4476 000043BD 752F                <1> 	jne .error
  4477                              <1> 	
  4478 000043BF A0007B              <1> 	mov byte al, [token]
  4479 000043C2 A2[0444]            <1> 	mov byte [.tmp], al
  4480                              <1> 	
  4481 000043C5 83F902              <1> 	cmp cx, 2
  4482 000043C8 7414                <1> 	je .set_var
  4483                              <1> 	
  4484                              <1> .get_var:
  4485 000043CA 8B36[0244]          <1> 	mov word si, [.string_loc]	; Move to string location
  4486 000043CE 01D6                <1> 	add si, dx			; Add offset
  4487 000043D0 AC                  <1> 	lodsb				; Load data
  4488 000043D1 B400                <1> 	mov ah, 0
  4489 000043D3 89C3                <1> 	mov bx, ax			; Set data in numerical variable
  4490 000043D5 A0[0444]            <1> 	mov byte al, [.tmp]
  4491 000043D8 E88000              <1> 	call set_var
  4492 000043DB E91CE9              <1> 	jmp mainloop
  4493                              <1> 	
  4494                              <1> .set_var:
  4495 000043DE A0[0444]            <1> 	mov byte al, [.tmp]		; Retrieve the variable
  4496 000043E1 E86A00              <1> 	call get_var			; Get it's value
  4497 000043E4 8B3E[0244]          <1> 	mov di, [.string_loc]		; Locate the string
  4498 000043E8 01D7                <1> 	add di, dx			; Add the offset
  4499 000043EA AA                  <1> 	stosb				; Store data
  4500 000043EB E90CE9              <1> 	jmp mainloop
  4501                              <1> 	
  4502                              <1> .error:
  4503 000043EE BE1400              <1> 	mov si, err_syntax
  4504 000043F1 E98F01              <1> 	jmp error
  4505                              <1> 	
  4506                              <1> .outrange:
  4507 000043F4 BE1300              <1> 	mov si, err_string_range
  4508 000043F7 E98901              <1> 	jmp error
  4509                              <1> 
  4510                              <1> .data:
  4511 000043FA 47455400            <1> 	.get_cmd		db "GET", 0
  4512 000043FE 53455400            <1> 	.set_cmd		db "SET", 0
  4513 00004402 0000                <1> 	.string_loc		dw 0
  4514 00004404 00                  <1> 	.tmp			db 0
  4515                              <1> 
  4516                              <1> 
  4517                              <1> 
  4518                              <1> ; ------------------------------------------------------------------
  4519                              <1> ; WAITKEY
  4520                              <1> 
  4521                              <1> do_waitkey:
  4522 00004405 E86200              <1> 	call get_token
  4523 00004408 83F801              <1> 	cmp ax, VARIABLE
  4524 0000440B 7406                <1> 	je .is_variable
  4525                              <1> 
  4526 0000440D BE1400              <1> 	mov si, err_syntax
  4527 00004410 E97001              <1> 	jmp error
  4528                              <1> 
  4529                              <1> .is_variable:
  4530 00004413 0FB606007B          <1> 	movzx ax, byte [token]
  4531                              <1> 
  4532 00004418 50                  <1> 	push ax
  4533                              <1> 
  4534 00004419 E85ECE              <1> 	call os_wait_for_key
  4535                              <1> 
  4536 0000441C 80FC48              <1> 	cmp ah, 48h
  4537 0000441F 7419                <1> 	je .up_pressed
  4538                              <1> 	
  4539 00004421 80FC50              <1> 	cmp ah, 50h
  4540 00004424 7419                <1> 	je .down_pressed
  4541                              <1> 
  4542 00004426 80FC4B              <1> 	cmp ah, 4Bh
  4543 00004429 7419                <1> 	je .left_pressed
  4544                              <1> 
  4545 0000442B 80FC4D              <1> 	cmp ah, 4Dh
  4546 0000442E 7419                <1> 	je .right_pressed
  4547                              <1> 
  4548                              <1> .store:
  4549 00004430 0FB6D8              <1> 	movzx bx, al
  4550                              <1> 
  4551 00004433 58                  <1> 	pop ax
  4552                              <1> 
  4553 00004434 E82400              <1> 	call set_var
  4554                              <1> 
  4555 00004437 E9C0E8              <1> 	jmp mainloop
  4556                              <1> 
  4557                              <1> 
  4558                              <1> .up_pressed:
  4559 0000443A B80100              <1> 	mov ax, 1
  4560 0000443D EBF1                <1> 	jmp .store
  4561                              <1> 
  4562                              <1> .down_pressed:
  4563 0000443F B80200              <1> 	mov ax, 2
  4564 00004442 EBEC                <1> 	jmp .store
  4565                              <1> 
  4566                              <1> .left_pressed:
  4567 00004444 B80300              <1> 	mov ax, 3
  4568 00004447 EBE7                <1> 	jmp .store
  4569                              <1> 
  4570                              <1> .right_pressed:
  4571 00004449 B80400              <1> 	mov ax, 4
  4572 0000444C EBE2                <1> 	jmp .store
  4573                              <1> 
  4574                              <1> 
  4575                              <1> ; ==================================================================
  4576                              <1> ; INTERNAL ROUTINES FOR INTERPRETER
  4577                              <1> 
  4578                              <1> ; ------------------------------------------------------------------
  4579                              <1> ; Get value of variable character specified in AL (eg 'A')
  4580                              <1> 
  4581                              <1> get_var:
  4582 0000444E B400                <1> 	mov ah, 0
  4583 00004450 2C41                <1> 	sub al, 65
  4584 00004452 BE4C7A              <1> 	mov si, variables
  4585 00004455 01C6                <1> 	add si, ax
  4586 00004457 01C6                <1> 	add si, ax
  4587 00004459 AD                  <1> 	lodsw
  4588 0000445A C3                  <1> 	ret
  4589                              <1> 
  4590                              <1> 
  4591                              <1> ; ------------------------------------------------------------------
  4592                              <1> ; Set value of variable character specified in AL (eg 'A')
  4593                              <1> ; with number specified in BX
  4594                              <1> 
  4595                              <1> set_var:
  4596 0000445B B400                <1> 	mov ah, 0
  4597 0000445D 2C41                <1> 	sub al, 65				; Remove ASCII codes before 'A'
  4598                              <1> 
  4599 0000445F BF4C7A              <1> 	mov di, variables			; Find position in table (of words)
  4600 00004462 01C7                <1> 	add di, ax
  4601 00004464 01C7                <1> 	add di, ax
  4602 00004466 89D8                <1> 	mov ax, bx
  4603 00004468 AB                  <1> 	stosw
  4604 00004469 C3                  <1> 	ret
  4605                              <1> 
  4606                              <1> 
  4607                              <1> ; ------------------------------------------------------------------
  4608                              <1> ; Get token from current position in prog
  4609                              <1> 
  4610                              <1> get_token:
  4611 0000446A 8B36[EE45]          <1> 	mov word si, [prog]
  4612 0000446E AC                  <1> 	lodsb
  4613                              <1> 
  4614 0000446F 3C0A                <1> 	cmp al, 10
  4615 00004471 741A                <1> 	je .newline
  4616                              <1> 
  4617 00004473 3C20                <1> 	cmp al, ' '
  4618 00004475 7416                <1> 	je .newline
  4619                              <1> 
  4620 00004477 E8F100              <1> 	call is_number
  4621 0000447A 7217                <1> 	jc get_number_token
  4622                              <1> 
  4623 0000447C 3C22                <1> 	cmp al, '"'
  4624 0000447E 745F                <1> 	je get_quote_token
  4625                              <1> 
  4626 00004480 3C27                <1> 	cmp al, 39			; Quote mark (')
  4627 00004482 7438                <1> 	je get_char_token
  4628                              <1> 
  4629 00004484 3C24                <1> 	cmp al, '$'
  4630 00004486 0F848000            <1> 	je near get_string_var_token
  4631                              <1> 
  4632 0000448A E99000              <1> 	jmp get_string_token
  4633                              <1> 
  4634                              <1> 
  4635                              <1> .newline:
  4636 0000448D FF06[EE45]          <1> 	inc word [prog]
  4637 00004491 EBD7                <1> 	jmp get_token
  4638                              <1> 
  4639                              <1> 
  4640                              <1> 
  4641                              <1> get_number_token:
  4642 00004493 8B36[EE45]          <1> 	mov word si, [prog]
  4643 00004497 BF007B              <1> 	mov di, token
  4644                              <1> 
  4645                              <1> .loop:
  4646 0000449A AC                  <1> 	lodsb
  4647 0000449B 3C0A                <1> 	cmp al, 10
  4648 0000449D 7416                <1> 	je .done
  4649 0000449F 3C20                <1> 	cmp al, ' '
  4650 000044A1 7412                <1> 	je .done
  4651 000044A3 E8C500              <1> 	call is_number
  4652 000044A6 7206                <1> 	jc .fine
  4653                              <1> 
  4654 000044A8 BE0000              <1> 	mov si, err_char_in_num
  4655 000044AB E9D500              <1> 	jmp error
  4656                              <1> 
  4657                              <1> .fine:
  4658 000044AE AA                  <1> 	stosb
  4659 000044AF FF06[EE45]          <1> 	inc word [prog]
  4660 000044B3 EBE5                <1> 	jmp .loop
  4661                              <1> 
  4662                              <1> .done:
  4663 000044B5 B000                <1> 	mov al, 0			; Zero-terminate the token
  4664 000044B7 AA                  <1> 	stosb
  4665                              <1> 
  4666 000044B8 B80300              <1> 	mov ax, NUMBER			; Pass back the token type
  4667 000044BB C3                  <1> 	ret
  4668                              <1> 
  4669                              <1> 
  4670                              <1> get_char_token:
  4671 000044BC FF06[EE45]          <1> 	inc word [prog]			; Move past first quote (')
  4672                              <1> 
  4673 000044C0 8B36[EE45]          <1> 	mov word si, [prog]
  4674 000044C4 AC                  <1> 	lodsb
  4675                              <1> 
  4676 000044C5 A2007B              <1> 	mov byte [token], al
  4677                              <1> 
  4678 000044C8 AC                  <1> 	lodsb
  4679 000044C9 3C27                <1> 	cmp al, 39			; Needs to finish with another quote
  4680 000044CB 7406                <1> 	je .is_ok
  4681                              <1> 
  4682 000044CD BE1100              <1> 	mov si, err_quote_term
  4683 000044D0 E9B000              <1> 	jmp error
  4684                              <1> 
  4685                              <1> .is_ok:
  4686 000044D3 FF06[EE45]          <1> 	inc word [prog]
  4687 000044D7 FF06[EE45]          <1> 	inc word [prog]
  4688                              <1> 
  4689 000044DB B80600              <1> 	mov ax, CHAR
  4690 000044DE C3                  <1> 	ret
  4691                              <1> 
  4692                              <1> 
  4693                              <1> get_quote_token:
  4694 000044DF FF06[EE45]          <1> 	inc word [prog]			; Move past first quote (") char
  4695 000044E3 8B36[EE45]          <1> 	mov word si, [prog]
  4696 000044E7 BF007B              <1> 	mov di, token
  4697                              <1> .loop:
  4698 000044EA AC                  <1> 	lodsb
  4699 000044EB 3C22                <1> 	cmp al, '"'
  4700 000044ED 740B                <1> 	je .done
  4701 000044EF 3C0A                <1> 	cmp al, 10
  4702 000044F1 7412                <1> 	je .error
  4703 000044F3 AA                  <1> 	stosb
  4704 000044F4 FF06[EE45]          <1> 	inc word [prog]
  4705 000044F8 EBF0                <1> 	jmp .loop
  4706                              <1> 
  4707                              <1> .done:
  4708 000044FA B000                <1> 	mov al, 0			; Zero-terminate the token
  4709 000044FC AA                  <1> 	stosb
  4710 000044FD FF06[EE45]          <1> 	inc word [prog]			; Move past final quote
  4711                              <1> 
  4712 00004501 B80500              <1> 	mov ax, QUOTE			; Pass back token type
  4713 00004504 C3                  <1> 	ret
  4714                              <1> 
  4715                              <1> .error:
  4716 00004505 BE1100              <1> 	mov si, err_quote_term
  4717 00004508 EB79                <1> 	jmp error
  4718                              <1> 
  4719                              <1> 
  4720                              <1> get_string_var_token:
  4721 0000450A AC                  <1> 	lodsb
  4722 0000450B 0FB6D8              <1> 	movzx bx, al
  4723 0000450E 80EB31              <1> 	sub bl, 49
  4724                              <1> 
  4725 00004511 FF06[EE45]          <1> 	inc word [prog]
  4726 00004515 FF06[EE45]          <1> 	inc word [prog]
  4727                              <1> 
  4728 00004519 B80200              <1> 	mov ax, STRING_VAR
  4729 0000451C C3                  <1> 	ret
  4730                              <1> 	
  4731                              <1> 
  4732                              <1> get_string_token:
  4733 0000451D 8B36[EE45]          <1> 	mov word si, [prog]
  4734 00004521 BF007B              <1> 	mov di, token
  4735                              <1> .loop:
  4736 00004524 AC                  <1> 	lodsb
  4737 00004525 3C0A                <1> 	cmp al, 10
  4738 00004527 740B                <1> 	je .done
  4739 00004529 3C20                <1> 	cmp al, ' '
  4740 0000452B 7407                <1> 	je .done
  4741 0000452D AA                  <1> 	stosb
  4742 0000452E FF06[EE45]          <1> 	inc word [prog]
  4743 00004532 EBF0                <1> 	jmp .loop
  4744                              <1> .done:
  4745 00004534 B000                <1> 	mov al, 0			; Zero-terminate the token
  4746 00004536 AA                  <1> 	stosb
  4747                              <1> 
  4748 00004537 B8007B              <1> 	mov ax, token
  4749 0000453A E8D3E4              <1> 	call os_string_uppercase
  4750                              <1> 
  4751 0000453D B8007B              <1> 	mov ax, token
  4752 00004540 E874E4              <1> 	call os_string_length		; How long was the token?
  4753 00004543 83F801              <1> 	cmp ax, 1			; If 1 char, it's a variable or delimiter
  4754 00004546 7413                <1> 	je .is_not_string
  4755                              <1> 
  4756 00004548 BE007B              <1> 	mov si, token			; If the token ends with ':', it's a label
  4757 0000454B 01C6                <1> 	add si, ax
  4758 0000454D 4E                  <1> 	dec si
  4759 0000454E AC                  <1> 	lodsb
  4760 0000454F 3C3A                <1> 	cmp al, ':'
  4761 00004551 7404                <1> 	je .is_label
  4762                              <1> 
  4763 00004553 B80400              <1> 	mov ax, STRING			; Otherwise it's a general string of characters
  4764 00004556 C3                  <1> 	ret
  4765                              <1> 
  4766                              <1> .is_label:
  4767 00004557 B80800              <1> 	mov ax, LABEL
  4768 0000455A C3                  <1> 	ret
  4769                              <1> 
  4770                              <1> 
  4771                              <1> .is_not_string:
  4772 0000455B A0007B              <1> 	mov byte al, [token]
  4773 0000455E E81600              <1> 	call is_letter
  4774 00004561 7204                <1> 	jc .is_var
  4775                              <1> 
  4776 00004563 B80700              <1> 	mov ax, UNKNOWN
  4777 00004566 C3                  <1> 	ret
  4778                              <1> 
  4779                              <1> .is_var:
  4780 00004567 B80100              <1> 	mov ax, VARIABLE		; Otherwise probably a variable
  4781 0000456A C3                  <1> 	ret
  4782                              <1> 
  4783                              <1> 
  4784                              <1> ; ------------------------------------------------------------------
  4785                              <1> ; Set carry flag if AL contains ASCII number
  4786                              <1> 
  4787                              <1> is_number:
  4788 0000456B 3C30                <1> 	cmp al, 48
  4789 0000456D 7C06                <1> 	jl .not_number
  4790 0000456F 3C39                <1> 	cmp al, 57
  4791 00004571 7F02                <1> 	jg .not_number
  4792 00004573 F9                  <1> 	stc
  4793 00004574 C3                  <1> 	ret
  4794                              <1> .not_number:
  4795 00004575 F8                  <1> 	clc
  4796 00004576 C3                  <1> 	ret
  4797                              <1> 
  4798                              <1> 
  4799                              <1> ; ------------------------------------------------------------------
  4800                              <1> ; Set carry flag if AL contains ASCII letter
  4801                              <1> 
  4802                              <1> is_letter:
  4803 00004577 3C41                <1> 	cmp al, 65
  4804 00004579 7C06                <1> 	jl .not_letter
  4805 0000457B 3C5A                <1> 	cmp al, 90
  4806 0000457D 7F02                <1> 	jg .not_letter
  4807 0000457F F9                  <1> 	stc
  4808 00004580 C3                  <1> 	ret
  4809                              <1> 
  4810                              <1> .not_letter:
  4811 00004581 F8                  <1> 	clc
  4812 00004582 C3                  <1> 	ret
  4813                              <1> 
  4814                              <1> 
  4815                              <1> ; ------------------------------------------------------------------
  4816                              <1> ; Print error message and quit out
  4817                              <1> 
  4818                              <1> error:
  4819 00004583 B80005              <1> 	mov ax, 5 * 256			; Revert display page
  4820 00004586 CD10                <1> 	int 10h
  4821                              <1> 
  4822 00004588 E8B7D9              <1> 	call os_print_newline
  4823 0000458B BE[CF45]            <1> 	mov si, err_msg
  4824 0000458E E864D2              <1> 	call os_print_string
  4825                              <1> 	
  4826 00004591 88D8                <1> 	mov al, bl
  4827 00004593 E800DC              <1> 	call os_print_2hex
  4828                              <1> 	
  4829 00004596 C606[F845]00        <1> 	mov byte [work_page], 0
  4830 0000459B C606[F945]00        <1> 	mov byte [disp_page], 0
  4831                              <1> 
  4832 000045A0 BE[E345]            <1> 	mov si, line_num_starter
  4833 000045A3 E84FD2              <1> 	call os_print_string
  4834                              <1> 
  4835                              <1> 
  4836                              <1> 	; And now print the line number where the error occurred. We do this
  4837                              <1> 	; by working from the start of the program to the current point,
  4838                              <1> 	; counting the number of newline characters along the way
  4839                              <1> 
  4840 000045A6 8B36[F245]          <1> 	mov word si, [load_point]
  4841 000045AA 8B1E[EE45]          <1> 	mov word bx, [prog]
  4842 000045AE B90100              <1> 	mov cx, 1
  4843                              <1> 
  4844                              <1> .loop:
  4845 000045B1 AC                  <1> 	lodsb
  4846 000045B2 3C0A                <1> 	cmp al, 10
  4847 000045B4 7501                <1> 	jne .not_newline
  4848 000045B6 41                  <1> 	inc cx
  4849                              <1> .not_newline:
  4850 000045B7 39DE                <1> 	cmp si, bx
  4851 000045B9 7402                <1> 	je .finish
  4852 000045BB EBF4                <1> 	jmp .loop
  4853                              <1> .finish:
  4854                              <1> 
  4855 000045BD 89C8                <1> 	mov ax, cx
  4856 000045BF E886E5              <1> 	call os_int_to_string
  4857 000045C2 89C6                <1> 	mov si, ax
  4858 000045C4 E82ED2              <1> 	call os_print_string
  4859                              <1> 
  4860                              <1> 
  4861 000045C7 E878D9              <1> 	call os_print_newline
  4862                              <1> 
  4863 000045CA 8B26[EC45]          <1> 	mov word sp, [orig_stack]	; Restore the stack to as it was when BASIC started
  4864                              <1> 
  4865 000045CE C3                  <1> 	ret				; And finish
  4866                              <1> 
  4867                              <1> 
  4868                              <1> 	; Error messages text...
  4869                              <1> 
  4870                              <1> 	err_char_in_num		equ 00h
  4871                              <1> 	err_cmd_unknown		equ 01h
  4872                              <1> 	err_divide_by_zero	equ 02h
  4873                              <1> 	err_doloop_maximum	equ 03h
  4874                              <1> 	err_file_notfound	equ 04h
  4875                              <1> 	err_goto_notlabel	equ 05h
  4876                              <1> 	err_label_notfound	equ 06h
  4877                              <1> 	err_nest_limit		equ 07h
  4878                              <1> 	err_next			equ 08h
  4879                              <1> 	err_loop			equ 09h
  4880                              <1> 	err_print_type		equ 10h
  4881                              <1> 	err_quote_term		equ 11h
  4882                              <1> 	err_return			equ 12h
  4883                              <1> 	err_string_range	equ 13h
  4884                              <1> 	err_syntax			equ 14h
  4885                              <1> 
  4886 000045CF 4572726F722000      <1> 	err_msg				db "Error ", 0
  4887                              <1> 
  4888 000045D6 425245414B2043414C- <1> 	err_break			db "BREAK CALLED", 0
  4888 000045DF 4C454400            <1>
  4889                              <1> 
  4890 000045E3 202D206C696E652000  <1> 	line_num_starter	db " - line ", 0
  4891                              <1> 
  4892                              <1> 
  4893                              <1> ; ==================================================================
  4894                              <1> ; DATA SECTION
  4895                              <1> 
  4896 000045EC 0000                <1> 	orig_stack		dw 0		; Original stack location when BASIC started
  4897                              <1> 
  4898 000045EE 0000                <1> 	prog			dw 0		; Pointer to current location in BASIC code
  4899 000045F0 0000                <1> 	prog_end		dw 0		; Pointer to final byte of BASIC code
  4900                              <1> 
  4901 000045F2 0000                <1> 	load_point		dw 0
  4902                              <1> 
  4903 000045F4 00                  <1> 	token_type		db 0		; Type of last token read (eg NUMBER, VARIABLE)
  4904                              <1> 	token			equ 32768-1024-256
  4905                              <1> 
  4906                              <1> vars_loc:
  4907                              <1> ;	variables		times 26 dw 0	; Storage space for variables A to Z
  4908                              <1> 	variables		equ 32768-1024-384-52	; Storage space for variables A to Z
  4909                              <1> 
  4910                              <1> ;	for_variables		times 26 dw 0	; Storage for FOR loops
  4911                              <1> 	for_variables		equ 32768-1024-384-104	; Storage for FOR loops
  4912                              <1> ;	for_code_points		times 26 dw 0	; Storage for code positions where FOR loops start
  4913                              <1> 	for_code_points		equ 32768-1024-384-156	; Storage for code positions where FOR loops start
  4914                              <1> 	
  4915                              <1> ;	do_loop_store		times 10 dw 0	; Storage for DO loops
  4916                              <1> 	do_loop_store		equ 32768-1024-384-176	; Storage for DO loops
  4917 000045F5 00                  <1> 	loop_in			db 0		; Loop level
  4918                              <1> 
  4919 000045F6 01                  <1> 	last_if_true		db 1		; Checking for 'ELSE'
  4920                              <1> 
  4921 000045F7 00                  <1> 	ink_colour		db 0		; Text printing colour
  4922 000045F8 00                  <1> 	work_page		db 0		; Page to print to
  4923 000045F9 00                  <1> 	disp_page		db 0		; Page to display
  4924                              <1> 	
  4925 000045FA 414C45525400        <1> 	alert_cmd			db "ALERT", 0
  4926 00004600 41534B46494C4500    <1> 	askfile_cmd			db "ASKFILE", 0
  4927 00004608 425245414B00        <1> 	break_cmd			db "BREAK", 0
  4928 0000460E 43414C4C00          <1> 	call_cmd			db "CALL", 0
  4929 00004613 4341534500          <1> 	case_cmd			db "CASE", 0
  4930 00004618 434C5300            <1> 	cls_cmd				db "CLS", 0
  4931 0000461C 435552534F5200      <1> 	cursor_cmd			db "CURSOR", 0
  4932 00004623 435552534348415200  <1> 	curschar_cmd		db "CURSCHAR", 0
  4933 0000462C 43555253434F4C00    <1> 	curscol_cmd			db "CURSCOL", 0
  4934 00004634 43555253504F5300    <1> 	curspos_cmd			db "CURSPOS", 0
  4935 0000463C 44454C45544500      <1> 	delete_cmd			db "DELETE", 0
  4936 00004643 444F00              <1> 	do_cmd				db "DO", 0
  4937 00004646 454C534500          <1> 	else_cmd			db "ELSE", 0
  4938 0000464B 454E4400            <1> 	end_cmd				db "END", 0
  4939 0000464F 46494C455300        <1> 	files_cmd			db "FILES", 0
  4940 00004655 464F5200            <1> 	for_cmd 			db "FOR", 0
  4941 00004659 474F53554200        <1> 	gosub_cmd			db "GOSUB", 0
  4942 0000465F 474F544F00          <1> 	goto_cmd			db "GOTO", 0
  4943 00004664 4745544B455900      <1> 	getkey_cmd			db "GETKEY", 0
  4944 0000466B 494600              <1> 	if_cmd 				db "IF", 0
  4945 0000466E 494E434C55444500    <1> 	include_cmd			db "INCLUDE", 0
  4946 00004676 494E4B00            <1> 	ink_cmd				db "INK", 0
  4947 0000467A 494E50555400        <1> 	input_cmd 			db "INPUT", 0
  4948 00004680 4C454E00            <1> 	len_cmd				db "LEN", 0
  4949 00004684 4C495354424F5800    <1> 	listbox_cmd			db "LISTBOX", 0
  4950 0000468C 4C4F414400          <1> 	load_cmd			db "LOAD", 0
  4951 00004691 4C4F4F5000          <1> 	loop_cmd			db "LOOP", 0
  4952 00004696 4D4F564500          <1> 	move_cmd 			db "MOVE", 0
  4953 0000469B 4E45585400          <1> 	next_cmd 			db "NEXT", 0
  4954 000046A0 4E554D42455200      <1> 	number_cmd			db "NUMBER", 0
  4955 000046A7 5041474500          <1> 	page_cmd			db "PAGE", 0
  4956 000046AC 504155534500        <1> 	pause_cmd 			db "PAUSE", 0
  4957 000046B2 5045454B00          <1> 	peek_cmd			db "PEEK", 0
  4958 000046B7 5045454B494E5400    <1> 	peekint_cmd			db "PEEKINT", 0
  4959 000046BF 504F4B4500          <1> 	poke_cmd			db "POKE", 0
  4960 000046C4 504F4B45494E5400    <1> 	pokeint_cmd			db "POKEINT", 0
  4961 000046CC 504F525400          <1> 	port_cmd			db "PORT", 0
  4962 000046D1 5052494E5400        <1> 	print_cmd 			db "PRINT", 0
  4963 000046D7 52414E4400          <1> 	rand_cmd			db "RAND", 0
  4964 000046DC 5245414400          <1> 	read_cmd			db "READ", 0
  4965 000046E1 52454D00            <1> 	rem_cmd				db "REM", 0
  4966 000046E5 52454E414D4500      <1> 	rename_cmd			db "RENAME", 0
  4967 000046EC 52455455524E00      <1> 	return_cmd			db "RETURN", 0
  4968 000046F3 5341564500          <1> 	save_cmd			db "SAVE", 0
  4969 000046F8 53455249414C00      <1> 	serial_cmd			db "SERIAL", 0
  4970 000046FF 53495A4500          <1> 	size_cmd			db "SIZE", 0
  4971 00004704 534F554E4400        <1> 	sound_cmd 			db "SOUND", 0
  4972 0000470A 535452494E4700      <1> 	string_cmd			db "STRING", 0
  4973 00004711 574149544B455900    <1> 	waitkey_cmd			db "WAITKEY", 0
  4974                              <1> 
  4975 00004719 414E4400            <1> 	and_keyword			db "AND", 0
  4976 0000471D 5448454E00          <1> 	then_keyword		db "THEN", 0
  4977 00004722 43485200            <1> 	chr_keyword			db "CHR", 0
  4978 00004726 48455800            <1> 	hex_keyword			db "HEX", 0
  4979                              <1> 	
  4980 0000472A 4C4F57455200        <1> 	lower_keyword		db "LOWER", 0
  4981 00004730 555050455200        <1> 	upper_keyword		db "UPPER", 0
  4982                              <1> 
  4983 00004736 494E4B00            <1> 	ink_keyword			db "INK", 0
  4984 0000473A 50524F475354415254- <1> 	progstart_keyword	db "PROGSTART", 0
  4984 00004743 00                  <1>
  4985 00004744 52414D535441525400  <1> 	ramstart_keyword	db "RAMSTART", 0
  4986 0000474D 54494D455200        <1> 	timer_keyword		db "TIMER", 0
  4987 00004753 5641524941424C4553- <1> 	variables_keyword	db "VARIABLES", 0
  4987 0000475C 00                  <1>
  4988 0000475D 56455253494F4E00    <1> 	version_keyword		db "VERSION", 0
  4989                              <1> 
  4990 00004765 00                  <1> 	gosub_depth		db 0
  4991                              <1> 	gosub_points		equ 32768-1024-384-196	; Points in code to RETURN to
  4992                              <1> 
  4993                              <1> 	string_vars		equ 32768-1024
  4994                              <1> 
  4995                              <1> ; ------------------------------------------------------------------
  4996                              <1> 
   819                                  	%INCLUDE "drivers/int.asm"
   820                              <1> ; -----------------------------------------------------------------
   821                              <1> ; os_modify_int_handler -- Change location of interrupt handler
   822                              <1> ; IN: CL = int number, DI:SI = handler location
   823                              <1> 
   824                              <1> os_modify_int_handler:
   825 00004766 60                  <1> 	pusha
   826                              <1> 
   827 00004767 FA                  <1> 	cli
   828                              <1> 
   829 00004768 06                  <1> 	push es
   830                              <1> 	
   831 00004769 8E06[F205]          <1> 	mov es, [driversgmt]
   832                              <1> 	
   833 0000476D 0FB6D9              <1> 	movzx bx, cl			; Move supplied int into BX
   834                              <1> 
   835 00004770 C1E302              <1> 	shl bx, 2			; Multiply by four to get position
   836                              <1> 	
   837 00004773 268937              <1> 	mov [es:bx], si		; First store offset
   838                              <1> 
   839 00004776 83C302              <1> 	add bx, 2
   840                              <1> 	
   841 00004779 26893F              <1> 	mov [es:bx], di		; Then segment of our handler
   842                              <1> 
   843 0000477C 07                  <1> 	pop es
   844                              <1> 	
   845 0000477D FB                  <1> 	sti
   846                              <1> 
   847 0000477E 61                  <1> 	popa
   848 0000477F C3                  <1> 	ret
   849                              <1> 
   850                              <1> ; -----------------------------------------------------------------
   851                              <1> ; os_get_int_handler -- Change location of interrupt handler
   852                              <1> ; IN: CL = int number; OUT: DI:SI = handler location
   853                              <1> 
   854                              <1> os_get_int_handler:
   855 00004780 60                  <1> 	pusha
   856                              <1> 
   857 00004781 1E                  <1> 	push ds
   858                              <1> 	
   859 00004782 8E1E[F205]          <1> 	mov ds, [driversgmt]
   860                              <1> 	
   861 00004786 0FB6D9              <1> 	movzx bx, cl			; Move supplied int into BX
   862                              <1> 
   863 00004789 C1E302              <1> 	shl bx, 2			; Multiply by four to get position
   864                              <1> 	
   865 0000478C 3E8B37              <1> 	mov si, [ds:bx]		; First store offset
   866 0000478F 83C302              <1> 	add bx, 2
   867                              <1> 
   868 00004792 3E8B3F              <1> 	mov di, [ds:bx]		; Then segment of our handler
   869                              <1> 
   870 00004795 1F                  <1> 	pop ds
   871                              <1> 
   872 00004796 8936[A847]          <1> 	mov [.tmp_word], si
   873 0000479A 893E[AA47]          <1> 	mov [.tmp_sgmt], di
   874 0000479E 61                  <1> 	popa
   875 0000479F 8B36[A847]          <1> 	mov si, [.tmp_word]
   876 000047A3 8B3E[AA47]          <1> 	mov di, [.tmp_sgmt]
   877 000047A7 C3                  <1> 	ret
   878                              <1> 
   879 000047A8 0000                <1> 	.tmp_word	dw 0
   880 000047AA 0000                <1> 	.tmp_sgmt	dw 0
   881                              <1> 	
   882                              <1> ; -----------------------------------------------------------------
   883                              <1> ; os_attach_timer_interrupt -- Attach a timer interrupt to an application and sets the timer speed
   884                              <1> ; Formula: speed = (105000000 / 88) / frequency
   885                              <1> ; IN: SI = handler location, CX = speed
   886                              <1> 
   887                              <1> os_attach_app_timer:
   888 000047AC 60                  <1> 	pusha
   889 000047AD 8936[B548]          <1> 	mov [timer_application_offset], si
   890 000047B1 C606[B448]01        <1> 	mov byte [timer_application_attached], 1
   891                              <1> 	
   892 000047B6 E81A00              <1> 	call os_set_timer_speed
   893 000047B9 61                  <1> 	popa
   894 000047BA C3                  <1> 	ret
   895                              <1> 	
   896                              <1> ; -----------------------------------------------------------------
   897                              <1> ; os_return_timer_interrupt -- Returns the timer interrupt back to the system and resets the timer speed
   898                              <1> ; IN: nothing
   899                              <1> 
   900                              <1> os_return_app_timer:
   901 000047BB 60                  <1> 	pusha
   902 000047BC C606[B448]00        <1> 	mov byte [timer_application_attached], 0
   903                              <1> 	
   904 000047C1 B90000              <1> 	mov cx, 0
   905 000047C4 E80C00              <1> 	call os_set_timer_speed
   906                              <1> 	
   907 000047C7 B11C                <1> 	mov cl, 1Ch					; RTC handler
   908 000047C9 BE[7C48]            <1> 	mov si, os_compat_int1C
   909 000047CC 8CCF                <1> 	mov di, cs
   910 000047CE E895FF              <1> 	call os_modify_int_handler
   911 000047D1 61                  <1> 	popa
   912 000047D2 C3                  <1> 	ret
   913                              <1> 	
   914                              <1> ; -----------------------------------------------------------------
   915                              <1> ; os_set_timer_speed -- Sets the timer's trigger speed.
   916                              <1> ; Formula: speed = (105000000 / 88) / frequency
   917                              <1> ; IN: CX = speed
   918                              <1> 
   919                              <1> os_set_timer_speed:
   920 000047D3 60                  <1> 	pusha
   921                              <1> 	
   922 000047D4 890E[B748]          <1> 	mov [current_timer_speed], cx
   923                              <1> 	
   924 000047D8 B036                <1> 	mov al, 00110110b	; Timer 0, square wave
   925 000047DA E643                <1> 	out 43h, al
   926 000047DC 88C8                <1> 	mov al, cl
   927 000047DE E640                <1> 	out 40h, al
   928 000047E0 88E8                <1> 	mov al, ch
   929 000047E2 E640                <1> 	out 40h, al
   930                              <1> 	
   931 000047E4 61                  <1> 	popa
   932 000047E5 C3                  <1> 	ret
   933                              <1> 	
   934                              <1> ; -----------------------------------------------------------------
   935                              <1> ; Interrupt call parsers
   936                              <1> 
   937                              <1> ; Division by 0 error handler
   938                              <1> os_compat_int00:
   939 000047E6 B8[EC47]            <1> 	mov ax, .msg
   940 000047E9 E9B4CD              <1> 	jmp os_fatal_error
   941                              <1> 
   942 000047EC 4350553A2044697669- <1> 	.msg db 'CPU: Division by zero error', 0
   942 000047F5 73696F6E206279207A- <1>
   942 000047FE 65726F206572726F72- <1>
   942 00004807 00                  <1>
   943                              <1> 
   944                              <1> os_compat_int05:
   945 00004808 B8[0E48]            <1> 	mov ax, .msg
   946 0000480B E992CD              <1> 	jmp os_fatal_error
   947                              <1> 
   948 0000480E 557365722074726967- <1> 	.msg db 'User triggered crash', 0
   948 00004817 676572656420637261- <1>
   948 00004820 736800              <1>
   949                              <1> 
   950                              <1> os_compat_int0C:
   951 00004823 FA                  <1> 	cli
   952 00004824 BCFEFF              <1> 	mov sp, 0FFFEh
   953 00004827 FB                  <1> 	sti
   954                              <1> 	
   955 00004828 B8[2E48]            <1> 	mov ax, .msg
   956 0000482B E972CD              <1> 	jmp os_fatal_error
   957                              <1> 	
   958 0000482E 537461636B206F7665- <1> 	.msg db 'Stack overflow', 0
   958 00004837 72666C6F7700        <1>
   959                              <1> 	
   960                              <1> ; Invalid opcode handler
   961                              <1> os_compat_int06:
   962 0000483D B8[4348]            <1> 	mov ax, .msg
   963 00004840 E95DCD              <1> 	jmp os_fatal_error
   964                              <1> 
   965 00004843 4350553A20496E7661- <1> 	.msg db 'CPU: Invalid opcode', 0
   965 0000484C 6C6964206F70636F64- <1>
   965 00004855 6500                <1>
   966                              <1> 
   967                              <1> ; Processor extension error handler
   968                              <1> os_compat_int07:
   969 00004857 B8[5D48]            <1> 	mov ax, .msg
   970 0000485A E943CD              <1> 	jmp os_fatal_error
   971                              <1> 
   972 0000485D 4350553A2050726F63- <1> 	.msg db 'CPU: Processor extension error', 0
   972 00004866 6573736F7220657874- <1>
   972 0000486F 656E73696F6E206572- <1>
   972 00004878 726F7200            <1>
   973                              <1> 
   974                              <1> ; System timer handler (8253/8254)
   975                              <1> os_compat_int1C:
   976 0000487C FA                  <1> 	cli
   977 0000487D 6660                <1> 	pushad
   978 0000487F 1E                  <1> 	push ds
   979 00004880 06                  <1> 	push es
   980                              <1> 	
   981 00004881 8CC8                <1> 	mov ax, cs
   982 00004883 8ED8                <1> 	mov ds, ax
   983 00004885 8EC0                <1> 	mov es, ax
   984                              <1> 	
   985 00004887 803E820001          <1> 	cmp byte [0082h], 1
   986 0000488C 740E                <1> 	je .no_update
   987                              <1> 	
   988 0000488E 833E[B948]00        <1> 	cmp word [screensaver_timer], 0
   989 00004893 7404                <1> 	je .no_update_screensaver
   990                              <1> 	
   991 00004895 FF0E[B948]          <1> 	dec word [screensaver_timer]
   992                              <1> 	
   993                              <1> .no_update_screensaver:	
   994 00004899 E8AECC              <1> 	call os_update_clock
   995                              <1> 
   996                              <1> .no_update:
   997 0000489C 2E803E[B448]01      <1> 	cmp byte [cs:timer_application_attached], 1
   998 000048A2 7406                <1> 	je .app_routine
   999                              <1> 
  1000 000048A4 07                  <1> 	pop es
  1001 000048A5 1F                  <1> 	pop ds
  1002 000048A6 6661                <1> 	popad
  1003 000048A8 FB                  <1> 	sti
  1004 000048A9 CF                  <1> 	iret
  1005                              <1> 
  1006                              <1> .app_routine:
  1007 000048AA 2EFF16[B548]        <1> 	call [cs:timer_application_offset]
  1008                              <1> 	
  1009 000048AF 07                  <1> 	pop es
  1010 000048B0 1F                  <1> 	pop ds	
  1011 000048B1 6661                <1> 	popad
  1012 000048B3 CF                  <1> 	iret
  1013                              <1> 
  1014 000048B4 00                  <1> 	timer_application_attached	db 0
  1015 000048B5 0000                <1> 	timer_application_offset	dw 0
  1016                              <1> 	
  1017 000048B7 0000                <1> 	current_timer_speed			dw 0
  1018                              <1> 	
  1019 000048B9 0000                <1> 	screensaver_timer			dw 0
   820                                  	%INCLUDE "drivers/graphics.asm"
   821                              <1> 
   822                              <1> ; Puts a pixel on the screen.
   823                              <1> ; IN: AL = Color; BH = Page; CX = X position; DX = Y position
   824                              <1> ; OUT: nothing
   825                              <1> os_put_pixel:
   826 000048BB 60                  <1> 	pusha
   827 000048BC B40C                <1> 	mov ah, 0Ch
   828 000048BE CD10                <1> 	int 10h
   829 000048C0 61                  <1> 	popa
   830 000048C1 C3                  <1> 	ret
   831                              <1> 	
   832                              <1> ; Gets a pixel from the screen.
   833                              <1> ; IN: BH = Page; CX = X position; DX = Y position
   834                              <1> ; OUT: AL = Color
   835                              <1> os_get_pixel:
   836 000048C2 60                  <1> 	pusha
   837 000048C3 B40D                <1> 	mov ah, 0Dh
   838 000048C5 CD10                <1> 	int 10h
   839 000048C7 A2[CF48]            <1> 	mov [.tmp_byte], al
   840 000048CA 61                  <1> 	popa
   841 000048CB A0[CF48]            <1> 	mov al, [.tmp_byte]
   842 000048CE C3                  <1> 	ret
   843                              <1> 	
   844 000048CF 00                  <1> 	.tmp_byte	db 0
   845                              <1> 
   846                              <1> os_set_pixel:
   847 000048D0 60                  <1> 	pusha
   848 000048D1 89CA                <1> 	mov dx, cx
   849 000048D3 89C1                <1> 	mov cx, ax
   850 000048D5 88D8                <1> 	mov al, bl
   851 000048D7 B700                <1> 	mov bh, 0
   852 000048D9 E8DFFF              <1> 	call os_put_pixel
   853 000048DC 61                  <1> 	popa
   854 000048DD C3                  <1> 	ret
   855                              <1> 	
   856                              <1> ; Implementation of Bresenham's line algorithm. Translated from an implementation in C (http://www.edepot.com/linebresenham.html)
   857                              <1> ; IN: CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour
   858                              <1> ; OUT: None, registers preserved
   859                              <1> os_draw_line:
   860 000048DE 60                  <1> 	pusha				; Save parameters
   861                              <1> 	
   862 000048DF 31C0                <1> 	xor ax, ax			; Clear variables
   863 000048E1 BF[444A]            <1> 	mov di, .x1
   864 000048E4 B90B00              <1> 	mov cx, 11
   865 000048E7 F3AB                <1> 	rep stosw
   866                              <1> 	
   867 000048E9 61                  <1> 	popa				; Restore and save parameters
   868 000048EA 60                  <1> 	pusha
   869                              <1> 	
   870 000048EB 890E[444A]          <1> 	mov [.x1], cx			; Save points
   871 000048EF 890E[4C4A]          <1> 	mov [.x], cx
   872 000048F3 8916[464A]          <1> 	mov [.y1], dx
   873 000048F7 8916[4E4A]          <1> 	mov [.y], dx
   874 000048FB 8936[484A]          <1> 	mov [.x2], si
   875 000048FF 893E[4A4A]          <1> 	mov [.y2], di
   876                              <1> 	
   877 00004903 881E[5A4A]          <1> 	mov [.colour], bl		; Save the colour
   878                              <1> 	
   879 00004907 8B1E[484A]          <1> 	mov bx, [.x2]
   880 0000490B A1[444A]            <1> 	mov ax, [.x1]
   881 0000490E 39C3                <1> 	cmp bx, ax
   882 00004910 7C0E                <1> 	jl .x1gtx2
   883                              <1> 	
   884 00004912 29C3                <1> 	sub bx, ax
   885 00004914 891E[504A]          <1> 	mov [.dx], bx
   886 00004918 B80100              <1> 	mov ax, 1
   887 0000491B A3[544A]            <1> 	mov [.incx], ax
   888 0000491E EB0B                <1> 	jmp .test2
   889                              <1> 	
   890                              <1> .x1gtx2:
   891 00004920 29D8                <1> 	sub ax, bx
   892 00004922 A3[504A]            <1> 	mov [.dx], ax
   893 00004925 B8FFFF              <1> 	mov ax, -1
   894 00004928 A3[544A]            <1> 	mov [.incx], ax
   895                              <1> 	
   896                              <1> .test2:
   897 0000492B 8B1E[4A4A]          <1> 	mov bx, [.y2]
   898 0000492F A1[464A]            <1> 	mov ax, [.y1]
   899 00004932 39C3                <1> 	cmp bx, ax
   900 00004934 7C0E                <1> 	jl .y1gty2
   901                              <1> 	
   902 00004936 29C3                <1> 	sub bx, ax
   903 00004938 891E[524A]          <1> 	mov [.dy], bx
   904 0000493C B80100              <1> 	mov ax, 1
   905 0000493F A3[564A]            <1> 	mov [.incy], ax
   906 00004942 EB0B                <1> 	jmp .test3
   907                              <1> 	
   908                              <1> .y1gty2:
   909 00004944 29D8                <1> 	sub ax, bx
   910 00004946 A3[524A]            <1> 	mov [.dy], ax
   911 00004949 B8FFFF              <1> 	mov ax, -1
   912 0000494C A3[564A]            <1> 	mov [.incy], ax
   913                              <1> 	
   914                              <1> .test3:
   915 0000494F 8B1E[504A]          <1> 	mov bx, [.dx]
   916 00004953 A1[524A]            <1> 	mov ax, [.dy]
   917 00004956 39C3                <1> 	cmp bx, ax
   918 00004958 7C6E                <1> 	jl .dygtdx
   919                              <1> 	
   920 0000495A A1[524A]            <1> 	mov ax, [.dy]
   921 0000495D D1E0                <1> 	shl ax, 1
   922 0000495F A3[524A]            <1> 	mov [.dy], ax
   923                              <1> 	
   924 00004962 8B1E[504A]          <1> 	mov bx, [.dx]
   925 00004966 29D8                <1> 	sub ax, bx
   926 00004968 A3[584A]            <1> 	mov [.balance], ax
   927                              <1> 	
   928 0000496B D1E3                <1> 	shl bx, 1
   929 0000496D 891E[504A]          <1> 	mov [.dx], bx
   930                              <1> 	
   931                              <1> .xloop:
   932 00004971 A1[4C4A]            <1> 	mov ax, [.x]
   933 00004974 8B1E[484A]          <1> 	mov bx, [.x2]
   934 00004978 39D8                <1> 	cmp ax, bx
   935 0000497A 0F84B600            <1> 	je .done
   936                              <1> 	
   937 0000497E A1[4C4A]            <1> 	mov ax, [.x]
   938 00004981 8B0E[4E4A]          <1> 	mov cx, [.y]
   939 00004985 8A1E[5A4A]          <1> 	mov bl, [.colour]
   940 00004989 E844FF              <1> 	call os_set_pixel
   941                              <1> 	
   942 0000498C 31F6                <1> 	xor si, si
   943 0000498E 8B3E[584A]          <1> 	mov di, [.balance]
   944 00004992 39F7                <1> 	cmp di, si
   945 00004994 7C18                <1> 	jl .xloop1
   946                              <1> 	
   947 00004996 A1[4E4A]            <1> 	mov ax, [.y]
   948 00004999 8B1E[564A]          <1> 	mov bx, [.incy]
   949 0000499D 01D8                <1> 	add ax, bx
   950 0000499F A3[4E4A]            <1> 	mov [.y], ax
   951                              <1> 	
   952 000049A2 A1[584A]            <1> 	mov ax, [.balance]
   953 000049A5 8B1E[504A]          <1> 	mov bx, [.dx]
   954 000049A9 29D8                <1> 	sub ax, bx
   955 000049AB A3[584A]            <1> 	mov [.balance], ax
   956                              <1> 	
   957                              <1> .xloop1:
   958 000049AE A1[584A]            <1> 	mov ax, [.balance]
   959 000049B1 8B1E[524A]          <1> 	mov bx, [.dy]
   960 000049B5 01D8                <1> 	add ax, bx
   961 000049B7 A3[584A]            <1> 	mov [.balance], ax
   962                              <1> 	
   963 000049BA A1[4C4A]            <1> 	mov ax, [.x]
   964 000049BD 8B1E[544A]          <1> 	mov bx, [.incx]
   965 000049C1 01D8                <1> 	add ax, bx
   966 000049C3 A3[4C4A]            <1> 	mov [.x], ax
   967                              <1> 	
   968 000049C6 EBA9                <1> 	jmp .xloop
   969                              <1> 	
   970                              <1> .dygtdx:
   971 000049C8 A1[504A]            <1> 	mov ax, [.dx]
   972 000049CB D1E0                <1> 	shl ax, 1
   973 000049CD A3[504A]            <1> 	mov [.dx], ax
   974                              <1> 	
   975 000049D0 8B1E[524A]          <1> 	mov bx, [.dy]
   976 000049D4 29D8                <1> 	sub ax, bx
   977 000049D6 A3[584A]            <1> 	mov [.balance], ax
   978                              <1> 	
   979 000049D9 D1E3                <1> 	shl bx, 1
   980 000049DB 891E[524A]          <1> 	mov [.dy], bx
   981                              <1> 	
   982                              <1> .yloop:
   983 000049DF A1[4E4A]            <1> 	mov ax, [.y]
   984 000049E2 8B1E[4A4A]          <1> 	mov bx, [.y2]
   985 000049E6 39D8                <1> 	cmp ax, bx
   986 000049E8 744A                <1> 	je .done
   987                              <1> 	
   988 000049EA A1[4C4A]            <1> 	mov ax, [.x]
   989 000049ED 8B0E[4E4A]          <1> 	mov cx, [.y]
   990 000049F1 8A1E[5A4A]          <1> 	mov bl, [.colour]
   991 000049F5 E8D8FE              <1> 	call os_set_pixel
   992                              <1> 	
   993 000049F8 31F6                <1> 	xor si, si
   994 000049FA 8B3E[584A]          <1> 	mov di, [.balance]
   995 000049FE 39F7                <1> 	cmp di, si
   996 00004A00 7C18                <1> 	jl .yloop1
   997                              <1> 	
   998 00004A02 A1[4C4A]            <1> 	mov ax, [.x]
   999 00004A05 8B1E[544A]          <1> 	mov bx, [.incx]
  1000 00004A09 01D8                <1> 	add ax, bx
  1001 00004A0B A3[4C4A]            <1> 	mov [.x], ax
  1002                              <1> 	
  1003 00004A0E A1[584A]            <1> 	mov ax, [.balance]
  1004 00004A11 8B1E[524A]          <1> 	mov bx, [.dy]
  1005 00004A15 29D8                <1> 	sub ax, bx
  1006 00004A17 A3[584A]            <1> 	mov [.balance], ax
  1007                              <1> 	
  1008                              <1> .yloop1:
  1009 00004A1A A1[584A]            <1> 	mov ax, [.balance]
  1010 00004A1D 8B1E[504A]          <1> 	mov bx, [.dx]
  1011 00004A21 01D8                <1> 	add ax, bx
  1012 00004A23 A3[584A]            <1> 	mov [.balance], ax
  1013                              <1> 	
  1014 00004A26 A1[4E4A]            <1> 	mov ax, [.y]
  1015 00004A29 8B1E[564A]          <1> 	mov bx, [.incy]
  1016 00004A2D 01D8                <1> 	add ax, bx
  1017 00004A2F A3[4E4A]            <1> 	mov [.y], ax
  1018                              <1> 	
  1019 00004A32 EBAB                <1> 	jmp .yloop
  1020                              <1> 	
  1021                              <1> .done:
  1022 00004A34 A1[4C4A]            <1> 	mov ax, [.x]
  1023 00004A37 8B0E[4E4A]          <1> 	mov cx, [.y]
  1024 00004A3B 8A1E[5A4A]          <1> 	mov bl, [.colour]
  1025 00004A3F E88EFE              <1> 	call os_set_pixel
  1026                              <1> 	
  1027 00004A42 61                  <1> 	popa
  1028 00004A43 C3                  <1> 	ret
  1029                              <1> 	
  1030                              <1> 	
  1031 00004A44 0000                <1> 	.x1 dw 0
  1032 00004A46 0000                <1> 	.y1 dw 0
  1033 00004A48 0000                <1> 	.x2 dw 0
  1034 00004A4A 0000                <1> 	.y2 dw 0
  1035                              <1> 	
  1036 00004A4C 0000                <1> 	.x dw 0
  1037 00004A4E 0000                <1> 	.y dw 0
  1038 00004A50 0000                <1> 	.dx dw 0
  1039 00004A52 0000                <1> 	.dy dw 0
  1040 00004A54 0000                <1> 	.incx dw 0
  1041 00004A56 0000                <1> 	.incy dw 0
  1042 00004A58 0000                <1> 	.balance dw 0
  1043 00004A5A 00                  <1> 	.colour db 0
  1044 00004A5B 00                  <1> 	.pad db 0
  1045                              <1> 	
  1046                              <1> ; Draw (straight) rectangle
  1047                              <1> ; IN: CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour, CF = set if filled or clear if not
  1048                              <1> ; OUT: None, registers preserved
  1049                              <1> os_draw_rectangle:
  1050 00004A5C 60                  <1> 	pusha
  1051 00004A5D 9C                  <1> 	pushf
  1052                              <1> 	
  1053 00004A5E 890E[E84A]          <1> 	mov word [.x1], cx
  1054 00004A62 8916[EC4A]          <1> 	mov word [.y1], dx
  1055 00004A66 8936[EA4A]          <1> 	mov word [.x2], si
  1056 00004A6A 893E[EE4A]          <1> 	mov word [.y2], di
  1057                              <1> 	
  1058 00004A6E 9D                  <1> 	popf
  1059 00004A6F 7302                <1> 	jnc .draw_line
  1060                              <1> 
  1061 00004A71 EB4E                <1> 	jmp .fill_shape
  1062                              <1> 	
  1063                              <1> .draw_line:
  1064                              <1> 	; top line
  1065 00004A73 8B0E[E84A]          <1> 	mov cx, [.x1]
  1066 00004A77 8B16[EC4A]          <1> 	mov dx, [.y1]
  1067 00004A7B 8B36[EA4A]          <1> 	mov si, [.x2]
  1068 00004A7F 8B3E[EC4A]          <1> 	mov di, [.y1]
  1069 00004A83 E858FE              <1> 	call os_draw_line
  1070                              <1> 	
  1071                              <1> 	; left line
  1072 00004A86 8B0E[E84A]          <1> 	mov cx, [.x1]
  1073 00004A8A 8B16[EC4A]          <1> 	mov dx, [.y1]
  1074 00004A8E 8B36[E84A]          <1> 	mov si, [.x1]
  1075 00004A92 8B3E[EE4A]          <1> 	mov di, [.y2]
  1076 00004A96 E845FE              <1> 	call os_draw_line
  1077                              <1> 	
  1078                              <1> 	; right line
  1079 00004A99 8B0E[EA4A]          <1> 	mov cx, [.x2]
  1080 00004A9D 8B16[EC4A]          <1> 	mov dx, [.y1]
  1081 00004AA1 8B36[EA4A]          <1> 	mov si, [.x2]
  1082 00004AA5 8B3E[EE4A]          <1> 	mov di, [.y2]
  1083 00004AA9 E832FE              <1> 	call os_draw_line
  1084                              <1> 
  1085                              <1> 	; bottom line
  1086 00004AAC 8B0E[E84A]          <1> 	mov cx, [.x1]
  1087 00004AB0 8B16[EE4A]          <1> 	mov dx, [.y2]
  1088 00004AB4 8B36[EA4A]          <1> 	mov si, [.x2]
  1089 00004AB8 8B3E[EE4A]          <1> 	mov di, [.y2]
  1090 00004ABC E81FFE              <1> 	call os_draw_line
  1091                              <1> 		
  1092 00004ABF EB25                <1> 	jmp .finished_fill
  1093                              <1> 		
  1094                              <1> .fill_shape:
  1095 00004AC1 88D8                <1> 	mov al, bl
  1096                              <1> 
  1097 00004AC3 39F1                <1> 	cmp cx, si		; Is X1 smaller than X2?
  1098 00004AC5 7C02                <1> 	jl .x_good
  1099 00004AC7 87CE                <1> 	xchg cx, si		; If not, exchange them
  1100                              <1> .x_good:
  1101 00004AC9 39FA                <1> 	cmp dx, di		; Is Y1 smaller than Y2?
  1102 00004ACB 7C02                <1> 	jl .y_good
  1103 00004ACD 87D7                <1> 	xchg dx, di		; If not, exchange them
  1104                              <1> .y_good:
  1105 00004ACF 890E[E84A]          <1> 	mov [.x1], cx
  1106 00004AD3 B700                <1> 	mov bh, 0
  1107                              <1> .x_loop:
  1108 00004AD5 E8E3FD              <1> 	call os_put_pixel
  1109 00004AD8 41                  <1> 	inc cx
  1110                              <1> 	
  1111 00004AD9 39F1                <1> 	cmp cx, si
  1112 00004ADB 7CF8                <1> 	jl .x_loop
  1113                              <1> 	
  1114 00004ADD 42                  <1> 	inc dx
  1115 00004ADE 8B0E[E84A]          <1> 	mov cx, [.x1]
  1116                              <1> 	
  1117 00004AE2 39FA                <1> 	cmp dx, di
  1118 00004AE4 7CEF                <1> 	jl .x_loop
  1119                              <1> 		
  1120                              <1> .finished_fill:
  1121 00004AE6 61                  <1> 	popa
  1122 00004AE7 C3                  <1> 	ret
  1123                              <1> 	
  1124 00004AE8 0000                <1> 	.x1				dw 0
  1125 00004AEA 0000                <1> 	.x2				dw 0
  1126 00004AEC 0000                <1> 	.y1				dw 0
  1127 00004AEE 0000                <1> 	.y2				dw 0
  1128                              <1> 
  1129                              <1> ; Draw freeform shape
  1130                              <1> ; IN: BH = number of points, BL = colour, SI = location of shape points data
  1131                              <1> ; OUT: None, registers preserved
  1132                              <1> ; DATA FORMAT: x1, y1, x2, y2, x3, y3, etc
  1133                              <1> os_draw_polygon:
  1134 00004AF0 60                  <1> 	pusha
  1135                              <1> 	
  1136 00004AF1 FECF                <1> 	dec bh
  1137 00004AF3 883E[5E4B]          <1> 	mov byte [.points], bh
  1138                              <1> 	
  1139 00004AF7 648B04              <1> 	mov word ax, [fs:si]
  1140 00004AFA 83C602              <1> 	add si, 2
  1141 00004AFD A3[564B]            <1> 	mov word [.xi], ax
  1142 00004B00 A3[5A4B]            <1> 	mov word [.xl], ax
  1143                              <1> 	
  1144 00004B03 648B04              <1> 	mov word ax, [fs:si]
  1145 00004B06 83C602              <1> 	add si, 2
  1146 00004B09 A3[584B]            <1> 	mov word [.yi], ax
  1147 00004B0C A3[5C4B]            <1> 	mov word [.yl], ax
  1148                              <1> 	
  1149                              <1> 	.draw_points:
  1150 00004B0F 8B0E[5A4B]          <1> 		mov cx, [.xl]
  1151 00004B13 8B16[5C4B]          <1> 		mov dx, [.yl]
  1152                              <1> 		
  1153 00004B17 648B04              <1> 		mov word ax, [fs:si]
  1154 00004B1A 83C602              <1> 		add si, 2
  1155 00004B1D A3[5A4B]            <1> 		mov word [.xl], ax
  1156                              <1> 		
  1157 00004B20 648B04              <1> 		mov word ax, [fs:si]
  1158 00004B23 83C602              <1> 		add si, 2
  1159 00004B26 A3[5C4B]            <1> 		mov word [.yl], ax
  1160                              <1> 		
  1161 00004B29 56                  <1> 		push si
  1162                              <1> 		
  1163 00004B2A 8B36[5A4B]          <1> 		mov si, [.xl]
  1164 00004B2E 8B3E[5C4B]          <1> 		mov di, [.yl]
  1165                              <1> 		
  1166 00004B32 E8A9FD              <1> 		call os_draw_line
  1167                              <1> 		
  1168 00004B35 5E                  <1> 		pop si
  1169                              <1> 		
  1170 00004B36 FE0E[5E4B]          <1> 		dec byte [.points]
  1171 00004B3A 803E[5E4B]00        <1> 		cmp byte [.points], 0
  1172 00004B3F 75CE                <1> 		jne .draw_points
  1173                              <1> 		
  1174 00004B41 8B0E[5A4B]          <1> 	mov cx, [.xl]
  1175 00004B45 8B16[5C4B]          <1> 	mov dx, [.yl]
  1176 00004B49 8B36[564B]          <1> 	mov si, [.xi]
  1177 00004B4D 8B3E[584B]          <1> 	mov di, [.yi]
  1178 00004B51 E88AFD              <1> 	call os_draw_line
  1179                              <1> 	
  1180 00004B54 61                  <1> 	popa
  1181 00004B55 C3                  <1> 	ret
  1182                              <1> 	
  1183 00004B56 0000                <1> 	.xi				dw 0
  1184 00004B58 0000                <1> 	.yi				dw 0
  1185 00004B5A 0000                <1> 	.xl				dw 0
  1186 00004B5C 0000                <1> 	.yl				dw 0
  1187 00004B5E 00                  <1> 	.points				db 0
  1188                              <1> 	
  1189                              <1> 
  1190                              <1> ; Clear the screen by setting all pixels to a single colour
  1191                              <1> ; BL = colour to set
  1192                              <1> os_clear_graphics:
  1193 00004B5F 60                  <1> 	pusha
  1194 00004B60 06                  <1> 	push es
  1195                              <1> 	
  1196 00004B61 B800A0              <1> 	mov ax, 0xA000
  1197 00004B64 8EC0                <1> 	mov es, ax
  1198                              <1> 
  1199 00004B66 88D8                <1> 	mov al, bl
  1200 00004B68 BF0000              <1> 	mov di, 0
  1201 00004B6B B900FA              <1> 	mov cx, 64000
  1202 00004B6E F3AA                <1> 	rep stosb
  1203                              <1> 
  1204 00004B70 07                  <1> 	pop es
  1205 00004B71 61                  <1> 	popa
  1206 00004B72 C3                  <1> 	ret
  1207                              <1> 	
  1208                              <1> 	
  1209                              <1> ; ----------------------------------------
  1210                              <1> ; os_draw_circle -- draw a circular shape
  1211                              <1> ; IN: AL = colour, BX = radius, CX = middle X, DX = middle y
  1212                              <1> 
  1213                              <1> os_draw_circle:
  1214 00004B73 60                  <1> 	pusha
  1215 00004B74 A2[354C]            <1> 	mov [.colour], al
  1216 00004B77 891E[3A4C]          <1> 	mov [.radius], bx
  1217 00004B7B 890E[364C]          <1> 	mov [.x0], cx
  1218 00004B7F 8916[384C]          <1> 	mov [.y0], dx
  1219                              <1> 
  1220 00004B83 891E[3C4C]          <1> 	mov [.x], bx
  1221 00004B87 C706[3E4C]0000      <1> 	mov word [.y], 0
  1222 00004B8D B80100              <1> 	mov ax, 1
  1223 00004B90 D1E3                <1> 	shl bx, 1
  1224 00004B92 29D8                <1> 	sub ax, bx
  1225 00004B94 A3[404C]            <1> 	mov [.xChange], ax
  1226 00004B97 C706[424C]0000      <1> 	mov word [.yChange], 0
  1227 00004B9D C706[444C]0000      <1> 	mov word [.radiusError], 0
  1228                              <1> 
  1229                              <1> .next_point:
  1230 00004BA3 8B0E[3C4C]          <1> 	mov cx, [.x]
  1231 00004BA7 8B16[3E4C]          <1> 	mov dx, [.y]
  1232 00004BAB 39D1                <1> 	cmp cx, dx
  1233 00004BAD 0F8C8200            <1> 	jl .finish
  1234                              <1> 
  1235                              <1> 	;ax bx - function points
  1236                              <1> 	;cx = x 
  1237                              <1> 	;dx = y
  1238                              <1> 	;si = -x
  1239                              <1> 	;di = -y
  1240                              <1> 
  1241 00004BB1 89CE                <1> 	mov si, cx
  1242 00004BB3 83F6FF              <1> 	xor si, 0xFFFF
  1243 00004BB6 46                  <1> 	inc si
  1244 00004BB7 89D7                <1> 	mov di, dx
  1245 00004BB9 83F7FF              <1> 	xor di, 0xFFFF
  1246 00004BBC 47                  <1> 	inc di
  1247                              <1> 
  1248                              <1> 	; (x + x0, y + y0)
  1249 00004BBD 89C8                <1> 	mov ax, cx
  1250 00004BBF 89D3                <1> 	mov bx, dx
  1251 00004BC1 E85B00              <1> 	call .draw_point
  1252                              <1> 
  1253                              <1> 	; (y + x0, x + y0)
  1254 00004BC4 93                  <1> 	xchg ax, bx
  1255 00004BC5 E85700              <1> 	call .draw_point
  1256                              <1> 
  1257                              <1> 	; (-x + x0, y + y0)
  1258 00004BC8 89F0                <1> 	mov ax, si
  1259 00004BCA 89D3                <1> 	mov bx, dx
  1260 00004BCC E85000              <1> 	call .draw_point
  1261                              <1> 
  1262                              <1> 	; (-y + x0, x + y0)
  1263 00004BCF 89F8                <1> 	mov ax, di
  1264 00004BD1 89CB                <1> 	mov bx, cx
  1265 00004BD3 E84900              <1> 	call .draw_point
  1266                              <1> 
  1267                              <1> 	; (-x + x0, -y + y0)
  1268 00004BD6 89F0                <1> 	mov ax, si
  1269 00004BD8 89FB                <1> 	mov bx, di
  1270 00004BDA E84200              <1> 	call .draw_point
  1271                              <1> 
  1272                              <1> 	; (-y + x0, -x + y0)
  1273 00004BDD 93                  <1> 	xchg ax, bx
  1274 00004BDE E83E00              <1> 	call .draw_point
  1275                              <1> 
  1276                              <1> 	; (x + x0, -y + y0)
  1277 00004BE1 89C8                <1> 	mov ax, cx
  1278 00004BE3 89FB                <1> 	mov bx, di
  1279 00004BE5 E83700              <1> 	call .draw_point
  1280                              <1> 
  1281                              <1> 	; (y + x0, -x + y0)
  1282 00004BE8 89D0                <1> 	mov ax, dx
  1283 00004BEA 89F3                <1> 	mov bx, si
  1284 00004BEC E83000              <1> 	call .draw_point
  1285                              <1> 	
  1286 00004BEF FF06[3E4C]          <1> 	inc word [.y]
  1287 00004BF3 A1[424C]            <1> 	mov ax, [.yChange]
  1288 00004BF6 0106[444C]          <1> 	add [.radiusError], ax
  1289 00004BFA 8306[424C]02        <1> 	add word [.yChange], 2
  1290                              <1> 	
  1291 00004BFF A1[444C]            <1> 	mov ax, [.radiusError]
  1292 00004C02 D1E0                <1> 	shl ax, 1
  1293 00004C04 0306[404C]          <1> 	add ax, [.xChange]
  1294                              <1> 	
  1295 00004C08 83F800              <1> 	cmp ax, 0
  1296 00004C0B 7E96                <1> 	jle .next_point
  1297                              <1> 	
  1298 00004C0D FF0E[3C4C]          <1> 	dec word [.x]
  1299 00004C11 A1[404C]            <1> 	mov ax, [.xChange]
  1300 00004C14 0106[444C]          <1> 	add [.radiusError], ax
  1301 00004C18 8306[404C]02        <1> 	add word [.xChange], 2
  1302                              <1> 
  1303 00004C1D EB84                <1> 	jmp .next_point
  1304                              <1> 
  1305                              <1> .draw_point:
  1306                              <1> 	; AX = X, BX = Y
  1307 00004C1F 60                  <1> 	pusha
  1308 00004C20 0306[364C]          <1> 	add ax, [.x0]
  1309 00004C24 031E[384C]          <1> 	add bx, [.y0]
  1310 00004C28 89D9                <1> 	mov cx, bx
  1311 00004C2A 8A1E[354C]          <1> 	mov bl, [.colour]
  1312 00004C2E E89FFC              <1> 	call os_set_pixel
  1313 00004C31 61                  <1> 	popa
  1314 00004C32 C3                  <1> 	ret
  1315                              <1> 	
  1316                              <1> .finish:
  1317 00004C33 61                  <1> 	popa
  1318 00004C34 C3                  <1> 	ret
  1319                              <1> 	
  1320                              <1> 
  1321                              <1> 
  1322 00004C35 00                  <1> .colour				db 0
  1323 00004C36 0000                <1> .x0					dw 0
  1324 00004C38 0000                <1> .y0					dw 0
  1325 00004C3A 0000                <1> .radius				dw 0
  1326 00004C3C 0000                <1> .x					dw 0
  1327 00004C3E 0000                <1> .y					dw 0
  1328 00004C40 0000                <1> .xChange			dw 0
  1329 00004C42 0000                <1> .yChange			dw 0
  1330 00004C44 0000                <1> .radiusError		dw 0
   821                                  	%INCLUDE "drivers/name.asm"
   822                              <1> 
   823 00004C46 43726570654F532076- <1> 	osname	db 'CrepeOS v0.7b4', 0
   823 00004C4F 302E37623400        <1>
   822                                  	%INCLUDE "drivers/shutdown.asm"
   823                              <1> 
   824                              <1> os_shutdown:
   825 00004C55 C606820001          <1> 	mov byte [0082h], 1
   826 00004C5A E849CC              <1> 	call os_hide_cursor
   827 00004C5D E8E000              <1> 	call .drawbackground
   828 00004C60 E87E00              <1> 	call .drawwindow
   829 00004C63 E81200              <1> 	call .selector
   830                              <1> 	
   831 00004C66 3C01                <1> 	cmp al, 1
   832 00004C68 0F841401            <1> 	je near .shutdown
   833                              <1> 	
   834 00004C6C 3C02                <1> 	cmp al, 2
   835 00004C6E 0F840901            <1> 	je near .reset
   836                              <1> 	
   837 00004C72 3C03                <1> 	cmp al, 3
   838 00004C74 0F845BB6            <1> 	je near checkformenu
   839                              <1> 	
   840                              <1> .selector:
   841 00004C78 BA1C0B              <1> 	mov dx, 11 * 256 + 28
   842 00004C7B E8E8CB              <1> 	call os_move_cursor
   843                              <1> 
   844                              <1> .selectorloop:
   845 00004C7E E87000              <1> 	call .drawcontents
   846 00004C81 E83A00              <1> 	call .invert
   847                              <1> 	
   848 00004C84 E8F3C5              <1> 	call os_wait_for_key
   849                              <1> 	
   850 00004C87 80FC50              <1> 	cmp ah, 80
   851 00004C8A 7417                <1> 	je .selectdown
   852                              <1> 	
   853 00004C8C 80FC48              <1> 	cmp ah, 72
   854 00004C8F 741D                <1> 	je .selectup
   855                              <1> 	
   856 00004C91 3C0D                <1> 	cmp al, 13
   857 00004C93 7424                <1> 	je .select
   858                              <1> 	
   859 00004C95 3C1B                <1> 	cmp al, 27
   860 00004C97 7402                <1> 	je .return
   861                              <1> 	
   862 00004C99 EBE3                <1> 	jmp .selectorloop
   863                              <1> 
   864                              <1> .return:
   865 00004C9B B003                <1> 	mov al, 3
   866 00004C9D C606820001          <1> 	mov byte [0082h], 1
   867 00004CA2 C3                  <1> 	ret
   868                              <1> 
   869                              <1> .selectdown:
   870 00004CA3 80FE0D              <1> 	cmp dh, 13
   871 00004CA6 0F84D4FF            <1> 	je near .selectorloop
   872 00004CAA FEC6                <1> 	inc dh
   873 00004CAC EBD0                <1> 	jmp .selectorloop
   874                              <1> 
   875                              <1> .selectup:
   876 00004CAE 80FE0B              <1> 	cmp dh, 11
   877 00004CB1 0F84C9FF            <1> 	je near .selectorloop
   878 00004CB5 FECE                <1> 	dec dh
   879 00004CB7 EBC5                <1> 	jmp .selectorloop
   880                              <1> 
   881                              <1> .select:
   882 00004CB9 88F0                <1> 	mov al, dh
   883 00004CBB 2C0A                <1> 	sub al, 10
   884 00004CBD C3                  <1> 	ret
   885                              <1> 	
   886                              <1> .invert:
   887 00004CBE B21C                <1> 	mov dl, 28
   888                              <1> 
   889                              <1> .invertloop:
   890 00004CC0 E8A3CB              <1> 	call os_move_cursor
   891 00004CC3 B408                <1> 	mov ah, 08h
   892 00004CC5 B700                <1> 	mov bh, 0
   893 00004CC7 CD10                <1> 	int 10h
   894                              <1> 
   895 00004CC9 BBF000              <1> 	mov bx, 240			; Black on white
   896 00004CCC B409                <1> 	mov ah, 09h
   897 00004CCE B90100              <1> 	mov cx, 1
   898 00004CD1 CD10                <1> 	int 10h
   899                              <1> 
   900 00004CD3 FEC2                <1> 	inc dl
   901 00004CD5 80FA3C              <1> 	cmp dl, 60
   902 00004CD8 0F840200            <1> 	je near .invertend
   903 00004CDC EBE2                <1> 	jmp .invertloop
   904                              <1> 	
   905                              <1> .invertend:
   906 00004CDE B21C                <1> 	mov dl, 28
   907 00004CE0 C3                  <1> 	ret
   908                              <1> 	
   909                              <1> .drawwindow:
   910 00004CE1 BA1309              <1> 	mov dx, 9 * 256 + 19			; First, draw white background box
   911 00004CE4 8A1EA9DE            <1> 	mov bl, [57001]
   912 00004CE8 BE2A00              <1> 	mov si, 42
   913 00004CEB BF0F00              <1> 	mov di, 15
   914 00004CEE E8BFCB              <1> 	call os_draw_block
   915                              <1> 
   916                              <1> .drawcontents:
   917 00004CF1 60                  <1> 	pusha
   918 00004CF2 8A1EA9DE            <1> 	mov bl, [57001]
   919 00004CF6 BA140A              <1> 	mov dx, 10 * 256 + 20
   920 00004CF9 E86ACB              <1> 	call os_move_cursor
   921                              <1> 
   922 00004CFC BE[1C4E]            <1> 	mov si, .dialogmsg1
   923 00004CFF E81DCB              <1> 	call os_format_string
   924 00004D02 BECCDE              <1> 	mov si, 57036
   925 00004D05 E817CB              <1> 	call os_format_string
   926 00004D08 BE[264E]            <1> 	mov si, .dialogmsg2
   927 00004D0B E811CB              <1> 	call os_format_string
   928                              <1> 
   929 00004D0E BA140B              <1> 	mov dx, 11 * 256 + 20
   930 00004D11 E852CB              <1> 	call os_move_cursor
   931 00004D14 BE[B94F]            <1> 	mov si, .logo0
   932 00004D17 E805CB              <1> 	call os_format_string
   933                              <1> 
   934 00004D1A BA140C              <1> 	mov dx, 12 * 256 + 20
   935 00004D1D E846CB              <1> 	call os_move_cursor
   936 00004D20 BE[E24F]            <1> 	mov si, .logo1
   937 00004D23 E8F9CA              <1> 	call os_format_string
   938                              <1> 
   939 00004D26 BA140D              <1> 	mov dx, 13 * 256 + 20
   940 00004D29 E83ACB              <1> 	call os_move_cursor
   941 00004D2C BE[0B50]            <1> 	mov si, .logo2
   942 00004D2F E8EDCA              <1> 	call os_format_string
   943                              <1> 
   944 00004D32 BA140E              <1> 	mov dx, 14 * 256 + 20
   945 00004D35 E82ECB              <1> 	call os_move_cursor
   946 00004D38 BE[3450]            <1> 	mov si, .logo3
   947 00004D3B E8E1CA              <1> 	call os_format_string
   948 00004D3E 61                  <1> 	popa
   949 00004D3F C3                  <1> 	ret
   950                              <1> 
   951                              <1> .drawbackground:
   952 00004D40 E80DCB              <1> 	call os_clear_screen
   953 00004D43 BA0000              <1> 	mov dx, 0
   954 00004D46 E81DCB              <1> 	call os_move_cursor
   955                              <1> 	
   956 00004D49 B82009              <1> 	mov ax, 0920h
   957 00004D4C 8B1EA9DE            <1> 	mov bx, [57001]
   958 00004D50 B95000              <1> 	mov cx, 80
   959 00004D53 CD10                <1> 	int 10h
   960                              <1> 	
   961 00004D55 BA0001              <1> 	mov dx, 1 * 256
   962 00004D58 E80BCB              <1> 	call os_move_cursor
   963                              <1> 	
   964 00004D5B 8A1EA8DE            <1> 	mov bl, [57000]		; Color from RAM
   965 00004D5F 80E3F0              <1> 	and bl, 11110000b
   966 00004D62 B93007              <1> 	mov cx, 1840
   967 00004D65 B0B1                <1> 	mov al, 177
   968 00004D67 CD10                <1> 	int 10h
   969                              <1> 	
   970 00004D69 BA0018              <1> 	mov dx, 24 * 256
   971 00004D6C E8F7CA              <1> 	call os_move_cursor
   972 00004D6F 8A1EA9DE            <1> 	mov bl, [57001]
   973 00004D73 B95000              <1> 	mov cx, 80
   974 00004D76 B020                <1> 	mov al, 32
   975 00004D78 CD10                <1> 	int 10h
   976 00004D7A C3                  <1> 	ret
   977                              <1> 	
   978                              <1> .reset:
   979 00004D7B EA0000FFFF          <1> 	jmp 0FFFFh:0
   980                              <1> 
   981                              <1> .shutdown:
   982 00004D80 E8CDCA              <1> 	call os_clear_screen
   983 00004D83 E815CB              <1> 	call os_show_cursor
   984                              <1> 
   985 00004D86 BE[EB4E]            <1> 	mov si, .apmmsg
   986 00004D89 E869CA              <1> 	call os_print_string
   987                              <1> 	
   988 00004D8C BE[104F]            <1> 	mov si, .dbgmsg1
   989 00004D8F E863CA              <1> 	call os_print_string
   990                              <1> 	
   991 00004D92 B80053              <1> 	mov ax, 5300h
   992 00004D95 31DB                <1> 	xor bx, bx
   993 00004D97 CD15                <1> 	int 15h				; check if APM is present
   994 00004D99 724F                <1> 	jc .APM_missing
   995                              <1> 
   996 00004D9B BE[224F]            <1> 	mov si, .dbgmsg2
   997 00004D9E E854CA              <1> 	call os_print_string
   998                              <1> 
   999 00004DA1 B80453              <1> 	mov ax, 5304h
  1000 00004DA4 31DB                <1> 	xor bx, bx
  1001 00004DA6 CD15                <1> 	int 15h				; disconnect any previous APM interface	
  1002                              <1> 	
  1003 00004DA8 BE[504F]            <1> 	mov si, .dbgmsg2_1
  1004 00004DAB E847CA              <1> 	call os_print_string
  1005                              <1> 	
  1006 00004DAE B80E53              <1> 	mov ax, 530Eh		; Set APM to version 1.2
  1007 00004DB1 31DB                <1> 	xor bx, bx
  1008 00004DB3 B90201              <1> 	mov cx, 0102h
  1009 00004DB6 CD15                <1> 	int 15h
  1010                              <1> 
  1011 00004DB8 BE[704F]            <1> 	mov si, .dbgmsg3
  1012 00004DBB E837CA              <1> 	call os_print_string
  1013                              <1> 
  1014 00004DBE B80153              <1> 	mov ax, 5301h
  1015 00004DC1 31DB                <1> 	xor bx, bx
  1016 00004DC3 31C9                <1> 	xor cx, cx
  1017 00004DC5 CD15                <1> 	int 15h				; open an interface with APM
  1018 00004DC7 7231                <1> 	jc .APM_interface
  1019                              <1> 
  1020 00004DC9 BE[874F]            <1> 	mov si, .dbgmsg4
  1021 00004DCC E826CA              <1> 	call os_print_string
  1022                              <1> 
  1023 00004DCF B80753              <1> 	mov ax, 5307h
  1024 00004DD2 BB0100              <1> 	mov bx, 1
  1025 00004DD5 B90300              <1> 	mov cx, 3
  1026 00004DD8 CD15                <1> 	int 15h				; do a power off
  1027                              <1> 	
  1028                              <1> .APM_error:
  1029 00004DDA B8[284E]            <1> 	mov ax, .errormsg1
  1030 00004DDD BB[8C4E]            <1> 	mov bx, .errormsg4
  1031 00004DE0 B9[B34E]            <1> 	mov cx, .errormsg45
  1032 00004DE3 31D2                <1> 	xor dx, dx
  1033 00004DE5 E854D2              <1> 	call os_dialog_box
  1034                              <1> 	
  1035 00004DE8 EB91                <1> 	jmp .reset
  1036                              <1> 	
  1037                              <1> .APM_missing:
  1038 00004DEA B8[4A4E]            <1> 	mov ax, .errormsg2
  1039 00004DED BB[8C4E]            <1> 	mov bx, .errormsg4
  1040 00004DF0 B9[B34E]            <1> 	mov cx, .errormsg45
  1041 00004DF3 31D2                <1> 	xor dx, dx
  1042 00004DF5 E844D2              <1> 	call os_dialog_box
  1043                              <1> 	
  1044 00004DF8 EB81                <1> 	jmp .reset
  1045                              <1> 	
  1046                              <1> .APM_interface:
  1047 00004DFA B8[6E4E]            <1> 	mov ax, .errormsg3
  1048 00004DFD BB[8C4E]            <1> 	mov bx, .errormsg4
  1049 00004E00 B9[B34E]            <1> 	mov cx, .errormsg45
  1050 00004E03 31D2                <1> 	xor dx, dx
  1051 00004E05 E834D2              <1> 	call os_dialog_box
  1052                              <1> 	
  1053 00004E08 E970FF              <1> 	jmp .reset
  1054                              <1> 	
  1055                              <1> .APM_pwrmgmt:
  1056 00004E0B B8[CA4E]            <1> 	mov ax, .errormsg5
  1057 00004E0E BB[8C4E]            <1> 	mov bx, .errormsg4
  1058 00004E11 B9[B34E]            <1> 	mov cx, .errormsg45
  1059 00004E14 31D2                <1> 	xor dx, dx
  1060 00004E16 E823D2              <1> 	call os_dialog_box
  1061                              <1> 	
  1062 00004E19 E95FFF              <1> 	jmp .reset
  1063                              <1> 
  1064                              <1> 	
  1065 00004E1C 476F6F646279652C20- <1> 	.dialogmsg1	db 'Goodbye, ', 0
  1065 00004E25 00                  <1>
  1066 00004E26 2E00                <1> 	.dialogmsg2	db '.', 0
  1067 00004E28 4572726F7220736875- <1> 	.errormsg1	db 'Error shutting down the computer.', 0
  1067 00004E31 7474696E6720646F77- <1>
  1067 00004E3A 6E2074686520636F6D- <1>
  1067 00004E43 70757465722E00      <1>
  1068 00004E4A 5468697320636F6D70- <1> 	.errormsg2	db 'This computer does not support APM.', 0
  1068 00004E53 7574657220646F6573- <1>
  1068 00004E5C 206E6F742073757070- <1>
  1068 00004E65 6F72742041504D2E00  <1>
  1069 00004E6E 4572726F7220636F6D- <1> 	.errormsg3	db 'Error communicating with APM.', 0
  1069 00004E77 6D756E69636174696E- <1>
  1069 00004E80 672077697468204150- <1>
  1069 00004E89 4D2E00              <1>
  1070 00004E8C 506C65617365207475- <1> 	.errormsg4	db 'Please turn off the computer manually,', 0
  1070 00004E95 726E206F6666207468- <1>
  1070 00004E9E 6520636F6D70757465- <1>
  1070 00004EA7 72206D616E75616C6C- <1>
  1070 00004EB0 792C00              <1>
  1071 00004EB3 6F7220707265737320- <1> 	.errormsg45	db 'or press OK to reboot.', 0
  1071 00004EBC 4F4B20746F20726562- <1>
  1071 00004EC5 6F6F742E00          <1>
  1072 00004ECA 4572726F7220656E61- <1> 	.errormsg5	db 'Error enabling power management.', 0
  1072 00004ED3 626C696E6720706F77- <1>
  1072 00004EDC 6572206D616E616765- <1>
  1072 00004EE5 6D656E742E00        <1>
  1073                              <1> 	
  1074 00004EEB 417474656D7074696E- <1> 	.apmmsg		db 'Attempting shutdown through APM...', 13, 10, 0
  1074 00004EF4 672073687574646F77- <1>
  1074 00004EFD 6E207468726F756768- <1>
  1074 00004F06 2041504D2E2E2E0D0A- <1>
  1074 00004F0F 00                  <1>
  1075                              <1> 	
  1076                              <1> 	
  1077 00004F10 436865636B696E6720- <1> 	.dbgmsg1	db 'Checking APM...', 13, 10, 0
  1077 00004F19 41504D2E2E2E0D0A00  <1>
  1078 00004F22 446973636F6E6E6563- <1> 	.dbgmsg2	db 'Disconnecting any previous APM interface...', 13, 10, 0
  1078 00004F2B 74696E6720616E7920- <1>
  1078 00004F34 70726576696F757320- <1>
  1078 00004F3D 41504D20696E746572- <1>
  1078 00004F46 666163652E2E2E0D0A- <1>
  1078 00004F4F 00                  <1>
  1079 00004F50 53657474696E672041- <1> 	.dbgmsg2_1	db 'Setting APM version to 1.2...', 13, 10, 0
  1079 00004F59 504D2076657273696F- <1>
  1079 00004F62 6E20746F20312E322E- <1>
  1079 00004F6B 2E2E0D0A00          <1>
  1080 00004F70 436F6E6E656374696E- <1> 	.dbgmsg3	db 'Connecting to APM...', 13, 10, 0
  1080 00004F79 6720746F2041504D2E- <1>
  1080 00004F82 2E2E0D0A00          <1>
  1081 00004F87 456E61626C696E6720- <1> 	.dbgmsg4	db 'Enabling power management...', 13, 10, 0
  1081 00004F90 706F776572206D616E- <1>
  1081 00004F99 6167656D656E742E2E- <1>
  1081 00004FA2 2E0D0A00            <1>
  1082 00004FA6 5368757474696E6720- <1> 	.dbgmsg5	db 'Shutting down...', 13, 10, 0
  1082 00004FAF 646F776E2E2E2E0D0A- <1>
  1082 00004FB8 00                  <1>
  1083                              <1> 	
  1084 00004FB9 DAC4C4B3C4C4BF2020- <1> 	.logo0		db 218, 196, 196, 179, 196, 196, 191, '  Shut down your computer        ', 0
  1084 00004FC2 5368757420646F776E- <1>
  1084 00004FCB 20796F757220636F6D- <1>
  1084 00004FD4 707574657220202020- <1>
  1084 00004FDD 2020202000          <1>
  1085 00004FE2 B32020B32020B32020- <1> 	.logo1		db 179, 32, 32, 179, 32, 32, 179,     '  Restart your computer          ', 0
  1085 00004FEB 526573746172742079- <1>
  1085 00004FF4 6F757220636F6D7075- <1>
  1085 00004FFD 746572202020202020- <1>
  1085 00005006 2020202000          <1>
  1086 0000500B B32020202020B32020- <1> 	.logo2		db 179, 32, 32, 32, 32, 32, 179,      '  Go back                        ', 0
  1086 00005014 476F206261636B2020- <1>
  1086 0000501D 202020202020202020- <1>
  1086 00005026 202020202020202020- <1>
  1086 0000502F 2020202000          <1>
  1087 00005034 C0C4C4C4C4C4D900    <1> 	.logo3		db 192, 196, 196, 196, 196, 196, 217, 0
   823                                  
   824                                  ; ==================================================================
   825                                  ; END OF KERNEL
   826                                  ; ==================================================================
   827                                  
   828                                  os_kernel_end:
