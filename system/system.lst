     1                                  
     2                                  	BITS 16
     3                                  	
     4                                  	ORG 32768
     5                                  	
     6                                  ; ------------------------------------------------------------------
     7                                  ; MACROS
     8                                  ; ------------------------------------------------------------------
     9                                  	
    10                                  %macro clr 1
    11                                  	xor %1, %1
    12                                  %endmacro
    13                                  
    14                                  %macro mov16 3
    15                                  	mov %1, (%2 + %3 * 256)
    16                                  %endmacro
    17                                  
    18                                  %define ADLIB_BUFFER 0500h
    19                                  %define DESKTOP_BACKGROUND 0600h
    20                                  %define SYSTEM_FONT 1600h
    21                                  %define FILE_MANAGER 2600h
    22                                  %define disk_buffer 0E000h
    23                                  
    24                                  ; ------------------------------------------------------------------
    25                                  ; crepeOS memory map:
    26                                  ; Segment 0000h:
    27                                  ;   - 0000h - 03FFh = Interrupt vector table
    28                                  ;   - 0400h - 04FFh = BIOS data area
    29                                  ;   - 0500h - 05FFh = AdLib register buffer
    30                                  ;   - 0600h - 15FFh = Desktop background (BG.ASC)
    31                                  ;   - 1600h - 25FFh = System font (FONT.SYS)
    32                                  ;   - 2600h - 35FFh = File manager (FILEMAN.APP)
    33                                  ; Segment 0360h:
    34                                  ;   - 0000h - 00FFh = System variables
    35                                  ;      - 0000h = RET instruction
    36                                  ;      - 0001h - 0050h = Footer buffer
    37                                  ;      - 0051h - 0081h = File selector filter buffer
    38                                  ;      - 0082h = System state (byte)
    39                                  ;         - 0 if a GUI application is running
    40                                  ;         - 1 if a non-GUI application is running (no header/footer)
    41                                  ;      - 0083h = Sound state (byte)
    42                                  ;         - 0 if sound disabled
    43                                  ;         - 1 if sound enabled
    44                                  ;      - 0084h = Default boot device (byte)
    45                                  ;      - 0085h = Default button for os_dialog_box (0 = OK, 1 = Cancel) (byte)
    46                                  ;      - 0086h = int_filename_convert error status (byte)
    47                                  ;         - 0 if filename too long
    48                                  ;         - 1 if filename empty
    49                                  ;         - 2 if no extension found
    50                                  ;         - 3 if no basename found
    51                                  ;         - 4 if extension too short
    52                                  ;      - 0087h = Flag for os_file_selector input (byte)
    53                                  ;      - 0088h = Maximum number of characters that os_input_string can input (byte)
    54                                  ;      - 0089h = Width of os_list_dialog (word)
    55                                  ;      - 00E0h - 00EFh - parameters for an app (eg. a file to open when an app launches)
    56                                  ;      - 00F0h - 00FFh - temporary buffer for storing apps' filenames
    57                                  ;   - 0100h - 7FFEh = Application
    58                                  ;   - 7FFEh - Application return flag
    59                                  ;      - 0 = return to the desktop after an application quits
    60                                  ;      - 1 = launch another application (00F0h-00FFh) after an application quits
    61                                  ;      (example: when a user opens an app through Terminal, then terminal stores its name to 00F0h-00FFh so it starts after the requested application exits)
    62                                  ;   - 7FFFh - Application launch flag
    63                                  ;      - 0 = return to the desktop after an application quits
    64                                  ;      - 1 = launch another application (filename passed in AX) after an application quits
    65                                  ;         - Note: after launching another application this flag is set to 0
    66                                  ;   - 8000h - DEA7h = crepeOS kernel
    67                                  ;   - DEA8h - DFFFh = Configuration file (SYSTEM.CFG)
    68                                  ;      - described in CONFIG.ASM
    69                                  ;   - E000h - FFFFh = Disk buffer
    70                                  ; End of memory: 2048 bytes stack
    71                                  ; ------------------------------------------------------------------
    72                                  
    73                                  ; ------------------------------------------------------------------
    74                                  ; OS CALL VECTORS
    75                                  
    76                                  os_call_vectors:
    77 00000000 E95601                  	jmp os_main					; 8000h -- Called from bootloader
    78 00000003 E9EE17                  	jmp os_print_string			; 8003h
    79 00000006 E95C18                  	jmp os_move_cursor			; 8006h
    80 00000009 E94318                  	jmp os_clear_screen			; 8009h
    81 0000000C E97218                  	jmp os_print_horiz_line		; 800Ch
    82 0000000F E92B1F                  	jmp os_print_newline		; 800Fh
    83 00000012 E96412                  	jmp os_wait_for_key			; 8012h
    84 00000015 E90413                  	jmp os_check_for_key		; 8015h
    85 00000018 E9282B                  	jmp os_int_to_string		; 8018h
    86 0000001B E90B26                  	jmp os_speaker_tone			; 801Bh
    87 0000001E E94826                  	jmp os_speaker_off			; 801Eh
    88 00000021 E9680B                  	jmp os_load_file			; 8021h
    89 00000024 E9A414                  	jmp os_pause				; 8024h
    90 00000027 E97515                  	jmp os_fatal_error			; 8027h
    91 0000002A E9431E                  	jmp os_draw_background		; 802Ah
    92 0000002D E98229                  	jmp os_string_length		; 802Dh
    93 00000030 E9D829                  	jmp os_string_uppercase		; 8030h
    94 00000033 E9F229                  	jmp os_string_lowercase		; 8033h
    95 00000036 E97321                  	jmp os_input_string			; 8036h
    96 00000039 E9092A                  	jmp os_string_copy			; 8039h
    97 0000003C E9F81F                  	jmp os_dialog_box			; 803Ch
    98 0000003F E90C2A                  	jmp os_string_join			; 803Fh
    99 00000042 E91A0A                  	jmp os_get_file_list		; 8042h
   100 00000045 E95C2A                  	jmp os_string_compare		; 8045h
   101 00000048 E9192A                  	jmp os_string_chomp			; 8048h
   102 0000004B E9AE2A                  	jmp os_string_to_hex		; 804Bh
   103 0000004E E9E226                  	jmp os_adlib_regwrite		; 804Eh
   104 00000051 E9AE13                  	jmp os_bcd_to_int			; 8051h
   105 00000054 E9542B                  	jmp os_get_time_string		; 8054h
   106 00000057 E9B023                  	jmp os_draw_logo			; 8057h
   107 0000005A E96A18                  	jmp os_file_selector		; 805Ah
   108 0000005D E9922B                  	jmp os_get_date_string		; 805Dh
   109 00000060 E95A17                  	jmp os_send_via_serial		; 8060h
   110 00000063 E96917                  	jmp os_get_via_serial		; 8063h
   111 00000066 E98229                  	jmp os_find_char_in_string	; 8066h
   112 00000069 E90218                  	jmp os_get_cursor_pos		; 8069h
   113 0000006C E9FF20                  	jmp os_print_space			; 806Ch
   114 0000006F E92724                  	jmp os_option_menu			; 806Fh
   115 00000072 E90121                  	jmp os_print_digit			; 8072h
   116 00000075 E91021                  	jmp os_print_1hex			; 8075h
   117 00000078 E91621                  	jmp os_print_2hex			; 8078h
   118 0000007B E92121                  	jmp os_print_4hex			; 807Bh
   119 0000007E E94D47                  	jmp os_set_timer_speed		; 807Eh
   120 00000081 E96409                  	jmp os_report_free_space	; 8081h
   121 00000084 E91C29                  	jmp os_string_add			; 8084h
   122 00000087 E9D125                  	jmp os_speaker_note_length	; 8087h
   123 0000008A E90D18                  	jmp os_show_cursor			; 808Ah
   124 0000008D E91518                  	jmp os_hide_cursor			; 808Dh
   125 00000090 E9B71E                  	jmp os_dump_registers		; 8090h
   126 00000093 E9E01A                  	jmp os_list_dialog_tooltip	; 8093h
   127 00000096 E9550C                  	jmp os_write_file			; 8096h
   128 00000099 E9340E                  	jmp os_file_exists			; 8099h
   129 0000009C E9520E                  	jmp os_create_file			; 809Ch
   130 0000009F E92D0F                  	jmp os_remove_file			; 809Fh
   131 000000A2 E9AC0F                  	jmp os_rename_file			; 80A2h
   132 000000A5 E9DE0F                  	jmp os_get_file_size		; 80A5h
   133 000000A8 E9F61E                  	jmp os_input_dialog			; 80A8h
   134 000000AB E9051B                  	jmp os_list_dialog			; 80ABh
   135 000000AE E91A29                  	jmp os_string_reverse		; 80AEh
   136 000000B1 E9442A                  	jmp os_string_to_int		; 80B1h
   137 000000B4 E9F817                  	jmp os_draw_block			; 80B4h
   138 000000B7 E92313                  	jmp os_get_random			; 80B7h
   139 000000BA E9062C                  	jmp os_print_32int			; 80BAh
   140 000000BD E9E916                  	jmp os_serial_port_enable	; 80BDh
   141 000000C0 E9AE2A                  	jmp os_sint_to_string		; 80C0h
   142 000000C3 E9F529                  	jmp os_string_parse			; 80C3h
   143 000000C6 E9072C                  	jmp os_run_basic			; 80C6h
   144 000000C9 E92228                  	jmp os_adlib_calcfreq		; 80C9h
   145 000000CC E9D846                  	jmp os_attach_app_timer		; 80CCh
   146 000000CF E9642B                  	jmp os_string_tokenize		; 80CFh
   147 000000D2 E93614                  	jmp os_clear_registers		; 80D2h
   148 000000D5 E94617                  	jmp os_format_string		; 80D5h
   149 000000D8 E90517                  	jmp os_putchar				; 80D8h
   150 000000DB E99425                  	jmp os_start_adlib			; 80DBh
   151 000000DE E9D546                  	jmp os_return_app_timer		; 80DEh
   152 000000E1 E90223                  	jmp os_reset_font			; 80E1h
   153 000000E4 E91A17                  	jmp os_print_string_box		; 80E4h
   154 000000E7 E9FD16                  	jmp os_put_chars			; 80E7h
   155 000000EA E92426                  	jmp os_check_adlib			; 80EAh
   156 000000ED E9E947                  	jmp os_draw_line			; 80EDh
   157 000000F0 E9F849                  	jmp os_draw_polygon			; 80F0h
   158 000000F3 E9784A                  	jmp os_draw_circle			; 80F3h
   159 000000F6 E9614A                  	jmp os_clear_graphics		; 80F6h
   160 000000F9 E9B80F                  	jmp os_get_file_datetime	; 80F9h
   161 000000FC E97F28                  	jmp os_string_encrypt		; 80FCh
   162 000000FF E9B447                  	jmp os_put_pixel			; 80FFh
   163 00000102 E9B847                  	jmp os_get_pixel			; 8102h
   164 00000105 E91C23                  	jmp os_draw_icon			; 8105h
   165 00000108 E9B625                  	jmp os_stop_adlib			; 8108h
   166 0000010B E94C28                  	jmp os_adlib_noteoff		; 810Bh
   167 0000010E E9A715                  	jmp os_int_1Ah				; 810Eh
   168 00000111 E90913                  	jmp os_int_to_bcd			; 8111h
   169 00000114 E90714                  	jmp os_illegal_call			; 8114h ; FREE!!!!!!!!!!!!!!!!!!!
   170 00000117 E9D11E                  	jmp os_password_dialog		; 8117h
   171 0000011A E9D326                  	jmp os_adlib_mute			; 811Ah
   172 0000011D E93749                  	jmp os_draw_rectangle		; 811Dh
   173 00000120 E97615                  	jmp os_get_memory			; 8120h
   174 00000123 E96321                  	jmp os_color_selector		; 8123h
   175 00000126 E93846                  	jmp os_modify_int_handler	; 8126h
   176 00000129 E9232B                  	jmp os_32int_to_string		; 8129h
   177 0000012C E95222                  	jmp os_print_footer			; 812Ch
   178 0000012F E9FD21                  	jmp os_print_8hex			; 812Fh
   179 00000132 E9542B                  	jmp os_string_to_32int		; 8132h
   180 00000135 E9FF12                  	jmp os_math_power			; 8135h
   181 00000138 E94113                  	jmp os_math_root			; 8138h
   182 0000013B E9D820                  	jmp os_input_password		; 813Bh
   183 0000013E E93A46                  	jmp os_get_int_handler		; 813Eh
   184 00000141 E9DA13                  	jmp os_illegal_call			; 8141h ; FREE!!!!!!!!!!!!!!!!!!!
   185 00000144 E9FB21                  	jmp os_temp_box				; 8144h
   186 00000147 E9CA26                  	jmp os_adlib_unmute			; 8147h
   187 0000014A E9EA08                  	jmp os_read_root			; 814Ah
   188 0000014D E9CE13                  	jmp os_illegal_call			; 814Dh ; FREE!!!!!!!!!!!!!!!!!!!
   189 00000150 E9CB13                  	jmp os_illegal_call			; 8150h ; FREE!!!!!!!!!!!!!!!!!!!
   190 00000153 E9C813                  	jmp os_illegal_call			; 8153h ; FREE!!!!!!!!!!!!!!!!!!!
   191 00000156 E9F010                  	jmp disk_convert_l2hts		; 8156h
   192                                  	
   193                                  ; ------------------------------------------------------------------
   194                                  ; START OF MAIN KERNEL CODE
   195                                  
   196                                  os_main:
   197 00000159 CD12                    	int 12h						; Get RAM size
   198 0000015B 48                      	dec ax						; Some BIOSes round up, so we have to sacrifice 1 kB :(
   199 0000015C C1E006                  	shl ax, 6					; Convert kB to segments
   200                                  
   201 0000015F FA                      	cli
   202                                  
   203 00000160 2D0010                  	sub ax, 65536 / 16			; Set the stack to the top of the memory
   204 00000163 8ED0                    	mov ss, ax
   205 00000165 BCFEFF                  	mov sp, 0FFFEh
   206                                  
   207                                  ;	xor ax, ax
   208                                  ;	mov ss, ax					; Set stack segment and pointer
   209                                  ;	mov sp, 0FFFEh
   210                                  
   211 00000168 FB                      	sti
   212                                  
   213 00000169 FC                      	cld							; The default direction for string operations
   214                                  								; will be 'up' - incrementing address in RAM
   215                                  
   216 0000016A 8CC8                    	mov ax, cs					; Set all segments to match where kernel is loaded
   217 0000016C 8ED8                    	mov ds, ax			
   218 0000016E 8EC0                    	mov es, ax
   219 00000170 8E26[F205]              	mov fs, [driversgmt]
   220 00000174 050010                  	add ax, 1000h
   221 00000177 8EE8                    	mov gs, ax
   222                                  	
   223 00000179 C6060000C3              	mov byte [0000h], 0xC3
   224 0000017E 88168400                	mov [0084h], dl
   225 00000182 8816[7812]              	mov [bootdev], dl			; Save boot device number
   226 00000186 C6068800FF              	mov byte [0088h], 255
   227 0000018B C70689004C00            	mov word [0089h], 76
   228 00000191 C606E00000              	mov byte [00E0h], 0
   229                                  
   230 00000196 891E[7412]              	mov [Sides], bx
   231 0000019A 890E[7612]              	mov [SecsPerTrack], cx
   232                                  
   233                                  	clr ax
    11 0000019E 31C0                <1>  xor %1, %1
   234 000001A0 E80616                  	call os_serial_port_enable
   235                                  
   236                                  	; Load the files
   237                                  	
   238 000001A3 06                      	push es
   239 000001A4 8E06[F205]              	mov es, [driversgmt]
   240                                  	
   241 000001A8 B8[0807]                	mov ax, fileman_name
   242 000001AB B90026                  	mov cx, FILE_MANAGER
   243 000001AE E8DB09                  	call os_load_file
   244                                  	
   245 000001B1 B8[0107]                	mov ax, bg_name
   246 000001B4 B90006                  	mov cx, DESKTOP_BACKGROUND
   247 000001B7 E8D209                  	call os_load_file
   248 000001BA 7305                    	jnc .background_ok
   249                                  	
   250 000001BC C606000600              	mov byte [DESKTOP_BACKGROUND], 0
   251                                  	
   252                                  .background_ok:	
   253 000001C1 B8[2C07]                	mov ax, font_name
   254 000001C4 B90016                  	mov cx, SYSTEM_FONT
   255 000001C7 E8C209                  	call os_load_file
   256                                  	
   257 000001CA 07                      	pop es
   258                                  	
   259 000001CB FA                      	cli
   260                                  
   261 000001CC 8CCF                    	mov di, cs
   262                                  
   263 000001CE B100                    	mov cl, 00h					; Divide by 0 error handler
   264 000001D0 BE[E147]                	mov si, os_compat_int00
   265 000001D3 E88B45                  	call os_modify_int_handler
   266                                  
   267 000001D6 B10C                    	mov cl, 0Ch					; Stack overflow
   268 000001D8 BE[1E48]                	mov si, os_compat_int0C
   269 000001DB E88345                  	call os_modify_int_handler
   270                                  
   271 000001DE B105                    	mov cl, 05h					; Debugger
   272 000001E0 BE[0348]                	mov si, os_compat_int05
   273 000001E3 E87B45                  	call os_modify_int_handler
   274                                  	
   275 000001E6 B106                    	mov cl, 06h					; Bad instruction error handler
   276 000001E8 BE[3848]                	mov si, os_compat_int06
   277 000001EB E87345                  	call os_modify_int_handler
   278                                  
   279 000001EE B107                    	mov cl, 07h					; Processor extension error handler
   280 000001F0 BE[5248]                	mov si, os_compat_int07
   281 000001F3 E86B45                  	call os_modify_int_handler
   282                                  
   283 000001F6 B11C                    	mov cl, 1Ch					; RTC handler
   284 000001F8 BE[7748]                	mov si, os_compat_int1C
   285 000001FB E86345                  	call os_modify_int_handler
   286                                  	
   287 000001FE FB                      	sti
   288                                  
   289                                  ;	int 5
   290                                  	
   291 000001FF E8BB11                  	call os_seed_random
   292                                  
   293 00000202 BF0001                  	mov di, 100h
   294 00000205 B000                    	mov al, 0
   295 00000207 B9FF7E                  	mov cx, 7EFFh
   296 0000020A F3AA                    	rep stosb
   297                                  
   298 0000020C E8D721                  	call os_reset_font
   299                                  
   300 0000020F B80310                  	mov ax, 1003h				; Set text output with certain attributes
   301 00000212 B300                    	mov bl, 0					; to be bright, and not blinking
   302 00000214 CD10                    	int 10h
   303                                  	
   304 00000216 B80503                  	mov ax, 0305h
   305 00000219 BB0401                  	mov bx, 0104h
   306 0000021C CD16                    	int 16h
   307                                  	
   308 0000021E C606820000              	mov byte [0082h], 0
   309                                  	
   310 00000223 B8[2107]                	mov ax, system_cfg			; Try to load SYSTEM.CFG
   311 00000226 B9A8DE                  	mov cx, 57000
   312 00000229 E86009                  	call os_load_file
   313                                  
   314 0000022C A0EDDE                  	mov al, [57069]				; Copy the default sound volume (on/off)
   315 0000022F A28300                  	mov [0083h], al
   316                                  	
   317 00000232 0F82E902                	jc load_demotour			; If failed, it doesn't exist, so the system is run for the first time
   318                                  	
   319                                  logoinput:
   320 00000236 B8[414C]                	mov ax, osname				; Set up the welcome screen
   321 00000239 BB[4907]                	mov bx, empty_string
   322 0000023C B90700                  	mov cx, 07h					; Colour: black
   323 0000023F E82E1C                  	call os_draw_background
   324                                  
   325 00000242 BA0009                  	mov dx, 9 * 256
   326 00000245 E81D16                  	call os_move_cursor
   327                                  
   328 00000248 B82009                  	mov ax, 0920h
   329 0000024B BB0400                  	mov bx, 00000100b
   330 0000024E B93002                  	mov cx, 560
   331 00000251 CD10                    	int 10h
   332                                  
   333 00000253 BE[6809]                	mov si, logo
   334 00000256 E8CB21                  	call os_draw_icon
   335                                  
   336 00000259 BE[EA02]                	mov si, ver_msg
   337 0000025C E89515                  	call os_print_string
   338                                  
   339 0000025F BA0216                  	mov dx, 22 * 256 + 2
   340 00000262 E80016                  	call os_move_cursor
   341                                  
   342 00000265 BE[2F03]                	mov si, passwordmsg
   343 00000268 E88915                  	call os_print_string
   344 0000026B E83716                  	call os_hide_cursor
   345                                  
   346 0000026E B80B02                  	mov ax, 523
   347 00000271 B90200                  	mov cx, 2
   348 00000274 E8E423                  	call os_speaker_note_length
   349 00000277 B80503                  	mov ax, 773
   350 0000027A B90200                  	mov cx, 2
   351 0000027D E8DB23                  	call os_speaker_note_length
   352 00000280 B86202                  	mov ax, 610
   353 00000283 B90500                  	mov cx, 5
   354 00000286 E8D223                  	call os_speaker_note_length
   355                                  
   356 00000289 E8ED0F                  	call os_wait_for_key
   357                                  	
   358                                  enterpressed:
   359 0000028C E80B16                  	call os_show_cursor
   360 0000028F 803EAADE00              	cmp byte [57002], 0				; Is the password disabled?
   361 00000294 743D                    	je checkformenu				; If it is, continue
   362                                  
   363                                  .try:	
   364 00000296 BA0016                  	mov dx, 22 * 256					; Clean the text on the screen
   365 00000299 E8C915                  	call os_move_cursor
   366                                  
   367 0000029C B82009                  	mov ax, 0920h
   368 0000029F BB0700                  	mov bx, 7
   369 000002A2 B95000                  	mov cx, 80
   370 000002A5 CD10                    	int 10h
   371                                  	
   372 000002A7 BA0216                  	mov dx, 22 * 256 + 2					; Ask for the password
   373 000002AA E8B815                  	call os_move_cursor
   374 000002AD BE[4A03]                	mov si, passentermsg
   375 000002B0 E84115                  	call os_print_string
   376                                  	
   377 000002B3 B80001                  	mov ax, 100h
   378 000002B6 B307                    	mov bl, 7
   379 000002B8 C606880020              	mov byte [0088h], 32
   380 000002BD E8561F                  	call os_input_password
   381 000002C0 C6068800FF              	mov byte [0088h], 255
   382                                  
   383 000002C5 BE0001                  	mov si, 100h
   384 000002C8 E8B326                  	call os_string_encrypt
   385                                  
   386 000002CB BFABDE                  	mov di, 57003
   387 000002CE E8D327                  	call os_string_compare
   388 000002D1 73C3                    	jnc .try
   389                                  	
   390                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;end LOGO!
   391                                  	
   392                                  checkformenu:
   393 000002D3 E8CF15                  	call os_hide_cursor
   394 000002D6 E8F702                  	call background
   395                                  
   396                                  checkformenuloop:	
   397 000002D9 E89D0F                  	call os_wait_for_key
   398 000002DC 3C20                    	cmp al, 32					; Space pressed?
   399 000002DE 0F84C500                	je near option_screen		; Open the menu
   400 000002E2 3C61                    	cmp al, 'a'					; a pressed?
   401 000002E4 0F842402                	je near load_fileman		; Open the file manager
   402 000002E8 EBEF                    	jmp checkformenuloop
   403                                  	
   404 000002EA 202020202020202020-     	ver_msg			db '                                                              v0.7b1',0
   404 000002F3 202020202020202020-
   404 000002FC 202020202020202020-
   404 00000305 202020202020202020-
   404 0000030E 202020202020202020-
   404 00000317 202020202020202020-
   404 00000320 202020202020202076-
   404 00000329 302E37623100       
   405 0000032F 507265737320616E79-     	passwordmsg		db 'Press any key to log in...', 0
   405 00000338 206B657920746F206C-
   405 00000341 6F6720696E2E2E2E00 
   406 0000034A 456E74657220796F75-     	passentermsg		db 'Enter your password: ', 0
   406 00000353 722070617373776F72-
   406 0000035C 643A2000           
   407                                  
   408 00000360 63726570654F532044-     	os_init_msg			db 'crepeOS Desktop', 0
   408 00000369 65736B746F7000     
   409 00000370 5B53706163655D204F-     	os_version_msg		db '[Space] Open the system menu [A] Open the file manager', 0
   409 00000379 70656E207468652073-
   409 00000382 797374656D206D656E-
   409 0000038B 75205B415D204F7065-
   409 00000394 6E207468652066696C-
   409 0000039D 65206D616E61676572-
   409 000003A6 00                 
   410                                  
   411                                  ; TODO: THE FOLLOWING CODE NEEDS TO BE REWRITTEN
   412                                  	
   413                                  option_screen:
   414 000003A7 E83502                  	call menu_background
   415                                  
   416 000003AA B8[4A07]                	mov ax, menuoptions
   417 000003AD BB0D00                  	mov bx, 13
   418 000003B0 E8E620                  	call os_option_menu
   419                                  
   420 000003B3 0F821CFF                	jc checkformenu
   421                                  	
   422 000003B7 83F801                  	cmp ax, 1
   423 000003BA 0F841500                	je near app_selector
   424                                  
   425 000003BE 83F802                  	cmp ax, 2
   426 000003C1 0F848000                	je near game_selector
   427                                  	
   428 000003C5 83F803                  	cmp ax, 3
   429 000003C8 0F846AFE                	je near logoinput
   430                                  	
   431 000003CC 83F804                  	cmp ax, 4
   432 000003CF 0F847D48                	je near os_shutdown
   433                                  
   434                                  app_selector:
   435 000003D3 E80902                  	call menu_background
   436                                  
   437 000003D6 B8[1908]                	mov ax, progoptions
   438 000003D9 BB1400                  	mov bx, 20
   439 000003DC E8BA20                  	call os_option_menu
   440                                  
   441 000003DF 72C6                    	jc option_screen
   442                                  
   443 000003E1 83F801                  	cmp ax, 1
   444 000003E4 0F842401                	je near load_fileman
   445                                  
   446 000003E8 83F80D                  	cmp ax, 13
   447 000003EB 0F842500                	je near debug_stuff
   448                                  	
   449 000003EF 89C6                    	mov si, ax
   450 000003F1 83EE02                  	sub si, 2
   451 000003F4 D1E6                    	shl si, 1
   452 000003F6 81C6[2B06]              	add si, appindex1
   453 000003FA AD                      	lodsw
   454 000003FB 89C6                    	mov si, ax
   455 000003FD BF0001                  	mov di, 0100h
   456 00000400 E84226                  	call os_string_copy
   457                                  	
   458 00000403 B80001                  	mov ax, 0100h
   459 00000406 BB[F806]                	mov bx, app_prefix
   460 00000409 B9F000                  	mov cx, 00F0h
   461 0000040C E83F26                  	call os_string_join
   462                                  	
   463 0000040F 89CB                    	mov bx, cx
   464 00000411 E93201                  	jmp start_program
   465                                  	
   466                                  debug_stuff:
   467 00000414 E8C801                  	call menu_background
   468                                  
   469 00000417 B8[8707]                	mov ax, debugoptions
   470 0000041A BB1F00                  	mov bx, 31
   471 0000041D E87920                  	call os_option_menu
   472                                  	
   473 00000420 72B1                    	jc app_selector
   474                                  	
   475 00000422 89C6                    	mov si, ax
   476 00000424 4E                      	dec si
   477 00000425 D1E6                    	shl si, 1
   478 00000427 81C6[3F06]              	add si, debugindex1
   479 0000042B AD                      	lodsw
   480 0000042C 89C6                    	mov si, ax
   481 0000042E BF0001                  	mov di, 0100h
   482 00000431 E81126                  	call os_string_copy
   483                                  	
   484 00000434 B80001                  	mov ax, 0100h
   485 00000437 BB[F806]                	mov bx, app_prefix
   486 0000043A B9F000                  	mov cx, 00F0h
   487 0000043D E80E26                  	call os_string_join
   488                                  	
   489 00000440 89CB                    	mov bx, cx
   490 00000442 E90101                  	jmp start_program
   491                                  	
   492                                  	
   493                                  game_selector:
   494 00000445 E89701                  	call menu_background
   495                                  
   496 00000448 B8[6B07]                	mov ax, gameoptions
   497 0000044B BB1300                  	mov bx, 19
   498 0000044E E84820                  	call os_option_menu
   499                                  
   500 00000451 0F8252FF                	jc option_screen
   501                                  
   502 00000455 89C6                    	mov si, ax
   503 00000457 4E                      	dec si
   504 00000458 D1E6                    	shl si, 1
   505 0000045A 81C6[4F06]              	add si, gameindex1
   506 0000045E AD                      	lodsw
   507                                  	
   508                                  launch_program:
   509 0000045F C606FF7F00              	mov byte [32767], 0
   510                                  
   511 00000464 E86901                  	call background
   512                                  	
   513 00000467 60                      	pusha
   514 00000468 89C6                    	mov si, ax
   515 0000046A 89F3                    	mov bx, si
   516 0000046C 89F0                    	mov ax, si
   517 0000046E E84125                  	call os_string_length
   518 00000471 89DE                    	mov si, bx
   519 00000473 01C6                    	add si, ax				; SI now points to end of filename...
   520 00000475 4E                      	dec si
   521 00000476 4E                      	dec si
   522 00000477 4E                      	dec si					; ...and now to start of extension!
   523 00000478 BF[F906]                	mov di, app_ext
   524 0000047B B90300                  	mov cx, 3
   525 0000047E F3A6                    	rep cmpsb				; Are final 3 chars 'APP'?
   526 00000480 7521                    	jne launch_basic		; If not, try 'BAS'
   527 00000482 61                      	popa
   528                                  	
   529 00000483 B90001                  	mov cx, 100h			; Where to load the program file
   530 00000486 E80307                  	call os_load_file		; Load filename pointed to by AX
   531                                  
   532 00000489 0F8246FE                	jc checkformenu
   533                                  	
   534 0000048D 60                      	pusha
   535 0000048E B9FD7E                  	mov cx, 7EFDh
   536 00000491 29D9                    	sub cx, bx
   537 00000493 BF0001                  	mov di, 100h
   538 00000496 01DF                    	add di, bx
   539 00000498 B000                    	mov al, 0
   540 0000049A F3AA                    	rep stosb
   541 0000049C 61                      	popa
   542                                  	
   543 0000049D E8FA13                  	call os_show_cursor
   544                                  	
   545 000004A0 E9CB00                  	jmp execute_bin_program
   546                                  
   547                                  launch_basic:
   548 000004A3 61                      	popa
   549                                  	
   550 000004A4 60                      	pusha
   551 000004A5 89C6                    	mov si, ax
   552 000004A7 89F3                    	mov bx, si
   553 000004A9 89F0                    	mov ax, si
   554 000004AB E80425                  	call os_string_length
   555 000004AE 89DE                    	mov si, bx
   556 000004B0 01C6                    	add si, ax				; SI now points to end of filename...
   557 000004B2 4E                      	dec si
   558 000004B3 4E                      	dec si
   559 000004B4 4E                      	dec si					; ...and now to start of extension!
   560 000004B5 BF[FD06]                	mov di, bas_ext
   561 000004B8 B90300                  	mov cx, 3
   562 000004BB F3A6                    	rep cmpsb				; Are final 3 chars 'BAS'?
   563 000004BD 753A                    	jne program_error		; If not, error out
   564 000004BF 61                      	popa
   565                                  
   566 000004C0 B90001                  	mov cx, 100h			; Where to load the program file
   567 000004C3 E8C606                  	call os_load_file		; Load filename pointed to by AX
   568                                  
   569 000004C6 0F8209FE                	jc checkformenu
   570                                  	
   571 000004CA 60                      	pusha
   572 000004CB B9FD7E                  	mov cx, 7EFDh
   573 000004CE 29D9                    	sub cx, bx
   574 000004D0 BF0001                  	mov di, 100h
   575 000004D3 01DF                    	add di, bx
   576 000004D5 B000                    	mov al, 0
   577 000004D7 F3AA                    	rep stosb
   578 000004D9 61                      	popa
   579                                  
   580 000004DA E8BD13                  	call os_show_cursor
   581                                  	
   582 000004DD B80001                  	mov ax, 100h
   583                                  	clr si
    11 000004E0 31F6                <1>  xor %1, %1
   584 000004E2 E8EB27                  	call os_run_basic
   585                                  
   586 000004E5 BE[3507]                	mov si, basic_finished_msg
   587 000004E8 E80913                  	call os_print_string
   588 000004EB E88B0D                  	call os_wait_for_key
   589                                  
   590 000004EE E85E13                  	call os_clear_screen
   591                                  	
   592 000004F1 C606820000              	mov byte [0082h], 0
   593                                  	
   594 000004F6 E9DAFD                  	jmp checkformenu
   595                                  	
   596                                  program_error:
   597 000004F9 61                      	popa
   598 000004FA E8D300                  	call background
   599 000004FD B8[F405]                	mov ax, prog_msg
   600                                  	clr bx
    11 00000500 31DB                <1>  xor %1, %1
   601                                  	clr cx
    11 00000502 31C9                <1>  xor %1, %1
   602                                  	clr dx
    11 00000504 31D2                <1>  xor %1, %1
   603 00000506 E82E1B                  	call os_dialog_box
   604 00000509 E9C7FD                  	jmp checkformenu
   605                                  	
   606                                  load_fileman:
   607 0000050C 1E                      	push ds
   608 0000050D 8E1E[F205]              	mov ds, [driversgmt]
   609 00000511 BE0026                  	mov si, FILE_MANAGER
   610 00000514 BF0001                  	mov di, 0100h
   611 00000517 B90010                  	mov cx, 1000h
   612 0000051A F3A4                    	rep movsb
   613 0000051C 1F                      	pop ds
   614 0000051D EB4F                    	jmp execute_bin_program
   615                                  	
   616                                  load_demotour:
   617 0000051F C606830001              	mov byte [0083h], 1
   618 00000524 B8[1407]                	mov ax, demotour_name
   619 00000527 B90001                  	mov cx, 100h
   620 0000052A E85F06                  	call os_load_file
   621 0000052D E8DB0F                  	call os_clear_registers
   622 00000530 E8(0001)                	call 100h
   623 00000533 E900FD                  	jmp logoinput
   624                                  	
   625                                  load_command:
   626 00000536 B8[6C06]                	mov ax, cmd_name
   627 00000539 BB[F806]                	mov bx, app_prefix
   628 0000053C B9F000                  	mov cx, 00F0h
   629 0000053F E80C25                  	call os_string_join
   630 00000542 89CB                    	mov bx, cx
   631 00000544 EB00                    	jmp start_program
   632                                  	
   633                                  start_program:				; BX = program name
   634 00000546 60                      	pusha
   635 00000547 B9FD7E                  	mov cx, 7EFDh
   636 0000054A BF0001                  	mov di, 100h
   637 0000054D B000                    	mov al, 0
   638 0000054F F3AA                    	rep stosb
   639 00000551 61                      	popa
   640                                  	
   641 00000552 89D8                    	mov ax, bx
   642 00000554 B90001                  	mov cx, 100h			; Where to load the program file
   643 00000557 E83206                  	call os_load_file		; Load filename pointed to by AX
   644                                  
   645 0000055A 0F828E00                	jc systemfilemissing
   646                                  	
   647 0000055E E83913                  	call os_show_cursor
   648                                  
   649 00000561 EB0B                    	jmp execute_bin_program
   650                                  	
   651                                  return_to_app:
   652 00000563 B8F000                  	mov ax, 00F0h
   653 00000566 B90001                  	mov cx, 100h			; Where to load the program file
   654 00000569 E82006                  	call os_load_file		; Load filename pointed to by AX
   655                                  
   656 0000056C 727E                    	jc systemfilemissing	
   657                                  
   658                                  execute_bin_program:
   659 0000056E E8DE12                  	call os_clear_screen	; Clear the screen before running
   660                                  
   661 00000571 C606820000              	mov byte [0082h], 0
   662                                  	
   663 00000576 C606[B308]01            	mov byte [app_running], 1
   664                                  
   665 0000057B 8926[B108]              	mov [origstack], sp
   666                                  	
   667 0000057F E8890F                  	call os_clear_registers
   668                                  	
   669 00000582 E8(0001)                	call 100h	
   670                                  	
   671                                  finish:
   672 00000585 C606[B308]00            	mov byte [app_running], 0
   673                                  	
   674 0000058A E83421                  	call os_stop_adlib		; Reset everything (in case the app crashed or something)
   675 0000058D E8D920                  	call os_speaker_off
   676                                  
   677 00000590 50                      	push ax
   678 00000591 8CC8                    	mov ax, cs
   679 00000593 8ED8                    	mov ds, ax
   680 00000595 8EC0                    	mov es, ax
   681 00000597 58                      	pop ax
   682                                  	
   683 00000598 60                      	pusha
   684 00000599 B40F                    	mov ah, 0Fh				; Get the current video mode
   685 0000059B CD10                    	int 10h
   686                                  	
   687 0000059D 3C03                    	cmp al, 3
   688 0000059F 7405                    	je .skip_gfx
   689                                  	
   690 000005A1 B80300                  	mov ax, 3
   691 000005A4 CD10                    	int 10h
   692                                  
   693                                  .skip_gfx:
   694 000005A6 B80310                  	mov ax, 1003h			; Set text output with certain attributes
   695                                  	clr bx					; to be bright, and not blinking
    11 000005A9 31DB                <1>  xor %1, %1
   696 000005AB CD10                    	int 10h
   697                                  
   698 000005AD C606820000              	mov byte [0082h], 0
   699 000005B2 C606850000              	mov byte [0085h], 0
   700                                  	
   701 000005B7 E82C1E                  	call os_reset_font
   702 000005BA 61                      	popa
   703                                  	
   704 000005BB 803EFF7F01              	cmp byte [7FFFh], 1
   705 000005C0 0F849BFE                	je near launch_program
   706                                  	
   707 000005C4 803EFE7F01              	cmp byte [7FFEh], 1
   708 000005C9 0F8496FF                	je near return_to_app
   709                                  	
   710 000005CD E903FD                  	jmp checkformenu		; When finished, go back to the program list
   711                                  
   712                                  	
   713                                  ; TODO: THE CODE ABOVE NEEDS TO BE REWRITTEN
   714                                  	
   715                                  background:
   716 000005D0 60                      	pusha
   717 000005D1 B8[6003]                	mov ax, os_init_msg		; Draw main screen layout
   718 000005D4 BB[7003]                	mov bx, os_version_msg
   719 000005D7 B90001                  	mov cx, 256				; Colour: white text on light blue
   720 000005DA E89318                  	call os_draw_background
   721 000005DD 61                      	popa
   722 000005DE C3                      	ret
   723                                  
   724                                  menu_background:
   725 000005DF 60                      	pusha
   726 000005E0 803EEFDE01              	cmp byte [57071], 1
   727 000005E5 7403                    	je .done
   728                                  	
   729 000005E7 E8E6FF                  	call background
   730                                  	
   731                                  .done:
   732 000005EA 61                      	popa
   733 000005EB C3                      	ret
   734                                  	
   735                                  systemfilemissing:
   736 000005EC B8[1506]                	mov ax, noprogerror
   737 000005EF E8AD0F                  	call os_fatal_error
   738                                  	
   739                                  	; And now data for the above code...
   740                                  
   741 000005F2 0000                    	driversgmt				dw 0000h
   742                                  	
   743 000005F4 546869732066696C65-     	prog_msg				db 'This file is not an application.', 0
   743 000005FD 206973206E6F742061-
   743 00000606 6E206170706C696361-
   743 0000060F 74696F6E2E00       
   744                                  
   745 00000615 53797374656D206669-     	noprogerror				db 'System file not found', 0
   745 0000061E 6C65206E6F7420666F-
   745 00000627 756E6400           
   746                                  
   747 0000062B [5506][5A06][6106]-     	appindex1				dw edit_name, viewer_name, calc_name, clock_name, cmd_name, config_name, ascii_name, pixel_name, player_name, hwcheck_name
   747 00000631 [6606][6C06][7506]-
   747 00000637 [7C06][8506][8B06]-
   747 0000063D [9206]             
   748 0000063F [A006][A906][B106]-     	debugindex1				dw debug1_name, debug2_name, debug3_name, debug4_name, debug5_name, debug6_name, debug7_name, debug8_name
   748 00000645 [B906][C106][C706]-
   748 0000064B [CC06][D206]       
   749 0000064F [D906][E006][EC06]      	gameindex1				dw cf_name, hangman_name, tetris_name
   750                                  	
   751 00000655 4544495400              	edit_name				db 'EDIT', 0
   752 0000065A 56494557455200          	viewer_name				db 'VIEWER', 0
   753 00000661 43414C4300              	calc_name				db 'CALC', 0
   754 00000666 434C4F434B00            	clock_name				db 'CLOCK', 0
   755 0000066C 5445524D494E414C00      	cmd_name				db 'TERMINAL', 0
   756 00000675 434F4E46494700          	config_name				db 'CONFIG', 0
   757 0000067C 415343494941525400      	ascii_name				db 'ASCIIART', 0
   758 00000685 504958454C00            	pixel_name				db 'PIXEL', 0
   759 0000068B 504C4159455200          	player_name				db 'PLAYER', 0
   760 00000692 4857434845434B00        	hwcheck_name				db 'HWCHECK', 0
   761 0000069A 41424F555400            	about_name				db 'ABOUT', 0
   762                                  
   763 000006A0 4449534B5445535400      	debug1_name				db 'DISKTEST', 0
   764 000006A9 4B42445445535400        	debug2_name				db 'KBDTEST', 0
   765 000006B1 5254435445535400        	debug3_name				db 'RTCTEST', 0
   766 000006B9 4D454D4544495400        	debug4_name				db 'MEMEDIT', 0
   767 000006C1 424F58455300            	debug5_name				db 'BOXES', 0
   768 000006C7 444F545300              	debug6_name				db 'DOTS', 0
   769 000006CC 524454534300            	debug7_name				db 'RDTSC', 0
   770 000006D2 53544154494300          	debug8_name				db 'STATIC', 0
   771                                  	
   772 000006D9 43462E42415300          	cf_name					db 'CF.BAS', 0
   773 000006E0 48414E474D414E2E41-     	hangman_name				db 'HANGMAN.APP', 0
   773 000006E9 505000             
   774 000006EC 41534D545249532E41-     	tetris_name				db 'ASMTRIS.APP', 0
   774 000006F5 505000             
   775                                  	
   776 000006F8 2E                      	app_prefix				db '.'
   777 000006F9 41505000                	app_ext					db 'APP', 0
   778 000006FD 42415300                	bas_ext					db 'BAS', 0
   779                                  
   780 00000701 42472E53595300          	bg_name					db 'BG.SYS', 0
   781 00000708 46494C454D414E2E41-     	fileman_name				db 'FILEMAN.APP', 0
   781 00000711 505000             
   782 00000714 44454D4F544F55522E-     	demotour_name				db 'DEMOTOUR.APP', 0
   782 0000071D 41505000           
   783 00000721 53595354454D2E4346-     	system_cfg				db 'SYSTEM.CFG', 0
   783 0000072A 4700               
   784 0000072C 464F4E542E53595300      	font_name				db 'FONT.SYS', 0
   785                                  
   786 00000735 42415349432070726F-     	basic_finished_msg		db 'BASIC program ended', 0
   786 0000073E 6772616D20656E6465-
   786 00000747 6400               
   787                                  
   788 00000749 00                      	empty_string			db 0
   789                                  	
   790 0000074A 50726F6772616D732C-     	menuoptions				db 'Programs,Games,Log out,Shut down', 0
   790 00000753 47616D65732C4C6F67-
   790 0000075C 206F75742C53687574-
   790 00000765 20646F776E00       
   791 0000076B 436F736D696320466C-     	gameoptions				db 'Cosmic Flight,Hangman,Snake', 0
   791 00000774 696768742C48616E67-
   791 0000077D 6D616E2C536E616B65-
   791 00000786 00                 
   792 00000787 4469736B2064657465-     	debugoptions			db 'Disk detection test,Keyboard tester,RTC clock tester,Disk Sector inspector,Memory editor,Boxes,Dots,TSC register tester,TV static generator (CGA)', 0
   792 00000790 6374696F6E20746573-
   792 00000799 742C4B6579626F6172-
   792 000007A2 64207465737465722C-
   792 000007AB 52544320636C6F636B-
   792 000007B4 207465737465722C44-
   792 000007BD 69736B20536563746F-
   792 000007C6 7220696E7370656374-
   792 000007CF 6F722C4D656D6F7279-
   792 000007D8 20656469746F722C42-
   792 000007E1 6F7865732C446F7473-
   792 000007EA 2C5453432072656769-
   792 000007F3 737465722074657374-
   792 000007FC 65722C545620737461-
   792 00000805 7469632067656E6572-
   792 0000080E 61746F722028434741-
   792 00000817 2900               
   793 00000819 46696C65206D616E61-     	progoptions				db 'File manager,Text editor,Image viewer,Calculator,Clock,Terminal,Settings,ASCII art editor,Pixel art editor,Music player,Hardware checker,Other stuff...', 0
   793 00000822 6765722C5465787420-
   793 0000082B 656469746F722C496D-
   793 00000834 616765207669657765-
   793 0000083D 722C43616C63756C61-
   793 00000846 746F722C436C6F636B-
   793 0000084F 2C5465726D696E616C-
   793 00000858 2C53657474696E6773-
   793 00000861 2C4153434949206172-
   793 0000086A 7420656469746F722C-
   793 00000873 506978656C20617274-
   793 0000087C 20656469746F722C4D-
   793 00000885 7573696320706C6179-
   793 0000088E 65722C486172647761-
   793 00000897 726520636865636B65-
   793 000008A0 722C4F746865722073-
   793 000008A9 747566662E2E2E00   
   794                                  	
   795                                  ; ------------------------------------------------------------------
   796                                  ; SYSTEM VARIABLES -- Settings for programs and system calls
   797                                  
   798                                  	; System runtime variables
   799                                  								
   800 000008B1 0000                    	origstack		dw 0		; SP before launching a program
   801                                  
   802 000008B3 00                      	app_running		db 0		; Is a program running?
   803                                  	
   804                                  ;	program_drawn	db 0		; Is the program already drawn by os_draw_background?
   805                                  	
   806                                  ; ------------------------------------------------------------------
   807                                  ; FEATURES -- Code to pull into the kernel
   808                                  
   809                                  	%INCLUDE "drivers/icons.asm"
   810                              <1> 
   811 000008B4 0910                <1> 	bomblogo	db 9, 16
   812 000008B6 000000000020006000  <1> 				db 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00100000b, 00000000b, 01100000b, 00000000b
   813 000008BF 000000000402018000  <1> 				db 00000000b, 00000000b, 00000000b, 00000000b, 00000100b, 00000010b, 00000001b, 10000000b, 00000000b
   814 000008C8 000000000084800000  <1> 				db 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 10000100b, 10000000b, 00000000b, 00000000b
   815 000008D1 0000006AA501508880  <1> 				db 00000000b, 00000000b, 00000000b, 01101010b, 10100101b, 00000001b, 01010000b, 10001000b, 10000000b
   816 000008DA 0000030000A8004000  <1> 				db 00000000b, 00000000b, 00000011b, 00000000b, 00000000b, 10101000b, 00000000b, 01000000b, 00000000b
   817 000008E3 000057540018202400  <1> 				db 00000000b, 00000000b, 01010111b, 01010100b, 00000000b, 00011000b, 00100000b, 00100100b, 00000000b
   818 000008EC 0000FFFC0080200200  <1> 				db 00000000b, 00000000b, 11111111b, 11111100b, 00000000b, 10000000b, 00100000b, 00000010b, 00000000b
   819 000008F5 005FFFFFD400200000  <1> 				db 00000000b, 01011111b, 11111111b, 11111111b, 11010100b, 00000000b, 00100000b, 00000000b, 00000000b
   820 000008FE 01FFFFFFFD00000000  <1> 				db 00000001b, 11111111b, 11111111b, 11111111b, 11111101b, 00000000b, 00000000b, 00000000b, 00000000b
   821 00000907 07FFFFFFFF40000000  <1> 				db 00000111b, 11111111b, 11111111b, 11111111b, 11111111b, 01000000b, 00000000b, 00000000b, 00000000b
   822 00000910 0FFFFFFFFFC0000000  <1> 				db 00001111b, 11111111b, 11111111b, 11111111b, 11111111b, 11000000b, 00000000b, 00000000b, 00000000b
   823 00000919 0FFFFFFFFFC0000000  <1> 				db 00001111b, 11111111b, 11111111b, 11111111b, 11111111b, 11000000b, 00000000b, 00000000b, 00000000b
   824 00000922 0FFFFFFFFFC0000000  <1> 				db 00001111b, 11111111b, 11111111b, 11111111b, 11111111b, 11000000b, 00000000b, 00000000b, 00000000b
   825 0000092B 03FFFFFFFF00000000  <1> 				db 00000011b, 11111111b, 11111111b, 11111111b, 11111111b, 00000000b, 00000000b, 00000000b, 00000000b
   826 00000934 00FFFFFFFC00000000  <1> 				db 00000000b, 11111111b, 11111111b, 11111111b, 11111100b, 00000000b, 00000000b, 00000000b, 00000000b
   827 0000093D 000AFFFE8000000000  <1> 				db 00000000b, 00001010b, 11111111b, 11111110b, 10000000b, 00000000b, 00000000b, 00000000b, 00000000b
   828                              <1> 
   829 00000946 0408                <1> 	filelogo	db 4, 8
   830 00000948 0EAAD000            <1> 				db 00001110b, 10101010b, 11010000b, 00000000b
   831 0000094C 0C00C900            <1> 				db 00001100b, 00000000b, 11001001b, 00000000b
   832 00000950 0C00AAC0            <1> 				db 00001100b, 00000000b, 10101010b, 11000000b
   833 00000954 0C5500C0            <1> 				db 00001100b, 01010101b, 00000000b, 11000000b
   834 00000958 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
   835 0000095C 0C5554C0            <1> 				db 00001100b, 01010101b, 01010100b, 11000000b
   836 00000960 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
   837 00000964 0D5555C0            <1> 				db 00001101b, 01010101b, 01010101b, 11000000b
   838                              <1> 	
   839 00000968 1207                <1> 	logo	db 18, 7
   840 0000096A 00000FFFFF00000000- <1> 				db 00000000b, 00000000b, 00001111b, 11111111b, 11111111b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 11111111b, 00001111b, 11110000b
   840 00000973 000000000000FF0FF0  <1>
   841 0000097C 00000F000000000000- <1> 				db 00000000b, 00000000b, 00001111b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 11000011b, 00001111b, 00000000b
   841 00000985 000000000000C30F00  <1>
   842 0000098E 00000F000007FFC7FF- <1> 				db 00000000b, 00000000b, 00001111b, 00000000b, 00000000b, 00000111b, 11111111b, 11000111b, 11111111b, 11110000b, 01111111b, 11110000b, 01111111b, 11111111b, 00000000b, 11000011b, 00001111b, 11110000b
   842 00000997 F07FF07FFF00C30FF0  <1>
   843 000009A0 00000F00000F000F00- <1> 				db 00000000b, 00000000b, 00001111b, 00000000b, 00000000b, 00001111b, 00000000b, 00001111b, 00000000b, 11110000b, 11110000b, 11110000b, 11110000b, 00001111b, 00000000b, 11000011b, 00000000b, 11110000b
   843 000009A9 F0F0F0F00F00C300F0  <1>
   844 000009B2 00000F00000F000F0F- <1> 				db 00000000b, 00000000b, 00001111b, 00000000b, 00000000b, 00001111b, 00000000b, 00001111b, 00001111b, 11110000b, 11111111b, 11100000b, 11110000b, 11111111b, 00000000b, 11111111b, 00001111b, 11110000b
   844 000009BB F0FFE0F0FF00FF0FF0  <1>
   845 000009C4 00000F00000F000F00- <1> 				db 00000000b, 00000000b, 00001111b, 00000000b, 00000000b, 00001111b, 00000000b, 00001111b, 00000000b, 00000000b, 11110000b, 00000000b, 11110000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b
   845 000009CD 00F000F00000000000  <1>
   846 000009D6 00000FFFFF0F000FFF- <1> 				db 00000000b, 00000000b, 00001111b, 11111111b, 11111111b, 00001111b, 00000000b, 00001111b, 11111111b, 11110000b, 11110000b, 00000000b, 11111111b, 11111111b, 00000000b, 00000000b, 00000000b, 00000000b
   846 000009DF F0F000FFFF00000000  <1>
   847                              <1> 			
   810                                   	%INCLUDE "drivers/disk.asm"
   811                              <1> ; ==================================================================
   812                              <1> ; FAT12 FLOPPY DISK ROUTINES
   813                              <1> ; ==================================================================
   814                              <1> 
   815                              <1> ; os_report_free_space -- Returns the amount of free space on disk
   816                              <1> ; OUT: AX = Number of sectors free
   817                              <1> 
   818                              <1> os_report_free_space:
   819 000009E8 60                  <1> 	pusha
   820 000009E9 C706[330A]0000      <1> 	mov word [.counter], 0
   821 000009EF C706[350A]0000      <1> 	mov word [.sectors_read], 0
   822                              <1> 	
   823 000009F5 E8AE07              <1> 	call disk_read_fat				; Read the FAT into memory
   824 000009F8 BE00E0              <1> 	mov si, disk_buffer
   825                              <1> 	
   826                              <1> .loop:
   827                              <1> 	; 0 = nothing, 1 = 1st nibble, 2 = 2nd nibble, 3 = 3rd nibble, G = data we don't care about
   828                              <1> 
   829 000009FB 8B04                <1> 	mov ax, [si]					; AX = 3333GGGG11112222
   830 000009FD 8A7C01              <1> 	mov bh, [si + 1]				; BX = GGGG111122223333
   831 00000A00 8A5C02              <1> 	mov bl, [si + 2]
   832                              <1> 	
   833 00000A03 C1C004              <1> 	rol ax, 4						; AX = GGGG111122223333
   834                              <1> 	
   835 00000A06 80E40F              <1> 	and ah, 0Fh						; AX = 0000111122223333
   836 00000A09 80E70F              <1> 	and bh, 0Fh						; BX = 0000111122223333
   837                              <1> 		
   838 00000A0C 83F800              <1> 	cmp ax, 0
   839 00000A0F 7504                <1> 	jne .no_increment_1
   840                              <1> 	
   841 00000A11 FF06[330A]          <1> 	inc word [.counter]
   842                              <1> 	
   843                              <1> .no_increment_1:
   844 00000A15 83FB00              <1> 	cmp bx, 0
   845                              <1> 		
   846 00000A18 7504                <1> 	jne .no_increment_2
   847                              <1> 	
   848 00000A1A FF06[330A]          <1> 	inc word [.counter]
   849                              <1> 	
   850                              <1> .no_increment_2:
   851 00000A1E 83C603              <1> 	add si, 3						; Increment the pointer
   852 00000A21 8306[350A]02        <1> 	add word [.sectors_read], 2		; Increment the counter of sectors
   853                              <1> 	
   854 00000A26 813E[350A]1F0B      <1> 	cmp word [.sectors_read], 2847	; Are we done? (33 of the sectors are the bootloader, FAT and root dir)
   855 00000A2C 7CCD                <1> 	jl .loop
   856                              <1> 	
   857 00000A2E 61                  <1> 	popa
   858 00000A2F A1[330A]            <1> 	mov ax, [.counter]
   859                              <1> 
   860 00000A32 C3                  <1> 	ret
   861                              <1> 	
   862 00000A33 0000                <1> 	.counter		dw 0
   863 00000A35 0000                <1> 	.sectors_read	dw 0
   864                              <1> 	
   865                              <1> ; --------------------------------------------------------------------------
   866                              <1> ; os_read_root -- Get the root directory contents
   867                              <1> ; IN: SI = where to store the root directory; OUT: carry set if error
   868                              <1> 
   869                              <1> os_read_root:
   870 00000A37 60                  <1> 	pusha
   871                              <1> 
   872 00000A38 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   873 00000A3B E80B08              <1> 	call disk_convert_l2hts
   874                              <1> 
   875 00000A3E 8CDB                <1> 	mov bx, ds
   876 00000A40 8EC3                <1> 	mov es, bx
   877 00000A42 89F3                <1> 	mov bx, si
   878                              <1> 
   879 00000A44 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
   880 00000A46 B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
   881                              <1> 
   882 00000A48 60                  <1> 	pusha				; Prepare to enter loop
   883                              <1> 
   884                              <1> 
   885                              <1> .read_root_dir_loop:
   886 00000A49 61                  <1> 	popa
   887 00000A4A 60                  <1> 	pusha
   888                              <1> 
   889 00000A4B F9                  <1> 	stc				; A few BIOSes do not set properly on error
   890 00000A4C CD13                <1> 	int 13h				; Read sectors
   891                              <1> 
   892 00000A4E 7308                <1> 	jnc .root_dir_finished
   893 00000A50 E8E707              <1> 	call disk_reset_floppy		; Reset controller and try again
   894 00000A53 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
   895                              <1> 
   896 00000A55 61                  <1> 	popa
   897 00000A56 EB04                <1> 	jmp .read_failure		; Fatal double error
   898                              <1> 
   899                              <1> 
   900                              <1> .root_dir_finished:
   901 00000A58 61                  <1> 	popa				; Restore registers from main loop
   902                              <1> 
   903 00000A59 61                  <1> 	popa				; And restore from start of this system call
   904                              <1> 
   905 00000A5A F8                  <1> 	clc				; Clear carry (for success)
   906 00000A5B C3                  <1> 	ret
   907                              <1> 
   908                              <1> .read_failure:
   909 00000A5C 61                  <1> 	popa
   910                              <1> 
   911 00000A5D F9                  <1> 	stc				; Set carry flag (for failure)
   912 00000A5E C3                  <1> 	ret
   913                              <1> 
   914                              <1> ; ------------------------------------------------------------------
   915                              <1> ; os_get_file_list -- Generate comma-separated string of files on floppy
   916                              <1> ; IN/OUT: AX = location to store zero-terminated filename string,
   917                              <1> ;         If [0087h] = 1, then BX = location of file extension list
   918                              <1> 
   919                              <1> os_get_file_list:
   920 00000A5F 60                  <1> 	pusha
   921                              <1> 
   922 00000A60 C606[440B]00        <1> 	mov byte [.num_entries], 0
   923 00000A65 891E[450B]          <1> 	mov [.extension_list], bx
   924                              <1> 	
   925 00000A69 BE[490B]            <1> 	mov si, .msg_load
   926 00000A6C E81219              <1> 	call os_print_footer
   927                              <1> 	
   928 00000A6F A3[470B]            <1> 	mov word [.file_list_tmp], ax
   929                              <1> 
   930 00000A72 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
   931                              <1> 
   932 00000A78 E8BF07              <1> 	call disk_reset_floppy		; Just in case disk was changed
   933                              <1> 
   934 00000A7B B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   935 00000A7E E8C807              <1> 	call disk_convert_l2hts
   936                              <1> 
   937 00000A81 BE00E0              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
   938 00000A84 89F3                <1> 	mov bx, si
   939                              <1> 
   940 00000A86 B80E02              <1> 	mov ax, 2 * 256 + 14	; Params for int 13h: read floppy sectors
   941                              <1> 
   942 00000A89 60                  <1> 	pusha				; Prepare to enter loop
   943                              <1> 
   944                              <1> 
   945                              <1> .read_root_dir:
   946 00000A8A 61                  <1> 	popa
   947 00000A8B 60                  <1> 	pusha
   948                              <1> 
   949 00000A8C F9                  <1> 	stc
   950 00000A8D CD13                <1> 	int 13h				; Read sectors
   951 00000A8F E8A807              <1> 	call disk_reset_floppy		; Check we've read them OK
   952 00000A92 730B                <1> 	jnc .show_dir_init		; No errors, continue
   953                              <1> 
   954 00000A94 E8A307              <1> 	call disk_reset_floppy		; Error = reset controller and try again
   955 00000A97 73F1                <1> 	jnc .read_root_dir
   956                              <1> 
   957 00000A99 B8[680B]            <1> 	mov ax, .error
   958 00000A9C E8000B              <1> 	call os_fatal_error
   959                              <1> 	
   960                              <1> .show_dir_init:
   961 00000A9F 61                  <1> 	popa
   962                              <1> 
   963 00000AA0 B80000              <1> 	mov ax, 0
   964 00000AA3 BE00E0              <1> 	mov si, disk_buffer		; Data reader from start of filenames
   965                              <1> 
   966 00000AA6 8B3E[470B]          <1> 	mov word di, [.file_list_tmp]	; Name destination buffer
   967                              <1> 
   968                              <1> 
   969                              <1> .start_entry:
   970 00000AAA 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
   971 00000AAD 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
   972 00000AAF 7478                <1> 	je .skip
   973                              <1> 
   974 00000AB1 A808                <1> 	test al, 08h			; Is this a directory entry or volume label?
   975 00000AB3 7574                <1> 	jnz .skip			; Yes, ignore it
   976                              <1> 
   977 00000AB5 8A04                <1> 	mov al, [si]
   978 00000AB7 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
   979 00000AB9 746E                <1> 	je .skip
   980                              <1> 
   981 00000ABB 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
   982 00000ABD 7470                <1> 	je .done
   983                              <1> 	
   984 00000ABF B90100              <1> 	mov cx, 1			; Set char counter
   985 00000AC2 89F2                <1> 	mov dx, si			; Beginning of possible entry
   986                              <1> 
   987                              <1> .testdirentry:
   988 00000AC4 46                  <1> 	inc si
   989 00000AC5 8A04                <1> 	mov al, [si]			; Test for most unusable characters
   990 00000AC7 3C20                <1> 	cmp al, ' '			; Windows sometimes puts 0 (UTF-8) or 0FFh
   991 00000AC9 7C5C                <1> 	jl .nxtdirentry
   992 00000ACB 3C7E                <1> 	cmp al, '~'
   993 00000ACD 7758                <1> 	ja .nxtdirentry
   994                              <1> 
   995 00000ACF 41                  <1> 	inc cx
   996 00000AD0 83F90B              <1> 	cmp cx, 11			; Done 11 char filename?
   997 00000AD3 7402                <1> 	je .gotfilename
   998 00000AD5 EBED                <1> 	jmp .testdirentry
   999                              <1> 
  1000                              <1> 
  1001                              <1> .gotfilename:				; Got a filename that passes testing
  1002 00000AD7 89D6                <1> 	mov si, dx			; DX = where getting string
  1003                              <1> 
  1004 00000AD9 803E870001          <1> 	cmp byte [0087h], 1
  1005 00000ADE 7522                <1> 	jne .no_extension_check
  1006                              <1> 	
  1007 00000AE0 8B1E[450B]          <1> 	mov bx, [.extension_list]
  1008 00000AE4 0FB60F              <1> 	movzx cx, byte [bx]
  1009                              <1> 
  1010                              <1> .extension_loop:
  1011 00000AE7 60                  <1> 	pusha
  1012 00000AE8 83C608              <1> 	add si, 8
  1013                              <1> 	
  1014 00000AEB 49                  <1> 	dec cx
  1015 00000AEC 89CF                <1> 	mov di, cx
  1016 00000AEE C1E702              <1> 	shl di, 2	; Each entry is 4 bytes long
  1017 00000AF1 47                  <1> 	inc di		; The entry list starts with a 1-byte header
  1018 00000AF2 033E[450B]          <1> 	add di, [.extension_list]	
  1019                              <1> 	
  1020 00000AF6 B90300              <1> 	mov cx, 3
  1021 00000AF9 F3A6                <1> 	rep cmpsb
  1022 00000AFB 61                  <1> 	popa
  1023 00000AFC 7404                <1> 	je .no_extension_check
  1024                              <1> 	
  1025 00000AFE E2E7                <1> 	loop .extension_loop
  1026                              <1> 	
  1027 00000B00 EB25                <1> 	jmp .nxtdirentry
  1028                              <1> 	
  1029                              <1> .no_extension_check:
  1030 00000B02 31C9                <1> 	xor cx, cx
  1031                              <1> 	
  1032                              <1> .loopy:
  1033 00000B04 AC                  <1> 	lodsb
  1034 00000B05 3C20                <1> 	cmp al, ' '
  1035 00000B07 7401                <1> 	je .ignore_space
  1036 00000B09 AA                  <1> 	stosb
  1037                              <1> 	
  1038                              <1> .ignore_space:
  1039 00000B0A 41                  <1> 	inc cx
  1040 00000B0B 83F908              <1> 	cmp cx, 8
  1041 00000B0E 7407                <1> 	je .add_dot
  1042 00000B10 83F90B              <1> 	cmp cx, 11
  1043 00000B13 7409                <1> 	je .done_copy
  1044 00000B15 EBED                <1> 	jmp .loopy
  1045                              <1> 
  1046                              <1> .add_dot:
  1047 00000B17 26C6052E            <1> 	mov byte [es:di], '.'
  1048 00000B1B 47                  <1> 	inc di
  1049 00000B1C EBE6                <1> 	jmp .loopy
  1050                              <1> 
  1051                              <1> .done_copy:
  1052 00000B1E 26C6052C            <1> 	mov byte [es:di], ','		; Use comma to separate filenames
  1053 00000B22 47                  <1> 	inc di
  1054 00000B23 FE06[440B]          <1> 	inc byte [.num_entries]
  1055                              <1> 	
  1056                              <1> .nxtdirentry:
  1057 00000B27 89D6                <1> 	mov si, dx			; Start of entry, pretend to skip to next
  1058                              <1> 
  1059                              <1> .skip:
  1060 00000B29 83C620              <1> 	add si, 32			; Shift to next 32 bytes (next filename)
  1061 00000B2C E97BFF              <1> 	jmp .start_entry
  1062                              <1> 
  1063                              <1> 
  1064                              <1> .done:
  1065 00000B2F 803E[440B]00        <1> 	cmp byte [.num_entries], 0
  1066 00000B34 7401                <1> 	je .no_dec
  1067                              <1> 	
  1068 00000B36 4F                  <1> 	dec di
  1069                              <1> 
  1070                              <1> .no_dec:
  1071 00000B37 26C60500            <1> 	mov byte [es:di], 0		; Zero-terminate string (gets rid of final comma)
  1072                              <1> 
  1073 00000B3B 60                  <1> 	pusha
  1074 00000B3C 31F6                <1> 	xor si, si
  1075 00000B3E E84018              <1> 	call os_print_footer
  1076 00000B41 61                  <1> 	popa
  1077                              <1> 
  1078 00000B42 61                  <1> 	popa
  1079                              <1> 
  1080 00000B43 C3                  <1> 	ret
  1081                              <1> 
  1082 00000B44 00                  <1> 	.num_entries		db 0
  1083 00000B45 0000                <1> 	.extension_list		dw 0
  1084 00000B47 0000                <1> 	.file_list_tmp		dw 0
  1085 00000B49 2052656164696E6720- <1> 	.msg_load			db ' Reading directory contents...', 0
  1085 00000B52 6469726563746F7279- <1>
  1085 00000B5B 20636F6E74656E7473- <1>
  1085 00000B64 2E2E2E00            <1>
  1086 00000B68 6F735F6765745F6669- <1> 	.error				db 'os_get_file_list: Floppy reset fail', 0
  1086 00000B71 6C655F6C6973743A20- <1>
  1086 00000B7A 466C6F707079207265- <1>
  1086 00000B83 736574206661696C00  <1>
  1087                              <1> 	
  1088                              <1> ; ------------------------------------------------------------------
  1089                              <1> ; os_load_file -- Load a file into RAM
  1090                              <1> ; IN: AX = location of filename, ES:CX = location in RAM to load file
  1091                              <1> ; OUT: BX = file size (in bytes), carry set if file not found
  1092                              <1> 
  1093                              <1> os_load_file:
  1094 00000B8C 06                  <1> 	push es
  1095 00000B8D 8C06[E20C]          <1> 	mov [.old_segment], es
  1096                              <1> 
  1097 00000B91 0E                  <1> 	push cs
  1098 00000B92 07                  <1> 	pop es
  1099                              <1> 	
  1100 00000B93 E8751E              <1> 	call os_string_uppercase
  1101                              <1> 
  1102 00000B96 60                  <1> 	pusha							; Message display routine
  1103 00000B97 89C3                <1> 	mov bx, ax
  1104 00000B99 B8[E40C]            <1> 	mov ax, .msg_load
  1105 00000B9C B95200              <1> 	mov cx, 82
  1106 00000B9F E8AC1E              <1> 	call os_string_join
  1107 00000BA2 BE5200              <1> 	mov si, 82
  1108 00000BA5 E8D917              <1> 	call os_print_footer
  1109 00000BA8 61                  <1> 	popa
  1110                              <1> 	
  1111 00000BA9 E83D05              <1> 	call int_filename_convert
  1112                              <1> 
  1113 00000BAC A3[BA0C]            <1> 	mov [.filename_loc], ax		; Store filename location
  1114 00000BAF 890E[BC0C]          <1> 	mov [.load_position], cx	; And where to load the file!
  1115                              <1> 
  1116 00000BB3 6631C0              <1> 	xor eax, eax			; Needed for some older BIOSes
  1117                              <1> 
  1118 00000BB6 E88106              <1> 	call disk_reset_floppy		; In case floppy has been changed
  1119 00000BB9 7306                <1> 	jnc .floppy_ok			; Did the floppy reset OK?
  1120                              <1> 
  1121 00000BBB B8[C20C]            <1> 	mov ax, .err_msg_floppy_reset	; If not, bail out
  1122 00000BBE E9DE09              <1> 	jmp os_fatal_error
  1123                              <1> 
  1124                              <1> 
  1125                              <1> .floppy_ok:				; Ready to read first block of data
  1126 00000BC1 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1127 00000BC4 E88206              <1> 	call disk_convert_l2hts
  1128                              <1> 
  1129 00000BC7 BE00E0              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
  1130 00000BCA 89F3                <1> 	mov bx, si
  1131                              <1> 
  1132 00000BCC B80E02              <1> 	mov ax, 2 * 256 + 14	; Params for int 13h: read floppy sectors
  1133                              <1> 
  1134 00000BCF 60                  <1> 	pusha				; Prepare to enter loop
  1135                              <1> 
  1136                              <1> 
  1137                              <1> .read_root_dir:
  1138 00000BD0 61                  <1> 	popa
  1139 00000BD1 60                  <1> 	pusha
  1140                              <1> 
  1141 00000BD2 F9                  <1> 	stc				; A few BIOSes clear, but don't set properly
  1142                              <1> 	
  1143 00000BD3 CD13                <1> 	int 13h				; Read sectors
  1144 00000BD5 7308                <1> 	jnc .search_root_dir		; No errors = continue
  1145                              <1> 
  1146 00000BD7 E86006              <1> 	call disk_reset_floppy		; Problem = reset controller and try again
  1147 00000BDA 73F4                <1> 	jnc .read_root_dir
  1148                              <1> 
  1149 00000BDC 61                  <1> 	popa
  1150 00000BDD EB38                <1> 	jmp .root_problem		; Double error = exit
  1151                              <1> 
  1152                              <1> .search_root_dir:
  1153 00000BDF 61                  <1> 	popa
  1154                              <1> 
  1155 00000BE0 B9E000              <1> 	mov cx, 224		; Search all entries in root dir
  1156 00000BE3 BBE0FF              <1> 	mov bx, -32			; Begin searching at offset 0 in root dir
  1157                              <1> 
  1158                              <1> .next_root_entry:
  1159 00000BE6 83C320              <1> 	add bx, 32			; Bump searched entries by 1 (offset + 32 bytes)
  1160 00000BE9 BF00E0              <1> 	mov di, disk_buffer		; Point root dir at next entry
  1161 00000BEC 01DF                <1> 	add di, bx
  1162                              <1> 
  1163 00000BEE 8A05                <1> 	mov al, [di]			; First character of name
  1164                              <1> 
  1165 00000BF0 3C00                <1> 	cmp al, 0			; Last file name already checked?
  1166 00000BF2 7423                <1> 	je .root_problem
  1167                              <1> 
  1168 00000BF4 3CE5                <1> 	cmp al, 229			; Was this file deleted?
  1169 00000BF6 74EE                <1> 	je .next_root_entry		; If yes, skip it
  1170                              <1> 
  1171 00000BF8 8A450B              <1> 	mov al, [di+11]			; Get the attribute byte
  1172                              <1> 
  1173 00000BFB 3C0F                <1> 	cmp al, 0Fh			; Is this a special Windows entry?
  1174 00000BFD 74E7                <1> 	je .next_root_entry
  1175                              <1> 
  1176 00000BFF A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
  1177 00000C01 75E3                <1> 	jnz .next_root_entry
  1178                              <1> 
  1179 00000C03 C6450B00            <1> 	mov byte [di+11], 0		; Add a terminator to directory name entry
  1180                              <1> 
  1181 00000C07 89F8                <1> 	mov ax, di			; Convert root buffer name to upper case
  1182 00000C09 E8FF1D              <1> 	call os_string_uppercase
  1183                              <1> 
  1184 00000C0C 8B36[BA0C]          <1> 	mov si, [.filename_loc]		; DS:SI = location of filename to load
  1185                              <1> 
  1186 00000C10 E8911E              <1> 	call os_string_compare		; Current entry same as requested?
  1187 00000C13 7208                <1> 	jc .found_file_to_load
  1188                              <1> 
  1189 00000C15 E2CF                <1> 	loop .next_root_entry
  1190                              <1> 
  1191                              <1> .root_problem:
  1192 00000C17 BB0000              <1> 	mov bx, 0			; If file not found or major disk error,
  1193 00000C1A 07                  <1> 	pop es
  1194                              <1> 
  1195 00000C1B F9                  <1> 	stc				; return with size = 0 and carry set
  1196 00000C1C C3                  <1> 	ret
  1197                              <1> 
  1198                              <1> 
  1199                              <1> .found_file_to_load:			; Now fetch cluster and load FAT into RAM
  1200 00000C1D 668B451C            <1> 	mov eax, [di+28]			; Store file size to return to calling routine
  1201 00000C21 66A3[BE0C]          <1> 	mov [.file_size], eax
  1202                              <1> 
  1203 00000C25 6683F800            <1> 	cmp eax, 0			; If the file size is zero, don't bother trying
  1204 00000C29 747B                <1> 	je .end				; to read more clusters
  1205                              <1> 
  1206 00000C2B 8B451A              <1> 	mov ax, [di+26]			; Now fetch cluster and load FAT into RAM
  1207 00000C2E A3[B60C]            <1> 	mov word [.cluster], ax
  1208                              <1> 
  1209 00000C31 B80100              <1> 	mov ax, 1			; Sector 1 = first sector of first FAT
  1210 00000C34 E81206              <1> 	call disk_convert_l2hts
  1211                              <1> 
  1212 00000C37 BB00E0              <1> 	mov bx, disk_buffer		; ES:BX points to our buffer
  1213                              <1> 
  1214 00000C3A B402                <1> 	mov ah, 2			; int 13h params: read sectors
  1215 00000C3C B009                <1> 	mov al, 9			; And read 9 of them
  1216                              <1> 
  1217 00000C3E 60                  <1> 	pusha
  1218                              <1> 
  1219                              <1> .read_fat:
  1220 00000C3F 61                  <1> 	popa				; In case registers altered by int 13h
  1221 00000C40 60                  <1> 	pusha
  1222                              <1> 
  1223 00000C41 F9                  <1> 	stc
  1224 00000C42 CD13                <1> 	int 13h
  1225 00000C44 7308                <1> 	jnc .read_fat_ok
  1226                              <1> 
  1227 00000C46 E8F105              <1> 	call disk_reset_floppy
  1228 00000C49 73F4                <1> 	jnc .read_fat
  1229                              <1> 
  1230 00000C4B 61                  <1> 	popa
  1231 00000C4C EBC9                <1> 	jmp .root_problem
  1232                              <1> 
  1233                              <1> 
  1234                              <1> .read_fat_ok:
  1235 00000C4E 61                  <1> 	popa
  1236                              <1> 
  1237                              <1> 
  1238                              <1> .load_file_sector:
  1239 00000C4F A1[B60C]            <1> 	mov ax, word [.cluster]		; Convert sector to logical
  1240 00000C52 83C01F              <1> 	add ax, 31
  1241                              <1> 
  1242 00000C55 E8F105              <1> 	call disk_convert_l2hts		; Make appropriate params for int 13h
  1243                              <1> 
  1244 00000C58 8B1E[BC0C]          <1> 	mov bx, [.load_position]
  1245 00000C5C 8E06[E20C]          <1> 	mov es, [.old_segment]
  1246                              <1> 
  1247 00000C60 B80102              <1> 	mov ax, 0201h			; AH = read sectors, AL = just read 1
  1248                              <1> 
  1249 00000C63 F9                  <1> 	stc
  1250 00000C64 CD13                <1> 	int 13h
  1251                              <1> 
  1252 00000C66 0E                  <1> 	push cs
  1253 00000C67 07                  <1> 	pop es
  1254                              <1> 	
  1255 00000C68 730B                <1> 	jnc .calculate_next_cluster	; If there's no error...
  1256                              <1> 
  1257 00000C6A E8CD05              <1> 	call disk_reset_floppy		; Otherwise, reset floppy and retry
  1258 00000C6D 73E0                <1> 	jnc .load_file_sector
  1259                              <1> 
  1260 00000C6F B8[C20C]            <1> 	mov ax, .err_msg_floppy_reset	; Reset failed, bail out
  1261 00000C72 E92A09              <1> 	jmp os_fatal_error
  1262                              <1> 
  1263                              <1> 
  1264                              <1> .calculate_next_cluster:
  1265 00000C75 A1[B60C]            <1> 	mov ax, [.cluster]
  1266 00000C78 BB0300              <1> 	mov bx, 3
  1267 00000C7B F7E3                <1> 	mul bx
  1268 00000C7D BB0200              <1> 	mov bx, 2
  1269 00000C80 F7F3                <1> 	div bx				; DX = [CLUSTER] mod 2
  1270 00000C82 BE00E0              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
  1271 00000C85 01C6                <1> 	add si, ax
  1272 00000C87 3E8B04              <1> 	mov ax, word [ds:si]
  1273                              <1> 
  1274 00000C8A 83FA00              <1> 	cmp dx, 0			; If DX = 0 [CLUSTER] = even, if DX = 1 then odd
  1275 00000C8D 7405                <1> 	je .even			; If [CLUSTER] = even, drop last 4 bits of word
  1276                              <1> 					; with next cluster; if odd, drop first 4 bits
  1277                              <1> 
  1278                              <1> .odd:
  1279 00000C8F C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (belong to another entry)
  1280 00000C92 EB03                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
  1281                              <1> 
  1282                              <1> .even:
  1283 00000C94 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits
  1284                              <1> 
  1285                              <1> .calculate_cluster_cont:
  1286 00000C97 A3[B60C]            <1> 	mov word [.cluster], ax		; Store cluster
  1287                              <1> 
  1288 00000C9A 3DF80F              <1> 	cmp ax, 0FF8h
  1289 00000C9D 7D07                <1> 	jge .end
  1290                              <1> 
  1291 00000C9F 8306[E20C]20        <1> 	add word [.old_segment], 512 / 16
  1292 00000CA4 EBA9                <1> 	jmp .load_file_sector		; Onto next sector!
  1293                              <1> 
  1294                              <1> 
  1295                              <1> .end:
  1296 00000CA6 668B1E[BE0C]        <1> 	mov ebx, [.file_size]		; Get file size to pass back in BX
  1297 00000CAB 60                  <1> 	pusha
  1298 00000CAC 31F6                <1> 	xor si, si
  1299 00000CAE E8D016              <1> 	call os_print_footer
  1300 00000CB1 61                  <1> 	popa
  1301 00000CB2 07                  <1> 	pop es
  1302                              <1> 
  1303 00000CB3 F8                  <1> 	clc				; Carry clear = good load
  1304 00000CB4 C3                  <1> 	ret
  1305                              <1> 
  1306                              <1> 
  1307 00000CB5 00                  <1> 	.bootd					db 0 		; Boot device number
  1308 00000CB6 0000                <1> 	.cluster				dw 0 		; Cluster of the file we want to load
  1309 00000CB8 0000                <1> 	.pointer				dw 0 		; Pointer into disk_buffer, for loading 'file2load'
  1310                              <1> 
  1311 00000CBA 0000                <1> 	.filename_loc			dw 0		; Temporary store of filename location
  1312 00000CBC 0000                <1> 	.load_position			dw 0		; Where we'll load the file
  1313 00000CBE 00000000            <1> 	.file_size				dd 0		; Size of the file
  1314                              <1> 
  1315 00000CC2 6F735F6C6F61645F66- <1> 	.err_msg_floppy_reset	db 'os_load_file: Floppy reset fail', 0
  1315 00000CCB 696C653A20466C6F70- <1>
  1315 00000CD4 707920726573657420- <1>
  1315 00000CDD 6661696C00          <1>
  1316                              <1> 
  1317 00000CE2 0000                <1> 	.old_segment			dw 0
  1318                              <1> 	
  1319 00000CE4 204C6F6164696E6720- <1> 	.msg_load				db ' Loading ', 0
  1319 00000CED 00                  <1>
  1320                              <1> 	
  1321                              <1> ; --------------------------------------------------------------------------
  1322                              <1> ; os_write_file -- Save (max 64K) file to disk
  1323                              <1> ; IN: AX = filename, ES:BX = data location, CX = bytes to write
  1324                              <1> ; OUT: Carry clear if OK, set if failure
  1325                              <1> 
  1326                              <1> os_write_file:
  1327 00000CEE 60                  <1> 	pusha
  1328                              <1> 	
  1329 00000CEF 8C06[C50E]          <1> 	mov [.old_segment], es
  1330                              <1> 	
  1331 00000CF3 0E                  <1> 	push cs
  1332 00000CF4 07                  <1> 	pop es
  1333                              <1> 		
  1334 00000CF5 60                  <1> 	pusha							; Message display routine
  1335 00000CF6 89C3                <1> 	mov bx, ax
  1336 00000CF8 B8[C70E]            <1> 	mov ax, .msg_save
  1337 00000CFB B95200              <1> 	mov cx, 82
  1338 00000CFE E84D1D              <1> 	call os_string_join
  1339 00000D01 BE5200              <1> 	mov si, 82
  1340 00000D04 E87A16              <1> 	call os_print_footer
  1341 00000D07 61                  <1> 	popa
  1342                              <1> 
  1343 00000D08 89C6                <1> 	mov si, ax
  1344 00000D0A E8A51C              <1> 	call os_string_length
  1345 00000D0D 83F800              <1> 	cmp ax, 0
  1346 00000D10 0F849601            <1> 	je near .failure
  1347 00000D14 89F0                <1> 	mov ax, si
  1348                              <1> 
  1349 00000D16 E8F21C              <1> 	call os_string_uppercase
  1350                              <1> 
  1351 00000D19 E8CD03              <1> 	call int_filename_convert	; Make filename FAT12-style
  1352 00000D1C 0F828A01            <1> 	jc near .failure
  1353                              <1> 
  1354 00000D20 890E[B90E]          <1> 	mov word [.filesize], cx
  1355 00000D24 891E[BF0E]          <1> 	mov word [.location], bx
  1356 00000D28 A3[C30E]            <1> 	mov word [.filename], ax
  1357                              <1> 
  1358 00000D2B E8A201              <1> 	call os_file_exists		; Don't overwrite a file if it exists!
  1359 00000D2E 0F837801            <1> 	jnc near .failure
  1360                              <1> 
  1361                              <1> 
  1362                              <1> 	; First, zero out the .free_clusters list from any previous execution
  1363 00000D32 60                  <1> 	pusha
  1364                              <1> 
  1365 00000D33 BF00FF              <1> 	mov di, .free_clusters
  1366 00000D36 B98000              <1> 	mov cx, 128
  1367                              <1> .clean_free_loop:
  1368 00000D39 C7050000            <1> 	mov word [di], 0
  1369 00000D3D 47                  <1> 	inc di
  1370 00000D3E 47                  <1> 	inc di
  1371 00000D3F E2F8                <1> 	loop .clean_free_loop
  1372                              <1> 
  1373 00000D41 61                  <1> 	popa
  1374                              <1> 
  1375                              <1> 
  1376                              <1> 	; Next, we need to calculate now many 512 byte clusters are required
  1377                              <1> 
  1378 00000D42 89C8                <1> 	mov ax, cx
  1379 00000D44 31D2                <1> 	xor dx, dx
  1380 00000D46 BB0002              <1> 	mov bx, 512			; Divide file size by 512 to get clusters needed
  1381 00000D49 F7F3                <1> 	div bx
  1382 00000D4B 83FA00              <1> 	cmp dx, 0
  1383 00000D4E 7F02                <1> 	jg .add_a_bit			; If there's a remainder, we need another cluster
  1384 00000D50 EB03                <1> 	jmp .carry_on
  1385                              <1> 
  1386                              <1> .add_a_bit:
  1387 00000D52 83C001              <1> 	add ax, 1
  1388                              <1> .carry_on:
  1389                              <1> 
  1390 00000D55 A3[C10E]            <1> 	mov word [.clusters_needed], ax
  1391                              <1> 
  1392 00000D58 A1[C30E]            <1> 	mov word ax, [.filename]	; Get filename back
  1393                              <1> 
  1394 00000D5B E89301              <1> 	call os_create_file		; Create empty root dir entry for this file
  1395 00000D5E 0F824801            <1> 	jc near .failure		; If we can't write to the media, jump out
  1396                              <1> 
  1397 00000D62 8B1E[B90E]          <1> 	mov word bx, [.filesize]
  1398 00000D66 83FB00              <1> 	cmp bx, 0
  1399 00000D69 0F842F01            <1> 	je near .finished
  1400                              <1> 
  1401 00000D6D E83604              <1> 	call disk_read_fat		; Get FAT copy into RAM
  1402 00000D70 BE03E0              <1> 	mov si, disk_buffer + 3		; And point SI at it (skipping first two clusters)
  1403                              <1> 
  1404 00000D73 BB0200              <1> 	mov bx, 2			; Current cluster counter
  1405 00000D76 8B0E[C10E]          <1> 	mov word cx, [.clusters_needed]
  1406 00000D7A 31D2                <1> 	xor dx, dx			; Offset in .free_clusters list
  1407                              <1> 
  1408                              <1> .find_free_cluster:
  1409 00000D7C AD                  <1> 	lodsw				; Get a word
  1410 00000D7D 25FF0F              <1> 	and ax, 0FFFh			; Mask out for even
  1411 00000D80 740D                <1> 	jz .found_free_even		; Free entry?
  1412                              <1> 
  1413                              <1> .more_odd:
  1414 00000D82 43                  <1> 	inc bx				; If not, bump our counter
  1415 00000D83 4E                  <1> 	dec si				; 'lodsw' moved on two chars; we only want to move on one
  1416                              <1> 
  1417 00000D84 AD                  <1> 	lodsw				; Get word
  1418 00000D85 C1E804              <1> 	shr ax, 4			; Shift for odd
  1419 00000D88 09C0                <1> 	or ax, ax			; Free entry?
  1420 00000D8A 7413                <1> 	jz .found_free_odd
  1421                              <1> 
  1422                              <1> .more_even:
  1423 00000D8C 43                  <1> 	inc bx				; If not, keep going
  1424 00000D8D EBED                <1> 	jmp .find_free_cluster
  1425                              <1> 
  1426                              <1> 
  1427                              <1> .found_free_even:
  1428 00000D8F 56                  <1> 	push si
  1429 00000D90 BE00FF              <1> 	mov si, .free_clusters		; Store cluster
  1430 00000D93 01D6                <1> 	add si, dx
  1431 00000D95 891C                <1> 	mov word [si], bx
  1432 00000D97 5E                  <1> 	pop si
  1433                              <1> 
  1434 00000D98 49                  <1> 	dec cx				; Got all the clusters we need?
  1435 00000D99 E314                <1> 	jcxz .finished_list
  1436                              <1> 
  1437 00000D9B 42                  <1> 	inc dx				; Next word in our list
  1438 00000D9C 42                  <1> 	inc dx
  1439 00000D9D EBE3                <1> 	jmp .more_odd
  1440                              <1> 
  1441                              <1> .found_free_odd:
  1442 00000D9F 56                  <1> 	push si
  1443 00000DA0 BE00FF              <1> 	mov si, .free_clusters		; Store cluster
  1444 00000DA3 01D6                <1> 	add si, dx
  1445 00000DA5 891C                <1> 	mov word [si], bx
  1446 00000DA7 5E                  <1> 	pop si
  1447                              <1> 
  1448 00000DA8 49                  <1> 	dec cx
  1449 00000DA9 E304                <1> 	jcxz .finished_list
  1450                              <1> 
  1451 00000DAB 42                  <1> 	inc dx				; Next word in our list
  1452 00000DAC 42                  <1> 	inc dx
  1453 00000DAD EBDD                <1> 	jmp .more_even
  1454                              <1> 
  1455                              <1> 
  1456                              <1> 
  1457                              <1> .finished_list:
  1458                              <1> 
  1459                              <1> 	; Now the .free_clusters table contains a series of numbers (words)
  1460                              <1> 	; that correspond to free clusters on the disk; the next job is to
  1461                              <1> 	; create a cluster chain in the FAT for our file
  1462                              <1> 
  1463 00000DAF 31C9                <1> 	xor cx, cx			; .free_clusters offset counter
  1464 00000DB1 C706[BD0E]0100      <1> 	mov word [.count], 1		; General cluster counter
  1465                              <1> 
  1466                              <1> .chain_loop:
  1467 00000DB7 A1[BD0E]            <1> 	mov word ax, [.count]		; Is this the last cluster?
  1468 00000DBA 3B06[C10E]          <1> 	cmp word ax, [.clusters_needed]
  1469 00000DBE 7454                <1> 	je .last_cluster
  1470                              <1> 
  1471 00000DC0 BF00FF              <1> 	mov di, .free_clusters
  1472                              <1> 
  1473 00000DC3 01CF                <1> 	add di, cx
  1474 00000DC5 8B1D                <1> 	mov word bx, [di]		; Get cluster
  1475                              <1> 
  1476 00000DC7 89D8                <1> 	mov ax, bx			; Find out if it's an odd or even cluster
  1477 00000DC9 31D2                <1> 	xor dx, dx
  1478 00000DCB BB0300              <1> 	mov bx, 3
  1479 00000DCE F7E3                <1> 	mul bx
  1480 00000DD0 BB0200              <1> 	mov bx, 2
  1481 00000DD3 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
  1482 00000DD5 BE00E0              <1> 	mov si, disk_buffer
  1483 00000DD8 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
  1484 00000DDA 3E8B04              <1> 	mov ax, word [ds:si]
  1485                              <1> 
  1486 00000DDD 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
  1487 00000DDF 741B                <1> 	jz .even
  1488                              <1> 
  1489                              <1> .odd:
  1490 00000DE1 83E00F              <1> 	and ax, 000Fh			; Zero out bits we want to use
  1491 00000DE4 BF00FF              <1> 	mov di, .free_clusters
  1492 00000DE7 01CF                <1> 	add di, cx			; Get offset in .free_clusters
  1493 00000DE9 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT cluster
  1494 00000DEC C1E304              <1> 	shl bx, 4			; And convert it into right format for FAT
  1495 00000DEF 01D8                <1> 	add ax, bx
  1496                              <1> 
  1497 00000DF1 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
  1498                              <1> 
  1499 00000DF4 FF06[BD0E]          <1> 	inc word [.count]
  1500 00000DF8 41                  <1> 	inc cx				; Move on a word in .free_clusters
  1501 00000DF9 41                  <1> 	inc cx
  1502                              <1> 
  1503 00000DFA EBBB                <1> 	jmp .chain_loop
  1504                              <1> 
  1505                              <1> .even:
  1506 00000DFC 2500F0              <1> 	and ax, 0F000h			; Zero out bits we want to use
  1507 00000DFF BF00FF              <1> 	mov di, .free_clusters
  1508 00000E02 01CF                <1> 	add di, cx			; Get offset in .free_clusters
  1509 00000E04 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT free cluster
  1510                              <1> 
  1511 00000E07 01D8                <1> 	add ax, bx
  1512                              <1> 
  1513 00000E09 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
  1514                              <1> 
  1515 00000E0C FF06[BD0E]          <1> 	inc word [.count]
  1516 00000E10 41                  <1> 	inc cx				; Move on a word in .free_clusters
  1517 00000E11 41                  <1> 	inc cx
  1518                              <1> 
  1519 00000E12 EBA3                <1> 	jmp .chain_loop
  1520                              <1> 
  1521                              <1> 
  1522                              <1> 
  1523                              <1> .last_cluster:
  1524 00000E14 BF00FF              <1> 	mov di, .free_clusters
  1525 00000E17 01CF                <1> 	add di, cx
  1526 00000E19 8B1D                <1> 	mov word bx, [di]		; Get cluster
  1527                              <1> 
  1528 00000E1B 89D8                <1> 	mov ax, bx
  1529                              <1> 
  1530 00000E1D 31D2                <1> 	xor dx, dx
  1531 00000E1F BB0300              <1> 	mov bx, 3
  1532 00000E22 F7E3                <1> 	mul bx
  1533 00000E24 BB0200              <1> 	mov bx, 2
  1534 00000E27 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
  1535 00000E29 BE00E0              <1> 	mov si, disk_buffer
  1536 00000E2C 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
  1537 00000E2E 3E8B04              <1> 	mov ax, word [ds:si]
  1538                              <1> 
  1539 00000E31 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
  1540 00000E33 7408                <1> 	jz .even_last
  1541                              <1> 
  1542                              <1> .odd_last:
  1543 00000E35 83E00F              <1> 	and ax, 000Fh			; Set relevant parts to FF8h (last cluster in file)
  1544 00000E38 83C080              <1> 	add ax, 0FF80h
  1545 00000E3B EB06                <1> 	jmp .finito
  1546                              <1> 
  1547                              <1> .even_last:
  1548 00000E3D 2500F0              <1> 	and ax, 0F000h			; Same as above, but for an even cluster
  1549 00000E40 05F80F              <1> 	add ax, 0FF8h
  1550                              <1> 
  1551                              <1> 
  1552                              <1> .finito:
  1553 00000E43 3E8904              <1> 	mov word [ds:si], ax
  1554                              <1> 
  1555 00000E46 E88803              <1> 	call disk_write_fat		; Save our FAT back to disk
  1556                              <1> 
  1557                              <1> 
  1558                              <1> 	; Now it's time to save the sectors to disk!
  1559                              <1> 
  1560 00000E49 31C9                <1> 	xor cx, cx
  1561                              <1> 
  1562                              <1> .save_loop:
  1563 00000E4B BF00FF              <1> 	mov di, .free_clusters
  1564 00000E4E 01CF                <1> 	add di, cx
  1565 00000E50 8B05                <1> 	mov word ax, [di]
  1566                              <1> 
  1567 00000E52 83F800              <1> 	cmp ax, 0
  1568 00000E55 0F842200            <1> 	je near .write_root_entry
  1569                              <1> 
  1570 00000E59 60                  <1> 	pusha
  1571                              <1> 
  1572 00000E5A 83C01F              <1> 	add ax, 31
  1573                              <1> 
  1574 00000E5D E8E903              <1> 	call disk_convert_l2hts
  1575                              <1> 
  1576 00000E60 8B1E[BF0E]          <1> 	mov word bx, [.location]
  1577 00000E64 8E06[C50E]          <1> 	mov es, [.old_segment]
  1578                              <1> 	
  1579 00000E68 B80103              <1> 	mov ax, 0301h
  1580 00000E6B F9                  <1> 	stc
  1581 00000E6C CD13                <1> 	int 13h
  1582                              <1> 
  1583 00000E6E 0E                  <1> 	push cs
  1584 00000E6F 07                  <1> 	pop es
  1585                              <1> 		
  1586 00000E70 61                  <1> 	popa
  1587                              <1> 
  1588 00000E71 8106[BF0E]0002      <1> 	add word [.location], 512
  1589 00000E77 41                  <1> 	inc cx
  1590 00000E78 41                  <1> 	inc cx
  1591 00000E79 EBD0                <1> 	jmp .save_loop
  1592                              <1> 
  1593                              <1> 
  1594                              <1> .write_root_entry:
  1595                              <1> 
  1596                              <1> 	; Now it's time to head back to the root directory, find our
  1597                              <1> 	; entry and update it with the cluster in use and file size
  1598                              <1> 
  1599 00000E7B E87203              <1> 	call disk_read_root_dir
  1600                              <1> 
  1601 00000E7E A1[C30E]            <1> 	mov word ax, [.filename]
  1602 00000E81 E8EA02              <1> 	call disk_get_root_entry
  1603                              <1> 
  1604 00000E84 A100FF              <1> 	mov word ax, [.free_clusters]	; Get first free cluster
  1605                              <1> 
  1606 00000E87 89451A              <1> 	mov word [di+26], ax		; Save cluster location into root dir entry
  1607                              <1> 
  1608 00000E8A 8B0E[B90E]          <1> 	mov word cx, [.filesize]
  1609 00000E8E 894D1C              <1> 	mov word [di+28], cx
  1610                              <1> 
  1611 00000E91 C6451E00            <1> 	mov byte [di+30], 0		; File size
  1612 00000E95 C6451F00            <1> 	mov byte [di+31], 0
  1613                              <1> 
  1614 00000E99 E87F03              <1> 	call disk_write_root_dir
  1615                              <1> 
  1616                              <1> .finished:
  1617 00000E9C 61                  <1> 	popa
  1618 00000E9D 60                  <1> 	pusha
  1619 00000E9E 31F6                <1> 	xor si, si
  1620 00000EA0 E8DE14              <1> 	call os_print_footer
  1621 00000EA3 61                  <1> 	popa
  1622 00000EA4 8E06[C50E]          <1> 	mov es, [.old_segment]
  1623                              <1> 
  1624 00000EA8 F8                  <1> 	clc
  1625 00000EA9 C3                  <1> 	ret
  1626                              <1> 
  1627                              <1> .failure:
  1628 00000EAA 61                  <1> 	popa
  1629 00000EAB 60                  <1> 	pusha
  1630 00000EAC BE0000              <1> 	mov si, 0
  1631 00000EAF E8CF14              <1> 	call os_print_footer
  1632 00000EB2 61                  <1> 	popa
  1633 00000EB3 8E06[C50E]          <1> 	mov es, [.old_segment]
  1634                              <1> 
  1635 00000EB7 F9                  <1> 	stc				; Couldn't write!
  1636 00000EB8 C3                  <1> 	ret
  1637                              <1> 
  1638                              <1> 
  1639 00000EB9 0000                <1> 	.filesize				dw 0
  1640 00000EBB 0000                <1> 	.cluster				dw 0
  1641 00000EBD 0000                <1> 	.count					dw 0
  1642 00000EBF 0000                <1> 	.location				dw 0
  1643                              <1> 
  1644 00000EC1 0000                <1> 	.clusters_needed		dw 0
  1645                              <1> 
  1646 00000EC3 0000                <1> 	.filename				dw 0
  1647                              <1> 
  1648                              <1> 	.free_clusters			equ 65280
  1649                              <1> 
  1650 00000EC5 0000                <1> 	.old_segment			dw 0
  1651                              <1> 
  1652 00000EC7 20536176696E672000  <1> 	.msg_save				db ' Saving ', 0
  1653                              <1> 	
  1654                              <1> ; --------------------------------------------------------------------------
  1655                              <1> ; os_file_exists -- Check for presence of file on the floppy
  1656                              <1> ; IN: AX = filename location; OUT: carry clear if found, set if not
  1657                              <1> 
  1658                              <1> os_file_exists:
  1659 00000ED0 E8381B              <1> 	call os_string_uppercase
  1660 00000ED3 E81302              <1> 	call int_filename_convert	; Make FAT12-style filename
  1661                              <1> 
  1662 00000ED6 50                  <1> 	push ax
  1663 00000ED7 E8D81A              <1> 	call os_string_length
  1664 00000EDA 83F800              <1> 	cmp ax, 0
  1665 00000EDD 740F                <1> 	je .failure
  1666 00000EDF 58                  <1> 	pop ax
  1667                              <1> 
  1668 00000EE0 50                  <1> 	push ax
  1669 00000EE1 E80C03              <1> 	call disk_read_root_dir
  1670                              <1> 
  1671 00000EE4 58                  <1> 	pop ax				; Restore filename
  1672                              <1> 
  1673 00000EE5 BF00E0              <1> 	mov di, disk_buffer
  1674                              <1> 
  1675 00000EE8 E88302              <1> 	call disk_get_root_entry	; Set or clear carry flag
  1676                              <1> 
  1677 00000EEB 9C                  <1> 	pushf
  1678                              <1> 
  1679 00000EEC 9D                  <1> 	popf
  1680 00000EED C3                  <1> 	ret
  1681                              <1> 
  1682                              <1> .failure:
  1683 00000EEE 58                  <1> 	pop ax
  1684                              <1> 
  1685 00000EEF F9                  <1> 	stc
  1686 00000EF0 C3                  <1> 	ret
  1687                              <1> 
  1688                              <1> 
  1689                              <1> ; --------------------------------------------------------------------------
  1690                              <1> ; os_create_file -- Creates a new 0-byte file on the floppy disk
  1691                              <1> ; IN: AX = location of filename; OUT: Nothing
  1692                              <1> 
  1693                              <1> os_create_file:
  1694 00000EF1 F8                  <1> 	clc
  1695                              <1> 
  1696 00000EF2 E8161B              <1> 	call os_string_uppercase
  1697 00000EF5 E8F101              <1> 	call int_filename_convert	; Make FAT12-style filename
  1698 00000EF8 60                  <1> 	pusha
  1699                              <1> 
  1700 00000EF9 50                  <1> 	push ax				; Save filename for now
  1701                              <1> 
  1702 00000EFA E8D3FF              <1> 	call os_file_exists		; Does the file already exist?
  1703 00000EFD 731B                <1> 	jnc .exists_error
  1704                              <1> 
  1705                              <1> 
  1706                              <1> 	; Root dir already read into disk_buffer by os_file_exists
  1707                              <1> 
  1708 00000EFF BF00E0              <1> 	mov di, disk_buffer		; So point DI at it!
  1709                              <1> 
  1710 00000F02 B9E000              <1> 	mov cx, 224			; Cycle through root dir entries
  1711                              <1> .next_entry:
  1712 00000F05 8A05                <1> 	mov byte al, [di]
  1713 00000F07 3C00                <1> 	cmp al, 0			; Is this a free entry?
  1714 00000F09 7412                <1> 	je .found_free_entry
  1715 00000F0B 3CE5                <1> 	cmp al, 0E5h			; Is this a free entry?
  1716 00000F0D 740E                <1> 	je .found_free_entry
  1717 00000F0F 83C720              <1> 	add di, 32			; If not, go onto next entry
  1718 00000F12 E2F1                <1> 	loop .next_entry
  1719                              <1> 	
  1720 00000F14 B8[B10F]            <1> 	mov ax, .err_msg		; Is the root directory full?
  1721 00000F17 E88506              <1> 	call os_fatal_error
  1722                              <1> 
  1723                              <1> .exists_error:				; We also get here if above loop finds nothing
  1724 00000F1A 58                  <1> 	pop ax				; Get filename back
  1725                              <1> 
  1726 00000F1B EB7C                <1> 	jmp .failure
  1727                              <1> 
  1728                              <1> .found_free_entry:
  1729 00000F1D 5E                  <1> 	pop si				; Get filename back
  1730 00000F1E B90B00              <1> 	mov cx, 11
  1731 00000F21 F3A4                <1> 	rep movsb			; And copy it into RAM copy of root dir (in DI)
  1732                              <1> 
  1733                              <1> 	; Get the time information
  1734                              <1> 	
  1735 00000F23 60                  <1> 	pusha
  1736 00000F24 B402                <1> 	mov ah, 2
  1737 00000F26 E88F07              <1> 	call os_int_1Ah
  1738                              <1> 
  1739 00000F29 88E8                <1> 	mov al, ch			; Hours
  1740 00000F2B E8D404              <1> 	call os_bcd_to_int
  1741 00000F2E 89C3                <1> 	mov bx, ax
  1742 00000F30 C1E306              <1> 	shl bx, 6
  1743                              <1> 	
  1744 00000F33 88C8                <1> 	mov al, cl			; Minutes
  1745 00000F35 E8CA04              <1> 	call os_bcd_to_int
  1746 00000F38 09C3                <1> 	or bx, ax
  1747 00000F3A C1E305              <1> 	shl bx, 5
  1748                              <1> 	
  1749 00000F3D D0EE                <1> 	shr dh, 1			; Seconds (they're stored as "doubleseconds")
  1750 00000F3F 88F0                <1> 	mov al, dh
  1751 00000F41 E8BE04              <1> 	call os_bcd_to_int
  1752 00000F44 09C3                <1> 	or bx, ax
  1753                              <1> 	
  1754 00000F46 891E[9F0F]          <1> 	mov [.creation_time], bx
  1755 00000F4A 891E[A70F]          <1> 	mov [.write_time], bx
  1756                              <1> 
  1757                              <1> 	; Get date information
  1758                              <1> 	
  1759 00000F4E B404                <1> 	mov ah, 4
  1760 00000F50 E86507              <1> 	call os_int_1Ah
  1761                              <1> 
  1762 00000F53 52                  <1> 	push dx
  1763 00000F54 88E8                <1> 	mov al, ch			; Century
  1764 00000F56 E8A904              <1> 	call os_bcd_to_int
  1765 00000F59 BB6400              <1> 	mov bx, 100
  1766 00000F5C F7E3                <1> 	mul bx
  1767 00000F5E 89C3                <1> 	mov bx, ax
  1768                              <1> 	
  1769 00000F60 88C8                <1> 	mov al, cl			; Years
  1770 00000F62 E89D04              <1> 	call os_bcd_to_int
  1771 00000F65 01C3                <1> 	add bx, ax
  1772                              <1> 	
  1773 00000F67 81EBBC07            <1> 	sub bx, 1980		; Years are stored as "years past 1980"
  1774                              <1> 	
  1775 00000F6B C1E304              <1> 	shl bx, 4
  1776 00000F6E 5A                  <1> 	pop dx
  1777                              <1> 	
  1778 00000F6F 88F0                <1> 	mov al, dh			; Months
  1779 00000F71 E88E04              <1> 	call os_bcd_to_int
  1780 00000F74 09C3                <1> 	or bx, ax
  1781 00000F76 C1E305              <1> 	shl bx, 5
  1782                              <1> 	
  1783 00000F79 88D0                <1> 	mov al, dl			; Days
  1784 00000F7B E88404              <1> 	call os_bcd_to_int
  1785 00000F7E 09C3                <1> 	or bx, ax
  1786                              <1> 	
  1787 00000F80 891E[A10F]          <1> 	mov [.creation_date], bx
  1788 00000F84 891E[A90F]          <1> 	mov [.write_date], bx
  1789 00000F88 61                  <1> 	popa
  1790                              <1> 	
  1791 00000F89 BE[9C0F]            <1> 	mov si, .table		; Copy over all the attributes
  1792 00000F8C B91500              <1> 	mov cx, 21
  1793 00000F8F F3A4                <1> 	rep movsb
  1794                              <1> 	
  1795 00000F91 E88702              <1> 	call disk_write_root_dir
  1796 00000F94 7203                <1> 	jc .failure
  1797                              <1> 
  1798 00000F96 61                  <1> 	popa
  1799                              <1> 
  1800 00000F97 F8                  <1> 	clc				; Clear carry for success
  1801 00000F98 C3                  <1> 	ret
  1802                              <1> 
  1803                              <1> .failure:
  1804 00000F99 61                  <1> 	popa
  1805                              <1> 
  1806 00000F9A F9                  <1> 	stc
  1807 00000F9B C3                  <1> 	ret
  1808                              <1> 
  1809                              <1> ;	.table			db 0, 0, 0, 0C6h, 07Eh, 0, 0, 0, 0, 0, 0, 0C6h, 07Eh, 0, 0, 0, 0, 0, 0, 0, 0 
  1810                              <1> 	.table:
  1811 00000F9C 00                  <1> 		.atttribute		db 0
  1812 00000F9D 00<rep 2h>          <1> 		.reserved		times 2 db 0
  1813 00000F9F 0000                <1> 		.creation_time	dw 0
  1814 00000FA1 0000                <1> 		.creation_date	dw 0
  1815 00000FA3 00<rep 4h>          <1> 		.reserved2		times 4 db 0
  1816 00000FA7 0000                <1> 		.write_time		dw 0
  1817 00000FA9 0000                <1> 		.write_date		dw 0
  1818 00000FAB 00<rep 6h>          <1> 		.reserved3		times 6 db 0
  1819 00000FB1 4E6F7420656E6F7567- <1> 	.err_msg		db 'Not enough space in directory', 0
  1819 00000FBA 682073706163652069- <1>
  1819 00000FC3 6E206469726563746F- <1>
  1819 00000FCC 727900              <1>
  1820                              <1> 
  1821                              <1> ; --------------------------------------------------------------------------
  1822                              <1> ; os_remove_file -- Deletes the specified file from the filesystem
  1823                              <1> ; IN: AX = location of filename to remove
  1824                              <1> 
  1825                              <1> os_remove_file:
  1826 00000FCF 60                  <1> 	pusha
  1827 00000FD0 E8381A              <1> 	call os_string_uppercase
  1828 00000FD3 E81301              <1> 	call int_filename_convert	; Make filename FAT12-style
  1829 00000FD6 50                  <1> 	push ax				; Save filename
  1830                              <1> 
  1831 00000FD7 F8                  <1> 	clc
  1832                              <1> 
  1833 00000FD8 E81502              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1834                              <1> 
  1835 00000FDB BF00E0              <1> 	mov di, disk_buffer		; Point DI to root dir
  1836                              <1> 
  1837 00000FDE 58                  <1> 	pop ax				; Get chosen filename back
  1838                              <1> 
  1839 00000FDF E88C01              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1840 00000FE2 7268                <1> 	jc .failure			; If entry can't be found
  1841                              <1> 
  1842                              <1> 
  1843 00000FE4 268B451A            <1> 	mov ax, word [es:di+26]		; Get first cluster number from the dir entry
  1844 00000FE8 A3[4F10]            <1> 	mov word [.cluster], ax		; And save it
  1845                              <1> 
  1846 00000FEB C605E5              <1> 	mov byte [di], 0E5h		; Mark directory entry (first byte of filename) as empty
  1847                              <1> 
  1848 00000FEE 47                  <1> 	inc di
  1849                              <1> 
  1850 00000FEF 31C9                <1> 	xor cx, cx			; Set rest of data in root dir entry to zeros
  1851                              <1> .clean_loop:
  1852 00000FF1 C60500              <1> 	mov byte [di], 0
  1853 00000FF4 47                  <1> 	inc di
  1854 00000FF5 41                  <1> 	inc cx
  1855 00000FF6 83F91F              <1> 	cmp cx, 31			; 32-byte entries, minus E5h byte we marked before
  1856 00000FF9 7CF6                <1> 	jl .clean_loop
  1857                              <1> 
  1858 00000FFB E81D02              <1> 	call disk_write_root_dir	; Save back the root directory from RAM
  1859                              <1> 
  1860                              <1> 
  1861 00000FFE E8A501              <1> 	call disk_read_fat		; Now FAT is in disk_buffer
  1862 00001001 BF00E0              <1> 	mov di, disk_buffer		; And DI points to it
  1863                              <1> 
  1864                              <1> 
  1865                              <1> .more_clusters:
  1866 00001004 A1[4F10]            <1> 	mov word ax, [.cluster]		; Get cluster contents
  1867                              <1> 
  1868 00001007 83F800              <1> 	cmp ax, 0			; If it's zero, this was an empty file
  1869 0000100A 743D                <1> 	je .nothing_to_do
  1870                              <1> 
  1871 0000100C BB0300              <1> 	mov bx, 3			; Determine if cluster is odd or even number
  1872 0000100F F7E3                <1> 	mul bx
  1873 00001011 BB0200              <1> 	mov bx, 2
  1874 00001014 F7F3                <1> 	div bx				; DX = [first_cluster] mod 2
  1875 00001016 BE00E0              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
  1876 00001019 01C6                <1> 	add si, ax
  1877 0000101B 3E8B04              <1> 	mov ax, word [ds:si]
  1878                              <1> 
  1879 0000101E 09D2                <1> 	or dx, dx			; If DX = 0 [.cluster] = even, if DX = 1 then odd
  1880                              <1> 
  1881 00001020 740D                <1> 	jz .even			; If [.cluster] = even, drop last 4 bits of word
  1882                              <1> 					; with next cluster; if odd, drop first 4 bits
  1883                              <1> .odd:
  1884 00001022 50                  <1> 	push ax
  1885 00001023 83E00F              <1> 	and ax, 000Fh			; Set cluster data to zero in FAT in RAM
  1886 00001026 3E8904              <1> 	mov word [ds:si], ax
  1887 00001029 58                  <1> 	pop ax
  1888                              <1> 
  1889 0000102A C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (they belong to another entry)
  1890 0000102D EB0B                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
  1891                              <1> 
  1892                              <1> .even:
  1893 0000102F 50                  <1> 	push ax
  1894 00001030 2500F0              <1> 	and ax, 0F000h			; Set cluster data to zero in FAT in RAM
  1895 00001033 3E8904              <1> 	mov word [ds:si], ax
  1896 00001036 58                  <1> 	pop ax
  1897                              <1> 
  1898 00001037 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits (they belong to another entry)
  1899                              <1> 
  1900                              <1> .calculate_cluster_cont:
  1901 0000103A A3[4F10]            <1> 	mov word [.cluster], ax		; Store cluster
  1902                              <1> 
  1903 0000103D 3DF80F              <1> 	cmp ax, 0FF8h			; Final cluster marker?
  1904 00001040 7302                <1> 	jae .end
  1905                              <1> 
  1906 00001042 EBC0                <1> 	jmp .more_clusters		; If not, grab more
  1907                              <1> 
  1908                              <1> .end:
  1909 00001044 E88A01              <1> 	call disk_write_fat
  1910 00001047 7203                <1> 	jc .failure
  1911                              <1> 
  1912                              <1> .nothing_to_do:
  1913 00001049 61                  <1> 	popa
  1914                              <1> 
  1915 0000104A F8                  <1> 	clc
  1916 0000104B C3                  <1> 	ret
  1917                              <1> 
  1918                              <1> .failure:
  1919 0000104C 61                  <1> 	popa
  1920                              <1> 
  1921 0000104D F9                  <1> 	stc
  1922 0000104E C3                  <1> 	ret
  1923                              <1> 
  1924                              <1> 
  1925 0000104F 0000                <1> 	.cluster dw 0
  1926                              <1> 
  1927                              <1> 
  1928                              <1> ; --------------------------------------------------------------------------
  1929                              <1> ; os_rename_file -- Change the name of a file on the disk
  1930                              <1> ; IN: AX = filename to change, BX = new filename (zero-terminated strings)
  1931                              <1> ; OUT: carry set on error
  1932                              <1> 
  1933                              <1> os_rename_file:
  1934 00001051 53                  <1> 	push bx
  1935 00001052 50                  <1> 	push ax
  1936                              <1> 
  1937 00001053 F8                  <1> 	clc
  1938                              <1> 
  1939 00001054 E89901              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1940                              <1> 
  1941 00001057 BF00E0              <1> 	mov di, disk_buffer		; Point DI to root dir
  1942                              <1> 
  1943 0000105A 58                  <1> 	pop ax				; Get chosen filename back
  1944                              <1> 
  1945 0000105B E8AD19              <1> 	call os_string_uppercase
  1946 0000105E E88800              <1> 	call int_filename_convert
  1947 00001061 721E                <1> 	jc .fail_read
  1948                              <1> 	
  1949 00001063 E80801              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1950 00001066 7219                <1> 	jc .fail_read			; Quit out if file not found
  1951                              <1> 
  1952 00001068 5B                  <1> 	pop bx				; Get new filename string (originally passed in BX)
  1953                              <1> 
  1954 00001069 89D8                <1> 	mov ax, bx
  1955                              <1> 
  1956 0000106B E89D19              <1> 	call os_string_uppercase
  1957 0000106E E87800              <1> 	call int_filename_convert
  1958 00001071 7211                <1> 	jc .fail_write
  1959                              <1> 	
  1960 00001073 89C6                <1> 	mov si, ax
  1961                              <1> 
  1962 00001075 B90B00              <1> 	mov cx, 11			; Copy new filename string into root dir entry in disk_buffer
  1963 00001078 F3A4                <1> 	rep movsb
  1964                              <1> 
  1965 0000107A E89E01              <1> 	call disk_write_root_dir	; Save root dir to disk
  1966 0000107D 7205                <1> 	jc .fail_write
  1967                              <1> 
  1968                              <1> 
  1969 0000107F F8                  <1> 	clc
  1970 00001080 C3                  <1> 	ret
  1971                              <1> 
  1972                              <1> .fail_read:
  1973 00001081 58                  <1> 	pop ax
  1974                              <1> 
  1975 00001082 F9                  <1> 	stc
  1976 00001083 C3                  <1> 	ret
  1977                              <1> 
  1978                              <1> .fail_write:
  1979                              <1> 
  1980 00001084 F9                  <1> 	stc
  1981 00001085 C3                  <1> 	ret
  1982                              <1> 
  1983                              <1> 
  1984                              <1> ; --------------------------------------------------------------------------
  1985                              <1> ; os_get_file_size -- Get file size information for specified file
  1986                              <1> ; IN: AX = filename; OUT: EBX = file size in bytes (up to 4GB)
  1987                              <1> ; or carry set if file not found
  1988                              <1> 
  1989                              <1> os_get_file_size:
  1990 00001086 60                  <1> 	pusha
  1991                              <1> 
  1992 00001087 E88119              <1> 	call os_string_uppercase
  1993 0000108A E85C00              <1> 	call int_filename_convert
  1994                              <1> 
  1995 0000108D F8                  <1> 	clc
  1996                              <1> 
  1997 0000108E 50                  <1> 	push ax
  1998                              <1> 
  1999 0000108F E85E01              <1> 	call disk_read_root_dir
  2000 00001092 7219                <1> 	jc .failure
  2001                              <1> 
  2002 00001094 58                  <1> 	pop ax
  2003                              <1> 
  2004 00001095 BF00E0              <1> 	mov di, disk_buffer
  2005                              <1> 
  2006 00001098 E8D300              <1> 	call disk_get_root_entry
  2007 0000109B 7210                <1> 	jc .failure
  2008                              <1> 
  2009 0000109D 668B5D1C            <1> 	mov ebx, [di+28]
  2010                              <1> 
  2011 000010A1 66891E[B010]        <1> 	mov [.tmp], ebx
  2012                              <1> 
  2013 000010A6 61                  <1> 	popa
  2014                              <1> 
  2015 000010A7 668B1E[B010]        <1> 	mov ebx, [.tmp]
  2016                              <1> 
  2017                              <1> 
  2018 000010AC C3                  <1> 	ret
  2019                              <1> 
  2020                              <1> .failure:
  2021 000010AD 61                  <1> 	popa
  2022 000010AE F9                  <1> 	stc
  2023                              <1> 
  2024 000010AF C3                  <1> 	ret
  2025                              <1> 
  2026                              <1> 
  2027 000010B0 00000000            <1> 	.tmp	dd 0
  2028                              <1> 
  2029                              <1> ; --------------------------------------------------------------------------
  2030                              <1> ; os_get_file_datetime -- Get file write time/date information for specified file
  2031                              <1> ; IN: AX = filename; OUT: BX = time of creation (HHHHHMMMMMMSSSSS), CX = date of creation (YYYYYYYMMMMDDDDD)
  2032                              <1> ; or carry set if file not found
  2033                              <1> 
  2034                              <1> os_get_file_datetime:
  2035 000010B4 60                  <1> 	pusha
  2036                              <1> 
  2037 000010B5 E85319              <1> 	call os_string_uppercase
  2038 000010B8 E82E00              <1> 	call int_filename_convert
  2039                              <1> 
  2040 000010BB F8                  <1> 	clc
  2041                              <1> 
  2042 000010BC 50                  <1> 	push ax
  2043                              <1> 
  2044 000010BD E83001              <1> 	call disk_read_root_dir
  2045 000010C0 7220                <1> 	jc .failure
  2046                              <1> 
  2047 000010C2 58                  <1> 	pop ax
  2048                              <1> 
  2049 000010C3 BF00E0              <1> 	mov di, disk_buffer
  2050                              <1> 
  2051 000010C6 E8A500              <1> 	call disk_get_root_entry
  2052 000010C9 7217                <1> 	jc .failure
  2053                              <1> 
  2054 000010CB 8B4516              <1> 	mov ax, [di+22]
  2055 000010CE 8B5D18              <1> 	mov bx, [di+24]
  2056                              <1> 
  2057 000010D1 A3[E510]            <1> 	mov [.tmp], ax
  2058 000010D4 891E[E710]          <1> 	mov [.tmp + 2], bx
  2059                              <1> 
  2060 000010D8 61                  <1> 	popa
  2061                              <1> 
  2062 000010D9 8B1E[E510]          <1> 	mov bx, [.tmp]
  2063 000010DD 8B0E[E710]          <1> 	mov cx, [.tmp + 2]
  2064                              <1> 
  2065                              <1> 
  2066 000010E1 C3                  <1> 	ret
  2067                              <1> 
  2068                              <1> .failure:
  2069 000010E2 61                  <1> 	popa
  2070 000010E3 F9                  <1> 	stc
  2071                              <1> 
  2072 000010E4 C3                  <1> 	ret
  2073                              <1> 
  2074                              <1> 
  2075 000010E5 00000000            <1> 	.tmp	dd 0
  2076                              <1> 
  2077                              <1> 
  2078                              <1> ; ==================================================================
  2079                              <1> ; INTERNAL OS ROUTINES -- Not accessible to user programs
  2080                              <1> 
  2081                              <1> ; ------------------------------------------------------------------
  2082                              <1> ; int_filename_convert -- Change 'TEST.BIN' into 'TEST    BIN' as per FAT12
  2083                              <1> ; IN: AX = filename string
  2084                              <1> ; OUT: AX = location of converted string (carry set if invalid)
  2085                              <1> 
  2086                              <1> 
  2087                              <1> int_filename_convert:
  2088 000010E9 60                  <1> 	pusha
  2089                              <1> 
  2090 000010EA 89C6                <1> 	mov si, ax
  2091                              <1> 
  2092 000010EC E8C318              <1> 	call os_string_length
  2093 000010EF 83F80C              <1> 	cmp ax, 12			; Filename too long?
  2094 000010F2 7F49                <1> 	jg .failure0			; Fail if so
  2095                              <1> 
  2096 000010F4 83F800              <1> 	cmp ax, 0
  2097 000010F7 744B                <1> 	je .failure1			; Similarly, fail if zero-char string
  2098                              <1> 
  2099 000010F9 89C2                <1> 	mov dx, ax			; Store string length for now
  2100                              <1> 
  2101 000010FB BF[6111]            <1> 	mov di, .dest_string
  2102                              <1> 
  2103 000010FE B90000              <1> 	mov cx, 0
  2104                              <1> .copy_loop:
  2105 00001101 AC                  <1> 	lodsb
  2106 00001102 3C2E                <1> 	cmp al, '.'
  2107 00001104 7408                <1> 	je .extension_found
  2108 00001106 AA                  <1> 	stosb
  2109 00001107 41                  <1> 	inc cx
  2110 00001108 39D1                <1> 	cmp cx, dx
  2111 0000110A 7F3F                <1> 	jg .failure2			; No extension found = wrong
  2112 0000110C EBF3                <1> 	jmp .copy_loop
  2113                              <1> 
  2114                              <1> .extension_found:
  2115 0000110E 83F900              <1> 	cmp cx, 0
  2116 00001111 743F                <1> 	je .failure3			; Fail if extension dot is first char
  2117                              <1> 
  2118 00001113 83F908              <1> 	cmp cx, 8
  2119 00001116 740A                <1> 	je .do_extension		; Skip spaces if first bit is 8 chars
  2120                              <1> 
  2121                              <1> 	; Now it's time to pad out the rest of the first part of the filename
  2122                              <1> 	; with spaces, if necessary
  2123                              <1> 
  2124                              <1> .add_spaces:
  2125 00001118 C60520              <1> 	mov byte [di], ' '
  2126 0000111B 47                  <1> 	inc di
  2127 0000111C 41                  <1> 	inc cx
  2128 0000111D 83F908              <1> 	cmp cx, 8
  2129 00001120 7CF6                <1> 	jl .add_spaces
  2130                              <1> 
  2131                              <1> 	; Finally, copy over the extension
  2132                              <1> .do_extension:
  2133 00001122 AC                  <1> 	lodsb				; 3 characters
  2134 00001123 3C00                <1> 	cmp al, 0
  2135 00001125 7432                <1> 	je .failure4
  2136 00001127 AA                  <1> 	stosb
  2137 00001128 AC                  <1> 	lodsb
  2138 00001129 3C00                <1> 	cmp al, 0
  2139 0000112B 742C                <1> 	je .failure4
  2140 0000112D AA                  <1> 	stosb
  2141 0000112E AC                  <1> 	lodsb
  2142 0000112F 3C00                <1> 	cmp al, 0
  2143 00001131 7426                <1> 	je .failure4
  2144 00001133 AA                  <1> 	stosb
  2145                              <1> 
  2146 00001134 C60500              <1> 	mov byte [di], 0		; Zero-terminate filename
  2147                              <1> 
  2148 00001137 61                  <1> 	popa
  2149 00001138 B8[6111]            <1> 	mov ax, .dest_string
  2150 0000113B F8                  <1> 	clc				; Clear carry for success
  2151 0000113C C3                  <1> 	ret
  2152                              <1> 
  2153                              <1> 
  2154                              <1> .failure0:
  2155 0000113D C606860000          <1> 	mov byte [0086h], 0
  2156 00001142 EB1A                <1> 	jmp .failure
  2157                              <1> 	
  2158                              <1> .failure1:
  2159 00001144 C606860001          <1> 	mov byte [0086h], 1
  2160 00001149 EB13                <1> 	jmp .failure
  2161                              <1> 	
  2162                              <1> .failure2:
  2163 0000114B C606860002          <1> 	mov byte [0086h], 2
  2164 00001150 EB0C                <1> 	jmp .failure
  2165                              <1> 	
  2166                              <1> .failure3:
  2167 00001152 C606860003          <1> 	mov byte [0086h], 3
  2168 00001157 EB05                <1> 	jmp .failure
  2169                              <1> 	
  2170                              <1> .failure4:
  2171 00001159 C606860004          <1> 	mov byte [0086h], 4
  2172                              <1> 
  2173                              <1> .failure:	
  2174 0000115E 61                  <1> 	popa
  2175 0000115F F9                  <1> 	stc				; Set carry for failure
  2176 00001160 C3                  <1> 	ret
  2177                              <1> 
  2178 00001161 00<rep Dh>          <1> 	.dest_string	times 13 db 0
  2179                              <1> 
  2180                              <1> 
  2181                              <1> ; --------------------------------------------------------------------------
  2182                              <1> ; disk_get_root_entry -- Search RAM copy of root dir for file entry
  2183                              <1> ; IN: AX = filename; OUT: DI = location in disk_buffer of root dir entry,
  2184                              <1> ; or carry set if file not found
  2185                              <1> 
  2186                              <1> disk_get_root_entry:
  2187 0000116E 60                  <1> 	pusha
  2188                              <1> 
  2189 0000116F A3[A211]            <1> 	mov word [.filename], ax
  2190                              <1> 
  2191 00001172 B9E000              <1> 	mov cx, 224			; Search all (224) entries
  2192 00001175 B80000              <1> 	mov ax, 0			; Searching at offset 0
  2193                              <1> 
  2194                              <1> .to_next_root_entry:
  2195 00001178 87CA                <1> 	xchg cx, dx			; We use CX in the inner loop...
  2196                              <1> 
  2197 0000117A 8B36[A211]          <1> 	mov word si, [.filename]	; Start searching for filename
  2198 0000117E B90B00              <1> 	mov cx, 11
  2199 00001181 F3A6                <1> 	rep cmpsb
  2200 00001183 740F                <1> 	je .found_file			; Pointer DI will be at offset 11, if file found
  2201                              <1> 
  2202 00001185 83C020              <1> 	add ax, 32			; Bump searched entries by 1 (32 bytes/entry)
  2203                              <1> 
  2204 00001188 BF00E0              <1> 	mov di, disk_buffer		; Point to next root dir entry
  2205 0000118B 01C7                <1> 	add di, ax
  2206                              <1> 
  2207 0000118D 87D1                <1> 	xchg dx, cx			; Get the original CX back
  2208 0000118F E2E7                <1> 	loop .to_next_root_entry
  2209                              <1> 
  2210 00001191 61                  <1> 	popa
  2211                              <1> 
  2212 00001192 F9                  <1> 	stc				; Set carry if entry not found
  2213 00001193 C3                  <1> 	ret
  2214                              <1> 
  2215                              <1> 
  2216                              <1> .found_file:
  2217 00001194 83EF0B              <1> 	sub di, 11			; Move back to start of this root dir entry
  2218                              <1> 
  2219 00001197 893E[A411]          <1> 	mov word [.tmp], di		; Restore all registers except for DI
  2220                              <1> 
  2221 0000119B 61                  <1> 	popa
  2222                              <1> 
  2223 0000119C 8B3E[A411]          <1> 	mov word di, [.tmp]
  2224                              <1> 
  2225 000011A0 F8                  <1> 	clc
  2226 000011A1 C3                  <1> 	ret
  2227                              <1> 
  2228                              <1> 
  2229 000011A2 0000                <1> 	.filename	dw 0
  2230 000011A4 0000                <1> 	.tmp		dw 0
  2231                              <1> 
  2232                              <1> 
  2233                              <1> ; --------------------------------------------------------------------------
  2234                              <1> ; disk_read_fat -- Read FAT entry from floppy into disk_buffer
  2235                              <1> ; IN: Nothing; OUT: carry set if failure
  2236                              <1> 
  2237                              <1> disk_read_fat:
  2238 000011A6 60                  <1> 	pusha
  2239                              <1> 
  2240 000011A7 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  2241 000011AA E89C00              <1> 	call disk_convert_l2hts
  2242                              <1> 
  2243 000011AD BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  2244 000011B0 8CCB                <1> 	mov bx, cs
  2245 000011B2 8EC3                <1> 	mov es, bx
  2246 000011B4 89F3                <1> 	mov bx, si
  2247                              <1> 
  2248 000011B6 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  2249 000011B8 B009                <1> 	mov al, 9			; And read 9 of them for first FAT
  2250                              <1> 
  2251 000011BA 60                  <1> 	pusha				; Prepare to enter loop
  2252                              <1> 
  2253                              <1> 
  2254                              <1> .read_fat_loop:
  2255 000011BB 61                  <1> 	popa
  2256 000011BC 60                  <1> 	pusha
  2257                              <1> 
  2258 000011BD F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2259 000011BE CD13                <1> 	int 13h				; Read sectors
  2260                              <1> 
  2261 000011C0 7308                <1> 	jnc .fat_done
  2262 000011C2 E87500              <1> 	call disk_reset_floppy		; Reset controller and try again
  2263 000011C5 73F4                <1> 	jnc .read_fat_loop		; Floppy reset OK?
  2264                              <1> 
  2265 000011C7 61                  <1> 	popa
  2266 000011C8 EB04                <1> 	jmp .read_failure		; Fatal double error
  2267                              <1> 
  2268                              <1> .fat_done:
  2269 000011CA 61                  <1> 	popa				; Restore registers from main loop
  2270                              <1> 
  2271 000011CB 61                  <1> 	popa				; And restore registers from start of system call
  2272 000011CC F8                  <1> 	clc
  2273 000011CD C3                  <1> 	ret
  2274                              <1> 
  2275                              <1> .read_failure:
  2276 000011CE 61                  <1> 	popa
  2277 000011CF F9                  <1> 	stc				; Set carry flag (for failure)
  2278 000011D0 C3                  <1> 	ret
  2279                              <1> 
  2280                              <1> 
  2281                              <1> ; --------------------------------------------------------------------------
  2282                              <1> ; disk_write_fat -- Save FAT contents from disk_buffer in RAM to disk
  2283                              <1> ; IN: FAT in disk_buffer; OUT: carry set if failure
  2284                              <1> 
  2285                              <1> disk_write_fat:
  2286 000011D1 60                  <1> 	pusha
  2287                              <1> 
  2288 000011D2 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  2289 000011D5 E87100              <1> 	call disk_convert_l2hts
  2290                              <1> 
  2291 000011D8 BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  2292 000011DB 8CDB                <1> 	mov bx, ds
  2293 000011DD 8EC3                <1> 	mov es, bx
  2294 000011DF 89F3                <1> 	mov bx, si
  2295                              <1> 
  2296 000011E1 B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  2297 000011E3 B009                <1> 	mov al, 9			; And write 9 of them for first FAT
  2298                              <1> 
  2299 000011E5 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2300 000011E6 CD13                <1> 	int 13h				; Write sectors
  2301                              <1> 
  2302 000011E8 7203                <1> 	jc .write_failure		; Fatal double error
  2303                              <1> 
  2304 000011EA 61                  <1> 	popa				; And restore from start of system call
  2305 000011EB F8                  <1> 	clc
  2306 000011EC C3                  <1> 	ret
  2307                              <1> 
  2308                              <1> .write_failure:
  2309 000011ED 61                  <1> 	popa
  2310 000011EE F9                  <1> 	stc				; Set carry flag (for failure)
  2311 000011EF C3                  <1> 	ret
  2312                              <1> 
  2313                              <1> 
  2314                              <1> ; --------------------------------------------------------------------------
  2315                              <1> ; disk_read_root_dir -- Get the root directory contents
  2316                              <1> ; IN: Nothing; OUT: root directory contents in disk_buffer, carry set if error
  2317                              <1> 
  2318                              <1> disk_read_root_dir:
  2319 000011F0 60                  <1> 	pusha
  2320                              <1> 
  2321 000011F1 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  2322 000011F4 E85200              <1> 	call disk_convert_l2hts
  2323                              <1> 
  2324 000011F7 BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  2325 000011FA 8CDB                <1> 	mov bx, ds
  2326 000011FC 8EC3                <1> 	mov es, bx
  2327 000011FE 89F3                <1> 	mov bx, si
  2328                              <1> 
  2329 00001200 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  2330 00001202 B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
  2331                              <1> 
  2332 00001204 60                  <1> 	pusha				; Prepare to enter loop
  2333                              <1> 
  2334                              <1> 
  2335                              <1> .read_root_dir_loop:
  2336 00001205 61                  <1> 	popa
  2337 00001206 60                  <1> 	pusha
  2338                              <1> 
  2339 00001207 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2340 00001208 CD13                <1> 	int 13h				; Read sectors
  2341                              <1> 
  2342 0000120A 7308                <1> 	jnc .root_dir_finished
  2343 0000120C E82B00              <1> 	call disk_reset_floppy		; Reset controller and try again
  2344 0000120F 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
  2345                              <1> 
  2346 00001211 61                  <1> 	popa
  2347 00001212 EB04                <1> 	jmp .read_failure		; Fatal double error
  2348                              <1> 
  2349                              <1> 
  2350                              <1> .root_dir_finished:
  2351 00001214 61                  <1> 	popa				; Restore registers from main loop
  2352                              <1> 
  2353 00001215 61                  <1> 	popa				; And restore from start of this system call
  2354 00001216 F8                  <1> 	clc				; Clear carry (for success)
  2355 00001217 C3                  <1> 	ret
  2356                              <1> 
  2357                              <1> .read_failure:
  2358 00001218 61                  <1> 	popa
  2359 00001219 F9                  <1> 	stc				; Set carry flag (for failure)
  2360 0000121A C3                  <1> 	ret
  2361                              <1> 
  2362                              <1> ; --------------------------------------------------------------------------
  2363                              <1> ; disk_write_root_dir -- Write root directory contents from disk_buffer to disk
  2364                              <1> ; IN: root dir copy in disk_buffer; OUT: carry set if error
  2365                              <1> 
  2366                              <1> disk_write_root_dir:
  2367 0000121B 60                  <1> 	pusha
  2368                              <1> 
  2369 0000121C B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  2370 0000121F E82700              <1> 	call disk_convert_l2hts
  2371                              <1> 
  2372 00001222 BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  2373 00001225 8CDB                <1> 	mov bx, ds
  2374 00001227 8EC3                <1> 	mov es, bx
  2375 00001229 89F3                <1> 	mov bx, si
  2376                              <1> 
  2377 0000122B B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  2378 0000122D B00E                <1> 	mov al, 14			; And write 14 of them (from 19 onwards)
  2379                              <1> 
  2380 0000122F F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2381 00001230 CD13                <1> 	int 13h				; Write sectors
  2382 00001232 7203                <1> 	jc .write_failure
  2383                              <1> 
  2384 00001234 61                  <1> 	popa				; And restore from start of this system call
  2385 00001235 F8                  <1> 	clc
  2386 00001236 C3                  <1> 	ret
  2387                              <1> 
  2388                              <1> .write_failure:
  2389 00001237 61                  <1> 	popa
  2390 00001238 F9                  <1> 	stc				; Set carry flag (for failure)
  2391 00001239 C3                  <1> 	ret
  2392                              <1> 
  2393                              <1> 
  2394                              <1> ; --------------------------------------------------------------------------
  2395                              <1> ; Reset floppy disk
  2396                              <1> 
  2397                              <1> disk_reset_floppy:
  2398 0000123A 50                  <1> 	push ax
  2399 0000123B 52                  <1> 	push dx
  2400 0000123C B80000              <1> 	mov ax, 0
  2401                              <1> ; ******************************************************************
  2402 0000123F 8A16[7812]          <1> 	mov dl, [bootdev]
  2403                              <1> ; ******************************************************************
  2404 00001243 F9                  <1> 	stc
  2405 00001244 CD13                <1> 	int 13h
  2406 00001246 5A                  <1> 	pop dx
  2407 00001247 58                  <1> 	pop ax
  2408 00001248 C3                  <1> 	ret
  2409                              <1> 
  2410                              <1> 
  2411                              <1> ; --------------------------------------------------------------------------
  2412                              <1> ; disk_convert_l2hts -- Calculate head, track and sector for int 13h
  2413                              <1> ; IN: logical sector in AX; OUT: correct registers for int 13h
  2414                              <1> 
  2415                              <1> disk_convert_l2hts:
  2416 00001249 53                  <1> 	push bx
  2417 0000124A 50                  <1> 	push ax
  2418                              <1> 
  2419 0000124B 89C3                <1> 	mov bx, ax			; Save logical sector
  2420                              <1> 
  2421 0000124D BA0000              <1> 	mov dx, 0			; First the sector
  2422 00001250 F736[7612]          <1> 	div word [SecsPerTrack]		; Sectors per track
  2423 00001254 80C201              <1> 	add dl, 01h			; Physical sectors start at 1
  2424 00001257 88D1                <1> 	mov cl, dl			; Sectors belong in CL for int 13h
  2425 00001259 89D8                <1> 	mov ax, bx
  2426                              <1> 
  2427 0000125B BA0000              <1> 	mov dx, 0			; Now calculate the head
  2428 0000125E F736[7612]          <1> 	div word [SecsPerTrack]		; Sectors per track
  2429 00001262 BA0000              <1> 	mov dx, 0
  2430 00001265 F736[7412]          <1> 	div word [Sides]		; Floppy sides
  2431 00001269 88D6                <1> 	mov dh, dl			; Head/side
  2432 0000126B 88C5                <1> 	mov ch, al			; Track
  2433                              <1> 	
  2434 0000126D 58                  <1> 	pop ax
  2435 0000126E 5B                  <1> 	pop bx
  2436                              <1> 
  2437 0000126F 8A16[7812]          <1> 	mov dl, [bootdev]		; Set correct device
  2438                              <1> 
  2439 00001273 C3                  <1> 	ret
  2440                              <1> 
  2441                              <1> 
  2442                              <1> 
  2443 00001274 0200                <1> 	Sides dw 2
  2444 00001276 1200                <1> 	SecsPerTrack dw 18
  2445                              <1> 	
  2446 00001278 00                  <1> 	bootdev db 0			; Boot device number
  2447                              <1> 
  2448                              <1> 
  2449                              <1> ; ==================================================================
  2450                              <1> 
  2451                              <1> 
   811                                  	%INCLUDE "drivers/keyboard.asm"
   812                              <1> ; ==================================================================
   813                              <1> ; KEYBOARD HANDLING ROUTINES
   814                              <1> ; ==================================================================
   815                              <1> 
   816                              <1> ; ------------------------------------------------------------------
   817                              <1> ; os_wait_for_key -- Waits for keypress and returns key
   818                              <1> ; Also handles the screensaver. TODO: move the screensaver code to "int.asm"
   819                              <1> ; IN: Nothing; OUT: AX = key pressed, other regs preserved
   820                              <1> 
   821                              <1> os_wait_for_key:
   822 00001279 60                  <1> 	pusha
   823                              <1> 	
   824                              <1> .try_again:
   825 0000127A B700                <1> 	mov bh, 0
   826 0000127C E88200              <1> 	call .screen_power
   827                              <1> 
   828                              <1> 	; Reset the screensaver tick
   829 0000127F 0FB606F2DE          <1> 	movzx ax, byte [57074]
   830 00001284 BB4404              <1> 	mov bx, 1092		; 18.2 Hz * 60 seconds
   831 00001287 F7E3                <1> 	mul bx
   832 00001289 A3[B448]            <1> 	mov [screensaver_timer], ax		; See "int.asm"
   833                              <1> 	
   834 0000128C C606[1A13]00        <1> 	mov byte [.scrn_active], 0	; Reset all the screensaver variables
   835                              <1> 
   836 00001291 A08200              <1> 	mov al, [0082h]				; Save the current screen state, for later
   837 00001294 A2[1713]            <1> 	mov [.gfx_state], al
   838 00001297 B403                <1> 	mov ah, 03h
   839 00001299 B700                <1> 	mov bh, 0
   840 0000129B CD10                <1> 	int 10h
   841 0000129D 890E[1813]          <1> 	mov [.orig_crsr], cx		; Get the shape of the cursor
   842                              <1> 	
   843                              <1> .loop:
   844 000012A1 F4                  <1> 	hlt							; Halt the CPU for 1/18.2 seconds, to save the CPU usage
   845 000012A2 E82C00              <1> 	call .screensaver
   846 000012A5 E87400              <1> 	call os_check_for_key
   847                              <1> 	
   848 000012A8 83F800              <1> 	cmp ax, 0
   849 000012AB 74F4                <1> 	je .loop
   850                              <1> 
   851 000012AD 60                  <1> 	pusha
   852 000012AE B80005              <1> 	mov ax, 0500h
   853 000012B1 CD10                <1> 	int 10h
   854                              <1> 	
   855 000012B3 A0[1713]            <1> 	mov al, [.gfx_state]
   856 000012B6 A28200              <1> 	mov [0082h], al
   857 000012B9 8B0E[1813]          <1> 	mov cx, [.orig_crsr]
   858 000012BD B401                <1> 	mov ah, 01h
   859 000012BF CD10                <1> 	int 10h
   860 000012C1 61                  <1> 	popa
   861                              <1> 	
   862 000012C2 803E[1A13]01        <1> 	cmp byte [.scrn_active], 1
   863 000012C7 74B1                <1> 	je .try_again
   864                              <1> 	
   865 000012C9 A3[1513]            <1> 	mov [.tmp_buf], ax
   866                              <1> 
   867 000012CC 61                  <1> 	popa
   868 000012CD A1[1513]            <1> 	mov ax, [.tmp_buf]
   869 000012D0 C3                  <1> 	ret
   870                              <1> 	
   871                              <1> .screensaver:
   872 000012D1 833E[B448]00        <1> 	cmp word [screensaver_timer], 0
   873 000012D6 7528                <1> 	jne .good
   874                              <1> 	
   875 000012D8 803EF2DE00          <1> 	cmp byte [57074], 0
   876 000012DD 7421                <1> 	je .good
   877                              <1> 	
   878 000012DF B40F                <1> 	mov ah, 0Fh
   879 000012E1 CD10                <1> 	int 10h
   880                              <1> 	
   881 000012E3 3C03                <1> 	cmp al, 3
   882 000012E5 7519                <1> 	jne .good
   883                              <1> 	
   884 000012E7 60                  <1> 	pusha
   885 000012E8 C606820001          <1> 	mov byte [0082h], 1
   886 000012ED B80105              <1> 	mov ax, 0501h
   887 000012F0 CD10                <1> 	int 10h
   888 000012F2 E8B005              <1> 	call os_hide_cursor
   889 000012F5 C606[1A13]01        <1> 	mov byte [.scrn_active], 1
   890                              <1> 
   891 000012FA B704                <1> 	mov bh, 4
   892 000012FC E80200              <1> 	call .screen_power
   893 000012FF 61                  <1> 	popa
   894                              <1> 
   895                              <1> .good:
   896 00001300 C3                  <1> 	ret
   897                              <1> 	
   898                              <1> .screen_power:
   899 00001301 3A3E[1B13]          <1> 	cmp bh, [.scrn_power]
   900 00001305 74F9                <1> 	je .good
   901                              <1> 
   902 00001307 60                  <1> 	pusha
   903 00001308 B8104F              <1> 	mov ax, 4F10h
   904 0000130B B301                <1> 	mov bl, 1
   905 0000130D 883E[1B13]          <1> 	mov [.scrn_power], bh
   906 00001311 CD10                <1> 	int 10h
   907 00001313 61                  <1> 	popa
   908 00001314 C3                  <1> 	ret
   909                              <1> 	
   910 00001315 0000                <1> 	.tmp_buf		dw 0
   911 00001317 00                  <1> 	.gfx_state		db 0
   912 00001318 0000                <1> 	.orig_crsr		dw 0
   913 0000131A 00                  <1> 	.scrn_active	db 0
   914 0000131B 00                  <1> 	.scrn_power		db 0
   915                              <1> 	
   916                              <1> ; ------------------------------------------------------------------
   917                              <1> ; os_check_for_key -- Scans keyboard buffer for input, but doesn't wait
   918                              <1> ; Also handles special keyboard shortcuts.
   919                              <1> ; IN: Nothing; OUT: AX = 0 if no key pressed, otherwise scan code
   920                              <1> 
   921                              <1> os_check_for_key:
   922 0000131C 60                  <1> 	pusha
   923                              <1> 
   924 0000131D B411                <1> 	mov ah, 11h			; BIOS call to check for key
   925                              <1> 	
   926 0000131F CD16                <1> 	int 16h
   927                              <1> 		
   928 00001321 740F                <1> 	jz .nokey			; If no key, skip to end
   929                              <1> 
   930 00001323 B410                <1> 	mov ah, 10h			; Otherwise get it from buffer
   931 00001325 CD16                <1> 	int 16h
   932                              <1> 
   933 00001327 E80E00              <1> 	call special_keys
   934                              <1> 
   935 0000132A A3[3613]            <1> 	mov [.tmp_buf], ax		; Store resulting keypress
   936                              <1> 
   937 0000132D 61                  <1> 	popa				; But restore all other regs
   938 0000132E A1[3613]            <1> 	mov ax, [.tmp_buf]
   939 00001331 C3                  <1> 	ret
   940                              <1> 
   941                              <1> .nokey:
   942 00001332 61                  <1> 	popa
   943                              <1> 	clr ax			; Zero result if no key pressed
    11 00001333 31C0                <2>  xor %1, %1
   944 00001335 C3                  <1> 	ret
   945                              <1> 
   946                              <1> 
   947 00001336 0000                <1> 	.tmp_buf	dw 0
   948                              <1> 
   949                              <1> 
   950                              <1> ; ==================================================================
   951                              <1> 
   952                              <1> ; Checks for special keys and performs their action.
   953                              <1> ; IN: AX = key
   954                              <1> ; OUT: nothing
   955                              <1> special_keys:
   956 00001338 60                  <1> 	pusha
   957 00001339 80FC69              <1> 	cmp ah, 105
   958 0000133C 0F844E00            <1> 	je near .disable_sound
   959 00001340 80FC6A              <1> 	cmp ah, 106
   960 00001343 0F844000            <1> 	je near .enable_sound
   961 00001347 80FC6B              <1> 	cmp ah, 107
   962 0000134A 0F842500            <1> 	je near .exit_app
   963 0000134E 80FC8B              <1> 	cmp ah, 139
   964 00001351 0F840200            <1> 	je near .intended_system_crash
   965 00001355 61                  <1> 	popa
   966 00001356 C3                  <1> 	ret
   967                              <1> 	
   968                              <1> .intended_system_crash:
   969 00001357 B8[5D13]            <1> 	mov ax, .crash_msg
   970 0000135A E84202              <1> 	call os_fatal_error
   971                              <1> 	
   972 0000135D 496E74656E64656420- <1> 	.crash_msg		db 'Intended system crash', 0
   972 00001366 73797374656D206372- <1>
   972 0000136F 61736800            <1>
   973                              <1> 	
   974                              <1> .exit_app:
   975 00001373 803E[B308]00        <1> 	cmp byte [app_running], 0
   976 00001378 0F840900            <1> 	je near .no_exit
   977                              <1> 	
   978 0000137C 61                  <1> 	popa
   979                              <1> 	
   980 0000137D 8B26[B108]          <1> 	mov sp, [origstack]
   981 00001381 83EC02              <1> 	sub sp, 2
   982                              <1> 	
   983 00001384 C3                  <1> 	ret
   984                              <1> 	
   985                              <1> .no_exit:
   986 00001385 61                  <1> 	popa
   987 00001386 C3                  <1> 	ret
   988                              <1> 		
   989                              <1> .enable_sound:
   990 00001387 C606830001          <1> 	mov byte [0083h], 1
   991 0000138C EB08                <1> 	jmp .display_speaker
   992                              <1> 	
   993                              <1> .disable_sound:
   994 0000138E C606830000          <1> 	mov byte [0083h], 0
   995 00001393 E8D312              <1> 	call os_speaker_off
   996                              <1> 
   997                              <1> .display_speaker:
   998 00001396 803E820001          <1> 	cmp byte [0082h], 1
   999 0000139B 741E                <1> 	je .no_display_spkr
  1000                              <1> 
  1001 0000139D E8CE04              <1> 	call os_get_cursor_pos
  1002 000013A0 52                  <1> 	push dx
  1003 000013A1 BA4F00              <1> 	mov dx, 79			; Print the little speaker icon
  1004 000013A4 E8BE04              <1> 	call os_move_cursor
  1005                              <1> 	
  1006 000013A7 B8170E              <1> 	mov ax, 0E17h
  1007 000013AA B700                <1> 	mov bh, 0
  1008 000013AC 803E830000          <1> 	cmp byte [0083h], 0
  1009 000013B1 7402                <1> 	je .no_crossed_spkr
  1010                              <1> 	
  1011 000013B3 FEC8                <1> 	dec al
  1012                              <1> 	
  1013                              <1> .no_crossed_spkr:
  1014 000013B5 CD10                <1> 	int 10h
  1015 000013B7 5A                  <1> 	pop dx
  1016 000013B8 E8AA04              <1> 	call os_move_cursor
  1017                              <1> 	
  1018                              <1> .no_display_spkr:
  1019 000013BB 61                  <1> 	popa
  1020 000013BC C3                  <1> 	ret
  1021                              <1> 	
  1022                              <1> ; ==================================================================
  1023                              <1> 
   812                                  	%INCLUDE "drivers/math.asm"
   813                              <1> ; ==================================================================
   814                              <1> ; MATH ROUTINES
   815                              <1> ; ==================================================================
   816                              <1> 
   817                              <1> ; ------------------------------------------------------------------
   818                              <1> ; os_seed_random -- Seed the random number generator based on the current state of registers and time
   819                              <1> ; IN: every register; OUT: Nothing (registers preserved)
   820                              <1> 
   821                              <1> os_seed_random:
   822 000013BD 60                  <1> 	pusha
   823                              <1> 
   824 000013BE B402                <1> 	mov ah, 02h
   825 000013C0 CD1A                <1> 	int 1Ah
   826                              <1> 	
   827 000013C2 31D8                <1> 	xor ax, bx
   828 000013C4 01C8                <1> 	add ax, cx
   829 000013C6 31D0                <1> 	xor ax, dx
   830 000013C8 01F0                <1> 	add ax, si
   831 000013CA 31F8                <1> 	xor ax, di
   832 000013CC 01E0                <1> 	add ax, sp
   833 000013CE 31E8                <1> 	xor ax, bp
   834 000013D0 05ADDE              <1> 	add ax, 0xDEAD
   835 000013D3 35EFBE              <1> 	xor ax, 0xBEEF
   836                              <1> 	
   837 000013D6 A3[DB13]            <1> 	mov [os_random_seed], ax	; Store the data
   838 000013D9 61                  <1> 	popa
   839 000013DA C3                  <1> 	ret
   840                              <1> 
   841                              <1> 
   842 000013DB 0000                <1> 	os_random_seed	dw 0
   843                              <1> 
   844                              <1> 
   845                              <1> ; ------------------------------------------------------------------
   846                              <1> ; os_get_random -- Return a random integer between low and high (inclusive)
   847                              <1> ; IN: AX = low integer, BX = high integer
   848                              <1> ; OUT: CX = random integer
   849                              <1> 
   850                              <1> os_get_random:
   851 000013DD 52                  <1> 	push dx
   852 000013DE 53                  <1> 	push bx
   853 000013DF 50                  <1> 	push ax
   854                              <1> 
   855 000013E0 29C3                <1> 	sub bx, ax			; We want a number between 0 and (high-low)
   856 000013E2 E80D00              <1> 	call .generate_random
   857 000013E5 89DA                <1> 	mov dx, bx
   858 000013E7 42                  <1> 	inc dx
   859 000013E8 F7E2                <1> 	mul dx
   860 000013EA 89D1                <1> 	mov cx, dx
   861                              <1> 
   862 000013EC 58                  <1> 	pop ax
   863 000013ED 5B                  <1> 	pop bx
   864 000013EE 5A                  <1> 	pop dx
   865 000013EF 01C1                <1> 	add cx, ax			; Add the low offset back
   866 000013F1 C3                  <1> 	ret
   867                              <1> 
   868                              <1> 
   869                              <1> .generate_random:
   870 000013F2 52                  <1> 	push dx
   871 000013F3 53                  <1> 	push bx
   872                              <1> 
   873 000013F4 A1[DB13]            <1> 	mov ax, [os_random_seed]
   874 000013F7 BA8373              <1> 	mov dx, 0x7383			; The magic number (random.org)
   875 000013FA F7E2                <1> 	mul dx				; DX:AX = AX * DX
   876 000013FC A3[DB13]            <1> 	mov [os_random_seed], ax
   877                              <1> 
   878 000013FF 5B                  <1> 	pop bx
   879 00001400 5A                  <1>  	pop dx
   880 00001401 C3                  <1> 	ret
   881                              <1> 
   882                              <1> 
   883                              <1> ; ------------------------------------------------------------------
   884                              <1> ; os_bcd_to_int -- Converts a binary coded decimal number to an integer
   885                              <1> ; IN: AL = BCD number; OUT: AX = integer value
   886                              <1> 
   887                              <1> os_bcd_to_int:
   888 00001402 60                  <1> 	pusha
   889                              <1> 
   890 00001403 88C3                <1> 	mov bl, al			; Store entire number for now
   891                              <1> 
   892 00001405 83E00F              <1> 	and ax, 0Fh			; Zero-out high bits
   893 00001408 89C1                <1> 	mov cx, ax			; CH/CL = lower BCD number, zero extended
   894                              <1> 
   895 0000140A C0EB04              <1> 	shr bl, 4			; Move higher BCD number into lower bits, zero fill msb
   896 0000140D B00A                <1> 	mov al, 10
   897 0000140F F6E3                <1> 	mul bl				; AX = 10 * BL
   898                              <1> 
   899 00001411 01C8                <1> 	add ax, cx			; Add lower BCD to 10*higher
   900 00001413 A3[1B14]            <1> 	mov [.tmp], ax
   901                              <1> 
   902 00001416 61                  <1> 	popa
   903 00001417 A1[1B14]            <1> 	mov ax, [.tmp]			; And return it in AX!
   904 0000141A C3                  <1> 	ret
   905                              <1> 
   906                              <1> 
   907 0000141B 0000                <1> 	.tmp	dw 0
   908                              <1> 
   909                              <1> 	
   910                              <1> ; ------------------------------------------------------------------
   911                              <1> ; os_int_to_bcd -- Converts an integer to a binary coded decimal number
   912                              <1> ; IN: AL = integer value; OUT: AL = BCD number
   913                              <1> 
   914                              <1> os_int_to_bcd:
   915 0000141D 60                  <1> 	pusha
   916 0000141E 0FB6C0              <1> 	movzx ax, al
   917 00001421 31D2                <1> 	xor dx, dx
   918                              <1> 	
   919 00001423 BB0A00              <1> 	mov bx, 10
   920 00001426 F7F3                <1> 	div bx
   921                              <1> 	
   922 00001428 C0E004              <1> 	shl al, 4
   923 0000142B 00C2                <1> 	add dl, al
   924                              <1> 	
   925 0000142D 8816[3614]          <1> 	mov [.tmp], dl
   926 00001431 61                  <1> 	popa
   927 00001432 A0[3614]            <1> 	mov al, [.tmp]
   928 00001435 C3                  <1> 	ret
   929                              <1> 
   930 00001436 00                  <1> 	.tmp	db 0
   931                              <1> 
   932                              <1> 
   933                              <1> ; Calculates EAX^EBX.
   934                              <1> ; IN: EAX^EBX = input
   935                              <1> ; OUT: EAX = result
   936                              <1> 
   937                              <1> os_math_power:
   938 00001437 6660                <1> 	pushad
   939 00001439 6683FB01            <1> 	cmp ebx, 1
   940 0000143D 0F841900            <1> 	je near .power_end
   941 00001441 6683FB00            <1> 	cmp ebx, 0
   942 00001445 0F841F00            <1> 	je near .zero
   943 00001449 6689D9              <1> 	mov ecx, ebx				; Prepare the data
   944 0000144C 6689C3              <1> 	mov ebx, eax
   945                              <1> .power_loop:
   946 0000144F 66F7E3              <1> 	mul ebx
   947 00001452 6649                <1> 	dec ecx
   948 00001454 6683F901            <1> 	cmp ecx, 1
   949 00001458 7FF5                <1> 	jnle .power_loop
   950                              <1> .power_end:
   951 0000145A 66A3[7414]          <1> 	mov [.tmp_dword], eax
   952 0000145E 6661                <1> 	popad
   953 00001460 66A1[7414]          <1> 	mov eax, [.tmp_dword]
   954 00001464 6631D2              <1> 	xor edx, edx
   955 00001467 C3                  <1> 	ret
   956                              <1> .zero:
   957 00001468 6661                <1> 	popad
   958 0000146A 66B801000000        <1> 	mov eax, 1
   959 00001470 6631D2              <1> 	xor edx, edx
   960 00001473 C3                  <1> 	ret
   961                              <1> 	
   962 00001474 00000000            <1> 	.tmp_dword		dd 0
   963 00001478 00000000            <1> 	.tmp_dword2		dd 0
   964                              <1> 	
   965                              <1> ; Calculates the EBX root of EAX.
   966                              <1> ; IN: EAX = input, EBX = root
   967                              <1> ; OUT: EAX(EDX = 0) = result; EAX to EDX = range
   968                              <1> 
   969                              <1> os_math_root:
   970 0000147C 6660                <1> 	pushad
   971 0000147E 6689C1              <1> 	mov ecx, eax				; Prepare the data
   972 00001481 66BE02000000        <1> 	mov esi, 2
   973                              <1> .root_loop:
   974 00001487 6689F0              <1> 	mov eax, esi
   975 0000148A E8AAFF              <1> 	call os_math_power
   976 0000148D 6639C8              <1> 	cmp eax, ecx
   977 00001490 0F840800            <1> 	je near .root_exact
   978 00001494 0F8F1300            <1> 	jg near .root_range
   979 00001498 6646                <1> 	inc esi
   980 0000149A EBEB                <1> 	jmp .root_loop
   981                              <1> .root_exact:
   982 0000149C 668936[C314]        <1> 	mov [.tmp_dword], esi
   983 000014A1 6661                <1> 	popad
   984 000014A3 66A1[C314]          <1> 	mov eax, [.tmp_dword]
   985 000014A7 6631D2              <1> 	xor edx, edx
   986 000014AA C3                  <1> 	ret
   987                              <1> .root_range:
   988 000014AB 668936[C714]        <1> 	mov [.tmp_dword2], esi
   989 000014B0 664E                <1> 	dec esi
   990 000014B2 668936[C314]        <1> 	mov [.tmp_dword], esi
   991 000014B7 6661                <1> 	popad
   992 000014B9 66A1[C314]          <1> 	mov eax, [.tmp_dword]
   993 000014BD 668B16[C714]        <1> 	mov edx, [.tmp_dword2]
   994 000014C2 C3                  <1> 	ret
   995                              <1> 	
   996 000014C3 00000000            <1> 	.tmp_dword		dd 0
   997 000014C7 00000000            <1> 	.tmp_dword2		dd 0
   998                              <1> 
   999                              <1> ; ==================================================================
   813                                  	%INCLUDE "drivers/misc.asm"
   814                              <1> ; ==================================================================
   815                              <1> ; MISCELLANEOUS ROUTINES
   816                              <1> ; ==================================================================
   817                              <1> 
   818                              <1> ; ------------------------------------------------------------------
   819                              <1> ; os_pause -- Delay execution for specified 110ms chunks
   820                              <1> ; IN: AX = amount of ticks to wait
   821                              <1> 
   822                              <1> os_pause:
   823 000014CB 60                  <1> 	pusha
   824 000014CC 83F800              <1> 	cmp ax, 0
   825 000014CF 741F                <1> 	je .time_up			; If delay = 0 then bail out
   826                              <1> 
   827 000014D1 C706[0715]0000      <1> 	mov word [.counter_var], 0		; Zero the counter variable
   828                              <1> 
   829 000014D7 A3[0515]            <1> 	mov [.orig_req_delay], ax	; Save it
   830                              <1> 
   831 000014DA B400                <1> 	mov ah, 0
   832 000014DC E8D901              <1> 	call os_int_1Ah				; Get tick count	
   833                              <1> 
   834 000014DF 8916[0915]          <1> 	mov [.prev_tick_count], dx	; Save it for later comparison
   835                              <1> 
   836                              <1> .checkloop:
   837 000014E3 B400                <1> 	mov ah,0
   838 000014E5 E8D001              <1> 	call os_int_1Ah				; Get tick count again
   839                              <1> 
   840 000014E8 3916[0915]          <1> 	cmp [.prev_tick_count], dx	; Compare with previous tick count
   841                              <1> 
   842 000014EC 7504                <1> 	jne .up_date			; If it's changed check it
   843 000014EE EBF3                <1> 	jmp .checkloop			; Otherwise wait some more
   844                              <1> 
   845                              <1> .time_up:
   846 000014F0 61                  <1> 	popa
   847 000014F1 C3                  <1> 	ret
   848                              <1> 
   849                              <1> .up_date:
   850 000014F2 FF06[0715]          <1> 	inc word [.counter_var]		; Inc counter_var
   851 000014F6 A1[0715]            <1> 	mov ax, [.counter_var]
   852                              <1> 	
   853 000014F9 3B06[0515]          <1> 	cmp ax, [.orig_req_delay]	; Is counter_var = required delay?
   854 000014FD 7DF1                <1> 	jge .time_up			; Yes, so bail out
   855                              <1> 
   856 000014FF 8916[0915]          <1> 	mov [.prev_tick_count], dx	; No, so update .prev_tick_count 
   857                              <1> 
   858 00001503 EBDE                <1> 	jmp .checkloop			; And go wait some more
   859                              <1> 
   860                              <1> 
   861 00001505 0000                <1> 	.orig_req_delay		dw	0
   862 00001507 0000                <1> 	.counter_var		dw	0
   863 00001509 0000                <1> 	.prev_tick_count	dw	0
   864                              <1> 
   865                              <1> ; ------------------------------------------------------------------
   866                              <1> ; os_clear_registers -- Clear all registers
   867                              <1> ; IN: Nothing; OUT: Clear registers
   868                              <1> 
   869                              <1> os_clear_registers:
   870 0000150B 6631C0              <1> 	xor eax, eax
   871 0000150E 6631DB              <1> 	xor ebx, ebx
   872 00001511 6631C9              <1> 	xor ecx, ecx
   873 00001514 6631D2              <1> 	xor edx, edx
   874 00001517 6631F6              <1> 	xor esi, esi
   875 0000151A 6631FF              <1> 	xor edi, edi
   876 0000151D C3                  <1> 	ret
   877                              <1> 
   878                              <1> os_illegal_call:
   879 0000151E B8[2315]            <1> 	mov ax, .msg
   880 00001521 EB7C                <1> 	jmp os_fatal_error
   881                              <1> 	
   882 00001523 43616C6C6564206120- <1> 	.msg db 'Called a non-existent system function', 0
   882 0000152C 6E6F6E2D6578697374- <1>
   882 00001535 656E74207379737465- <1>
   882 0000153E 6D2066756E6374696F- <1>
   882 00001547 6E00                <1>
   883                              <1> 	
   884                              <1> os_update_clock:
   885 00001549 60                  <1> 	pusha
   886 0000154A 803E820001          <1> 	cmp byte [0082h], 1
   887 0000154F 0F843B00            <1> 	je near .update_time_end
   888                              <1> 	
   889 00001553 B402                <1> 	mov ah, 02h			; Get the time
   890 00001555 E86001              <1> 	call os_int_1Ah
   891 00001558 3B0E[9C15]          <1> 	cmp cx, [.tmp_time]
   892 0000155C 0F842E00            <1> 	je near .update_time_end
   893 00001560 890E[9C15]          <1> 	mov [.tmp_time], cx
   894                              <1> 	
   895 00001564 E80703              <1> 	call os_get_cursor_pos
   896 00001567 52                  <1> 	push dx
   897                              <1> 	
   898 00001568 BB[9015]            <1> 	mov bx, .tmp_buffer
   899 0000156B E88416              <1> 	call os_get_date_string
   900                              <1> 	
   901 0000156E BA4500              <1> 	mov dx, 69			; Display date
   902 00001571 E8F102              <1> 	call os_move_cursor
   903                              <1> 
   904 00001574 89DE                <1> 	mov si, bx
   905 00001576 E87B02              <1> 	call os_print_string
   906                              <1> 	
   907 00001579 BB[9015]            <1> 	mov bx, .tmp_buffer
   908 0000157C E82C16              <1> 	call os_get_time_string
   909                              <1> 
   910 0000157F BA3F00              <1> 	mov dx, 63			; Display time
   911 00001582 E8E002              <1> 	call os_move_cursor
   912 00001585 89DE                <1> 	mov si, bx
   913 00001587 E86A02              <1> 	call os_print_string
   914                              <1> 	
   915 0000158A 5A                  <1> 	pop dx
   916 0000158B E8D702              <1> 	call os_move_cursor
   917                              <1> 	
   918                              <1> .update_time_end:
   919 0000158E 61                  <1> 	popa
   920 0000158F C3                  <1> 	ret
   921                              <1> 	
   922 00001590 00<rep Ch>          <1> 	.tmp_buffer		times 12 db 0
   923 0000159C 0000                <1> 	.tmp_time		dw 0
   924 0000159E 00                  <1> 	.tmp_hours		db 0
   925                              <1> 
   926                              <1> ; ------------------------------------------------------------------
   927                              <1> ; os_fatal_error -- Display error message and halt execution
   928                              <1> ; IN: AX = error message string location
   929                              <1> 
   930                              <1> os_fatal_error:
   931 0000159F A3[9716]            <1> 	mov [.ax], ax			; Store string location for now, ...
   932 000015A2 E8AA02              <1> 	call os_clear_screen
   933                              <1> 	
   934                              <1> .main_screen:
   935 000015A5 8CC8                <1> 	mov ax, cs
   936 000015A7 8ED8                <1> 	mov ds, ax
   937 000015A9 8EC0                <1> 	mov es, ax
   938                              <1> 
   939 000015AB B80300              <1> 	mov ax, 3
   940 000015AE CD10                <1> 	int 10h
   941                              <1> 	
   942 000015B0 B80310              <1> 	mov ax, 1003h				; Set text output with certain attributes
   943 000015B3 31DB                <1> 	xor bx, bx					; to be bright, and not blinking
   944 000015B5 CD10                <1> 	int 10h	
   945                              <1> 
   946 000015B7 B8[5316]            <1> 	mov ax, .title_msg
   947 000015BA BB[6716]            <1> 	mov bx, .footer_msg
   948 000015BD B94F00              <1> 	mov cx, 01001111b
   949 000015C0 E8AD08              <1> 	call os_draw_background
   950 000015C3 E8200E              <1> 	call os_reset_font
   951                              <1> 	
   952 000015C6 BA0002              <1> 	mov dx, 2 * 256
   953 000015C9 E89902              <1> 	call os_move_cursor
   954 000015CC BE[B408]            <1> 	mov si, bomblogo
   955 000015CF E8520E              <1> 	call os_draw_icon
   956                              <1> 	
   957 000015D2 BA2302              <1> 	mov dx, 2 * 256 + 35
   958 000015D5 E88D02              <1> 	call os_move_cursor
   959                              <1> 	
   960 000015D8 BE[6816]            <1> 	mov si, .msg0
   961 000015DB E81602              <1> 	call os_print_string
   962                              <1> 	
   963 000015DE BA2303              <1> 	mov dx, 3 * 256 + 35
   964 000015E1 E88102              <1> 	call os_move_cursor
   965                              <1> 	
   966 000015E4 B82A0A              <1> 	mov ax, 0A2Ah					; Write a 43-character long asterisk-type line
   967 000015E7 B700                <1> 	mov bh, 0
   968 000015E9 B92B00              <1> 	mov cx, 43
   969 000015EC CD10                <1> 	int 10h
   970                              <1> 	
   971 000015EE BA2305              <1> 	mov dx, 5 * 256 + 35
   972 000015F1 E87102              <1> 	call os_move_cursor
   973 000015F4 BE[8F16]            <1> 	mov si, .msg3
   974 000015F7 E8FA01              <1> 	call os_print_string
   975                              <1> 
   976 000015FA 8B36[9716]          <1> 	mov si, [.ax]
   977 000015FE E8F301              <1> 	call os_print_string
   978                              <1> 
   979 00001601 E8A102              <1> 	call os_hide_cursor
   980                              <1> 	
   981 00001604 5B                  <1> 	pop bx
   982 00001605 58                  <1> 	pop ax
   983                              <1> 	
   984                              <1> 	mov16 dx, 35, 7
    15 00001606 BA2307              <2>  mov %1, (%2 + %3 * 256)
   985 00001609 E85902              <1> 	call os_move_cursor
   986                              <1> 	
   987 0000160C BE[3216]            <1> 	mov si, .msg
   988 0000160F E8E201              <1> 	call os_print_string
   989                              <1> 	
   990 00001612 E88A0B              <1> 	call os_print_4hex
   991                              <1> 	
   992 00001615 B03A                <1> 	mov al, ':'
   993 00001617 E8C601              <1> 	call os_putchar
   994                              <1> 	
   995 0000161A 89D8                <1> 	mov ax, bx
   996 0000161C E8800B              <1> 	call os_print_4hex
   997                              <1> 	
   998                              <1> 	mov16 dx, 35, 8
    15 0000161F BA2308              <2>  mov %1, (%2 + %3 * 256)
   999 00001622 E84002              <1> 	call os_move_cursor
  1000                              <1> 	
  1001 00001625 BE[4316]            <1> 	mov si, .msg1
  1002 00001628 E8C901              <1> 	call os_print_string
  1003                              <1> 	
  1004 0000162B 89E0                <1> 	mov ax, sp
  1005 0000162D E86F0B              <1> 	call os_print_4hex
  1006                              <1> 	
  1007 00001630 FA                  <1> 	cli
  1008 00001631 F4                  <1> 	hlt
  1009                              <1> 	
  1010 00001632 4372617368206C6F63- <1> 	.msg 			db 'Crash location: ', 0
  1010 0000163B 6174696F6E3A2000    <1>
  1011 00001643 537461636B20706F69- <1> 	.msg1			db 'Stack pointer: ', 0
  1011 0000164C 6E7465723A2000      <1>
  1012                              <1> 	
  1013 00001653 43726570654F532053- <1> 	.title_msg		db 'CrepeOS System Error'
  1013 0000165C 797374656D20457272- <1>
  1013 00001665 6F72                <1>
  1014 00001667 00                  <1> 	.footer_msg		db 0
  1015                              <1> 	
  1016 00001668 43726570654F532068- <1> 	.msg0			db 'CrepeOS has encountered a fatal error.', 0
  1016 00001671 617320656E636F756E- <1>
  1016 0000167A 746572656420612066- <1>
  1016 00001683 6174616C206572726F- <1>
  1016 0000168C 722E00              <1>
  1017 0000168F 4572726F723A2000    <1> 	.msg3			db 'Error: ', 0
  1018                              <1> 
  1019 00001697 0000                <1> 	.ax				dw 0
  1020                              <1> 
  1021                              <1> ; Gets the amount of system RAM.
  1022                              <1> ; IN: nothing
  1023                              <1> ; OUT: AX = conventional memory(kB), EBX = high memory(kB)
  1024                              <1> os_get_memory:
  1025 00001699 60                  <1> 	pusha
  1026 0000169A 31C9                <1> 	xor cx, cx
  1027 0000169C CD12                <1> 	int 12h					; Get the conventional memory size...
  1028 0000169E A3[B116]            <1> 	mov [.conv_mem], ax		; ...and store it
  1029                              <1> 	
  1030 000016A1 B488                <1> 	mov ah, 88h				; Also get the high memory (>1MB)...
  1031 000016A3 CD15                <1> 	int 15h
  1032 000016A5 A3[B316]            <1> 	mov [.high_mem], ax		; ...and store it too
  1033 000016A8 61                  <1> 	popa
  1034 000016A9 A1[B116]            <1> 	mov ax, [.conv_mem]
  1035 000016AC 8B1E[B316]          <1> 	mov bx, [.high_mem]
  1036 000016B0 C3                  <1> 	ret
  1037                              <1> 
  1038 000016B1 0000                <1> 	.conv_mem	dw 0
  1039 000016B3 0000                <1> 	.high_mem	dw 0
  1040                              <1> 
  1041                              <1> ; Calls a system function from a far location.
  1042                              <1> ; IN: BP = System function number (8000h, 8003h...)
  1043                              <1> ; OUT: nothing
  1044                              <1> os_far_call:
  1045 000016B5 FFD5                <1> 	call bp
  1046 000016B7 CB                  <1> 	retf
  1047                              <1> 	
  1048                              <1> ; Serves as a middle-man between the INT 1Ah call and the kernel/apps (used for timezones).
  1049                              <1> ; IN/OUT: same as int 1Ah
  1050                              <1> os_int_1Ah:
  1051 000016B8 60                  <1> 	pusha
  1052                              <1> 
  1053 000016B9 80FC02              <1> 	cmp ah, 2		; Read system time
  1054 000016BC 7416                <1> 	je .read_time
  1055                              <1> 	
  1056 000016BE 80FC04              <1> 	cmp ah, 4		; Read system date
  1057 000016C1 7404                <1> 	je .read_date
  1058                              <1> 	
  1059 000016C3 61                  <1> 	popa
  1060 000016C4 CD1A                <1> 	int 1Ah
  1061 000016C6 C3                  <1> 	ret
  1062                              <1> 	
  1063                              <1> .read_date:
  1064 000016C7 E81700              <1> 	call .update_time
  1065 000016CA 61                  <1> 	popa
  1066 000016CB 8B16[A517]          <1> 	mov dx, [.days]
  1067 000016CF 8B0E[A717]          <1> 	mov cx, [.years]
  1068 000016D3 C3                  <1> 	ret
  1069                              <1> 	
  1070                              <1> .read_time:
  1071 000016D4 E80A00              <1> 	call .update_time
  1072                              <1> 	
  1073 000016D7 61                  <1> 	popa
  1074 000016D8 8A36[A217]          <1> 	mov dh, [.seconds]
  1075 000016DC 8B0E[A317]          <1> 	mov cx, [.minutes]
  1076                              <1> 	
  1077 000016E0 C3                  <1> 	ret
  1078                              <1> 
  1079                              <1> .update_time:
  1080 000016E1 B404                <1> 	mov ah, 4
  1081 000016E3 CD1A                <1> 	int 1Ah
  1082 000016E5 8916[A517]          <1> 	mov [.days], dx
  1083 000016E9 890E[A717]          <1> 	mov [.years], cx
  1084                              <1> 	
  1085 000016ED B402                <1> 	mov ah, 2
  1086 000016EF CD1A                <1> 	int 1Ah
  1087                              <1> 
  1088 000016F1 8836[A217]          <1> 	mov [.seconds], dh
  1089 000016F5 890E[A317]          <1> 	mov [.minutes], cx
  1090                              <1> 	
  1091                              <1> 	; Convert all of these values from BCD to integers
  1092                              <1> 	
  1093 000016F9 B90700              <1> 	mov cx, 7
  1094 000016FC BE[A217]            <1> 	mov si, .seconds
  1095 000016FF 89F7                <1> 	mov di, si
  1096                              <1> 	
  1097                              <1> .loop:
  1098 00001701 AC                  <1> 	lodsb
  1099 00001702 E8FDFC              <1> 	call os_bcd_to_int
  1100 00001705 AA                  <1> 	stosb
  1101                              <1> 	
  1102 00001706 E2F9                <1> 	loop .loop
  1103                              <1> 	
  1104                              <1> 	; Calculate the time with the time offset
  1105                              <1> 	
  1106 00001708 A1F9DE              <1> 	mov ax, [57081]
  1107 0000170B A90080              <1> 	test ax, 8000h
  1108 0000170E 7541                <1> 	jnz .subtract
  1109                              <1> 	
  1110 00001710 31D2                <1> 	xor dx, dx
  1111 00001712 BB3C00              <1> 	mov bx, 60
  1112 00001715 F7F3                <1> 	div bx
  1113                              <1> 	
  1114                              <1> 	; DX = value to add to minutes
  1115                              <1> 	; AX = value to add to hours
  1116                              <1> 	
  1117 00001717 0016[A317]          <1> 	add [.minutes], dl
  1118 0000171B 803E[A317]3C        <1> 	cmp byte [.minutes], 60
  1119 00001720 7C19                <1> 	jl .add_minutes_ok
  1120                              <1> 	
  1121 00001722 802E[A317]3C        <1> 	sub byte [.minutes], 60
  1122 00001727 FE06[A417]          <1> 	inc byte [.hours]
  1123 0000172B 803E[A417]18        <1> 	cmp byte [.hours], 24
  1124 00001730 7C09                <1> 	jl .add_minutes_ok
  1125                              <1> 	
  1126 00001732 802E[A417]18        <1> 	sub byte [.hours], 24
  1127 00001737 FE06[A517]          <1> 	inc byte [.days]
  1128                              <1> 	
  1129                              <1> 	; At this point I don't care
  1130                              <1> 	
  1131                              <1> .add_minutes_ok:
  1132 0000173B 0006[A417]          <1> 	add [.hours], al
  1133 0000173F 803E[A417]18        <1> 	cmp byte [.hours], 24
  1134 00001744 7C4C                <1> 	jl .encodeandexit
  1135                              <1> 	
  1136 00001746 802E[A417]18        <1> 	sub byte [.hours], 24
  1137 0000174B FE06[A517]          <1> 	inc byte [.days]
  1138                              <1> 	
  1139 0000174F EB41                <1> 	jmp .encodeandexit
  1140                              <1> 	
  1141                              <1> .subtract:
  1142 00001751 F7D8                <1> 	neg ax
  1143                              <1> 	
  1144 00001753 31D2                <1> 	xor dx, dx
  1145 00001755 BB3C00              <1> 	mov bx, 60
  1146 00001758 F7F3                <1> 	div bx
  1147                              <1> 	
  1148                              <1> 	; DX = value to subtract from minutes
  1149                              <1> 	; AX = value to subtract from hours
  1150                              <1> 
  1151 0000175A 2816[A317]          <1> 	sub [.minutes], dl
  1152 0000175E 803E[A317]00        <1> 	cmp byte [.minutes], 0
  1153 00001763 7D19                <1> 	jge .sub_minutes_ok
  1154                              <1> 	
  1155                              <1> 	
  1156 00001765 8006[A317]3C        <1> 	add byte [.minutes], 60
  1157 0000176A FE0E[A417]          <1> 	dec byte [.hours]
  1158 0000176E 803E[A417]00        <1> 	cmp byte [.hours], 0
  1159 00001773 7D09                <1> 	jge .sub_minutes_ok
  1160                              <1> 	
  1161 00001775 8006[A417]18        <1> 	add byte [.hours], 24
  1162 0000177A FE0E[A517]          <1> 	dec byte [.days]
  1163                              <1> 	
  1164                              <1> 	; At this point I don't care
  1165                              <1> 	
  1166                              <1> .sub_minutes_ok:
  1167 0000177E 2806[A417]          <1> 	sub [.hours], al
  1168 00001782 803E[A417]00        <1> 	cmp byte [.hours], 0
  1169 00001787 7D09                <1> 	jge .encodeandexit
  1170                              <1> 	
  1171 00001789 8006[A417]18        <1> 	add byte [.hours], 24
  1172 0000178E FE0E[A517]          <1> 	dec byte [.days]
  1173                              <1> 	
  1174                              <1> .encodeandexit:
  1175 00001792 B90700              <1> 	mov cx, 7
  1176 00001795 BE[A217]            <1> 	mov si, .seconds
  1177 00001798 89F7                <1> 	mov di, si
  1178                              <1> 	
  1179                              <1> .encode_loop:
  1180 0000179A AC                  <1> 	lodsb
  1181 0000179B E87FFC              <1> 	call os_int_to_bcd
  1182 0000179E AA                  <1> 	stosb
  1183 0000179F E2F9                <1> 	loop .encode_loop
  1184                              <1> 
  1185 000017A1 C3                  <1> 	ret
  1186                              <1> 	
  1187                              <1> 	
  1188 000017A2 00                  <1> 	.seconds	db 0
  1189 000017A3 00                  <1> 	.minutes	db 0
  1190 000017A4 00                  <1> 	.hours		db 0
  1191 000017A5 00                  <1> 	.days		db 0
  1192 000017A6 00                  <1> 	.months		db 0
  1193 000017A7 00                  <1> 	.years		db 0
  1194 000017A8 00                  <1> 	.centuries	db 0
  1195                              <1> 	
  1196                              <1> ; ==================================================================
  1197                              <1> 
   814                                  	%INCLUDE "drivers/ports.asm"
   815                              <1> ; ==================================================================
   816                              <1> ; PORT INPUT AND OUTPUT ROUTINES
   817                              <1> ; ==================================================================
   818                              <1> 
   819                              <1> ; ------------------------------------------------------------------
   820                              <1> ; os_serial_port_enable -- Set up the serial port for transmitting data
   821                              <1> ; IN: AX = 0 for normal mode (9600 baud), or 1 for slow mode (1200 baud)
   822                              <1> 
   823                              <1> os_serial_port_enable:
   824 000017A9 60                  <1> 	pusha
   825                              <1> 
   826                              <1> 	clr dx			; Configure serial port 1
    11 000017AA 31D2                <2>  xor %1, %1
   827 000017AC 83F801              <1> 	cmp ax, 1
   828 000017AF 7405                <1> 	je .slow_mode
   829                              <1> 
   830 000017B1 B8E300              <1> 	mov ax, 11100011b		; 9600 baud, no parity, 8 data bits, 1 stop bit
   831 000017B4 EB03                <1> 	jmp .finish
   832                              <1> 
   833                              <1> .slow_mode:
   834 000017B6 B88300              <1> 	mov ax, 10000011b		; 1200 baud, no parity, 8 data bits, 1 stop bit	
   835                              <1> 
   836                              <1> .finish:
   837 000017B9 CD14                <1> 	int 14h
   838                              <1> 
   839 000017BB 61                  <1> 	popa
   840 000017BC C3                  <1> 	ret
   841                              <1> 
   842                              <1> 
   843                              <1> ; ------------------------------------------------------------------
   844                              <1> ; os_send_via_serial -- Send a byte via the serial port
   845                              <1> ; IN: AL = byte to send via serial; OUT: AH = Bit 7 clear on success
   846                              <1> 
   847                              <1> os_send_via_serial:
   848 000017BD 60                  <1> 	pusha
   849                              <1> 
   850 000017BE B401                <1> 	mov ah, 01h
   851                              <1> 	clr dx			; COM1
    11 000017C0 31D2                <2>  xor %1, %1
   852                              <1> 
   853 000017C2 CD14                <1> 	int 14h
   854                              <1> 
   855 000017C4 8826[CE17]          <1> 	mov [.tmp], ah
   856                              <1> 
   857 000017C8 61                  <1> 	popa
   858                              <1> 
   859 000017C9 8A26[CE17]          <1> 	mov ah, [.tmp]
   860                              <1> 
   861 000017CD C3                  <1> 	ret
   862                              <1> 
   863 000017CE 00                  <1> 	.tmp db 0
   864                              <1> 
   865                              <1> 
   866                              <1> ; ------------------------------------------------------------------
   867                              <1> ; os_get_via_serial -- Get a byte from the serial port
   868                              <1> ; IN: nothing; OUT: AL = byte that was received, AH = Bit 7 clear on success
   869                              <1> 
   870                              <1> os_get_via_serial:
   871 000017CF 60                  <1> 	pusha
   872                              <1> 
   873 000017D0 B402                <1> 	mov ah, 02h
   874                              <1> 	clr dx			; COM1
    11 000017D2 31D2                <2>  xor %1, %1
   875                              <1> 
   876 000017D4 CD14                <1> 	int 14h
   877                              <1> 
   878 000017D6 A3[DE17]            <1> 	mov [.tmp], ax
   879                              <1> 
   880 000017D9 61                  <1> 	popa
   881                              <1> 
   882 000017DA A1[DE17]            <1> 	mov ax, [.tmp]
   883                              <1> 
   884 000017DD C3                  <1> 	ret
   885                              <1> 
   886                              <1> 
   887 000017DE 0000                <1> 	.tmp dw 0
   888                              <1> 
   889                              <1> ; ==================================================================
   890                              <1> 
   815                                  	%INCLUDE "drivers/screen.asm"
   816                              <1> ; ==================================================================
   817                              <1> ; SCREEN HANDLING SYSTEM CALLS
   818                              <1> ; ==================================================================
   819                              <1> 
   820                              <1> ; ------------------------------------------------------------------
   821                              <1> ; os_putchar -- Puts a character on the screen
   822                              <1> ; IN: AL = character
   823                              <1> ; OUT: Nothing (registers preserved)
   824                              <1> 
   825                              <1> os_putchar:
   826 000017E0 60                  <1> 	pusha
   827 000017E1 B40E                <1> 	mov ah, 0Eh
   828 000017E3 CD10                <1> 	int 10h
   829 000017E5 61                  <1> 	popa
   830 000017E6 C3                  <1> 	ret
   831                              <1> 
   832                              <1> ; ------------------------------------------------------------------
   833                              <1> ; os_put_chars -- Puts up to a set amount of characters on the screen
   834                              <1> ; IN: BL = terminator, SI = location, CX = character count
   835                              <1> ; OUT: Nothing (registers preserved)
   836                              <1> 
   837                              <1> os_put_chars:
   838 000017E7 60                  <1> 	pusha
   839                              <1> 	
   840                              <1> .loop:
   841 000017E8 AC                  <1> 	lodsb
   842 000017E9 38D8                <1> 	cmp al, bl
   843 000017EB 7405                <1> 	je .done
   844                              <1> 	
   845 000017ED E8F0FF              <1> 	call os_putchar
   846                              <1> 	
   847 000017F0 E2F6                <1> 	loop .loop
   848                              <1> 	
   849                              <1> .done:
   850 000017F2 61                  <1> 	popa
   851 000017F3 C3                  <1> 	ret
   852                              <1> 
   853                              <1> ; ------------------------------------------------------------------
   854                              <1> ; os_print_string -- Displays text
   855                              <1> ; IN: SI = message location (zero-terminated string)
   856                              <1> ; OUT: Nothing (registers preserved)
   857                              <1> 
   858                              <1> os_print_string:
   859 000017F4 60                  <1> 	pusha
   860                              <1> 
   861                              <1> .repeat:
   862 000017F5 AC                  <1> 	lodsb				; Get char from string
   863 000017F6 3C00                <1> 	cmp al, 0
   864 000017F8 7405                <1> 	je .done			; If char is zero, end of string
   865                              <1> 
   866 000017FA E8E3FF              <1> 	call os_putchar
   867 000017FD EBF6                <1> 	jmp .repeat			; And move on to next char
   868                              <1> 
   869                              <1> .done:
   870 000017FF 61                  <1> 	popa
   871 00001800 C3                  <1> 	ret
   872                              <1> 
   873                              <1> ; ------------------------------------------------------------------
   874                              <1> ; os_print_string_box -- Displays text inside a text-box.
   875                              <1> ; IN: SI = message location (zero-terminated string), DL = left alignment
   876                              <1> ; OUT: Nothing (registers preserved)
   877                              <1> 
   878                              <1> os_print_string_box:
   879 00001801 60                  <1> 	pusha
   880 00001802 88D1                <1> 	mov cl, dl
   881                              <1> 
   882                              <1> .repeat:
   883 00001804 AC                  <1> 	lodsb				; Get char from string
   884 00001805 3C00                <1> 	cmp al, 0
   885 00001807 7409                <1> 	je .done			; If char is zero, end of string
   886                              <1> 
   887 00001809 3C0D                <1> 	cmp al, 13
   888 0000180B 7407                <1> 	je .cr
   889                              <1> 	
   890 0000180D E8D0FF              <1> 	call os_putchar
   891 00001810 EBF2                <1> 	jmp .repeat			; And move on to next char
   892                              <1> 
   893                              <1> .done:
   894 00001812 61                  <1> 	popa
   895 00001813 C3                  <1> 	ret
   896                              <1> 	
   897                              <1> .cr:
   898 00001814 E85700              <1> 	call os_get_cursor_pos
   899 00001817 88CA                <1> 	mov dl, cl
   900 00001819 E84900              <1> 	call os_move_cursor
   901 0000181C EBE6                <1> 	jmp .repeat
   902                              <1> 
   903                              <1> ; ------------------------------------------------------------------
   904                              <1> ; os_format_string -- Displays colored text
   905                              <1> ; IN: BL/SI = text color/message location (zero-terminated string)
   906                              <1> ; OUT: Nothing (registers preserved)
   907                              <1> 
   908                              <1> os_format_string:
   909 0000181E 60                  <1> 	pusha
   910                              <1> 
   911 0000181F B409                <1> 	mov ah, 09h			; int 09h
   912 00001821 B700                <1> 	mov bh, 0
   913 00001823 B90100              <1> 	mov cx, 1
   914 00001826 E84500              <1> 	call os_get_cursor_pos
   915                              <1> 	
   916                              <1> .repeat:
   917 00001829 AC                  <1> 	lodsb				; Get char from string
   918 0000182A 3C0D                <1> 	cmp al, 13
   919 0000182C 7411                <1> 	je .cr
   920 0000182E 3C0A                <1> 	cmp al, 10
   921 00001830 7414                <1> 	je .lf
   922 00001832 3C00                <1> 	cmp al, 0
   923 00001834 7417                <1> 	je .done			; If char is zero, end of string
   924                              <1> 
   925 00001836 CD10                <1> 	int 10h				; Otherwise, print it
   926                              <1> 
   927 00001838 FEC2                <1> 	inc dl
   928 0000183A E82800              <1> 	call os_move_cursor
   929                              <1> 	
   930 0000183D EBEA                <1> 	jmp .repeat			; And move on to next char
   931                              <1> 	
   932                              <1> .cr:
   933 0000183F B200                <1> 	mov dl, 0
   934 00001841 E82100              <1> 	call os_move_cursor
   935 00001844 EBE3                <1> 	jmp .repeat
   936                              <1> 
   937                              <1> .lf:
   938 00001846 FEC6                <1> 	inc dh
   939 00001848 E81A00              <1> 	call os_move_cursor
   940 0000184B EBDC                <1> 	jmp .repeat
   941                              <1> 	
   942                              <1> .done:
   943 0000184D 61                  <1> 	popa
   944 0000184E C3                  <1> 	ret
   945                              <1> 
   946                              <1> 
   947                              <1> ; ------------------------------------------------------------------
   948                              <1> ; os_clear_screen -- Clears the screen to background
   949                              <1> ; IN/OUT: Nothing (registers preserved)
   950                              <1> 
   951                              <1> os_clear_screen:
   952 0000184F 60                  <1> 	pusha
   953                              <1> 
   954 00001850 BA0000              <1> 	mov dx, 0			; Position cursor at top-left
   955 00001853 E80F00              <1> 	call os_move_cursor
   956                              <1> 
   957                              <1> 	mov16 ax, 0, 6		; Scroll full-screen
    15 00001856 B80006              <2>  mov %1, (%2 + %3 * 256)
   958 00001859 B707                <1> 	mov bh, 7
   959                              <1> 	mov16 cx, 0, 0		; Top-left
    15 0000185B B90000              <2>  mov %1, (%2 + %3 * 256)
   960                              <1> 	mov16 dx, 79, 24	; Bottom-right
    15 0000185E BA4F18              <2>  mov %1, (%2 + %3 * 256)
   961 00001861 CD10                <1> 	int 10h
   962                              <1> 
   963 00001863 61                  <1> 	popa
   964 00001864 C3                  <1> 	ret
   965                              <1> 
   966                              <1> 
   967                              <1> ; ------------------------------------------------------------------
   968                              <1> ; os_move_cursor -- Moves cursor in text mode
   969                              <1> ; IN: DH, DL = row, column; OUT: Nothing (registers preserved)
   970                              <1> 
   971                              <1> os_move_cursor:
   972 00001865 60                  <1> 	pusha
   973                              <1> 
   974 00001866 B700                <1> 	mov bh, 0
   975 00001868 B402                <1> 	mov ah, 2
   976 0000186A CD10                <1> 	int 10h				; BIOS interrupt to move cursor
   977                              <1> 
   978 0000186C 61                  <1> 	popa
   979 0000186D C3                  <1> 	ret
   980                              <1> 
   981                              <1> 
   982                              <1> ; ------------------------------------------------------------------
   983                              <1> ; os_get_cursor_pos -- Return position of text cursor
   984                              <1> ; OUT: DH, DL = row, column
   985                              <1> 
   986                              <1> os_get_cursor_pos:
   987 0000186E 60                  <1> 	pusha
   988                              <1> 
   989 0000186F B700                <1> 	mov bh, 0
   990 00001871 B403                <1> 	mov ah, 3
   991 00001873 CD10                <1> 	int 10h				; BIOS interrupt to get cursor position
   992                              <1> 
   993 00001875 8916[7F18]          <1> 	mov [.tmp], dx
   994 00001879 61                  <1> 	popa
   995 0000187A 8B16[7F18]          <1> 	mov dx, [.tmp]
   996 0000187E C3                  <1> 	ret
   997                              <1> 
   998                              <1> 
   999 0000187F 0000                <1> 	.tmp dw 0
  1000                              <1> 
  1001                              <1> 
  1002                              <1> ; ------------------------------------------------------------------
  1003                              <1> ; os_print_horiz_line -- Draw a horizontal line on the screen
  1004                              <1> ; IN: AX = line type (1 for double (-), otherwise single (=))
  1005                              <1> ; OUT: Nothing (registers preserved)
  1006                              <1> 
  1007                              <1> os_print_horiz_line:
  1008 00001881 60                  <1> 	pusha
  1009                              <1> 
  1010 00001882 89C1                <1> 	mov cx, ax			; Store line type param
  1011 00001884 B0C4                <1> 	mov al, 196			; Default is single-line code
  1012                              <1> 
  1013 00001886 83F901              <1> 	cmp cx, 1			; Was double-line specified in AX?
  1014 00001889 7502                <1> 	jne .ready
  1015 0000188B B0CD                <1> 	mov al, 205			; If so, here's the code
  1016                              <1> 
  1017                              <1> .ready:
  1018 0000188D B95000              <1> 	mov cx, 80			; Counter
  1019 00001890 B40E                <1> 	mov ah, 0Eh			; BIOS output char routine
  1020 00001892 B700                <1> 	mov bh, 0
  1021                              <1> 	
  1022                              <1> .loop:
  1023 00001894 CD10                <1> 	int 10h
  1024 00001896 E2FC                <1> 	loop .loop
  1025                              <1> 	
  1026 00001898 61                  <1> 	popa
  1027 00001899 C3                  <1> 	ret
  1028                              <1> 
  1029                              <1> 
  1030                              <1> ; ------------------------------------------------------------------
  1031                              <1> ; os_show_cursor -- Turns on cursor in text mode
  1032                              <1> ; IN/OUT: Nothing
  1033                              <1> 
  1034                              <1> os_show_cursor:
  1035 0000189A 60                  <1> 	pusha
  1036                              <1> 
  1037                              <1> 	mov16 cx, 7, 6
    15 0000189B B90706              <2>  mov %1, (%2 + %3 * 256)
  1038                              <1> 	mov16 ax, 3, 1
    15 0000189E B80301              <2>  mov %1, (%2 + %3 * 256)
  1039 000018A1 CD10                <1> 	int 10h
  1040                              <1> 
  1041 000018A3 61                  <1> 	popa
  1042 000018A4 C3                  <1> 	ret
  1043                              <1> 
  1044                              <1> 
  1045                              <1> ; ------------------------------------------------------------------
  1046                              <1> ; os_hide_cursor -- Turns off cursor in text mode
  1047                              <1> ; IN/OUT: Nothing
  1048                              <1> 
  1049                              <1> os_hide_cursor:
  1050 000018A5 60                  <1> 	pusha
  1051                              <1> 
  1052 000018A6 B520                <1> 	mov ch, 32
  1053                              <1> 	mov16 ax, 3, 1	; AL must be video mode for buggy BIOSes!
    15 000018A8 B80301              <2>  mov %1, (%2 + %3 * 256)
  1054 000018AB CD10                <1> 	int 10h
  1055                              <1> 
  1056 000018AD 61                  <1> 	popa
  1057 000018AE C3                  <1> 	ret
  1058                              <1> 
  1059                              <1> 
  1060                              <1> ; ------------------------------------------------------------------
  1061                              <1> ; os_draw_block -- Render block of specified colour
  1062                              <1> ; IN: BL/DL/DH/SI/DI = colour/start X pos/start Y pos/width/finish Y pos
  1063                              <1> 
  1064                              <1> os_draw_block:
  1065 000018AF 60                  <1> 	pusha
  1066                              <1> 
  1067                              <1> .more:
  1068 000018B0 E8B2FF              <1> 	call os_move_cursor		; Move to block starting position
  1069                              <1> 
  1070                              <1> 	mov16 ax, ' ', 09h			; Draw colour section
    15 000018B3 B82009              <2>  mov %1, (%2 + %3 * 256)
  1071 000018B6 B700                <1> 	mov bh, 0
  1072 000018B8 89F1                <1> 	mov cx, si
  1073 000018BA CD10                <1> 	int 10h
  1074                              <1> 
  1075 000018BC FEC6                <1> 	inc dh				; Get ready for next line
  1076                              <1> 
  1077 000018BE 0FB6C6              <1> 	movzx ax, dh		; Get current Y position into DL
  1078 000018C1 39F8                <1> 	cmp ax, di			; Reached finishing point (DI)?
  1079 000018C3 75EB                <1> 	jne .more			; If not, keep drawing
  1080                              <1> 
  1081 000018C5 61                  <1> 	popa
  1082 000018C6 C3                  <1> 	ret
  1083                              <1> 
  1084                              <1> 
  1085                              <1> ; ------------------------------------------------------------------
  1086                              <1> ; os_file_selector -- Show a file selection dialog
  1087                              <1> ; IN: If [0087h] = 1, then BX = location of file extension list
  1088                              <1> ; OUT: AX = location of filename string (or carry set if Esc pressed)
  1089                              <1> 
  1090                              <1> os_file_selector:
  1091                              <1> 	; Get volume name
  1092                              <1> 	
  1093 000018C7 60                  <1> 	pusha
  1094 000018C8 B90100              <1> 	mov cx, 1					; Load first disk sector into RAM
  1095 000018CB 0FB6168400          <1> 	movzx dx, byte [0084h]
  1096 000018D0 BB00E0              <1> 	mov bx, disk_buffer
  1097                              <1> 
  1098                              <1> 	mov16 ax, 1, 2
    15 000018D3 B80102              <2>  mov %1, (%2 + %3 * 256)
  1099 000018D6 F9                  <1> 	stc
  1100 000018D7 CD13                <1> 	int 13h						; BIOS load sector call
  1101                              <1> 
  1102 000018D9 BE2BE0              <1> 	mov si, disk_buffer + 2Bh	; Disk label starts here
  1103                              <1> 
  1104 000018DC BF[621B]            <1> 	mov di, .volname
  1105 000018DF B90B00              <1> 	mov cx, 11					; Copy 11 chars of it
  1106 000018E2 F3A4                <1> 	rep movsb
  1107 000018E4 61                  <1> 	popa
  1108                              <1> 	
  1109 000018E5 60                  <1> 	pusha
  1110 000018E6 C706[471B]0000      <1> 	mov word [.filename], 0		; Terminate string in case user leaves without choosing
  1111                              <1> 
  1112 000018EC E8F9F0              <1> 	call os_report_free_space
  1113 000018EF D1E8                <1> 	shr ax, 1					; Sectors -> kB
  1114 000018F1 A3[6E1B]            <1> 	mov [.freespace], ax
  1115                              <1> 	
  1116                              <1> 	; Add the filters, if desired
  1117                              <1> 
  1118 000018F4 BF5100              <1> 	mov di, 0051h
  1119 000018F7 C60500              <1> 	mov byte [di], 0
  1120                              <1> 	
  1121 000018FA 803E870001          <1> 	cmp byte [0087h], 1
  1122 000018FF 752F                <1> 	jne .no_filter
  1123                              <1> 	
  1124 00001901 891E[701B]          <1> 	mov [.extension_list], bx
  1125                              <1> 
  1126 00001905 BE[111B]            <1> 	mov si, .filter_msg
  1127 00001908 BF5100              <1> 	mov di, 0051h
  1128 0000190B E83711              <1> 	call os_string_copy
  1129                              <1> 
  1130 0000190E 60                  <1> 	pusha
  1131 0000190F BF5A00              <1> 	mov di, 0051h + 9
  1132 00001912 89DE                <1> 	mov si, bx
  1133 00001914 8A1C                <1> 	mov bl, [si]
  1134 00001916 46                  <1> 	inc si
  1135 00001917 B100                <1> 	mov cl, 0
  1136                              <1> 	
  1137                              <1> .filter_loop:
  1138 00001919 E82911              <1> 	call os_string_copy
  1139 0000191C C6450320            <1> 	mov byte [di + 3], ' '
  1140 00001920 83C704              <1> 	add di, 4
  1141 00001923 83C604              <1> 	add si, 4
  1142 00001926 FEC1                <1> 	inc cl
  1143 00001928 38D9                <1> 	cmp cl, bl
  1144 0000192A 75ED                <1> 	jne .filter_loop
  1145                              <1> 	
  1146 0000192C C60500              <1> 	mov byte [di], 0
  1147 0000192F 61                  <1> 	popa
  1148                              <1> 	
  1149                              <1> .no_filter:
  1150                              <1> 	; Create the filename index list
  1151                              <1> 
  1152 00001930 E8BDF8              <1> 	call disk_read_root_dir		; Get the files into the buffer
  1153                              <1> 
  1154 00001933 BE00E0              <1> 	mov si, disk_buffer			; Raw directory buffer
  1155 00001936 BF00FC              <1> 	mov di, 64512				; Buffer for indexes
  1156 00001939 B90000              <1> 	mov cx, 0					; Number of found files
  1157                              <1> 
  1158                              <1> .index_loop:
  1159 0000193C 81FE00FC            <1> 	cmp si, 64512			; Are we done looping through the directory?
  1160 00001940 744E                <1> 	je .done
  1161                              <1> 
  1162 00001942 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
  1163 00001945 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
  1164 00001947 7442                <1> 	je .skip
  1165                              <1> 
  1166 00001949 A808                <1> 	test al, 08h			; Is this a directory entry or volume label?
  1167 0000194B 753E                <1> 	jnz .skip			; Yes, ignore it
  1168                              <1> 
  1169 0000194D 8A04                <1> 	mov al, [si]
  1170 0000194F 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
  1171 00001951 7438                <1> 	je .skip
  1172                              <1> 
  1173 00001953 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
  1174 00001955 7439                <1> 	je .done
  1175                              <1> 
  1176 00001957 60                  <1> 	pusha
  1177                              <1> 
  1178 00001958 803E870001          <1> 	cmp byte [0087h], 1	; Check if we are supposed to filter the filenames
  1179 0000195D 7523                <1> 	jne .no_extension_check
  1180                              <1> 	
  1181 0000195F 8B1E[701B]          <1> 	mov bx, [.extension_list]
  1182 00001963 0FB60F              <1> 	movzx cx, byte [bx]
  1183                              <1> 
  1184                              <1> .extension_loop:
  1185 00001966 60                  <1> 	pusha
  1186 00001967 83C608              <1> 	add si, 8
  1187                              <1> 	
  1188 0000196A 49                  <1> 	dec cx
  1189 0000196B 89CF                <1> 	mov di, cx
  1190 0000196D C1E702              <1> 	shl di, 2	; Each entry is 4 bytes long
  1191 00001970 47                  <1> 	inc di		; The entry list starts with a 1-byte header
  1192 00001971 033E[701B]          <1> 	add di, [.extension_list]
  1193                              <1> 	
  1194 00001975 B90300              <1> 	mov cx, 3
  1195 00001978 F3A6                <1> 	rep cmpsb
  1196 0000197A 61                  <1> 	popa
  1197 0000197B 7405                <1> 	je .no_extension_check
  1198                              <1> 	
  1199 0000197D E2E7                <1> 	loop .extension_loop
  1200                              <1> 	
  1201 0000197F 61                  <1> 	popa
  1202 00001980 EB09                <1> 	jmp .skip
  1203                              <1> 
  1204                              <1> .no_extension_check:
  1205 00001982 61                  <1> 	popa
  1206                              <1> 
  1207 00001983 41                  <1> 	inc cx				; Increment the number of discovered files
  1208 00001984 89F0                <1> 	mov ax, si			; Store the filename pointer into the buffer
  1209 00001986 AB                  <1> 	stosw
  1210                              <1> 
  1211 00001987 C6440B00            <1> 	mov byte [si+11], 0	; Zero-terminate the string
  1212                              <1> 
  1213                              <1> .skip:
  1214 0000198B 83C620              <1> 	add si, byte 32		; Skip to the next file
  1215 0000198E EBAC                <1> 	jmp .index_loop
  1216                              <1> 
  1217                              <1> .done:
  1218                              <1> 	; Let the user select a file
  1219                              <1> 
  1220 00001990 89C8                <1> 	mov ax, cx			; Pass the number of files
  1221 00001992 BB[331B]            <1> 	mov bx, .root
  1222 00001995 B95100              <1> 	mov cx, 0051h
  1223 00001998 BE[E419]            <1> 	mov si, .callback
  1224                              <1> 
  1225 0000199B C606[721B]01        <1> 	mov byte [.file_selector_calling], 1
  1226 000019A0 E8D301              <1> 	call os_list_dialog_tooltip
  1227 000019A3 C606[721B]00        <1> 	mov byte [.file_selector_calling], 0
  1228                              <1> 
  1229 000019A8 7209                <1> 	jc .esc_pressed
  1230                              <1> 
  1231 000019AA E80900              <1> 	call .get_filename
  1232                              <1> 	
  1233 000019AD 61                  <1> 	popa
  1234 000019AE B8[471B]            <1> 	mov ax, .filename
  1235 000019B1 F8                  <1> 	clc
  1236 000019B2 C3                  <1> 	ret
  1237                              <1> 
  1238                              <1> .esc_pressed:				; Set carry flag if Escape was pressed
  1239 000019B3 61                  <1> 	popa
  1240 000019B4 F9                  <1> 	stc
  1241 000019B5 C3                  <1> 	ret
  1242                              <1> 
  1243                              <1> .get_filename:
  1244 000019B6 48                  <1> 	dec ax				; Result from os_list_dialog starts from 1, but
  1245                              <1> 						; for our file list offset we want to start from 0
  1246                              <1> 	
  1247 000019B7 89C6                <1> 	mov si, ax			; Get the pointer to the string in the index
  1248 000019B9 D1E6                <1> 	shl si, 1
  1249 000019BB 81C600FC            <1> 	add si, 64512
  1250                              <1> 
  1251 000019BF AD                  <1> 	lodsw
  1252 000019C0 89C6                <1> 	mov si, ax			; Our resulting pointer
  1253                              <1> 	clr cx
    11 000019C2 31C9                <2>  xor %1, %1
  1254 000019C4 BF[471B]            <1> 	mov di, .filename
  1255                              <1> 	
  1256                              <1> .loopy:
  1257 000019C7 AC                  <1> 	lodsb
  1258 000019C8 3C20                <1> 	cmp al, ' '
  1259 000019CA 7401                <1> 	je .ignore_space
  1260 000019CC AA                  <1> 	stosb
  1261                              <1> 	
  1262                              <1> .ignore_space:
  1263 000019CD 41                  <1> 	inc cx
  1264 000019CE 83F908              <1> 	cmp cx, 8
  1265 000019D1 7407                <1> 	je .add_dot
  1266 000019D3 83F90B              <1> 	cmp cx, 11
  1267 000019D6 7408                <1> 	je .done_copy
  1268 000019D8 EBED                <1> 	jmp .loopy
  1269                              <1> 
  1270                              <1> .add_dot:
  1271 000019DA C6052E              <1> 	mov byte [di], '.'
  1272 000019DD 47                  <1> 	inc di
  1273 000019DE EBE7                <1> 	jmp .loopy
  1274                              <1> 
  1275                              <1> .done_copy:
  1276 000019E0 C60500              <1> 	mov byte [di], 0
  1277                              <1> 
  1278 000019E3 C3                  <1> 	ret
  1279                              <1> 	
  1280                              <1> .callback:
  1281                              <1> 	; Draw the box on the right
  1282 000019E4 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  1283                              <1> 	mov16 dx, 41, 2		; Start X/Y position
    15 000019E8 BA2902              <2>  mov %1, (%2 + %3 * 256)
  1284 000019EB BE2500              <1> 	mov si, 37			; Width
  1285 000019EE BF1700              <1> 	mov di, 23			; Finish Y position
  1286 000019F1 E8BBFE              <1> 	call os_draw_block	; Draw option selector window
  1287                              <1> 
  1288                              <1> 	; Draw the icon's background
  1289 000019F4 B3F0                <1> 	mov bl, 0F0h
  1290                              <1> 	mov16 dx, 50, 3
    15 000019F6 BA3203              <2>  mov %1, (%2 + %3 * 256)
  1291 000019F9 BE1300              <1> 	mov si, 19			; Width
  1292 000019FC BF0D00              <1> 	mov di, 13			; Finish Y position
  1293 000019FF E8ADFE              <1> 	call os_draw_block	; Draw option selector window	
  1294                              <1> 
  1295                              <1> 	; Draw the icon
  1296                              <1> 	
  1297                              <1> 	mov16 dx, 52, 4
    15 00001A02 BA3404              <2>  mov %1, (%2 + %3 * 256)
  1298 00001A05 E85DFE              <1> 	call os_move_cursor
  1299                              <1> 	
  1300 00001A08 BE[4609]            <1> 	mov si, filelogo
  1301 00001A0B E8160A              <1> 	call os_draw_icon
  1302                              <1> 
  1303                              <1> 	; Display the filename
  1304                              <1> 
  1305                              <1> 	mov16 dx, 42, 14
    15 00001A0E BA2A0E              <2>  mov %1, (%2 + %3 * 256)
  1306 00001A11 E851FE              <1> 	call os_move_cursor
  1307                              <1> 
  1308 00001A14 50                  <1> 	push ax
  1309 00001A15 E89EFF              <1> 	call .get_filename
  1310                              <1> 	
  1311 00001A18 BE[471B]            <1> 	mov si, .filename
  1312 00001A1B E8D6FD              <1> 	call os_print_string
  1313                              <1> 	
  1314                              <1> 	; Find the correct directory entry for this file
  1315                              <1> 
  1316 00001A1E 58                  <1> 	pop ax
  1317                              <1> 
  1318 00001A1F 48                  <1> 	dec ax
  1319 00001A20 89C6                <1> 	mov si, ax
  1320 00001A22 D1E6                <1> 	shl si, 1
  1321 00001A24 81C600FC            <1> 	add si, 64512
  1322 00001A28 8B34                <1> 	mov si, [si]			; Get the pointer to the entry in the index list
  1323                              <1> 
  1324 00001A2A 56                  <1> 	push si
  1325                              <1> 	
  1326                              <1> 	; Display the file size
  1327                              <1> 	
  1328 00001A2B 668B441C            <1> 	mov eax, [si + 28]
  1329 00001A2F E81D12              <1> 	call os_32int_to_string
  1330                              <1> 	
  1331 00001A32 89C6                <1> 	mov si, ax
  1332 00001A34 BF[471B]            <1> 	mov di, .filename
  1333 00001A37 E80B10              <1> 	call os_string_copy
  1334                              <1> 	
  1335 00001A3A B8[471B]            <1> 	mov ax, .filename
  1336 00001A3D BB[1B1B]            <1> 	mov bx, .byte_msg
  1337 00001A40 E8600F              <1> 	call os_string_add
  1338                              <1> 	
  1339 00001A43 E86C0F              <1> 	call os_string_length
  1340                              <1> 
  1341 00001A46 B24D                <1> 	mov dl, 77
  1342 00001A48 28C2                <1> 	sub dl, al
  1343 00001A4A E818FE              <1> 	call os_move_cursor
  1344                              <1> 	
  1345 00001A4D BE[471B]            <1> 	mov si, .filename
  1346 00001A50 E8A1FD              <1> 	call os_print_string
  1347                              <1> 	
  1348                              <1> 	; Display the file write date/time
  1349                              <1> 	
  1350 00001A53 C606[471B]00        <1> 	mov byte [.filename], 0
  1351                              <1> 	
  1352 00001A58 5E                  <1> 	pop si
  1353 00001A59 8B5C0E              <1> 	mov bx, [si + 14]
  1354 00001A5C 8B4C10              <1> 	mov cx, [si + 16]
  1355                              <1> 	
  1356 00001A5F 53                  <1> 	push bx
  1357 00001A60 89C8                <1> 	mov ax, cx		; Days
  1358 00001A62 83E01F              <1> 	and ax, 11111b
  1359                              <1> 	
  1360 00001A65 BA[2D1B]            <1> 	mov dx, .dateseparator
  1361 00001A68 E88400              <1> 	call .cb_add_num
  1362                              <1> 	
  1363 00001A6B 89C8                <1> 	mov ax, cx		; Months
  1364 00001A6D C1E805              <1> 	shr ax, 5
  1365 00001A70 83E00F              <1> 	and ax, 1111b
  1366                              <1> 	
  1367 00001A73 E87900              <1> 	call .cb_add_num
  1368                              <1> 	
  1369 00001A76 89C8                <1> 	mov ax, cx		; Years
  1370 00001A78 C1E809              <1> 	shr ax, 9
  1371 00001A7B 05BC07              <1> 	add ax, 1980
  1372                              <1> 	
  1373 00001A7E BA[2F1B]            <1> 	mov dx, .whiteseparator
  1374 00001A81 E86B00              <1> 	call .cb_add_num
  1375                              <1> 	
  1376 00001A84 59                  <1> 	pop cx
  1377                              <1> 	
  1378 00001A85 89C8                <1> 	mov ax, cx		; Hours
  1379 00001A87 C1E80B              <1> 	shr ax, 11
  1380                              <1> 
  1381 00001A8A BA[2B1B]            <1> 	mov dx, .timeseparator
  1382 00001A8D E85F00              <1> 	call .cb_add_num
  1383                              <1> 	
  1384 00001A90 89C8                <1> 	mov ax, cx		; Minutes
  1385 00001A92 C1E805              <1> 	shr ax, 5
  1386 00001A95 83E03F              <1> 	and ax, 111111b
  1387                              <1> 	
  1388 00001A98 E85400              <1> 	call .cb_add_num
  1389                              <1> 
  1390 00001A9B 89C8                <1> 	mov ax, cx		; Seconds
  1391 00001A9D 83E01F              <1> 	and ax, 11111b
  1392 00001AA0 D1E0                <1> 	shl ax, 1
  1393                              <1> 
  1394 00001AA2 BA[101B]            <1> 	mov dx, .help_msg2
  1395 00001AA5 E84700              <1> 	call .cb_add_num
  1396                              <1> 	
  1397                              <1> 	mov16 dx, 42, 16
    15 00001AA8 BA2A10              <2>  mov %1, (%2 + %3 * 256)
  1398 00001AAB E8B7FD              <1> 	call os_move_cursor
  1399                              <1> 
  1400 00001AAE BE[371B]            <1> 	mov si, .time_msg
  1401 00001AB1 E840FD              <1> 	call os_print_string
  1402                              <1> 	
  1403                              <1> 	; Display volume information
  1404                              <1> 	
  1405                              <1> 	mov16 dx, 42, 20
    15 00001AB4 BA2A14              <2>  mov %1, (%2 + %3 * 256)
  1406 00001AB7 E8ABFD              <1> 	call os_move_cursor
  1407                              <1> 
  1408 00001ABA B8C409              <1> 	mov ax, 09C4h
  1409 00001ABD 0FB61EA9DE          <1> 	movzx bx, byte [57001]
  1410 00001AC2 B92300              <1> 	mov cx, 35
  1411 00001AC5 CD10                <1> 	int 10h
  1412                              <1> 	
  1413 00001AC7 FEC6                <1> 	inc dh
  1414 00001AC9 E899FD              <1> 	call os_move_cursor
  1415                              <1> 
  1416 00001ACC BE[5B1B]            <1> 	mov si, .vol_msg
  1417 00001ACF E822FD              <1> 	call os_print_string
  1418                              <1> 	
  1419 00001AD2 A1[6E1B]            <1> 	mov ax, [.freespace]
  1420 00001AD5 E86B10              <1> 	call os_int_to_string
  1421 00001AD8 89C6                <1> 	mov si, ax
  1422 00001ADA E8D50E              <1> 	call os_string_length
  1423                              <1> 	
  1424 00001ADD 80C21B              <1> 	add dl, 27
  1425 00001AE0 28C2                <1> 	sub dl, al
  1426 00001AE2 E880FD              <1> 	call os_move_cursor
  1427                              <1> 		
  1428 00001AE5 E80CFD              <1> 	call os_print_string
  1429                              <1> 		
  1430 00001AE8 BE[221B]            <1> 	mov si, .free_msg
  1431 00001AEB E806FD              <1> 	call os_print_string
  1432 00001AEE C3                  <1> 	ret
  1433                              <1> 	
  1434                              <1> .cb_add_num:
  1435 00001AEF 83F80A              <1> 	cmp ax, 10
  1436 00001AF2 7D0B                <1> 	jge .no_zero
  1437                              <1> 	
  1438 00001AF4 50                  <1> 	push ax
  1439 00001AF5 BB[311B]            <1> 	mov bx, .zerofill
  1440 00001AF8 B8[471B]            <1> 	mov ax, .filename
  1441 00001AFB E8A50E              <1> 	call os_string_add
  1442 00001AFE 58                  <1> 	pop ax
  1443                              <1> 	
  1444                              <1> .no_zero:
  1445 00001AFF E84110              <1> 	call os_int_to_string
  1446 00001B02 89C3                <1> 	mov bx, ax
  1447 00001B04 B8[471B]            <1> 	mov ax, .filename
  1448 00001B07 E8990E              <1> 	call os_string_add
  1449                              <1> 	
  1450 00001B0A 89D3                <1> 	mov bx, dx
  1451 00001B0C E8940E              <1> 	call os_string_add
  1452                              <1> 
  1453 00001B0F C3                  <1> 	ret
  1454                              <1> 	
  1455 00001B10 00                  <1> 	.help_msg2		db 0
  1456 00001B11 46696C746572733A20- <1> 	.filter_msg		db 'Filters: ', 0
  1456 00001B1A 00                  <1>
  1457 00001B1B 20627974657300      <1> 	.byte_msg		db ' bytes', 0
  1458 00001B22 206B42206672656500  <1> 	.free_msg		db ' kB free', 0
  1459 00001B2B 3A00                <1> 	.timeseparator	db ':', 0
  1460 00001B2D 2F00                <1> 	.dateseparator	db '/', 0
  1461 00001B2F 2000                <1> 	.whiteseparator	db ' ', 0
  1462 00001B31 3000                <1> 	.zerofill		db '0', 0
  1463 00001B33 413A2F00            <1> 	.root			db 'A:/', 0
  1464                              <1> 
  1465 00001B37 5772697474656E2074- <1> 	.time_msg		db 'Written to on:  '
  1465 00001B40 6F206F6E3A2020      <1>
  1466 00001B47 00<rep 14h>         <1> 	.filename		times 20 db 0
  1467                              <1> 	
  1468 00001B5B 566F6C756D6520      <1> 	.vol_msg		db 'Volume '
  1469 00001B62 00<rep Ch>          <1> 	.volname		times 12 db 0
  1470 00001B6E 0000                <1> 	.freespace		dw 0
  1471 00001B70 0000                <1> 	.extension_list	dw 0
  1472                              <1> 
  1473 00001B72 00                  <1> 	.file_selector_calling			db 0
  1474 00001B73 00                  <1> 	.file_selector_cursorpos		db 0
  1475 00001B74 00                  <1> 	.file_selector_skipnum			db 0
  1476 00001B75 00                  <1> 	.file_selector_numofentries		db 0
  1477                              <1> 
  1478                              <1> 
  1479                              <1> ; ------------------------------------------------------------------
  1480                              <1> ; os_list_dialog_tooltip -- Show a dialog with a list of options and a tooltip.
  1481                              <1> ; That means, when the user changes the selection, the application will be called back
  1482                              <1> ; to change the tooltip's contents.
  1483                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1484                              <1> ;     BX = first help string, CX = second help string
  1485                              <1> ;     SI = callback pointer
  1486                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1487                              <1> 
  1488                              <1> os_list_dialog_tooltip:
  1489 00001B76 C70689002500        <1> 	mov word [0089h], 37
  1490                              <1> 	
  1491 00001B7C 8936[B11B]          <1> 	mov [.callbackaddr], si
  1492                              <1> 	
  1493 00001B80 C706[6E1E][961B]    <1> 	mov word [os_list_dialog.callback], .callback
  1494 00001B86 E82A00              <1> 	call os_list_dialog
  1495 00001B89 C706[6E1E]0000      <1> 	mov word [os_list_dialog.callback], 0
  1496 00001B8F C70689004C00        <1> 	mov word [0089h], 76
  1497 00001B95 C3                  <1> 	ret
  1498                              <1> 	
  1499                              <1> .callback:
  1500                              <1> 	; Draw the box on the right
  1501 00001B96 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  1502                              <1> 	mov16 dx, 41, 2		; Start X/Y position
    15 00001B9A BA2902              <2>  mov %1, (%2 + %3 * 256)
  1503 00001B9D BE2500              <1> 	mov si, 37			; Width
  1504 00001BA0 BF1700              <1> 	mov di, 23			; Finish Y position
  1505 00001BA3 E809FD              <1> 	call os_draw_block	; Draw option selector window	
  1506                              <1> 
  1507                              <1> 	mov16 dx, 42, 3
    15 00001BA6 BA2A03              <2>  mov %1, (%2 + %3 * 256)
  1508 00001BA9 E8B9FC              <1> 	call os_move_cursor
  1509                              <1> 
  1510 00001BAC FF16[B11B]          <1> 	call [.callbackaddr]
  1511 00001BB0 C3                  <1> 	ret
  1512                              <1> 	
  1513 00001BB1 0000                <1> 	.callbackaddr	dw 0
  1514                              <1> 	
  1515                              <1> ; ------------------------------------------------------------------
  1516                              <1> ; os_list_dialog -- Show a dialog with a list of options
  1517                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1518                              <1> ;     BX = first help string, CX = second help string
  1519                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1520                              <1> 
  1521                              <1> os_list_dialog:
  1522 00001BB3 60                  <1> 	pusha
  1523                              <1> 
  1524 00001BB4 50                  <1> 	push ax				; Store string list for now
  1525                              <1> 
  1526 00001BB5 51                  <1> 	push cx				; And help strings
  1527 00001BB6 53                  <1> 	push bx
  1528                              <1> 
  1529 00001BB7 E8EBFC              <1> 	call os_hide_cursor
  1530                              <1> 
  1531                              <1> 	; Are we calling from the file selector?
  1532                              <1> 
  1533 00001BBA 803E[721B]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1534 00001BBF 7509                <1> 	jne .normal_count
  1535                              <1> 
  1536 00001BC1 83F800              <1> 	cmp ax, 0
  1537 00001BC4 740B                <1> 	je .empty_list
  1538                              <1> 
  1539 00001BC6 89C1                <1> 	mov cx, ax
  1540                              <1> 
  1541 00001BC8 EB4B                <1> 	jmp .done_count_f
  1542                              <1> 
  1543                              <1> .normal_count:
  1544 00001BCA 89C6                <1> 	mov si, ax
  1545 00001BCC 803C00              <1> 	cmp byte [si], 0
  1546 00001BCF 7530                <1> 	jne .count_entries
  1547                              <1> 
  1548                              <1> .empty_list:
  1549 00001BD1 83C406              <1> 	add sp, 6
  1550 00001BD4 61                  <1> 	popa
  1551                              <1> 
  1552 00001BD5 B8[E31B]            <1> 	mov ax, .nofilesmsg
  1553                              <1> 	clr bx
    11 00001BD8 31DB                <2>  xor %1, %1
  1554                              <1> 	clr cx
    11 00001BDA 31C9                <2>  xor %1, %1
  1555                              <1> 	clr dx
    11 00001BDC 31D2                <2>  xor %1, %1
  1556 00001BDE E85604              <1> 	call os_dialog_box
  1557                              <1> 
  1558 00001BE1 F9                  <1> 	stc
  1559 00001BE2 C3                  <1> 	ret
  1560                              <1> 
  1561 00001BE3 546865726520617265- <1> 	.nofilesmsg	db "There are no items to select.", 0
  1561 00001BEC 206E6F206974656D73- <1>
  1561 00001BF5 20746F2073656C6563- <1>
  1561 00001BFE 742E00              <1>
  1562                              <1> 	
  1563                              <1> .count_entries:	
  1564 00001C01 B100                <1> 	mov cl, 0			; Count the number of entries in the list
  1565                              <1> 	
  1566                              <1> .count_loop:
  1567 00001C03 268A04              <1> 	mov al, [es:si]
  1568 00001C06 46                  <1> 	inc si
  1569 00001C07 3C00                <1> 	cmp al, 0
  1570 00001C09 7408                <1> 	je .done_count
  1571 00001C0B 3C2C                <1> 	cmp al, ','
  1572 00001C0D 75F4                <1> 	jne .count_loop
  1573 00001C0F FEC1                <1> 	inc cl
  1574 00001C11 EBF0                <1> 	jmp .count_loop
  1575                              <1> 
  1576                              <1> .done_count:
  1577 00001C13 FEC1                <1> 	inc cl
  1578                              <1> 
  1579                              <1> .done_count_f:
  1580 00001C15 880E[621E]          <1> 	mov byte [.num_of_entries], cl
  1581                              <1> 
  1582                              <1> 
  1583 00001C19 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  1584                              <1> 	mov16 dx, 2, 2		; Start X/Y position
    15 00001C1D BA0202              <2>  mov %1, (%2 + %3 * 256)
  1585 00001C20 8B368900            <1> 	mov si, [0089h]		; Width
  1586 00001C24 BF1700              <1> 	mov di, 23			; Finish Y position
  1587 00001C27 E885FC              <1> 	call os_draw_block	; Draw option selector window
  1588                              <1> 
  1589                              <1> 	mov16 dx, 3, 3		; Show first line of help text...
    15 00001C2A BA0303              <2>  mov %1, (%2 + %3 * 256)
  1590 00001C2D E835FC              <1> 	call os_move_cursor
  1591                              <1> 
  1592 00001C30 5E                  <1> 	pop si				; Get back first string
  1593 00001C31 E8C0FB              <1> 	call os_print_string
  1594                              <1> 
  1595 00001C34 FEC6                <1> 	inc dh
  1596 00001C36 E82CFC              <1> 	call os_move_cursor
  1597                              <1> 
  1598 00001C39 5E                  <1> 	pop si				; ...and the second
  1599 00001C3A E8B7FB              <1> 	call os_print_string
  1600                              <1> 
  1601                              <1> 
  1602 00001C3D 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  1603 00001C3E 8936[641E]          <1> 	mov word [.list_string], si
  1604                              <1> 
  1605                              <1> 
  1606                              <1> 	; Now that we've drawn the list, highlight the currently selected
  1607                              <1> 	; entry and let the user move up and down using the cursor keys
  1608                              <1> 
  1609 00001C42 C606[631E]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  1610                              <1> 
  1611                              <1> 	mov16 dx, 25, 6			; Set up starting position for selector
    15 00001C47 BA1906              <2>  mov %1, (%2 + %3 * 256)
  1612                              <1> 
  1613 00001C4A 803E[721B]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1614 00001C4F 7510                <1> 	jne .no_load_position
  1615                              <1> 	
  1616 00001C51 3A0E[751B]          <1> 	cmp cl, [os_file_selector.file_selector_numofentries]
  1617 00001C55 750A                <1> 	jne .no_load_position
  1618                              <1> 	
  1619 00001C57 8A36[731B]          <1> 	mov dh, [os_file_selector.file_selector_cursorpos]
  1620 00001C5B A0[741B]            <1> 	mov al, [os_file_selector.file_selector_skipnum]
  1621 00001C5E A2[631E]            <1> 	mov [.skip_num], al
  1622                              <1> 	
  1623                              <1> .no_load_position:
  1624 00001C61 E801FC              <1> 	call os_move_cursor
  1625                              <1> 
  1626                              <1> .more_select:
  1627 00001C64 60                  <1> 	pusha
  1628 00001C65 B3F0                <1> 	mov bl, 11110000b		; Black on white for option list box
  1629                              <1> 	mov16 dx, 3, 5
    15 00001C67 BA0305              <2>  mov %1, (%2 + %3 * 256)
  1630 00001C6A 8B368900            <1> 	mov si, [0089h]
  1631 00001C6E 83EE02              <1> 	sub si, byte 2
  1632 00001C71 BF1600              <1> 	mov di, 22
  1633 00001C74 E838FC              <1> 	call os_draw_block
  1634 00001C77 61                  <1> 	popa
  1635                              <1> 
  1636 00001C78 E8B701              <1> 	call .draw_black_bar
  1637                              <1> 
  1638 00001C7B 8B36[641E]          <1> 	mov word si, [.list_string]
  1639 00001C7F E8FA00              <1>  	call .draw_list
  1640                              <1> 
  1641                              <1> .another_key:
  1642 00001C82 E8F4F5              <1> 	call os_wait_for_key		; Move / select option
  1643 00001C85 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  1644 00001C88 7420                <1> 	je .go_up
  1645 00001C8A 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  1646 00001C8D 742C                <1> 	je .go_down
  1647 00001C8F 3C0D                <1> 	cmp al, 13			; Enter pressed?
  1648 00001C91 0F849B00            <1> 	je .option_selected
  1649 00001C95 3C1B                <1> 	cmp al, 27			; Esc pressed?
  1650 00001C97 0F84C400            <1> 	je .esc_pressed
  1651 00001C9B 3C09                <1> 	cmp al, 9			; Tab pressed?
  1652 00001C9D 7402                <1> 	je .tab_pressed
  1653 00001C9F EBC3                <1> 	jmp .more_select	; If not, wait for another key
  1654                              <1> 
  1655                              <1> .tab_pressed:
  1656 00001CA1 B606                <1> 	mov dh, 6
  1657 00001CA3 C606[631E]00        <1> 	mov byte [.skip_num], 0
  1658 00001CA8 EBBA                <1> 	jmp .more_select
  1659                              <1> 	
  1660                              <1> .go_up:
  1661 00001CAA 80FE06              <1> 	cmp dh, 6			; Already at top?
  1662 00001CAD 7E2F                <1> 	jle .hit_top
  1663                              <1> 
  1664 00001CAF E89701              <1> 	call .draw_white_bar
  1665                              <1> 
  1666 00001CB2 B219                <1> 	mov dl, 25
  1667 00001CB4 E8AEFB              <1> 	call os_move_cursor
  1668                              <1> 
  1669 00001CB7 FECE                <1> 	dec dh				; Row to select (increasing down)
  1670 00001CB9 EBA9                <1> 	jmp .more_select
  1671                              <1> 
  1672                              <1> 
  1673                              <1> .go_down:				; Already at bottom of list?
  1674 00001CBB 80FE14              <1> 	cmp dh, 20
  1675 00001CBE 742E                <1> 	je .hit_bottom
  1676                              <1> 
  1677                              <1> 	clr cx
    11 00001CC0 31C9                <2>  xor %1, %1
  1678 00001CC2 88F1                <1> 	mov byte cl, dh
  1679                              <1> 
  1680 00001CC4 80E905              <1> 	sub cl, 5
  1681 00001CC7 020E[631E]          <1> 	add byte cl, [.skip_num]
  1682                              <1> 
  1683 00001CCB A0[621E]            <1> 	mov byte al, [.num_of_entries]
  1684 00001CCE 38C1                <1> 	cmp cl, al
  1685 00001CD0 741C                <1> 	je .hit_bottom
  1686                              <1> 
  1687 00001CD2 E87401              <1> 	call .draw_white_bar
  1688                              <1> 
  1689 00001CD5 B219                <1> 	mov dl, 25
  1690 00001CD7 E88BFB              <1> 	call os_move_cursor
  1691                              <1> 
  1692 00001CDA FEC6                <1> 	inc dh
  1693 00001CDC EB86                <1> 	jmp .more_select
  1694                              <1> 
  1695                              <1> 
  1696                              <1> .hit_top:
  1697 00001CDE 8A0E[631E]          <1> 	mov byte cl, [.skip_num]	; Any lines to scroll up?
  1698 00001CE2 80F900              <1> 	cmp cl, 0
  1699 00001CE5 742C                <1> 	je .skip_to_bottom			; If not, wait for another key
  1700                              <1> 
  1701 00001CE7 FE0E[631E]          <1> 	dec byte [.skip_num]		; If so, decrement lines to skip
  1702 00001CEB E976FF              <1> 	jmp .more_select
  1703                              <1> 
  1704                              <1> 
  1705                              <1> .hit_bottom:				; See if there's more to scroll
  1706                              <1> 	clr cx
    11 00001CEE 31C9                <2>  xor %1, %1
  1707 00001CF0 88F1                <1> 	mov byte cl, dh
  1708                              <1> 
  1709 00001CF2 80E906              <1> 	sub cl, 6
  1710 00001CF5 FEC1                <1> 	inc cl
  1711 00001CF7 020E[631E]          <1> 	add byte cl, [.skip_num]
  1712                              <1> 
  1713 00001CFB A0[621E]            <1> 	mov byte al, [.num_of_entries]
  1714 00001CFE 38C1                <1> 	cmp cl, al
  1715 00001D00 7407                <1> 	je .skip_to_top
  1716                              <1> 
  1717 00001D02 FE06[631E]          <1> 	inc byte [.skip_num]		; If so, increment lines to skip
  1718 00001D06 E95BFF              <1> 	jmp .more_select
  1719                              <1> 
  1720                              <1> .skip_to_top:
  1721 00001D09 C606[631E]00        <1> 	mov byte [.skip_num], 0
  1722 00001D0E B606                <1> 	mov dh, 6
  1723 00001D10 E951FF              <1> 	jmp .more_select
  1724                              <1> 
  1725                              <1> .skip_to_bottom:
  1726 00001D13 A0[621E]            <1> 	mov al, [.num_of_entries]
  1727 00001D16 3C0F                <1> 	cmp al, 15
  1728 00001D18 7E0A                <1> 	jle .basic_skip
  1729                              <1> 	
  1730                              <1> .no_basic_skip:
  1731 00001D1A B614                <1> 	mov dh, 20
  1732 00001D1C 2C0F                <1> 	sub al, 15
  1733 00001D1E A2[631E]            <1> 	mov [.skip_num], al
  1734                              <1> 
  1735 00001D21 E940FF              <1> 	jmp .more_select
  1736                              <1> 	
  1737                              <1> .basic_skip:
  1738 00001D24 3C00                <1> 	cmp al, 0
  1739 00001D26 7CF2                <1> 	jl .no_basic_skip
  1740 00001D28 88C6                <1> 	mov dh, al
  1741 00001D2A 80C605              <1> 	add dh, 5
  1742 00001D2D E934FF              <1> 	jmp .more_select
  1743                              <1> 	
  1744                              <1> .option_selected:
  1745 00001D30 E867FB              <1> 	call os_show_cursor
  1746                              <1> 
  1747 00001D33 803E[721B]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1748 00001D38 7510                <1> 	jne .no_store_position
  1749                              <1> 	
  1750 00001D3A 8836[731B]          <1> 	mov [os_file_selector.file_selector_cursorpos], dh
  1751 00001D3E A0[631E]            <1> 	mov al, [.skip_num]
  1752 00001D41 A2[741B]            <1> 	mov [os_file_selector.file_selector_skipnum], al
  1753 00001D44 A0[621E]            <1> 	mov al, [.num_of_entries]
  1754 00001D47 A2[751B]            <1> 	mov [os_file_selector.file_selector_numofentries], al
  1755                              <1> 	
  1756                              <1> .no_store_position:
  1757 00001D4A 80EE06              <1> 	sub dh, 6
  1758                              <1> 
  1759 00001D4D 0FB6C6              <1> 	movzx ax, dh
  1760                              <1> 
  1761 00001D50 FEC0                <1> 	inc al				; Options start from 1
  1762 00001D52 0206[631E]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  1763                              <1> 
  1764 00001D56 A3[601E]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  1765                              <1> 
  1766 00001D59 61                  <1> 	popa
  1767                              <1> 
  1768 00001D5A A1[601E]            <1> 	mov word ax, [.tmp]
  1769 00001D5D F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  1770 00001D5E C3                  <1> 	ret
  1771                              <1> 
  1772                              <1> 
  1773                              <1> 
  1774                              <1> .esc_pressed:
  1775 00001D5F E838FB              <1> 	call os_show_cursor
  1776                              <1> 
  1777 00001D62 803E[721B]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1778 00001D67 7510                <1> 	jne .no_store_position_on_exit
  1779                              <1> 	
  1780 00001D69 8836[731B]          <1> 	mov [os_file_selector.file_selector_cursorpos], dh
  1781 00001D6D A0[631E]            <1> 	mov al, [.skip_num]
  1782 00001D70 A2[741B]            <1> 	mov [os_file_selector.file_selector_skipnum], al
  1783 00001D73 A0[621E]            <1> 	mov al, [.num_of_entries]
  1784 00001D76 A2[751B]            <1> 	mov [os_file_selector.file_selector_numofentries], al
  1785                              <1> 	
  1786                              <1> .no_store_position_on_exit:
  1787 00001D79 61                  <1> 	popa
  1788 00001D7A F9                  <1> 	stc				; Set carry for Esc
  1789 00001D7B C3                  <1> 	ret
  1790                              <1> 
  1791                              <1> 
  1792                              <1> 
  1793                              <1> .draw_list:
  1794 00001D7C 60                  <1> 	pusha
  1795                              <1> 
  1796                              <1> 	mov16 dx, 5, 6		; Get into position for option list text
    15 00001D7D BA0506              <2>  mov %1, (%2 + %3 * 256)
  1797 00001D80 E8E2FA              <1> 	call os_move_cursor
  1798                              <1> 
  1799                              <1> 	clr cx				; Skip lines scrolled off the top of the dialog
    11 00001D83 31C9                <2>  xor %1, %1
  1800 00001D85 8A0E[631E]          <1> 	mov byte cl, [.skip_num]
  1801                              <1> 
  1802 00001D89 803E[721B]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1803 00001D8E 747C                <1> 	je .file_draw_list
  1804                              <1> 
  1805                              <1> .skip_loop:
  1806 00001D90 83F900              <1> 	cmp cx, 0
  1807 00001D93 740B                <1> 	je .skip_loop_finished
  1808                              <1> .more_lodsb:
  1809 00001D95 268A04              <1> 	mov al, [es:si]
  1810 00001D98 46                  <1> 	inc si
  1811 00001D99 3C2C                <1> 	cmp al, ','
  1812 00001D9B 75F8                <1> 	jne .more_lodsb
  1813 00001D9D 49                  <1> 	dec cx
  1814 00001D9E EBF0                <1> 	jmp .skip_loop
  1815                              <1> 
  1816                              <1> 
  1817                              <1> .skip_loop_finished:
  1818                              <1> 	clr bx				; Counter for total number of options
    11 00001DA0 31DB                <2>  xor %1, %1
  1819                              <1> 
  1820                              <1> 
  1821                              <1> .more:
  1822 00001DA2 268A04              <1> 	mov al, [es:si]		; Get next character in file name, increment pointer
  1823 00001DA5 46                  <1> 	inc si
  1824                              <1> 	
  1825 00001DA6 3C00                <1> 	cmp al, 0			; End of string?
  1826 00001DA8 7417                <1> 	je .done_list
  1827                              <1> 
  1828 00001DAA 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  1829 00001DAC 7406                <1> 	je .newline
  1830                              <1> 
  1831 00001DAE B40E                <1> 	mov ah, 0Eh
  1832 00001DB0 CD10                <1> 	int 10h
  1833 00001DB2 EBEE                <1> 	jmp .more
  1834                              <1> 
  1835                              <1> .newline:
  1836 00001DB4 B205                <1> 	mov dl, 5			; Go back to starting X position
  1837 00001DB6 FEC6                <1> 	inc dh				; But jump down a line
  1838 00001DB8 E8AAFA              <1> 	call os_move_cursor
  1839                              <1> 
  1840 00001DBB 43                  <1> 	inc bx				; Update the number-of-options counter
  1841 00001DBC 83FB0F              <1> 	cmp bx, 15			; Limit to one screen of options
  1842 00001DBF 7CE1                <1> 	jl .more
  1843                              <1> 
  1844                              <1> .done_list:
  1845 00001DC1 61                  <1> 	popa
  1846                              <1> 
  1847 00001DC2 60                  <1> 	pusha
  1848 00001DC3 52                  <1> 	push dx
  1849                              <1> 	mov16 dx, 5, 22
    15 00001DC4 BA0516              <2>  mov %1, (%2 + %3 * 256)
  1850 00001DC7 E89BFA              <1> 	call os_move_cursor
  1851                              <1> 	
  1852 00001DCA BE[661E]            <1> 	mov si, .string1
  1853 00001DCD E824FA              <1> 	call os_print_string
  1854                              <1> 	
  1855 00001DD0 5A                  <1> 	pop dx
  1856 00001DD1 A0[631E]            <1> 	mov al, [.skip_num]
  1857 00001DD4 00F0                <1> 	add al, dh
  1858 00001DD6 2C05                <1> 	sub al, 5
  1859 00001DD8 0FB6C0              <1> 	movzx ax, al
  1860 00001DDB E8650D              <1> 	call os_int_to_string
  1861 00001DDE 89C6                <1> 	mov si, ax
  1862 00001DE0 E811FA              <1> 	call os_print_string
  1863                              <1> 	
  1864 00001DE3 BE[681E]            <1> 	mov si, .string2
  1865 00001DE6 E80BFA              <1> 	call os_print_string
  1866                              <1> 	
  1867 00001DE9 0FB606[621E]        <1> 	movzx ax, byte [.num_of_entries]
  1868 00001DEE E8520D              <1> 	call os_int_to_string
  1869 00001DF1 89C6                <1> 	mov si, ax
  1870 00001DF3 E8FEF9              <1> 	call os_print_string
  1871                              <1> 	
  1872 00001DF6 BE[6A1E]            <1> 	mov si, .string3
  1873 00001DF9 E8F8F9              <1> 	call os_print_string
  1874                              <1> 	
  1875                              <1> 	
  1876 00001DFC A0[631E]            <1> 	mov al, [.skip_num]
  1877 00001DFF 00F0                <1> 	add al, dh
  1878 00001E01 2C05                <1> 	sub al, 5
  1879 00001E03 0FB6C0              <1> 	movzx ax, al
  1880 00001E06 FF16[6E1E]          <1> 	call [.callback]
  1881                              <1> 	
  1882 00001E0A 61                  <1> 	popa
  1883 00001E0B C3                  <1> 	ret
  1884                              <1> 
  1885                              <1> .file_draw_list:
  1886                              <1> 	clr bx
    11 00001E0C 31DB                <2>  xor %1, %1
  1887                              <1> 
  1888                              <1> .f_more:
  1889 00001E0E 51                  <1> 	push cx
  1890 00001E0F 89C8                <1> 	mov ax, cx
  1891 00001E11 40                  <1> 	inc ax
  1892 00001E12 E8A1FB              <1> 	call os_file_selector.get_filename
  1893 00001E15 BE[471B]            <1> 	mov si, os_file_selector.filename
  1894 00001E18 E8D9F9              <1> 	call os_print_string
  1895 00001E1B 59                  <1> 	pop cx
  1896                              <1> 
  1897 00001E1C B205                <1> 	mov dl, 5			; Go back to starting X position
  1898 00001E1E FEC6                <1> 	inc dh				; But jump down a line
  1899 00001E20 E842FA              <1> 	call os_move_cursor
  1900                              <1> 
  1901 00001E23 41                  <1> 	inc cx
  1902 00001E24 3A0E[621E]          <1> 	cmp cl, [.num_of_entries]
  1903 00001E28 7497                <1> 	je .done_list
  1904                              <1> 
  1905 00001E2A 43                  <1> 	inc bx				; Update the number-of-options counter
  1906 00001E2B 83FB0F              <1> 	cmp bx, 15			; Limit to one screen of options
  1907 00001E2E 7CDE                <1> 	jl .f_more
  1908 00001E30 EB8F                <1> 	jmp .done_list
  1909                              <1> 
  1910                              <1> .draw_black_bar:
  1911 00001E32 60                  <1> 	pusha
  1912                              <1> 
  1913 00001E33 B204                <1> 	mov dl, 4
  1914 00001E35 E82DFA              <1> 	call os_move_cursor
  1915                              <1> 
  1916                              <1> 	mov16 ax, ' ', 09h			; Draw white bar at top
    15 00001E38 B82009              <2>  mov %1, (%2 + %3 * 256)
  1917                              <1> 	mov16 bx, 00001111b, 0	; White text on black background
    15 00001E3B BB0F00              <2>  mov %1, (%2 + %3 * 256)
  1918 00001E3E 8B0E8900            <1> 	mov cx, [0089h]
  1919 00001E42 83E904              <1> 	sub cx, byte 4
  1920 00001E45 CD10                <1> 	int 10h
  1921                              <1> 
  1922 00001E47 61                  <1> 	popa
  1923 00001E48 C3                  <1> 	ret
  1924                              <1> 
  1925                              <1> 
  1926                              <1> 
  1927                              <1> .draw_white_bar:
  1928 00001E49 60                  <1> 	pusha
  1929                              <1> 
  1930 00001E4A B204                <1> 	mov dl, 4
  1931 00001E4C E816FA              <1> 	call os_move_cursor
  1932                              <1> 
  1933                              <1> 	mov16 ax, ' ', 09h			; Draw white bar at top
    15 00001E4F B82009              <2>  mov %1, (%2 + %3 * 256)
  1934                              <1> 	mov16 bx, 11110000b, 0	; White text on black background
    15 00001E52 BBF000              <2>  mov %1, (%2 + %3 * 256)
  1935 00001E55 8B0E8900            <1> 	mov cx, [0089h]
  1936 00001E59 83E904              <1> 	sub cx, byte 4
  1937 00001E5C CD10                <1> 	int 10h
  1938                              <1> 
  1939 00001E5E 61                  <1> 	popa
  1940 00001E5F C3                  <1> 	ret
  1941                              <1> 
  1942                              <1> 
  1943 00001E60 0000                <1> 	.tmp			dw 0
  1944 00001E62 00                  <1> 	.num_of_entries	db 0
  1945 00001E63 00                  <1> 	.skip_num		db 0
  1946 00001E64 0000                <1> 	.list_string	dw 0
  1947 00001E66 2800                <1> 	.string1		db '(', 0
  1948 00001E68 2F00                <1> 	.string2		db '/', 0
  1949 00001E6A 29202000            <1> 	.string3		db ')  ', 0
  1950 00001E6E 0000                <1> 	.callback		dw 0
  1951                              <1> 	
  1952                              <1> ; ------------------------------------------------------------------
  1953                              <1> ; os_draw_background -- Clear screen with white top and bottom bars
  1954                              <1> ; containing text, and a coloured middle section.
  1955                              <1> ; IN: AX/BX = top/bottom string locations, CX = colour (256 if the app wants to display the default background)
  1956                              <1> 
  1957                              <1> os_draw_background:
  1958 00001E70 60                  <1> 	pusha
  1959                              <1> 	
  1960 00001E71 50                  <1> 	push ax				; Store params to pop out later
  1961 00001E72 53                  <1> 	push bx
  1962 00001E73 51                  <1> 	push cx
  1963                              <1> 
  1964 00001E74 BA0000              <1> 	mov dx, 0
  1965 00001E77 E8EBF9              <1> 	call os_move_cursor
  1966                              <1> 
  1967 00001E7A B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  1968 00001E7D B95000              <1> 	mov cx, 80
  1969 00001E80 BB7000              <1> 	mov bx, 01110000b
  1970 00001E83 CD10                <1> 	int 10h
  1971                              <1> 
  1972 00001E85 BA0001              <1> 	mov dx, 256
  1973 00001E88 E8DAF9              <1> 	call os_move_cursor
  1974                              <1> 	
  1975 00001E8B 5B                  <1> 	pop bx				; Get colour param (originally in CX)
  1976 00001E8C 81FB0001            <1> 	cmp bx, 256
  1977 00001E90 7469                <1> 	je .draw_default_background
  1978                              <1> 	
  1979 00001E92 B82009              <1> 	mov ax, 0920h			; Draw colour section
  1980 00001E95 B93007              <1> 	mov cx, 1840
  1981 00001E98 B700                <1> 	mov bh, 0
  1982 00001E9A CD10                <1> 	int 10h
  1983                              <1> 
  1984                              <1> .bg_drawn:
  1985                              <1> 	mov16 dx, 0, 24
    15 00001E9C BA0018              <2>  mov %1, (%2 + %3 * 256)
  1986 00001E9F E8C3F9              <1> 	call os_move_cursor
  1987                              <1> 
  1988 00001EA2 B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  1989 00001EA5 B95000              <1> 	mov cx, 80
  1990 00001EA8 BB7000              <1> 	mov bx, 01110000b
  1991 00001EAB CD10                <1> 	int 10h
  1992                              <1> 
  1993                              <1> 	mov16 dx, 1, 24
    15 00001EAD BA0118              <2>  mov %1, (%2 + %3 * 256)
  1994 00001EB0 E8B2F9              <1> 	call os_move_cursor
  1995 00001EB3 5E                  <1> 	pop si				; Get bottom string param
  1996 00001EB4 E83DF9              <1> 	call os_print_string
  1997                              <1> 
  1998 00001EB7 BA0100              <1> 	mov dx, 1
  1999 00001EBA E8A8F9              <1> 	call os_move_cursor
  2000 00001EBD 5E                  <1> 	pop si				; Get top string param
  2001 00001EBE E833F9              <1> 	call os_print_string
  2002                              <1> 
  2003 00001EC1 BB[2E1F]            <1> 	mov bx, tmp_string
  2004 00001EC4 E82B0D              <1> 	call os_get_date_string
  2005                              <1> 	
  2006 00001EC7 BA4500              <1> 	mov dx, 69			; Display date
  2007 00001ECA E898F9              <1> 	call os_move_cursor
  2008 00001ECD 89DE                <1> 	mov si, bx
  2009 00001ECF E822F9              <1> 	call os_print_string
  2010                              <1> 	
  2011 00001ED2 BB[2E1F]            <1> 	mov bx, tmp_string
  2012 00001ED5 E8D30C              <1> 	call os_get_time_string
  2013                              <1> 
  2014 00001ED8 BA3F00              <1> 	mov dx, 63			; Display time
  2015 00001EDB E887F9              <1> 	call os_move_cursor
  2016 00001EDE 89DE                <1> 	mov si, bx
  2017 00001EE0 E811F9              <1> 	call os_print_string
  2018                              <1> 	
  2019 00001EE3 B24F                <1> 	mov dl, 79			; Print the little speaker icon
  2020 00001EE5 E87DF9              <1> 	call os_move_cursor
  2021                              <1> 	
  2022 00001EE8 B8170E              <1> 	mov ax, 0E17h
  2023 00001EEB 2A068300            <1> 	sub al, [0083h]
  2024 00001EEF B700                <1> 	mov bh, 0
  2025 00001EF1 CD10                <1> 	int 10h
  2026                              <1> 	
  2027                              <1> 	mov16 dx, 0, 1		; Ready for app text
    15 00001EF3 BA0001              <2>  mov %1, (%2 + %3 * 256)
  2028 00001EF6 E86CF9              <1> 	call os_move_cursor
  2029                              <1> 
  2030 00001EF9 61                  <1> 	popa
  2031 00001EFA C3                  <1> 	ret
  2032                              <1> 
  2033                              <1> .draw_default_background:
  2034 00001EFB 64803E000600        <1> 	cmp byte [fs:DESKTOP_BACKGROUND], 0
  2035 00001F01 741B                <1> 	je .fill_color
  2036                              <1> 	
  2037 00001F03 1E                  <1> 	push ds
  2038 00001F04 06                  <1> 	push es
  2039                              <1> 	
  2040 00001F05 8E1E[F205]          <1> 	mov ds, [driversgmt]
  2041 00001F09 BE0006              <1> 	mov si, DESKTOP_BACKGROUND
  2042                              <1> 
  2043 00001F0C B800B8              <1> 	mov ax, 0B800h
  2044 00001F0F 8EC0                <1> 	mov es, ax
  2045 00001F11 BFA000              <1> 	mov di, 160
  2046                              <1> 	
  2047 00001F14 B9600E              <1> 	mov cx, 80 * 23 * 2
  2048                              <1> 	
  2049 00001F17 F3A4                <1> 	rep movsb
  2050                              <1> 	
  2051 00001F19 07                  <1> 	pop es
  2052 00001F1A 1F                  <1> 	pop ds
  2053 00001F1B E97EFF              <1> 	jmp .bg_drawn
  2054                              <1> 	
  2055                              <1> .fill_color:
  2056 00001F1E 0FB61EA8DE          <1> 	movzx bx, byte [57000]
  2057 00001F23 B82009              <1> 	mov ax, 0920h
  2058 00001F26 B93007              <1> 	mov cx, 1840
  2059                              <1> 
  2060 00001F29 CD10                <1> 	int 10h
  2061 00001F2B E96EFF              <1> 	jmp .bg_drawn
  2062                              <1> 
  2063 00001F2E 00<rep Fh>          <1> 	tmp_string			times 15 db 0
  2064                              <1> 
  2065                              <1> 
  2066                              <1> ; ------------------------------------------------------------------
  2067                              <1> ; os_print_newline -- Reset cursor to start of next line
  2068                              <1> ; IN/OUT: Nothing (registers preserved)
  2069                              <1> 
  2070                              <1> os_print_newline:
  2071 00001F3D 60                  <1> 	pusha
  2072                              <1> 
  2073 00001F3E B40E                <1> 	mov ah, 0Eh			; BIOS output char code
  2074                              <1> 
  2075 00001F40 B00D                <1> 	mov al, 13
  2076 00001F42 CD10                <1> 	int 10h
  2077 00001F44 B00A                <1> 	mov al, 10
  2078 00001F46 CD10                <1> 	int 10h
  2079                              <1> 
  2080 00001F48 61                  <1> 	popa
  2081 00001F49 C3                  <1> 	ret
  2082                              <1> 
  2083                              <1> 
  2084                              <1> ; ------------------------------------------------------------------
  2085                              <1> ; os_dump_registers -- Displays register contents in hex on the screen
  2086                              <1> ; IN/OUT: EAX/EBX/ECX/EDX/ESI/EDI = registers to show
  2087                              <1> 
  2088                              <1> os_dump_registers:
  2089 00001F4A 6660                <1> 	pushad
  2090                              <1> 
  2091 00001F4C 6657                <1> 	push edi
  2092 00001F4E 68[9B1F]            <1> 	push .di_string
  2093 00001F51 6656                <1> 	push esi
  2094 00001F53 68[951F]            <1> 	push .si_string
  2095 00001F56 6652                <1> 	push edx
  2096 00001F58 68[8F1F]            <1> 	push .dx_string
  2097 00001F5B 6651                <1> 	push ecx
  2098 00001F5D 68[891F]            <1> 	push .cx_string
  2099 00001F60 6653                <1> 	push ebx
  2100 00001F62 68[831F]            <1> 	push .bx_string
  2101 00001F65 6650                <1> 	push eax
  2102 00001F67 68[7E1F]            <1> 	push .ax_string
  2103                              <1> 	
  2104 00001F6A B90600              <1> 	mov cx, 6
  2105                              <1> 	
  2106                              <1> .loop:
  2107 00001F6D 5E                  <1> 	pop si
  2108 00001F6E E883F8              <1> 	call os_print_string
  2109 00001F71 6658                <1> 	pop eax
  2110 00001F73 E8B903              <1> 	call os_print_8hex
  2111 00001F76 E2F5                <1> 	loop .loop
  2112                              <1> 	
  2113 00001F78 E8C2FF              <1> 	call os_print_newline
  2114                              <1> 
  2115 00001F7B 6661                <1> 	popad
  2116 00001F7D C3                  <1> 	ret
  2117                              <1> 
  2118                              <1> 
  2119 00001F7E 4541583A00          <1> 	.ax_string		db 'EAX:', 0
  2120 00001F83 204542583A00        <1> 	.bx_string		db ' EBX:', 0
  2121 00001F89 204543583A00        <1> 	.cx_string		db ' ECX:', 0
  2122 00001F8F 204544583A00        <1> 	.dx_string		db ' EDX:', 0
  2123 00001F95 204553493A00        <1> 	.si_string		db ' ESI:', 0
  2124 00001F9B 204544493A00        <1> 	.di_string		db ' EDI:', 0
  2125                              <1> 
  2126                              <1> 
  2127                              <1> ; ------------------------------------------------------------------
  2128                              <1> ; os_input_dialog -- Get text string from user via a dialog box
  2129                              <1> ; IN: AX = string location, BX = message to show; OUT: AX = string location
  2130                              <1> 
  2131                              <1> os_input_dialog:
  2132 00001FA1 60                  <1> 	pusha
  2133                              <1> 
  2134 00001FA2 50                  <1> 	push ax				; Save string location
  2135 00001FA3 53                  <1> 	push bx				; Save message to show
  2136                              <1> 
  2137                              <1> 
  2138                              <1> 	mov16 dx, 12, 10			; First, draw red background box
    15 00001FA4 BA0C0A              <2>  mov %1, (%2 + %3 * 256)
  2139                              <1> 
  2140                              <1> .redbox:				; Loop to draw all lines of box
  2141 00001FA7 E8BBF8              <1> 	call os_move_cursor
  2142                              <1> 
  2143 00001FAA 60                  <1> 	pusha
  2144                              <1> 	mov16 ax, ' ', 09h
    15 00001FAB B82009              <2>  mov %1, (%2 + %3 * 256)
  2145 00001FAE B93700              <1> 	mov cx, 55
  2146 00001FB1 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  2147 00001FB6 CD10                <1> 	int 10h
  2148 00001FB8 61                  <1> 	popa
  2149                              <1> 
  2150 00001FB9 FEC6                <1> 	inc dh
  2151 00001FBB 80FE10              <1> 	cmp dh, 16
  2152 00001FBE 7402                <1> 	je .boxdone
  2153 00001FC0 EBE5                <1> 	jmp .redbox
  2154                              <1> 
  2155                              <1> 
  2156                              <1> .boxdone:
  2157                              <1> 	mov16 dx, 14, 14
    15 00001FC2 BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2158 00001FC5 E89DF8              <1> 	call os_move_cursor
  2159                              <1> 
  2160                              <1> 	mov16 ax, ' ', 09h
    15 00001FC8 B82009              <2>  mov %1, (%2 + %3 * 256)
  2161 00001FCB BBF000              <1> 	mov bx, 240
  2162 00001FCE B93300              <1> 	mov cx, 51
  2163 00001FD1 CD10                <1> 	int 10h
  2164                              <1> 	
  2165                              <1> 	mov16 dx, 14, 11
    15 00001FD3 BA0E0B              <2>  mov %1, (%2 + %3 * 256)
  2166 00001FD6 E88CF8              <1> 	call os_move_cursor
  2167                              <1> 	
  2168                              <1> 
  2169 00001FD9 5B                  <1> 	pop bx				; Get message back and display it
  2170 00001FDA 89DE                <1> 	mov si, bx
  2171 00001FDC E815F8              <1> 	call os_print_string
  2172                              <1> 
  2173                              <1> 	mov16 dx, 14, 14
    15 00001FDF BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2174 00001FE2 E880F8              <1> 	call os_move_cursor
  2175                              <1> 
  2176                              <1> 
  2177 00001FE5 58                  <1> 	pop ax				; Get input string back
  2178 00001FE6 E8C301              <1> 	call os_input_string
  2179                              <1> 
  2180 00001FE9 61                  <1> 	popa
  2181 00001FEA C3                  <1> 	ret
  2182                              <1> 
  2183                              <1> ; ------------------------------------------------------------------
  2184                              <1> ; os_password_dialog -- Get a password from user via a dialog box
  2185                              <1> ; IN: AX = string location, BX = message to show; OUT: AX = string location
  2186                              <1> 
  2187                              <1> os_password_dialog:
  2188 00001FEB 60                  <1> 	pusha
  2189                              <1> 
  2190 00001FEC 50                  <1> 	push ax				; Save string location
  2191 00001FED 53                  <1> 	push bx				; Save message to show
  2192                              <1> 
  2193                              <1> 
  2194                              <1> 	mov16 dx, 12, 10			; First, draw red background box
    15 00001FEE BA0C0A              <2>  mov %1, (%2 + %3 * 256)
  2195                              <1> 
  2196                              <1> .redbox:				; Loop to draw all lines of box
  2197 00001FF1 E871F8              <1> 	call os_move_cursor
  2198                              <1> 
  2199 00001FF4 60                  <1> 	pusha
  2200                              <1> 	mov16 ax, ' ', 09h
    15 00001FF5 B82009              <2>  mov %1, (%2 + %3 * 256)
  2201 00001FF8 B93700              <1> 	mov cx, 55
  2202 00001FFB 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  2203 00002000 CD10                <1> 	int 10h
  2204 00002002 61                  <1> 	popa
  2205                              <1> 
  2206 00002003 FEC6                <1> 	inc dh
  2207 00002005 80FE10              <1> 	cmp dh, 16
  2208 00002008 7402                <1> 	je .boxdone
  2209 0000200A EBE5                <1> 	jmp .redbox
  2210                              <1> 
  2211                              <1> 
  2212                              <1> .boxdone:
  2213                              <1> 	mov16 dx, 14, 14
    15 0000200C BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2214 0000200F E853F8              <1> 	call os_move_cursor
  2215                              <1> 
  2216                              <1> 	mov16 ax, ' ', 09h
    15 00002012 B82009              <2>  mov %1, (%2 + %3 * 256)
  2217 00002015 BBF000              <1> 	mov bx, 240
  2218 00002018 B93300              <1> 	mov cx, 51
  2219 0000201B CD10                <1> 	int 10h
  2220                              <1> 	
  2221                              <1> 	mov16 dx, 14, 11
    15 0000201D BA0E0B              <2>  mov %1, (%2 + %3 * 256)
  2222 00002020 E842F8              <1> 	call os_move_cursor
  2223                              <1> 	
  2224                              <1> 
  2225 00002023 5B                  <1> 	pop bx				; Get message back and display it
  2226 00002024 89DE                <1> 	mov si, bx
  2227 00002026 E8CBF7              <1> 	call os_print_string
  2228                              <1> 
  2229                              <1> 	mov16 dx, 14, 14
    15 00002029 BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2230 0000202C E836F8              <1> 	call os_move_cursor
  2231                              <1> 
  2232                              <1> 
  2233 0000202F 58                  <1> 	pop ax				; Get input string back
  2234 00002030 B3F0                <1> 	mov bl, 240
  2235 00002032 E8E101              <1> 	call os_input_password
  2236                              <1> 
  2237 00002035 61                  <1> 	popa
  2238 00002036 C3                  <1> 	ret
  2239                              <1> 
  2240                              <1> 
  2241                              <1> ; ------------------------------------------------------------------
  2242                              <1> ; os_dialog_box -- Print dialog box in middle of screen, with button(s)
  2243                              <1> ; IN: AX, BX, CX = string locations (set registers to 0 for no display),
  2244                              <1> ; IN: DX = 0 for single 'OK' dialog, 1 for two-button 'OK' and 'Cancel'
  2245                              <1> ; IN: [0085h] = Default button for 2-button dialog (0 or 1)
  2246                              <1> ; OUT: If two-button mode, AX = 0 for OK and 1 for cancel
  2247                              <1> ; NOTE: Each string is limited to 40 characters
  2248                              <1> 
  2249                              <1> os_dialog_box:
  2250 00002037 60                  <1> 	pusha
  2251                              <1> 
  2252 00002038 52                  <1> 	push dx
  2253                              <1> 
  2254 00002039 51                  <1> 	push cx
  2255 0000203A 53                  <1> 	push bx
  2256 0000203B 50                  <1> 	push ax
  2257                              <1> 	
  2258 0000203C E866F8              <1> 	call os_hide_cursor
  2259                              <1> 
  2260 0000203F 60                  <1> 	pusha
  2261 00002040 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  2262                              <1> 	mov16 dx, 19, 9			; First, draw red background box
    15 00002044 BA1309              <2>  mov %1, (%2 + %3 * 256)
  2263 00002047 BE2A00              <1> 	mov si, 42
  2264 0000204A BF1000              <1> 	mov di, 16
  2265 0000204D E85FF8              <1> 	call os_draw_block
  2266 00002050 61                  <1> 	popa
  2267                              <1> 	
  2268                              <1> 	mov16 dx, 20, 9
    15 00002051 BA1409              <2>  mov %1, (%2 + %3 * 256)
  2269 00002054 B90300              <1> 	mov cx, 3
  2270                              <1> 	
  2271                              <1> .loop:
  2272 00002057 FEC6                <1> 	inc dh
  2273 00002059 E809F8              <1> 	call os_move_cursor
  2274                              <1> 	
  2275 0000205C 5E                  <1> 	pop si
  2276 0000205D 83FE00              <1> 	cmp si, 0
  2277 00002060 7403                <1> 	je .no_string
  2278                              <1> 	
  2279 00002062 E88FF7              <1> 	call os_print_string
  2280                              <1> 	
  2281                              <1> .no_string:
  2282 00002065 E2F0                <1> 	loop .loop
  2283                              <1> 	
  2284 00002067 5A                  <1> 	pop dx
  2285 00002068 83FA01              <1> 	cmp dx, 1
  2286 0000206B 7426                <1> 	je .two_button
  2287                              <1> 
  2288                              <1> 	
  2289                              <1> .one_button:
  2290 0000206D B3F0                <1> 	mov bl, 11110000b		; Black on white
  2291                              <1> 	mov16 dx, 35, 14
    15 0000206F BA230E              <2>  mov %1, (%2 + %3 * 256)
  2292 00002072 BE0800              <1> 	mov si, 8
  2293 00002075 BF0F00              <1> 	mov di, 15
  2294 00002078 E834F8              <1> 	call os_draw_block
  2295                              <1> 
  2296                              <1> 	mov16 dx, 38, 14		; OK button, centred at bottom of box
    15 0000207B BA260E              <2>  mov %1, (%2 + %3 * 256)
  2297 0000207E E8E4F7              <1> 	call os_move_cursor
  2298 00002081 BE[6221]            <1> 	mov si, .ok_button_string
  2299 00002084 E86DF7              <1> 	call os_print_string
  2300                              <1> 
  2301                              <1> .one_button_wait:
  2302 00002087 E8EFF1              <1> 	call os_wait_for_key
  2303 0000208A 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
  2304 0000208C 75F9                <1> 	jne .one_button_wait
  2305                              <1> 
  2306 0000208E E809F8              <1> 	call os_show_cursor
  2307                              <1> 
  2308 00002091 61                  <1> 	popa
  2309 00002092 C3                  <1> 	ret
  2310                              <1> 
  2311                              <1> .two_button:
  2312 00002093 B3F0                <1> 	mov bl, 11110000b		; Black on white
  2313                              <1> 	mov16 dx, 27, 14
    15 00002095 BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  2314 00002098 BE0800              <1> 	mov si, 8
  2315 0000209B BF0F00              <1> 	mov di, 15
  2316 0000209E E80EF8              <1> 	call os_draw_block
  2317                              <1> 
  2318                              <1> 	mov16 dx, 30, 14			; OK button
    15 000020A1 BA1E0E              <2>  mov %1, (%2 + %3 * 256)
  2319 000020A4 E8BEF7              <1> 	call os_move_cursor
  2320 000020A7 BE[6221]            <1> 	mov si, .ok_button_string
  2321 000020AA E847F7              <1> 	call os_print_string
  2322                              <1> 
  2323                              <1> 	mov16 dx, 44, 14			; Cancel button
    15 000020AD BA2C0E              <2>  mov %1, (%2 + %3 * 256)
  2324 000020B0 E8B2F7              <1> 	call os_move_cursor
  2325 000020B3 BE[6521]            <1> 	mov si, .cancel_button_string
  2326 000020B6 E83BF7              <1> 	call os_print_string
  2327                              <1> 
  2328 000020B9 803E850001          <1> 	cmp byte [0085h], 1
  2329 000020BE 7466                <1> 	je .draw_right
  2330 000020C0 7529                <1> 	jne .draw_left
  2331                              <1> 	
  2332                              <1> .two_button_wait:
  2333 000020C2 E8B4F1              <1> 	call os_wait_for_key
  2334                              <1> 
  2335 000020C5 80FC4B              <1> 	cmp ah, 75			; Left cursor key pressed?
  2336 000020C8 7421                <1> 	je .draw_left
  2337 000020CA 80FC4D              <1> 	cmp ah, 77			; Right cursor key pressed?
  2338 000020CD 7457                <1> 	je .draw_right
  2339                              <1> 	
  2340 000020CF 3C1B                <1> 	cmp al, 27			; Escape, automatically select "Cancel"
  2341 000020D1 7410                <1> 	je .cancel
  2342 000020D3 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
  2343 000020D5 75EB                <1> 	jne .two_button_wait
  2344                              <1> 	
  2345 000020D7 E8C0F7              <1> 	call os_show_cursor
  2346                              <1> 
  2347 000020DA 890E[6C21]          <1> 	mov [.tmp], cx			; Keep result after restoring all regs
  2348 000020DE 61                  <1> 	popa
  2349 000020DF A1[6C21]            <1> 	mov ax, [.tmp]
  2350                              <1> 
  2351 000020E2 C3                  <1> 	ret
  2352                              <1> 
  2353                              <1> .cancel:
  2354 000020E3 E8B4F7              <1> 	call os_show_cursor
  2355 000020E6 61                  <1> 	popa
  2356 000020E7 B80100              <1> 	mov ax, 1
  2357 000020EA C3                  <1> 	ret
  2358                              <1> 
  2359                              <1> .draw_left:
  2360 000020EB B3F0                <1> 	mov bl, 11110000b		; Black on white
  2361                              <1> 	mov16 dx, 27, 14
    15 000020ED BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  2362 000020F0 BE0800              <1> 	mov si, 8
  2363 000020F3 BF0F00              <1> 	mov di, 15
  2364 000020F6 E8B6F7              <1> 	call os_draw_block
  2365                              <1> 
  2366                              <1> 	mov16 dx, 30, 14		; OK button
    15 000020F9 BA1E0E              <2>  mov %1, (%2 + %3 * 256)
  2367 000020FC E866F7              <1> 	call os_move_cursor
  2368 000020FF BE[6221]            <1> 	mov si, .ok_button_string
  2369 00002102 E8EFF6              <1> 	call os_print_string
  2370                              <1> 
  2371 00002105 8A1EA9DE            <1> 	mov bl, [57001]
  2372                              <1> 	mov16 dx, 42, 14
    15 00002109 BA2A0E              <2>  mov %1, (%2 + %3 * 256)
  2373 0000210C BE0900              <1> 	mov si, 9
  2374 0000210F BF0F00              <1> 	mov di, 15
  2375 00002112 E89AF7              <1> 	call os_draw_block
  2376                              <1> 
  2377                              <1> 	mov16 dx, 44, 14		; Cancel button
    15 00002115 BA2C0E              <2>  mov %1, (%2 + %3 * 256)
  2378 00002118 E84AF7              <1> 	call os_move_cursor
  2379 0000211B BE[6521]            <1> 	mov si, .cancel_button_string
  2380 0000211E E8D3F6              <1> 	call os_print_string
  2381                              <1> 
  2382 00002121 B90000              <1> 	mov cx, 0			; And update result we'll return
  2383 00002124 EB9C                <1> 	jmp .two_button_wait
  2384                              <1> 
  2385                              <1> .draw_right:
  2386 00002126 8A1EA9DE            <1> 	mov bl, [57001]
  2387                              <1> 	mov16 dx, 27, 14
    15 0000212A BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  2388 0000212D BE0800              <1> 	mov si, 8
  2389 00002130 BF0F00              <1> 	mov di, 15
  2390 00002133 E879F7              <1> 	call os_draw_block
  2391                              <1> 
  2392                              <1> 	mov16 dx, 30, 14			; OK button
    15 00002136 BA1E0E              <2>  mov %1, (%2 + %3 * 256)
  2393 00002139 E829F7              <1> 	call os_move_cursor
  2394 0000213C BE[6221]            <1> 	mov si, .ok_button_string
  2395 0000213F E8B2F6              <1> 	call os_print_string
  2396                              <1> 
  2397 00002142 B3F0                <1> 	mov bl, 11110000b
  2398                              <1> 	mov16 dx, 43, 14
    15 00002144 BA2B0E              <2>  mov %1, (%2 + %3 * 256)
  2399 00002147 BE0800              <1> 	mov si, 8
  2400 0000214A BF0F00              <1> 	mov di, 15
  2401 0000214D E85FF7              <1> 	call os_draw_block
  2402                              <1> 
  2403                              <1> 	mov16 dx, 44, 14			; Cancel button
    15 00002150 BA2C0E              <2>  mov %1, (%2 + %3 * 256)
  2404 00002153 E80FF7              <1> 	call os_move_cursor
  2405 00002156 BE[6521]            <1> 	mov si, .cancel_button_string
  2406 00002159 E898F6              <1> 	call os_print_string
  2407                              <1> 
  2408 0000215C B90100              <1> 	mov cx, 1			; And update result we'll return
  2409 0000215F E960FF              <1> 	jmp .two_button_wait
  2410                              <1> 
  2411                              <1> 
  2412                              <1> 
  2413 00002162 4F4B00              <1> 	.ok_button_string	db 'OK', 0
  2414 00002165 43616E63656C00      <1> 	.cancel_button_string	db 'Cancel', 0
  2415                              <1> 
  2416 0000216C 0000                <1> 	.tmp dw 0
  2417                              <1> 
  2418                              <1> ; ------------------------------------------------------------------
  2419                              <1> ; os_print_space -- Print a space to the screen
  2420                              <1> ; IN/OUT: Nothing
  2421                              <1> 
  2422                              <1> os_print_space:
  2423 0000216E 60                  <1> 	pusha
  2424                              <1> 
  2425 0000216F B8200E              <1> 	mov ax, 0E20h			; BIOS teletype function
  2426 00002172 CD10                <1> 	int 10h
  2427                              <1> 
  2428 00002174 61                  <1> 	popa
  2429 00002175 C3                  <1> 	ret
  2430                              <1> 
  2431                              <1> 
  2432                              <1> ; ------------------------------------------------------------------
  2433                              <1> ; os_print_digit -- Displays contents of AX as a single digit
  2434                              <1> ; Works up to base 37, ie digits 0-Z
  2435                              <1> ; IN: AX = "digit" to format and print
  2436                              <1> 
  2437                              <1> os_print_digit:
  2438 00002176 60                  <1> 	pusha
  2439                              <1> 
  2440 00002177 83F809              <1> 	cmp ax, 9			; There is a break in ASCII table between 9 and A
  2441 0000217A 7E03                <1> 	jle .digit_format
  2442                              <1> 
  2443 0000217C 83C007              <1> 	add ax, 'A'-'9'-1		; Correct for the skipped punctuation
  2444                              <1> 
  2445                              <1> .digit_format:
  2446 0000217F 83C030              <1> 	add ax, '0'			; 0 will display as '0', etc.	
  2447                              <1> 
  2448 00002182 B40E                <1> 	mov ah, 0Eh			; May modify other registers
  2449 00002184 CD10                <1> 	int 10h
  2450                              <1> 
  2451 00002186 61                  <1> 	popa
  2452 00002187 C3                  <1> 	ret
  2453                              <1> 
  2454                              <1> 
  2455                              <1> ; ------------------------------------------------------------------
  2456                              <1> ; os_print_1hex -- Displays low nibble of AL in hex format
  2457                              <1> ; IN: AL = number to format and print
  2458                              <1> 
  2459                              <1> os_print_1hex:
  2460 00002188 60                  <1> 	pusha
  2461                              <1> 
  2462 00002189 83E00F              <1> 	and ax, 0Fh			; Mask off data to display
  2463 0000218C E8E7FF              <1> 	call os_print_digit
  2464                              <1> 
  2465 0000218F 61                  <1> 	popa
  2466 00002190 C3                  <1> 	ret
  2467                              <1> 
  2468                              <1> 
  2469                              <1> ; ------------------------------------------------------------------
  2470                              <1> ; os_print_2hex -- Displays AL in hex format
  2471                              <1> ; IN: AL = number to format and print
  2472                              <1> 
  2473                              <1> os_print_2hex:
  2474 00002191 60                  <1> 	pusha
  2475                              <1> 
  2476 00002192 50                  <1> 	push ax				; Output high nibble
  2477 00002193 C1E804              <1> 	shr ax, 4
  2478 00002196 E8EFFF              <1> 	call os_print_1hex
  2479                              <1> 
  2480 00002199 58                  <1> 	pop ax				; Output low nibble
  2481 0000219A E8EBFF              <1> 	call os_print_1hex
  2482                              <1> 
  2483 0000219D 61                  <1> 	popa
  2484 0000219E C3                  <1> 	ret
  2485                              <1> 
  2486                              <1> 
  2487                              <1> ; ------------------------------------------------------------------
  2488                              <1> ; os_print_4hex -- Displays AX in hex format
  2489                              <1> ; IN: AX = number to format and print
  2490                              <1> 
  2491                              <1> os_print_4hex:
  2492 0000219F 60                  <1> 	pusha
  2493                              <1> 
  2494 000021A0 50                  <1> 	push ax				; Output high byte
  2495 000021A1 88E0                <1> 	mov al, ah
  2496 000021A3 E8EBFF              <1> 	call os_print_2hex
  2497                              <1> 
  2498 000021A6 58                  <1> 	pop ax				; Output low byte
  2499 000021A7 E8E7FF              <1> 	call os_print_2hex
  2500                              <1> 
  2501 000021AA 61                  <1> 	popa
  2502 000021AB C3                  <1> 	ret
  2503                              <1> 
  2504                              <1> 
  2505                              <1> ; ------------------------------------------------------------------
  2506                              <1> ; os_input_string -- Take string from keyboard entry
  2507                              <1> ; IN/OUT: AX = location of string, other regs preserved
  2508                              <1> ; (Location will contain up to [0088h] characters, zero-terminated)
  2509                              <1> 
  2510                              <1> os_input_string:
  2511 000021AC 60                  <1> 	pusha
  2512                              <1> 
  2513 000021AD E8EAF6              <1> 	call os_show_cursor
  2514                              <1> 	
  2515 000021B0 89C7                <1> 	mov di, ax			; DI is where we'll store input (buffer)
  2516 000021B2 B90000              <1> 	mov cx, 0			; Character received counter for backspace
  2517                              <1> 
  2518                              <1> 
  2519                              <1> .more:					; Now onto string getting
  2520 000021B5 E8C1F0              <1> 	call os_wait_for_key
  2521                              <1> 
  2522 000021B8 3C0D                <1> 	cmp al, 13			; If Enter key pressed, finish
  2523 000021BA 7455                <1> 	je .done
  2524                              <1> 
  2525 000021BC 3C08                <1> 	cmp al, 8			; Backspace pressed?
  2526 000021BE 7406                <1> 	je .backspace			; If not, skip following checks
  2527                              <1> 
  2528 000021C0 3C20                <1> 	cmp al, ' '			; In ASCII range (32 - 127)?
  2529 000021C2 7CF1                <1> 	jl .more			; Ignore most non-printing characters
  2530                              <1> 
  2531 000021C4 EB35                <1> 	jmp .nobackspace
  2532                              <1> 
  2533                              <1> 
  2534                              <1> .backspace:
  2535 000021C6 83F900              <1> 	cmp cx, 0			; Backspace at start of string?
  2536 000021C9 74EA                <1> 	je .more			; Ignore it if so
  2537                              <1> 
  2538 000021CB E8A0F6              <1> 	call os_get_cursor_pos		; Backspace at start of screen line?
  2539 000021CE 80FA00              <1> 	cmp dl, 0
  2540 000021D1 7413                <1> 	je .backspace_linestart
  2541                              <1> 
  2542 000021D3 60                  <1> 	pusha
  2543 000021D4 B8080E              <1> 	mov ax, 0E08h		; If not, write space and move cursor back
  2544 000021D7 CD10                <1> 	int 10h				; Backspace twice, to clear space
  2545 000021D9 B020                <1> 	mov al, 32
  2546 000021DB CD10                <1> 	int 10h
  2547 000021DD B008                <1> 	mov al, 8
  2548 000021DF CD10                <1> 	int 10h
  2549 000021E1 61                  <1> 	popa
  2550                              <1> 
  2551 000021E2 4F                  <1> 	dec di				; Character position will be overwritten by new
  2552                              <1> 						; character or terminator at end
  2553                              <1> 
  2554 000021E3 49                  <1> 	dec cx				; Step back counter
  2555                              <1> 
  2556 000021E4 EBCF                <1> 	jmp .more
  2557                              <1> 
  2558                              <1> 
  2559                              <1> .backspace_linestart:
  2560 000021E6 FECE                <1> 	dec dh				; Jump back to end of previous line
  2561 000021E8 B24F                <1> 	mov dl, 79
  2562 000021EA E878F6              <1> 	call os_move_cursor
  2563                              <1> 
  2564 000021ED B8200E              <1> 	mov ax, 0E20h		; Print space there
  2565 000021F0 CD10                <1> 	int 10h
  2566                              <1> 
  2567 000021F2 B24F                <1> 	mov dl, 79			; And jump back before the space
  2568 000021F4 E86EF6              <1> 	call os_move_cursor
  2569                              <1> 
  2570 000021F7 4F                  <1> 	dec di				; Step back position in string
  2571 000021F8 49                  <1> 	dec cx				; Step back counter
  2572                              <1> 
  2573 000021F9 EBBA                <1> 	jmp .more
  2574                              <1> 
  2575                              <1> 
  2576                              <1> .nobackspace:
  2577 000021FB 0FB61E8800          <1> 	movzx bx, byte [0088h]
  2578 00002200 39D9                <1> 	cmp cx, bx			; Make sure we don't exhaust buffer
  2579 00002202 0F8DAFFF            <1> 	jge near .more
  2580                              <1> 
  2581 00002206 60                  <1> 	pusha
  2582 00002207 B40E                <1> 	mov ah, 0Eh			; Output entered, printable character
  2583 00002209 CD10                <1> 	int 10h
  2584 0000220B 61                  <1> 	popa
  2585                              <1> 
  2586 0000220C AA                  <1> 	stosb				; Store character in designated buffer
  2587 0000220D 41                  <1> 	inc cx				; Characters processed += 1
  2588                              <1> 	
  2589 0000220E E9A4FF              <1> 	jmp near .more			; Still room for more
  2590                              <1> 
  2591                              <1> .done:
  2592 00002211 B000                <1> 	mov al, 0
  2593 00002213 AA                  <1> 	stosb
  2594                              <1> 
  2595 00002214 61                  <1> 	popa
  2596 00002215 C3                  <1> 	ret
  2597                              <1> 
  2598                              <1> ; Input password(displays it as *s)
  2599                              <1> ; IN: AX = location of string, other regs preserved, BL = color
  2600                              <1> ; OUT: nothing
  2601                              <1> ; (Location will contain up to [0088h] characters, zero-terminated)
  2602                              <1> 
  2603                              <1> os_input_password:
  2604 00002216 60                  <1> 	pusha
  2605                              <1> 
  2606 00002217 E854F6              <1> 	call os_get_cursor_pos	; Store the cursor position
  2607 0000221A 8916[8722]          <1> 	mov [.cursor], dx
  2608                              <1> 	
  2609 0000221E 89C7                <1> 	mov di, ax			; DI is where we'll store input (buffer)
  2610 00002220 B90000              <1> 	mov cx, 0			; Character received counter for backspace
  2611                              <1> 
  2612                              <1> .more:					; Now onto string getting
  2613 00002223 E853F0              <1> 	call os_wait_for_key
  2614                              <1> 
  2615 00002226 3C0D                <1> 	cmp al, 13			; If Enter key pressed, finish
  2616 00002228 742E                <1> 	je .done
  2617                              <1> 
  2618 0000222A 3C08                <1> 	cmp al, 8			; Backspace pressed?
  2619 0000222C 740A                <1> 	je .backspace			; If not, skip following checks
  2620                              <1> 
  2621 0000222E 3C20                <1> 	cmp al, ' '			; In ASCII range (32 - 126)?
  2622 00002230 7D13                <1> 	jge .nobackspace	; Ignore most non-printing characters
  2623                              <1> 	
  2624 00002232 3C00                <1> 	cmp al, 0
  2625 00002234 7C0F                <1> 	jl .nobackspace
  2626                              <1> 	
  2627 00002236 EBEB                <1> 	jmp .more
  2628                              <1> 
  2629                              <1> 
  2630                              <1> .backspace:
  2631 00002238 83F900              <1> 	cmp cx, 0			; Backspace at start of string?
  2632 0000223B 74E6                <1> 	je .more			; Ignore it if so
  2633                              <1> 
  2634 0000223D 4F                  <1> 	dec di				; Character position will be overwritten by new
  2635                              <1> 						; character or terminator at end
  2636                              <1> 
  2637 0000223E 49                  <1> 	dec cx				; Step back counter
  2638                              <1> 
  2639 0000223F E81C00              <1> 	call .update
  2640                              <1> 	
  2641 00002242 E9DEFF              <1> 	jmp near .more
  2642                              <1> 
  2643                              <1> 
  2644                              <1> .nobackspace:
  2645 00002245 0FB6168800          <1> 	movzx dx, byte [0088h]
  2646 0000224A 39D1                <1> 	cmp cx, dx			; Make sure we don't exhaust buffer
  2647 0000224C 0F8DD3FF            <1> 	jge near .more
  2648                              <1> 
  2649 00002250 AA                  <1> 	stosb				; Store character in designated buffer
  2650 00002251 41                  <1> 	inc cx				; Characters processed += 1
  2651                              <1> 
  2652 00002252 E80900              <1> 	call .update
  2653                              <1> 	
  2654 00002255 E9CBFF              <1> 	jmp near .more		; Still room for more
  2655                              <1> 
  2656                              <1> .done:
  2657 00002258 B000                <1> 	mov al, 0
  2658 0000225A AA                  <1> 	stosb
  2659                              <1> 
  2660 0000225B 61                  <1> 	popa
  2661 0000225C F8                  <1> 	clc
  2662 0000225D C3                  <1> 	ret
  2663                              <1> 
  2664                              <1> .update:
  2665 0000225E 60                  <1> 	pusha
  2666 0000225F 8B16[8722]          <1> 	mov dx, [.cursor]
  2667 00002263 E8FFF5              <1> 	call os_move_cursor
  2668 00002266 B82009              <1> 	mov ax, 0920h		; Clear the line
  2669 00002269 B700                <1> 	mov bh, 0
  2670 0000226B B92000              <1> 	mov cx, 32
  2671 0000226E CD10                <1> 	int 10h
  2672 00002270 61                  <1> 	popa
  2673                              <1> 
  2674 00002271 60                  <1> 	pusha
  2675 00002272 8B16[8722]          <1> 	mov dx, [.cursor]
  2676 00002276 E8ECF5              <1> 	call os_move_cursor
  2677 00002279 B82A09              <1> 	mov ax, 092Ah		; Print *s(amount in CX)
  2678 0000227C B700                <1> 	mov bh, 0
  2679 0000227E CD10                <1> 	int 10h
  2680 00002280 00CA                <1> 	add dl, cl
  2681 00002282 E8E0F5              <1> 	call os_move_cursor
  2682 00002285 61                  <1> 	popa
  2683 00002286 C3                  <1> 	ret
  2684                              <1> 	
  2685 00002287 0000                <1> 	.cursor			dw 0
  2686                              <1> 	
  2687                              <1> ; Opens up os_list_dialog with color.
  2688                              <1> ; IN: nothing
  2689                              <1> ; OUT: color number(0-15)
  2690                              <1> 
  2691                              <1> os_color_selector:
  2692 00002289 60                  <1> 	pusha
  2693 0000228A B8[9F22]            <1> 	mov ax, .colorlist			; Call os_list_dialog with colors
  2694 0000228D BB[1A23]            <1> 	mov bx, .colormsg0
  2695 00002290 B9[2C23]            <1> 	mov cx, .colormsg1
  2696 00002293 E81DF9              <1> 	call os_list_dialog
  2697                              <1> 	
  2698 00002296 48                  <1> 	dec ax						; Output from os_list_dialog starts with 1, so decrement it
  2699 00002297 A3[2D23]            <1> 	mov [.tmp_word], ax
  2700 0000229A 61                  <1> 	popa
  2701 0000229B A0[2D23]            <1> 	mov al, [.tmp_word]
  2702 0000229E C3                  <1> 	ret
  2703                              <1> 	
  2704 0000229F 426C61636B2C426C75- <1> 	.colorlist	db 'Black,Blue,Green,Cyan,Red,Magenta,Brown,Light Gray,Dark Gray,Light Blue,Light Green,Light Cyan,Light Red,Pink,Yellow,White', 0
  2704 000022A8 652C477265656E2C43- <1>
  2704 000022B1 79616E2C5265642C4D- <1>
  2704 000022BA 6167656E74612C4272- <1>
  2704 000022C3 6F776E2C4C69676874- <1>
  2704 000022CC 20477261792C446172- <1>
  2704 000022D5 6B20477261792C4C69- <1>
  2704 000022DE 67687420426C75652C- <1>
  2704 000022E7 4C6967687420477265- <1>
  2704 000022F0 656E2C4C6967687420- <1>
  2704 000022F9 4379616E2C4C696768- <1>
  2704 00002302 74205265642C50696E- <1>
  2704 0000230B 6B2C59656C6C6F772C- <1>
  2704 00002314 576869746500        <1>
  2705 0000231A 43686F6F7365206120- <1> 	.colormsg0	db 'Choose a color...', 0
  2705 00002323 636F6C6F722E2E2E00  <1>
  2706 0000232C 00                  <1> 	.colormsg1	db 0
  2707 0000232D 0000                <1> 	.tmp_word	dw 0
  2708                              <1> 	
  2709                              <1> ; Displays EAX in hex format
  2710                              <1> ; IN: EAX = unsigned integer
  2711                              <1> ; OUT: nothing
  2712                              <1> os_print_8hex:
  2713 0000232F 6660                <1> 	pushad
  2714 00002331 6660                <1> 	pushad
  2715 00002333 66C1E810            <1> 	shr eax, 16
  2716 00002337 E865FE              <1> 	call os_print_4hex
  2717 0000233A 6661                <1> 	popad
  2718 0000233C E860FE              <1> 	call os_print_4hex
  2719 0000233F 6661                <1> 	popad
  2720 00002341 C3                  <1> 	ret
  2721                              <1> 	
  2722                              <1> ; Displays a dialog similar to os_dialog_box, but without the buttons.
  2723                              <1> ; IN: SI/AX/BX/CX/DX = string locations (or 0 for no display)
  2724                              <1> ; OUT: nothing
  2725                              <1> os_temp_box:
  2726 00002342 60                  <1> 	pusha
  2727                              <1> 
  2728 00002343 52                  <1> 	push dx
  2729 00002344 51                  <1> 	push cx
  2730 00002345 53                  <1> 	push bx
  2731 00002346 50                  <1> 	push ax
  2732 00002347 56                  <1> 	push si
  2733                              <1> 	
  2734 00002348 E85AF5              <1> 	call os_hide_cursor
  2735                              <1> 
  2736                              <1> 	mov16 dx, 19, 9			; First, draw red background box
    15 0000234B BA1309              <2>  mov %1, (%2 + %3 * 256)
  2737                              <1> 
  2738                              <1> .redbox:				; Loop to draw all lines of box
  2739 0000234E E814F5              <1> 	call os_move_cursor
  2740                              <1> 
  2741 00002351 60                  <1> 	pusha
  2742 00002352 B82009              <1> 	mov ax, 0920h
  2743 00002355 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  2744 0000235A B92A00              <1> 	mov cx, 42
  2745 0000235D CD10                <1> 	int 10h
  2746 0000235F 61                  <1> 	popa
  2747                              <1> 
  2748 00002360 FEC6                <1> 	inc dh
  2749 00002362 80FE10              <1> 	cmp dh, 16
  2750 00002365 7402                <1> 	je .boxdone
  2751 00002367 EBE5                <1> 	jmp .redbox
  2752                              <1> 
  2753                              <1> 
  2754                              <1> .boxdone:
  2755                              <1> 	mov16 dx, 20, 9
    15 00002369 BA1409              <2>  mov %1, (%2 + %3 * 256)
  2756 0000236C B90500              <1> 	mov cx, 5
  2757                              <1> 
  2758                              <1> .loop:
  2759 0000236F FEC6                <1> 	inc dh
  2760 00002371 E8F1F4              <1> 	call os_move_cursor
  2761                              <1> 
  2762 00002374 5E                  <1> 	pop si
  2763 00002375 83FE00              <1> 	cmp si, 0			; Skip string params if zero
  2764 00002378 7403                <1> 	je .no_string
  2765                              <1> 
  2766 0000237A E877F4              <1> 	call os_print_string
  2767                              <1> 
  2768                              <1> .no_string:
  2769 0000237D E2F0                <1> 	loop .loop
  2770 0000237F 61                  <1> 	popa
  2771 00002380 C3                  <1> 	ret
  2772                              <1> 
  2773                              <1> ; Prints a message on the footer.
  2774                              <1> ; IN: SI = Message location(if 0, then it restores the previous message)
  2775                              <1> ; OUT: nothing
  2776                              <1> os_print_footer:
  2777 00002381 60                  <1> 	pusha
  2778 00002382 A08200              <1> 	mov al, [0082h]
  2779 00002385 3C01                <1> 	cmp al, 1
  2780 00002387 0F844700            <1> 	je near .exit
  2781                              <1> 	
  2782 0000238B E8E0F4              <1> 	call os_get_cursor_pos
  2783 0000238E 52                  <1> 	push dx
  2784                              <1> 	
  2785 0000238F BF0100              <1> 	mov di, 1
  2786 00002392 83FE00              <1> 	cmp si, 0
  2787 00002395 0F843B00            <1> 	je near .restore
  2788                              <1> 	
  2789                              <1> 	mov16 dx, 0, 24
    15 00002399 BA0018              <2>  mov %1, (%2 + %3 * 256)
  2790                              <1> 	
  2791                              <1> .loop:
  2792 0000239C E8C6F4              <1> 	call os_move_cursor
  2793                              <1> 	
  2794 0000239F B408                <1> 	mov ah, 08h
  2795 000023A1 B700                <1> 	mov bh, 0
  2796 000023A3 CD10                <1> 	int 10h
  2797                              <1> 	
  2798 000023A5 AA                  <1> 	stosb
  2799                              <1> 	
  2800 000023A6 FEC2                <1> 	inc dl
  2801 000023A8 83FF51              <1> 	cmp di, 81
  2802 000023AB 0F8CEDFF            <1> 	jnge near .loop
  2803                              <1> 	
  2804 000023AF C606500000          <1> 	mov byte [80], 0
  2805                              <1> 	
  2806                              <1> 	mov16 dx, 0, 24
    15 000023B4 BA0018              <2>  mov %1, (%2 + %3 * 256)
  2807 000023B7 E8ABF4              <1> 	call os_move_cursor
  2808                              <1> 	
  2809 000023BA B82009              <1> 	mov ax, 0920h
  2810 000023BD BB7000              <1> 	mov bx, 70h
  2811 000023C0 B95000              <1> 	mov cx, 80
  2812 000023C3 CD10                <1> 	int 10h
  2813                              <1> 	
  2814                              <1> 	mov16 dx, 0, 24
    15 000023C5 BA0018              <2>  mov %1, (%2 + %3 * 256)
  2815 000023C8 E89AF4              <1> 	call os_move_cursor
  2816                              <1> 	
  2817 000023CB E826F4              <1> 	call os_print_string
  2818                              <1> 	
  2819 000023CE 5A                  <1> 	pop dx
  2820 000023CF E893F4              <1> 	call os_move_cursor
  2821                              <1> 
  2822                              <1> .exit:	
  2823 000023D2 61                  <1> 	popa
  2824 000023D3 C3                  <1> 	ret
  2825                              <1> 	
  2826                              <1> .restore:
  2827                              <1> 	mov16 dx, 0, 24
    15 000023D4 BA0018              <2>  mov %1, (%2 + %3 * 256)
  2828 000023D7 E88BF4              <1> 	call os_move_cursor
  2829 000023DA BE0100              <1> 	mov si, 1
  2830 000023DD E814F4              <1> 	call os_print_string
  2831                              <1> 	
  2832 000023E0 5A                  <1> 	pop dx
  2833 000023E1 E881F4              <1> 	call os_move_cursor
  2834                              <1> 	
  2835 000023E4 61                  <1> 	popa
  2836 000023E5 C3                  <1> 	ret
  2837                              <1> 	
  2838                              <1> ; Resets the font to the selected default.
  2839                              <1> ; IN = nothing
  2840                              <1> ; OUT = nothing
  2841                              <1> os_reset_font:
  2842 000023E6 60                  <1> 	pusha
  2843                              <1> 	
  2844 000023E7 803EF1DE01          <1> 	cmp byte [57073], 1
  2845 000023EC 0F841800            <1> 	je near .bios
  2846                              <1> 	
  2847 000023F0 06                  <1> 	push es
  2848 000023F1 B80011              <1> 	mov ax, 1100h
  2849 000023F4 BB0010              <1> 	mov bx, 1000h
  2850 000023F7 B90001              <1> 	mov cx, 0100h
  2851                              <1> 	clr dx
    11 000023FA 31D2                <2>  xor %1, %1
  2852 000023FC 8E06[F205]          <1> 	mov es, [driversgmt]
  2853 00002400 BD0016              <1> 	mov bp, SYSTEM_FONT
  2854 00002403 CD10                <1> 	int 10h
  2855 00002405 07                  <1> 	pop es
  2856 00002406 61                  <1> 	popa
  2857 00002407 C3                  <1> 	ret
  2858                              <1> 	
  2859                              <1> .bios:
  2860 00002408 61                  <1> 	popa
  2861 00002409 C3                  <1> 	ret
  2862                              <1> 
  2863                              <1> ; Draws the crepeOS logo.
  2864                              <1> ; IN: nothing
  2865                              <1> ; OUT: a very beautiful logo :-)
  2866                              <1> os_draw_logo:
  2867 0000240A 60                  <1> 	pusha
  2868                              <1> 	
  2869                              <1> 	mov16 dx, 0, 2
    15 0000240B BA0002              <2>  mov %1, (%2 + %3 * 256)
  2870 0000240E E854F4              <1> 	call os_move_cursor
  2871                              <1> 
  2872 00002411 B82009              <1> 	mov ax, 0920h
  2873 00002414 BB0400              <1> 	mov bx, 00000100b
  2874 00002417 B93002              <1> 	mov cx, 560
  2875 0000241A CD10                <1> 	int 10h
  2876                              <1> 
  2877 0000241C BE[6809]            <1> 	mov si, logo
  2878 0000241F E80200              <1> 	call os_draw_icon
  2879 00002422 61                  <1> 	popa
  2880 00002423 C3                  <1> 	ret
  2881                              <1> 
  2882                              <1> ; Draws an icon (in the crepeOS format).
  2883                              <1> ; IN: SI = address of the icon
  2884                              <1> ; OUT: nothing
  2885                              <1> os_draw_icon:
  2886 00002424 60                  <1> 	pusha
  2887                              <1> 	
  2888 00002425 E846F4              <1> 	call os_get_cursor_pos
  2889 00002428 8916[9124]          <1> 	mov [.cursor], dx
  2890                              <1> 	
  2891 0000242C AD                  <1> 	lodsw
  2892 0000242D A3[9724]            <1> 	mov [.size], ax
  2893                              <1> 	
  2894                              <1> 	clr cx
    11 00002430 31C9                <2>  xor %1, %1
  2895                              <1> 	
  2896                              <1> .loop:
  2897 00002432 AC                  <1> 	lodsb
  2898                              <1> 	
  2899 00002433 B40E                <1> 	mov ah, 0Eh
  2900                              <1> 	
  2901 00002435 51                  <1> 	push cx
  2902 00002436 88C1                <1> 	mov cl, al
  2903 00002438 0FB6D9              <1> 	movzx bx, cl
  2904 0000243B 80E3C0              <1> 	and bl, 11000000b
  2905 0000243E C0EB06              <1> 	shr bl, 6
  2906 00002441 8A87[9324]          <1> 	mov al, [.chars + bx]
  2907 00002445 CD10                <1> 	int 10h
  2908                              <1> 	
  2909 00002447 0FB6D9              <1> 	movzx bx, cl
  2910 0000244A 80E330              <1> 	and bl, 110000b
  2911 0000244D C0EB04              <1> 	shr bl, 4
  2912 00002450 8A87[9324]          <1> 	mov al, [.chars + bx]
  2913 00002454 CD10                <1> 	int 10h
  2914                              <1> 	
  2915 00002456 0FB6D9              <1> 	movzx bx, cl
  2916 00002459 80E30C              <1> 	and bl, 1100b
  2917 0000245C C0EB02              <1> 	shr bl, 2
  2918 0000245F 8A87[9324]          <1> 	mov al, [.chars + bx]
  2919 00002463 CD10                <1> 	int 10h
  2920                              <1> 	
  2921 00002465 0FB6D9              <1> 	movzx bx, cl
  2922 00002468 80E303              <1> 	and bl, 11b
  2923 0000246B 8A87[9324]          <1> 	mov al, [.chars + bx]
  2924 0000246F CD10                <1> 	int 10h
  2925 00002471 59                  <1> 	pop cx
  2926                              <1> 	
  2927 00002472 FEC1                <1> 	inc cl
  2928 00002474 3A0E[9724]          <1> 	cmp cl, [.size]
  2929 00002478 75B8                <1> 	jne .loop
  2930                              <1> 
  2931 0000247A FE06[9224]          <1> 	inc byte [.cursor + 1]
  2932 0000247E 8B16[9124]          <1> 	mov dx, [.cursor]
  2933 00002482 E8E0F3              <1> 	call os_move_cursor
  2934                              <1> 	
  2935 00002485 B100                <1> 	mov cl, 0
  2936 00002487 FEC5                <1> 	inc ch
  2937 00002489 3A2E[9824]          <1> 	cmp ch, [.size + 1]
  2938 0000248D 75A3                <1> 	jne .loop
  2939                              <1> 	
  2940 0000248F 61                  <1> 	popa
  2941 00002490 C3                  <1> 	ret
  2942                              <1> 
  2943 00002491 0000                <1> 	.cursor		dw 0
  2944 00002493 20DCDFDB            <1> 	.chars		db 32, 220, 223, 219
  2945 00002497 0000                <1> 	.size		dw 0
  2946                              <1> 	
  2947                              <1> ; ------------------------------------------------------------------
  2948                              <1> ; os_option_menu -- Show a menu with a list of options
  2949                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated), BX = menu width
  2950                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc, left or right pressed
  2951                              <1> 
  2952                              <1> os_option_menu:
  2953 00002499 60                  <1> 	pusha
  2954                              <1> 
  2955 0000249A 803EEFDE00          <1> 	cmp byte [57071], 0
  2956 0000249F 741C                <1> 	je .skip
  2957                              <1> 	
  2958                              <1> 	mov16 dx, 0, 1
    15 000024A1 BA0001              <2>  mov %1, (%2 + %3 * 256)
  2959                              <1> 
  2960 000024A4 E8BEF3              <1> 	call os_move_cursor
  2961                              <1> 	
  2962 000024A7 B408                <1> 	mov ah, 08h
  2963 000024A9 B700                <1> 	mov bh, 0
  2964 000024AB CD10                <1> 	int 10h				; Get the character's attribute (X = 0, Y = 1)
  2965                              <1> 	
  2966 000024AD 80E4F0              <1> 	and ah, 0F0h		; Keep only the background, set foreground to 0
  2967                              <1> 	
  2968 000024B0 0FB6DC              <1> 	movzx bx, ah
  2969 000024B3 B8B109              <1> 	mov ax, 09B1h
  2970 000024B6 B93007              <1> 	mov cx, 1840
  2971 000024B9 CD10                <1> 	int 10h
  2972                              <1> 	
  2973 000024BB 61                  <1> 	popa
  2974 000024BC 60                  <1> 	pusha
  2975                              <1> 
  2976                              <1> .skip:
  2977 000024BD 891E[2726]          <1> 	mov [.width], bx
  2978                              <1> 
  2979 000024C1 50                  <1> 	push ax				; Store string list for now
  2980                              <1> 
  2981 000024C2 E8E0F3              <1> 	call os_hide_cursor
  2982                              <1> 
  2983 000024C5 B100                <1> 	mov cl, 0			; Count the number of entries in the list
  2984 000024C7 89C6                <1> 	mov si, ax
  2985                              <1> 	
  2986                              <1> .count_loop:
  2987 000024C9 AC                  <1> 	lodsb
  2988 000024CA 3C00                <1> 	cmp al, 0
  2989 000024CC 7408                <1> 	je .done_count
  2990 000024CE 3C2C                <1> 	cmp al, ','
  2991 000024D0 75F7                <1> 	jne .count_loop
  2992 000024D2 FEC1                <1> 	inc cl
  2993 000024D4 EBF3                <1> 	jmp .count_loop
  2994                              <1> 
  2995                              <1> .done_count:
  2996 000024D6 FEC1                <1> 	inc cl
  2997 000024D8 880E[2326]          <1> 	mov byte [.num_of_entries], cl
  2998                              <1> 
  2999                              <1> 
  3000 000024DC 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  3001 000024DD 8936[2526]          <1> 	mov word [.list_string], si
  3002                              <1> 
  3003                              <1> 
  3004                              <1> 	; Now that we've drawn the list, highlight the currently selected
  3005                              <1> 	; entry and let the user move up and down using the cursor keys
  3006                              <1> 
  3007 000024E1 C606[2426]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  3008                              <1> 
  3009                              <1> 	mov16 dx, 25, 2			; Set up starting position for selector
    15 000024E6 BA1902              <2>  mov %1, (%2 + %3 * 256)
  3010                              <1> 
  3011 000024E9 E879F3              <1> 	call os_move_cursor
  3012                              <1> 
  3013                              <1> .more_select:
  3014 000024EC 60                  <1> 	pusha
  3015 000024ED 8A1EF0DE            <1> 	mov bl, [57072]		; Black on white for option list box
  3016                              <1> 	mov16 dx, 1, 1
    15 000024F1 BA0101              <2>  mov %1, (%2 + %3 * 256)
  3017                              <1> 
  3018 000024F4 8B36[2726]          <1> 	mov si, [.width]
  3019 000024F8 0FB63E[2326]        <1> 	movzx di, [.num_of_entries]
  3020 000024FD 83C703              <1> 	add di, 3
  3021 00002500 E8ACF3              <1> 	call os_draw_block
  3022 00002503 61                  <1> 	popa
  3023                              <1> 
  3024 00002504 E8EA00              <1> 	call .draw_black_bar
  3025                              <1> 
  3026 00002507 8B36[2526]          <1> 	mov word si, [.list_string]
  3027 0000250B E8A000              <1> 	call .draw_list
  3028                              <1> 
  3029                              <1> .another_key:
  3030 0000250E E868ED              <1> 	call os_wait_for_key		; Move / select option
  3031 00002511 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  3032 00002514 7419                <1> 	je .go_up
  3033 00002516 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  3034 00002519 7425                <1> 	je .go_down
  3035 0000251B 3C0D                <1> 	cmp al, 13			; Enter pressed?
  3036 0000251D 745A                <1> 	je .option_selected
  3037 0000251F 3C1B                <1> 	cmp al, 27			; Esc pressed?
  3038 00002521 7470                <1> 	je .esc_pressed
  3039 00002523 80FC4B              <1> 	cmp ah, 75			; Left pressed?
  3040 00002526 7474                <1> 	je .left_pressed
  3041 00002528 80FC4D              <1> 	cmp ah, 77			; Right pressed?
  3042 0000252B 7478                <1> 	je .right_pressed
  3043 0000252D EBDF                <1> 	jmp .another_key		; If not, wait for another key
  3044                              <1> 
  3045                              <1> 
  3046                              <1> .go_up:
  3047 0000252F 80FE02              <1> 	cmp dh, 2			; Already at top?
  3048 00002532 7E37                <1> 	jle .hit_top
  3049                              <1> 
  3050 00002534 E8D100              <1> 	call .draw_white_bar
  3051                              <1> 
  3052 00002537 B219                <1> 	mov dl, 25
  3053 00002539 E829F3              <1> 	call os_move_cursor
  3054                              <1> 
  3055 0000253C FECE                <1> 	dec dh				; Row to select (increasing down)
  3056 0000253E EBAC                <1> 	jmp .more_select
  3057                              <1> 
  3058                              <1> 
  3059                              <1> .go_down:				; Already at bottom of list?
  3060 00002540 8A1E[2326]          <1> 	mov bl, [.num_of_entries]
  3061 00002544 FEC3                <1> 	inc bl
  3062 00002546 38DE                <1> 	cmp dh, bl
  3063 00002548 742A                <1> 	je .hit_bottom
  3064                              <1> 
  3065 0000254A B90000              <1> 	mov cx, 0
  3066 0000254D 88F1                <1> 	mov byte cl, dh
  3067                              <1> 
  3068 0000254F 80E906              <1> 	sub cl, 6
  3069 00002552 FEC1                <1> 	inc cl
  3070 00002554 020E[2426]          <1> 	add byte cl, [.skip_num]
  3071                              <1> 
  3072 00002558 A0[2326]            <1> 	mov byte al, [.num_of_entries]
  3073 0000255B 38C1                <1> 	cmp cl, al
  3074 0000255D 74AF                <1> 	je .another_key
  3075                              <1> 
  3076 0000255F E8A600              <1> 	call .draw_white_bar
  3077                              <1> 
  3078 00002562 B219                <1> 	mov dl, 25
  3079 00002564 E8FEF2              <1> 	call os_move_cursor
  3080                              <1> 
  3081 00002567 FEC6                <1> 	inc dh
  3082 00002569 EB81                <1> 	jmp .more_select
  3083                              <1> 
  3084                              <1> 
  3085                              <1> .hit_top:
  3086 0000256B B601                <1> 	mov dh, 1
  3087 0000256D 0236[2326]          <1> 	add dh, [.num_of_entries]
  3088 00002571 E978FF              <1> 	jmp .more_select
  3089                              <1> 
  3090                              <1> 
  3091                              <1> .hit_bottom:
  3092 00002574 B602                <1> 	mov dh, 2
  3093 00002576 E973FF              <1> 	jmp .more_select
  3094                              <1> 
  3095                              <1> 
  3096                              <1> 
  3097                              <1> .option_selected:
  3098 00002579 E81EF3              <1> 	call os_show_cursor
  3099                              <1> 
  3100 0000257C 80EE02              <1> 	sub dh, 2
  3101                              <1> 
  3102 0000257F B80000              <1> 	mov ax, 0
  3103 00002582 88F0                <1> 	mov al, dh
  3104                              <1> 
  3105 00002584 FEC0                <1> 	inc al				; Options start from 1
  3106 00002586 0206[2426]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  3107                              <1> 
  3108 0000258A A3[2126]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  3109                              <1> 
  3110 0000258D 61                  <1> 	popa
  3111                              <1> 
  3112 0000258E A1[2126]            <1> 	mov word ax, [.tmp]
  3113 00002591 F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  3114 00002592 C3                  <1> 	ret
  3115                              <1> 
  3116                              <1> 
  3117                              <1> 
  3118                              <1> .esc_pressed:
  3119 00002593 E804F3              <1> 	call os_show_cursor
  3120 00002596 61                  <1> 	popa
  3121 00002597 B80000              <1> 	mov ax, 0
  3122 0000259A F9                  <1> 	stc
  3123 0000259B C3                  <1> 	ret
  3124                              <1> 
  3125                              <1> .left_pressed:
  3126 0000259C E8FBF2              <1> 	call os_show_cursor
  3127 0000259F 61                  <1> 	popa
  3128 000025A0 B80100              <1> 	mov ax, 1
  3129 000025A3 F9                  <1> 	stc
  3130 000025A4 C3                  <1> 	ret
  3131                              <1> 
  3132                              <1> .right_pressed:
  3133 000025A5 E8F2F2              <1> 	call os_show_cursor
  3134 000025A8 61                  <1> 	popa
  3135 000025A9 B80200              <1> 	mov ax, 2
  3136 000025AC F9                  <1> 	stc
  3137 000025AD C3                  <1> 	ret
  3138                              <1> 
  3139                              <1> .draw_list:
  3140 000025AE 60                  <1> 	pusha
  3141                              <1> 
  3142                              <1> 	mov16 dx, 3, 2			; Get into position for option list text
    15 000025AF BA0302              <2>  mov %1, (%2 + %3 * 256)
  3143 000025B2 E8B0F2              <1> 	call os_move_cursor
  3144                              <1> 
  3145                              <1> 
  3146 000025B5 B90000              <1> 	mov cx, 0			; Skip lines scrolled off the top of the dialog
  3147 000025B8 8A0E[2426]          <1> 	mov byte cl, [.skip_num]
  3148                              <1> 
  3149                              <1> .skip_loop:
  3150 000025BC 83F900              <1> 	cmp cx, 0
  3151 000025BF 7408                <1> 	je .skip_loop_finished
  3152                              <1> 	
  3153                              <1> .more_lodsb:
  3154 000025C1 AC                  <1> 	lodsb
  3155 000025C2 3C2C                <1> 	cmp al, ','
  3156 000025C4 75FB                <1> 	jne .more_lodsb
  3157 000025C6 49                  <1> 	dec cx
  3158 000025C7 EBF3                <1> 	jmp .skip_loop
  3159                              <1> 
  3160                              <1> 
  3161                              <1> .skip_loop_finished:
  3162 000025C9 BB0000              <1> 	mov bx, 0			; Counter for total number of options
  3163                              <1> 
  3164                              <1> 
  3165                              <1> .more:
  3166 000025CC AC                  <1> 	lodsb				; Get next character in file name, increment pointer
  3167                              <1> 
  3168 000025CD 3C00                <1> 	cmp al, 0			; End of string?
  3169 000025CF 741B                <1> 	je .done_list
  3170                              <1> 
  3171 000025D1 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  3172 000025D3 7406                <1> 	je .newline
  3173                              <1> 
  3174 000025D5 B40E                <1> 	mov ah, 0Eh
  3175 000025D7 CD10                <1> 	int 10h
  3176 000025D9 EBF1                <1> 	jmp .more
  3177                              <1> 
  3178                              <1> .newline:
  3179 000025DB B203                <1> 	mov dl, 3			; Go back to starting X position
  3180 000025DD FEC6                <1> 	inc dh				; But jump down a line
  3181 000025DF E883F2              <1> 	call os_move_cursor
  3182                              <1> 
  3183 000025E2 43                  <1> 	inc bx				; Update the number-of-options counter
  3184 000025E3 0FB63E[2326]        <1> 	movzx di, [.num_of_entries]	; Low 8 bits of DI = [.items], high 8 bits = 0
  3185 000025E8 39FB                <1> 	cmp bx, di			; Limit to one screen of options
  3186 000025EA 7CE0                <1> 	jl .more
  3187                              <1> 
  3188                              <1> .done_list:
  3189 000025EC 61                  <1> 	popa
  3190 000025ED E875F2              <1> 	call os_move_cursor
  3191                              <1> 
  3192 000025F0 C3                  <1> 	ret
  3193                              <1> 
  3194                              <1> 
  3195                              <1> 
  3196                              <1> .draw_black_bar:
  3197 000025F1 60                  <1> 	pusha
  3198                              <1> 
  3199 000025F2 B202                <1> 	mov dl, 2
  3200 000025F4 E86EF2              <1> 	call os_move_cursor
  3201                              <1> 
  3202 000025F7 B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  3203 000025FA 8B0E[2726]          <1> 	mov cx, [.width]
  3204 000025FE 83E902              <1> 	sub cx, 2
  3205 00002601 BB0F00              <1> 	mov bx, 00001111b		; White text on black background
  3206 00002604 CD10                <1> 	int 10h
  3207                              <1> 
  3208 00002606 61                  <1> 	popa
  3209 00002607 C3                  <1> 	ret
  3210                              <1> 
  3211                              <1> .draw_white_bar:
  3212 00002608 60                  <1> 	pusha
  3213                              <1> 
  3214 00002609 B202                <1> 	mov dl, 2
  3215 0000260B E857F2              <1> 	call os_move_cursor
  3216                              <1> 
  3217 0000260E B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  3218 00002611 8B0E[2726]          <1> 	mov cx, [.width]
  3219 00002615 83E902              <1> 	sub cx, 2
  3220 00002618 0FB61EF0DE          <1> 	movzx bx, byte [57072]	; Black text on white background
  3221 0000261D CD10                <1> 	int 10h
  3222                              <1> 
  3223 0000261F 61                  <1> 	popa
  3224 00002620 C3                  <1> 	ret
  3225                              <1> 
  3226 00002621 0000                <1> 	.tmp					dw 0
  3227 00002623 00                  <1> 	.num_of_entries			db 0
  3228 00002624 00                  <1> 	.skip_num				db 0
  3229 00002625 0000                <1> 	.list_string			dw 0
  3230 00002627 0000                <1> 	.width					dw 0
  3231                              <1> 	
  3232                              <1> ; ==================================================================
   816                                  	%INCLUDE "drivers/sound.asm"
   817                              <1> ; ==================================================================
   818                              <1> ; PC SPEAKER/ADLIB SOUND ROUTINES
   819                              <1> ; ==================================================================
   820                              <1> 
   821                              <1> ; ------------------------------------------------------------------
   822                              <1> ; os_speaker_tone -- Generate PC speaker tone (call os_speaker_off to turn off)
   823                              <1> ; IN: AX = note frequency; OUT: Nothing (registers preserved)
   824                              <1> 
   825                              <1> os_speaker_tone:
   826 00002629 60                  <1> 	pusha
   827 0000262A 803E830000          <1> 	cmp byte [0083h], 0
   828 0000262F 0F842600            <1> 	je near .exit
   829 00002633 61                  <1> 	popa
   830                              <1> 	
   831 00002634 60                  <1> 	pusha
   832 00002635 83F800              <1> 	cmp ax, 0
   833 00002638 0F841D00            <1> 	je near .exit
   834                              <1> 	
   835 0000263C E82A00              <1> 	call os_speaker_off
   836 0000263F 89C1                <1> 	mov cx, ax			; Store note value for now
   837                              <1> 
   838 00002641 B0B6                <1> 	mov al, 10110110b
   839 00002643 E643                <1> 	out 43h, al
   840 00002645 BA1200              <1> 	mov dx, 12h			; Set up frequency
   841 00002648 B8DC34              <1> 	mov ax, 34DCh
   842 0000264B F7F1                <1> 	div cx
   843 0000264D E642                <1> 	out 42h, al
   844 0000264F 88E0                <1> 	mov al, ah
   845 00002651 E642                <1> 	out 42h, al
   846                              <1> 
   847 00002653 E461                <1> 	in al, 61h			; Switch PC speaker on
   848 00002655 0C03                <1> 	or al, 03h
   849 00002657 E661                <1> 	out 61h, al
   850                              <1> 
   851                              <1> .exit:
   852 00002659 61                  <1> 	popa
   853 0000265A C3                  <1> 	ret
   854                              <1> 
   855                              <1> ; ------------------------------------------------------------------
   856                              <1> ; os_speaker_note_length -- Generate PC speaker tone for a set amount of time and then stop
   857                              <1> ; IN: AX = note frequency, CX = length (in ticks)
   858                              <1> 
   859                              <1> os_speaker_note_length:
   860 0000265B 60                  <1> 	pusha
   861 0000265C E8CAFF              <1> 	call os_speaker_tone
   862                              <1> 	
   863 0000265F 89C8                <1> 	mov ax, cx
   864 00002661 E867EE              <1> 	call os_pause
   865                              <1> 	
   866 00002664 E80200              <1> 	call os_speaker_off
   867 00002667 61                  <1> 	popa
   868 00002668 C3                  <1> 	ret
   869                              <1> 
   870                              <1> ; ------------------------------------------------------------------
   871                              <1> ; os_speaker_off -- Turn off PC speaker
   872                              <1> ; IN/OUT: Nothing (registers preserved)
   873                              <1> 
   874                              <1> os_speaker_off:
   875 00002669 60                  <1> 	pusha
   876                              <1> 
   877 0000266A E461                <1> 	in al, 61h
   878 0000266C 24FC                <1> 	and al, 0FCh
   879 0000266E E661                <1> 	out 61h, al
   880                              <1> 
   881 00002670 61                  <1> 	popa
   882 00002671 C3                  <1> 	ret
   883                              <1> 
   884                              <1> ; ------------------------------------------------------------------
   885                              <1> ; os_start_adlib -- Starts the selected Adlib driver
   886                              <1> ; IN: SI = interrupt handler, CX = prescaler, BL = number of channels
   887                              <1> ; The interrupt will fire at 33144 Hz (the closest possible to 32768 Hz) divided by CX.
   888                              <1> ; Common prescaler values:
   889                              <1> ;		33 = ~1 kHz (1004.362 Hz)
   890                              <1> ;		663 = ~50 Hz (49.991 Hz)
   891                              <1> ;		1820 = ~18.2 Hz (18.211 Hz)
   892                              <1> 
   893                              <1> os_start_adlib:
   894 00002672 60                  <1> 	pusha
   895 00002673 C606[4828]01        <1> 	mov byte [adlib_running], 1
   896                              <1> 
   897 00002678 803EEEDE01          <1> 	cmp byte [57070], 1
   898 0000267D 7D16                <1> 	jge .pcspk
   899                              <1> 	
   900 0000267F B80000              <1> 	mov ax, 0
   901                              <1> 	
   902                              <1> .loop:
   903 00002682 E8C700              <1> 	call int_adlib_regwrite
   904 00002685 FEC4                <1> 	inc ah
   905 00002687 75F9                <1> 	jnz .loop
   906                              <1> 	
   907 00002689 B82400              <1> 	mov ax, 36
   908 0000268C F7E1                <1> 	mul cx
   909                              <1> 	
   910 0000268E 89C1                <1> 	mov cx, ax
   911 00002690 E81421              <1> 	call os_attach_app_timer
   912                              <1> 	
   913 00002693 61                  <1> 	popa
   914 00002694 C3                  <1> 	ret
   915                              <1> 	
   916                              <1> .pcspk:
   917 00002695 B82400              <1> 	mov ax, 36
   918 00002698 F6F3                <1> 	div bl
   919                              <1> 	
   920 0000269A A2[E328]            <1> 	mov [pwm_channel_amplitude], al
   921                              <1> 
   922 0000269D 8936[DC28]          <1> 	mov [pwm_callback], si
   923 000026A1 890E[DE28]          <1> 	mov [pwm_callback_ctr], cx
   924 000026A5 890E[E028]          <1> 	mov [pwm_callback_ctr_def], cx
   925                              <1> 
   926                              <1> 	; Set up the PC speaker
   927 000026A9 E461                <1> 	in al, 0x61
   928 000026AB 0C03                <1> 	or al, 3
   929 000026AD E661                <1> 	out 0x61, al
   930                              <1> 
   931                              <1> 	; Enable the callback
   932 000026AF BE[4928]            <1> 	mov si, pwm_handler
   933 000026B2 8CCF                <1> 	mov di, cs
   934 000026B4 B11C                <1> 	mov cl, 01Ch
   935 000026B6 E8A820              <1> 	call os_modify_int_handler
   936                              <1> 
   937 000026B9 B92400              <1> 	mov cx, 36
   938 000026BC E80F21              <1> 	call os_set_timer_speed
   939                              <1> 	
   940 000026BF 61                  <1> 	popa
   941 000026C0 C3                  <1> 	ret
   942                              <1> 	
   943                              <1> ; ------------------------------------------------------------------
   944                              <1> ; os_stop_adlib -- Stops the Adlib driver
   945                              <1> 
   946                              <1> os_stop_adlib:
   947 000026C1 60                  <1> 	pusha
   948 000026C2 803EEEDE01          <1> 	cmp byte [57070], 1
   949 000026C7 7D1D                <1> 	jge .pcspk
   950                              <1> 	
   951 000026C9 E8EA20              <1> 	call os_return_app_timer
   952                              <1> 
   953 000026CC B400                <1> 	mov ah, 0
   954                              <1> 	
   955                              <1> .loop:
   956 000026CE 0FB6DC              <1> 	movzx bx, ah
   957 000026D1 C1EB05              <1> 	shr bx, 5
   958 000026D4 8A87[0927]          <1> 	mov al, [adlib_clear_regs + bx]
   959                              <1> 
   960 000026D8 E87100              <1> 	call int_adlib_regwrite
   961                              <1> 	
   962 000026DB FEC4                <1> 	inc ah
   963 000026DD 75EF                <1> 	jnz .loop
   964                              <1> 	
   965 000026DF C606[4828]00        <1> 	mov byte [adlib_running], 0
   966 000026E4 61                  <1> 	popa
   967 000026E5 C3                  <1> 	ret
   968                              <1> 	
   969                              <1> .pcspk:
   970                              <1> 	; Turn off the PC speaker
   971 000026E6 E461                <1> 	in al, 0x61
   972 000026E8 24FC                <1> 	and al, 0xfc
   973 000026EA E661                <1> 	out 0x61, al
   974                              <1> 
   975 000026EC B90000              <1> 	mov cx, 0
   976 000026EF E8DC20              <1> 	call os_set_timer_speed
   977                              <1> 	
   978                              <1> 	; Reset the RTC handler
   979 000026F2 B11C                <1> 	mov cl, 1Ch
   980 000026F4 BE[7748]            <1> 	mov si, os_compat_int1C
   981 000026F7 8CCF                <1> 	mov di, cs
   982 000026F9 E86520              <1> 	call os_modify_int_handler
   983                              <1> 	
   984                              <1> 	; Turn off all of the channels
   985 000026FC B91200              <1> 	mov cx, 18		; Not only nuke pwm_freq, but also pwm_cntr!
   986 000026FF BF[B728]            <1> 	mov di, pwm_freq
   987 00002702 B80000              <1> 	mov ax, 0
   988 00002705 F3AB                <1> 	rep stosw
   989                              <1> 	
   990 00002707 61                  <1> 	popa
   991 00002708 C3                  <1> 	ret
   992                              <1> 	
   993                              <1> 	; Registers:    	   0x00  0x20  0x40  0x60  0x80  0xA0  0xC0  0xE0
   994 00002709 00003FFFFF000000    <1> 	adlib_clear_regs	db 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0x00, 0x00, 0x00
   995                              <1> 	
   996                              <1> ; ------------------------------------------------------------------
   997                              <1> ; os_check_adlib -- Checks if YM3812 is present in the system
   998                              <1> ; OUT: CF clear if YM3812 is present
   999                              <1> 
  1000                              <1> os_check_adlib:
  1001 00002711 60                  <1> 	pusha
  1002 00002712 803EEEDE01          <1> 	cmp byte [57070], 1
  1003 00002717 7D14                <1> 	jge .ok
  1004                              <1> 
  1005 00002719 B86004              <1> 	mov ax, 0460h
  1006 0000271C E82D00              <1> 	call int_adlib_regwrite
  1007                              <1> 	
  1008 0000271F B88004              <1> 	mov ax, 0480h
  1009 00002722 E82700              <1> 	call int_adlib_regwrite
  1010                              <1> 	
  1011 00002725 BA8803              <1> 	mov dx, 388h
  1012 00002728 EC                  <1> 	in al, dx
  1013 00002729 3C00                <1> 	cmp al, 0
  1014 0000272B 7503                <1> 	jne .error
  1015                              <1> 	
  1016                              <1> .ok:
  1017 0000272D 61                  <1> 	popa
  1018 0000272E F8                  <1> 	clc
  1019 0000272F C3                  <1> 	ret
  1020                              <1> 	
  1021                              <1> .error:
  1022 00002730 61                  <1> 	popa
  1023 00002731 F9                  <1> 	stc
  1024 00002732 C3                  <1> 	ret
  1025                              <1> 	
  1026                              <1> ; ------------------------------------------------------------------
  1027                              <1> ; os_adlib_regwrite -- Write to a YM3812 register
  1028                              <1> ; IN: AH/AL - register address/value to write
  1029                              <1> 
  1030                              <1> os_adlib_regwrite:
  1031 00002733 60                  <1> 	pusha
  1032                              <1> 	
  1033 00002734 0FB6DC              <1> 	movzx bx, ah		; Store the value in the buffer first
  1034 00002737 6488870005          <1> 	mov [fs:ADLIB_BUFFER + bx], al
  1035                              <1> 	
  1036 0000273C E80D00              <1> 	call int_adlib_regwrite
  1037                              <1> 	
  1038 0000273F 61                  <1> 	popa
  1039 00002740 C3                  <1> 	ret
  1040                              <1> 	
  1041                              <1> ; ------------------------------------------------------------------
  1042                              <1> ; os_adlib_regread -- Read from a YM3812 register
  1043                              <1> ; IN: AH - register address; OUT: AL - value
  1044                              <1> 
  1045                              <1> os_adlib_regread:
  1046 00002741 53                  <1> 	push bx
  1047                              <1> 	
  1048 00002742 0FB6DC              <1> 	movzx bx, ah		; Store the value in the buffer first
  1049 00002745 648A870005          <1> 	mov al, [fs:ADLIB_BUFFER + bx]
  1050                              <1> 	
  1051 0000274A 5B                  <1> 	pop bx
  1052 0000274B C3                  <1> 	ret
  1053                              <1> 	
  1054                              <1> ; ------------------------------------------------------------------
  1055                              <1> ; int_adlib_regwrite -- Internal kernel function - not available to user programs
  1056                              <1> ; IN: AH/AL - register address/value to write
  1057                              <1> 	
  1058                              <1> int_adlib_regwrite:
  1059 0000274C 60                  <1> 	pusha
  1060                              <1> 
  1061 0000274D 803EEEDE01          <1> 	cmp byte [57070], 1
  1062 00002752 7D21                <1> 	jge .pcspk
  1063                              <1> 
  1064 00002754 803E[4828]00        <1> 	cmp byte [adlib_running], 0
  1065 00002759 7418                <1> 	je .no_write
  1066                              <1> 
  1067 0000275B BA8803              <1> 	mov dx, 388h
  1068 0000275E 50                  <1> 	push ax
  1069 0000275F 88E0                <1> 	mov al, ah
  1070 00002761 EE                  <1> 	out dx, al
  1071                              <1> 
  1072 00002762 EC                  <1> 	in al, dx
  1073 00002763 EC                  <1> 	in al, dx
  1074 00002764 EC                  <1> 	in al, dx
  1075 00002765 EC                  <1> 	in al, dx
  1076 00002766 EC                  <1> 	in al, dx
  1077 00002767 EC                  <1> 	in al, dx
  1078                              <1> 	
  1079 00002768 58                  <1> 	pop ax
  1080 00002769 42                  <1> 	inc dx
  1081 0000276A EE                  <1> 	out dx, al
  1082                              <1> 
  1083 0000276B 4A                  <1> 	dec	dx
  1084 0000276C B422                <1> 	mov	ah, 22h
  1085                              <1> 
  1086                              <1> .wait:
  1087 0000276E EC                  <1> 	in al,dx
  1088 0000276F FECC                <1> 	dec ah
  1089 00002771 75FB                <1> 	jnz .wait
  1090                              <1> 	
  1091                              <1> .no_write:
  1092 00002773 61                  <1> 	popa
  1093 00002774 C3                  <1> 	ret
  1094                              <1> 
  1095                              <1> .pcspk:
  1096 00002775 80FCA0              <1> 	cmp ah, 0A0h
  1097 00002778 7CF9                <1> 	jl .no_write
  1098                              <1> 
  1099 0000277A 80FCB8              <1> 	cmp ah, 0B8h
  1100 0000277D 7FF4                <1> 	jg .no_write
  1101                              <1> 
  1102 0000277F 80E40F              <1> 	and ah, 0Fh
  1103 00002782 0FB6DC              <1> 	movzx bx, ah
  1104                              <1> 	
  1105 00002785 648A87A005          <1> 	mov al, [fs:ADLIB_BUFFER + 0A0h + bx]
  1106 0000278A 648AA7B005          <1> 	mov ah, [fs:ADLIB_BUFFER + 0B0h + bx]
  1107                              <1> 	
  1108 0000278F F6C420              <1> 	test ah, 20h
  1109 00002792 7439                <1> 	jz .pcspk_clear
  1110                              <1> 	
  1111 00002794 88E2                <1> 	mov dl, ah		; Get the block number
  1112 00002796 C0EA02              <1> 	shr dl, 2
  1113 00002799 80E207              <1> 	and dl, 7
  1114                              <1> 	
  1115 0000279C 25FF03              <1> 	and ax, 3FFh	; Get the FNum
  1116                              <1> 	
  1117                              <1> 	; WARNING! Due to the 16-bit integer limit (for speed), the maximum is block = 7, FNum = 511.
  1118                              <1> 	; Quick and dirty formula: freq = (fnum << block) / 21
  1119                              <1> 
  1120 0000279F 8816[A527]          <1> 	mov [.shift + 2], dl
  1121                              <1> 	
  1122 000027A3 C1E000              <1> 	.shift: db 0C1h, 0E0h, 0	; Shift AX left by the block number
  1123                              <1> 
  1124 000027A6 53                  <1> 	push bx
  1125                              <1> 	
  1126 000027A7 31D2                <1> 	xor dx, dx
  1127 000027A9 BB1500              <1> 	mov bx, 21
  1128 000027AC F7F3                <1> 	div bx						; Calculate the frequency
  1129                              <1> 
  1130 000027AE 5B                  <1> 	pop bx
  1131                              <1> 
  1132 000027AF 53                  <1> 	push bx						; Apply the frequency multiplier
  1133 000027B0 B700                <1> 	mov bh, 0
  1134 000027B2 8A9F[E727]          <1> 	mov bl, [adlib_fmul_registers + bx]
  1135 000027B6 648A9F0005          <1> 	mov bl, [fs:ADLIB_BUFFER + bx]
  1136 000027BB 80E30F              <1> 	and bl, 0Fh
  1137 000027BE 8A9F[D727]          <1> 	mov bl, [adlib_fmul_values + bx]
  1138                              <1> 	
  1139 000027C2 F7E3                <1> 	mul bx
  1140 000027C4 5B                  <1> 	pop bx
  1141                              <1> 	
  1142 000027C5 D1E3                <1> 	shl bx, 1		; Words
  1143 000027C7 8987[B728]          <1> 	mov word [pwm_freq + bx], ax
  1144                              <1> 
  1145 000027CB 61                  <1> 	popa
  1146 000027CC C3                  <1> 	ret
  1147                              <1> 	
  1148                              <1> .pcspk_clear:
  1149 000027CD D1E3                <1> 	shl bx, 1		; Words
  1150 000027CF C787[B728]0000      <1> 	mov word [pwm_freq + bx], 0
  1151                              <1> 	
  1152 000027D5 61                  <1> 	popa
  1153 000027D6 C3                  <1> 	ret
  1154                              <1> 	
  1155 000027D7 01020406080A0C0E10- <1> 	adlib_fmul_values		db 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 20, 24, 24, 30, 30
  1155 000027E0 12141418181E1E      <1>
  1156 000027E7 2324252B2C2D333435  <1> 	adlib_fmul_registers	db 23h, 24h, 25h, 2Bh, 2Ch, 2Dh, 33h, 34h, 35h
  1157                              <1> 	
  1158                              <1> ; ------------------------------------------------------------------
  1159                              <1> ; os_adlib_mute -- Mute the YM3812's current state
  1160                              <1> ; IN: nothing
  1161                              <1> 
  1162                              <1> os_adlib_mute:
  1163 000027F0 60                  <1> 	pusha
  1164                              <1> 	
  1165 000027F1 803EEEDE01          <1> 	cmp byte [57070], 1
  1166 000027F6 7D15                <1> 	jge .pcspk
  1167                              <1> 	
  1168 000027F8 BE[3628]            <1> 	mov si, adlib_volume_registers
  1169 000027FB B91200              <1> 	mov cx, 18
  1170                              <1> 	
  1171                              <1> .loop:
  1172 000027FE AC                  <1> 	lodsb
  1173 000027FF 88C4                <1> 	mov ah, al
  1174                              <1> 	
  1175 00002801 E83DFF              <1> 	call os_adlib_regread
  1176 00002804 0C3F                <1> 	or al, 3Fh
  1177 00002806 E843FF              <1> 	call int_adlib_regwrite
  1178                              <1> 	
  1179 00002809 E2F3                <1> 	loop .loop
  1180 0000280B 61                  <1> 	popa
  1181 0000280C C3                  <1> 	ret
  1182                              <1> 
  1183                              <1> .pcspk:
  1184 0000280D C606[DB28]01        <1> 	mov byte [pwm_muted], 1
  1185 00002812 61                  <1> 	popa
  1186 00002813 C3                  <1> 	ret
  1187                              <1> 	
  1188                              <1> ; ------------------------------------------------------------------
  1189                              <1> ; os_adlib_unmute -- Unmute the YM3812's current state
  1190                              <1> ; IN: nothing
  1191                              <1> 
  1192                              <1> os_adlib_unmute:
  1193 00002814 60                  <1> 	pusha
  1194                              <1> 
  1195 00002815 803EEEDE01          <1> 	cmp byte [57070], 1
  1196 0000281A 7D13                <1> 	jge .pcspk
  1197                              <1> 	
  1198 0000281C BE[3628]            <1> 	mov si, adlib_volume_registers
  1199 0000281F B91200              <1> 	mov cx, 18
  1200                              <1> 	
  1201                              <1> .loop:
  1202 00002822 AC                  <1> 	lodsb
  1203 00002823 88C4                <1> 	mov ah, al
  1204                              <1> 	
  1205 00002825 E819FF              <1> 	call os_adlib_regread
  1206 00002828 E821FF              <1> 	call int_adlib_regwrite
  1207                              <1> 	
  1208 0000282B E2F5                <1> 	loop .loop
  1209 0000282D 61                  <1> 	popa
  1210 0000282E C3                  <1> 	ret
  1211                              <1> 	
  1212                              <1> .pcspk:
  1213 0000282F C606[DB28]00        <1> 	mov byte [pwm_muted], 0
  1214 00002834 61                  <1> 	popa
  1215 00002835 C3                  <1> 	ret
  1216                              <1> 
  1217 00002836 40414243444548494A- <1> 	adlib_volume_registers	db 40h, 41h, 42h, 43h, 44h, 45h, 48h, 49h, 4Ah, 4Bh, 4Ch, 4Dh, 50h, 51h, 52h, 53h, 54h, 55h
  1217 0000283F 4B4C4D505152535455  <1>
  1218 00002848 00                  <1> 	adlib_running			db 0
  1219                              <1> 
  1220                              <1> ; ------------------------------------------------------------------
  1221                              <1> ; PWM DRIVER
  1222                              <1> ; What is emulated: FNum, block number, carrier frequency multiplier
  1223                              <1> ; What is NOT emulated: literally everything else - amplitude, ADSR, waveforms, modulator
  1224                              <1> 
  1225                              <1> pwm_handler:
  1226 00002849 FA                  <1> 	cli
  1227 0000284A 60                  <1> 	pusha
  1228 0000284B 1E                  <1> 	push ds
  1229                              <1> 	
  1230 0000284C 8CC8                <1> 	mov ax, cs
  1231 0000284E 8ED8                <1> 	mov ds, ax
  1232                              <1> 	
  1233 00002850 803E[DB28]01        <1> 	cmp byte [pwm_muted], 1
  1234 00002855 744D                <1> 	je .no_spk
  1235                              <1> 
  1236                              <1> 	; Send the PWM value to the PC speaker
  1237 00002857 B0B0                <1> 	mov al, 10110000b
  1238 00002859 E643                <1> 	out 0x43, al
  1239 0000285B A0[E228]            <1> 	mov al, [pwm_val]
  1240 0000285E E642                <1> 	out 0x42, al
  1241 00002860 B000                <1> 	mov al, 0
  1242 00002862 E642                <1> 	out 0x42, al
  1243                              <1> 
  1244                              <1> 	; Calculate the next value
  1245 00002864 B90900              <1> 	mov cx, 9
  1246 00002867 BE[B728]            <1> 	mov si, pwm_freq
  1247 0000286A BF[C728]            <1> 	mov di, pwm_cntr - 2
  1248 0000286D B300                <1> 	mov bl, 0
  1249                              <1> 	
  1250 0000286F 8A16[E328]          <1> 	mov dl, [pwm_channel_amplitude]
  1251                              <1> 	
  1252 00002873 803EEEDE02          <1> 	cmp byte [57070], 2
  1253 00002878 7513                <1> 	jne .handler_loop
  1254                              <1> 	
  1255                              <1> 	; Max volume mode, count the number of active channels
  1256 0000287A 56                  <1> 	push si
  1257 0000287B 51                  <1> 	push cx
  1258                              <1> 	
  1259                              <1> 	clr bx
    11 0000287C 31DB                <2>  xor %1, %1
  1260                              <1> 	
  1261                              <1> .channel_count_loop:
  1262 0000287E AD                  <1> 	lodsw
  1263                              <1> 	
  1264 0000287F 83F800              <1> 	cmp ax, 0
  1265 00002882 7401                <1> 	je .channel_count_loop_no_inc
  1266                              <1> 	
  1267 00002884 43                  <1> 	inc bx
  1268                              <1> 	
  1269                              <1> .channel_count_loop_no_inc:
  1270 00002885 E2F7                <1> 	loop .channel_count_loop
  1271                              <1> 	
  1272 00002887 59                  <1> 	pop cx
  1273 00002888 5E                  <1> 	pop si
  1274                              <1> 	
  1275 00002889 8A97[E428]          <1> 	mov dl, [pwm_fixed_amplitudes + bx]
  1276                              <1> 
  1277                              <1> 	; Add all of the channels together
  1278                              <1> .handler_loop:
  1279 0000288D AD                  <1> 	lodsw
  1280                              <1> 	
  1281 0000288E 83F800              <1> 	cmp ax, 0
  1282 00002891 7409                <1> 	je .handler_loop_no_inc
  1283                              <1> 	
  1284 00002893 83C702              <1> 	add di, 2
  1285 00002896 0105                <1> 	add [di], ax
  1286                              <1> 	
  1287 00002898 7902                <1> 	jns .handler_loop_no_inc
  1288                              <1> 	
  1289 0000289A 00D3                <1> 	add	bl, dl
  1290                              <1> 
  1291                              <1> .handler_loop_no_inc:
  1292 0000289C E2EF                <1> 	loop .handler_loop
  1293                              <1> 	
  1294 0000289E FEC3                <1> 	inc bl
  1295 000028A0 881E[E228]          <1> 	mov [pwm_val], bl
  1296                              <1> 	
  1297                              <1> .no_spk:
  1298                              <1> 	; Have we reached the callback value?	
  1299 000028A4 FF0E[DE28]          <1> 	dec word [pwm_callback_ctr]
  1300 000028A8 750A                <1> 	jnz .exit
  1301                              <1> 
  1302                              <1> 	; Yes, reset it
  1303 000028AA A1[E028]            <1> 	mov ax, [pwm_callback_ctr_def]
  1304 000028AD A3[DE28]            <1> 	mov [pwm_callback_ctr], ax
  1305                              <1> 	
  1306                              <1> 	; Call the callback
  1307 000028B0 FF16[DC28]          <1> 	call [pwm_callback]
  1308                              <1> 	
  1309                              <1> .exit:
  1310 000028B4 1F                  <1> 	pop ds
  1311 000028B5 61                  <1> 	popa
  1312 000028B6 CF                  <1> 	iret
  1313                              <1> 
  1314 000028B7 0000<rep 9h>        <1> 	pwm_freq				times 9 dw 0
  1315 000028C9 0000<rep 9h>        <1> 	pwm_cntr				times 9 dw 0
  1316 000028DB 00                  <1> 	pwm_muted				db 0
  1317 000028DC 0000                <1> 	pwm_callback			dw 0
  1318 000028DE 0000                <1> 	pwm_callback_ctr		dw 0
  1319 000028E0 0000                <1> 	pwm_callback_ctr_def	dw 0
  1320 000028E2 00                  <1> 	pwm_val					db 0
  1321 000028E3 00                  <1> 	pwm_channel_amplitude	db 0
  1322 000028E4 0024120C0907060504- <1> 	pwm_fixed_amplitudes	db 0, 36, 18, 12, 9, 7, 6, 5, 4, 4
  1322 000028ED 04                  <1>
  1323                              <1> 	
  1324                              <1> ; ------------------------------------------------------------------
  1325                              <1> ; os_adlib_calcfreq -- Play a frequency
  1326                              <1> ; IN: AX - frequency, CL = channel; OUT: nothing
  1327                              <1> 
  1328                              <1> os_adlib_calcfreq:
  1329 000028EE 6660                <1> 	pushad
  1330                              <1> 
  1331 000028F0 803EEEDE01          <1> 	cmp byte [57070], 1
  1332 000028F5 7D54                <1> 	jge .pcspk
  1333                              <1> 
  1334 000028F7 880E[5929]          <1> 	mov [.channel], cl
  1335                              <1> 	
  1336 000028FB 660FB7C0            <1> 	movzx eax, ax
  1337 000028FF B100                <1> 	mov cl, 0		; Block number
  1338                              <1> 	
  1339 00002901 6650                <1> 	push eax
  1340                              <1> 
  1341                              <1> .block_loop:		; f-num = freq * 2^(20 - block) / 49716
  1342 00002903 6658                <1> 	pop eax
  1343 00002905 6650                <1> 	push eax
  1344                              <1> 	
  1345 00002907 B314                <1> 	mov bl, 20
  1346 00002909 28CB                <1> 	sub bl, cl
  1347                              <1> 	
  1348 0000290B 881E[1229]          <1> 	mov [.shift + 3], bl
  1349 0000290F 66C1E000            <1> .shift: db 0x66, 0xc1, 0xe0, 0		; shl eax, XX
  1350                              <1> 
  1351                              <1> 	clr edx
    11 00002913 6631D2              <2>  xor %1, %1
  1352 00002916 66BB34C20000        <1> 	mov ebx, 49716	; Divide by the sample rate
  1353 0000291C 66F7F3              <1> 	div ebx
  1354                              <1> 
  1355 0000291F FEC1                <1> 	inc cl
  1356                              <1> 	
  1357 00002921 3D0004              <1> 	cmp ax, 1024	; Is the result too large?
  1358 00002924 7DDD                <1> 	jge .block_loop
  1359                              <1> 	
  1360 00002926 FEC9                <1> 	dec cl
  1361                              <1> 	
  1362 00002928 C0E102              <1> 	shl cl, 2		; Write the block number
  1363 0000292B 00CC                <1> 	add ah, cl
  1364                              <1> 
  1365 0000292D 80CC20              <1> 	or ah, 20h		; Note on
  1366                              <1> 	
  1367 00002930 50                  <1> 	push ax
  1368 00002931 B4A0                <1> 	mov ah, 0A0h
  1369 00002933 0226[5929]          <1> 	add ah, [.channel]
  1370 00002937 E8F9FD              <1> 	call os_adlib_regwrite
  1371 0000293A 58                  <1> 	pop ax
  1372                              <1> 	
  1373 0000293B 88E0                <1> 	mov al, ah
  1374 0000293D B4B0                <1> 	mov ah, 0B0h
  1375 0000293F 0226[5929]          <1> 	add ah, [.channel]
  1376 00002943 E8EDFD              <1> 	call os_adlib_regwrite
  1377                              <1> 	
  1378 00002946 6658                <1> 	pop eax
  1379 00002948 6661                <1> 	popad
  1380 0000294A C3                  <1> 	ret
  1381                              <1> 	
  1382                              <1> .pcspk:
  1383 0000294B 0FB6D9              <1> 	movzx bx, cl
  1384 0000294E D1E3                <1> 	shl bx, 1
  1385 00002950 D1E0                <1> 	shl ax, 1
  1386 00002952 8987[B728]          <1> 	mov [pwm_freq + bx], ax
  1387 00002956 6661                <1> 	popad
  1388 00002958 C3                  <1> 	ret
  1389                              <1> 	
  1390 00002959 00                  <1> 	.channel	db 0
  1391                              <1> 	
  1392                              <1> ; ------------------------------------------------------------------
  1393                              <1> ; os_adlib_noteoff -- Turns off a note
  1394                              <1> ; IN: CL = channel; OUT: nothing
  1395                              <1> 
  1396                              <1> os_adlib_noteoff:
  1397 0000295A 803EEEDE01          <1> 	cmp byte [57070], 1
  1398 0000295F 7D0F                <1> 	jge .pcspk
  1399                              <1> 	
  1400 00002961 60                  <1> 	pusha
  1401                              <1> 
  1402 00002962 B4B0                <1> 	mov ah, 0B0h
  1403 00002964 00CC                <1> 	add ah, cl
  1404 00002966 E8D8FD              <1> 	call os_adlib_regread
  1405                              <1> 	
  1406 00002969 24DF                <1> 	and al, 11011111b
  1407 0000296B E8C5FD              <1> 	call os_adlib_regwrite
  1408                              <1> 	
  1409 0000296E 61                  <1> 	popa
  1410 0000296F C3                  <1> 	ret
  1411                              <1> 	
  1412                              <1> .pcspk:
  1413 00002970 60                  <1> 	pusha
  1414 00002971 0FB6D9              <1> 	movzx bx, cl
  1415 00002974 D1E3                <1> 	shl bx, 1
  1416 00002976 C787[B728]0000      <1> 	mov word [pwm_freq + bx], 0
  1417 0000297C 61                  <1> 	popa
  1418 0000297D C3                  <1> 	ret	
  1419                              <1> 	
  1420                              <1> ; ==================================================================
  1421                              <1> 
   817                                  	%INCLUDE "drivers/string.asm"
   818                              <1> ; ==================================================================
   819                              <1> ; STRING MANIPULATION ROUTINES
   820                              <1> ; ==================================================================
   821                              <1> 
   822                              <1> ; os_string_encrypt -- Encrypts a string using a totally military-grade encryption algorithm
   823                              <1> ; IN: SI = Input string/Output string
   824                              <1> 
   825                              <1> os_string_encrypt:
   826 0000297E 60                  <1> 	pusha
   827 0000297F 89F7                <1> 	mov di, si
   828                              <1> 
   829 00002981 89F0                <1> 	mov ax, si
   830 00002983 E82C00              <1> 	call os_string_length
   831 00002986 C0E002              <1> 	shl al, 2
   832 00002989 347B                <1> 	xor al, 123
   833                              <1> 	
   834 0000298B B17B                <1> 	mov cl, 123
   835 0000298D 00C1                <1> 	add cl, al
   836 0000298F 80F1DB              <1> 	xor cl, 219
   837                              <1> 	
   838                              <1> .loop:
   839 00002992 AC                  <1> 	lodsb
   840 00002993 3C00                <1> 	cmp al, 0
   841 00002995 740A                <1> 	je .exit
   842                              <1> 	
   843 00002997 00C8                <1> 	add al, cl
   844 00002999 34AA                <1> 	xor al, 10101010b
   845 0000299B AA                  <1> 	stosb
   846                              <1> 	
   847 0000299C 80C14D              <1> 	add cl, 77
   848 0000299F EBF1                <1> 	jmp .loop
   849                              <1> 	
   850                              <1> .exit:
   851 000029A1 61                  <1> 	popa
   852 000029A2 C3                  <1> 	ret
   853                              <1> 	
   854                              <1> ; os_string_add -- Add a string on top of another string
   855                              <1> ; IN: AX/BX = Main string/Added string
   856                              <1> 
   857                              <1> os_string_add:
   858 000029A3 60                  <1> 	pusha
   859 000029A4 50                  <1> 	push ax
   860 000029A5 E80A00              <1> 	call os_string_length		; Get the length of the main string
   861 000029A8 5F                  <1> 	pop di
   862 000029A9 01C7                <1> 	add di, ax					; Add it to the pointer
   863 000029AB 89DE                <1> 	mov si, bx
   864 000029AD E89500              <1>  	call os_string_copy			; Copy the string
   865 000029B0 61                  <1>  	popa
   866 000029B1 C3                  <1>  	ret
   867                              <1> 	
   868                              <1> ; ------------------------------------------------------------------
   869                              <1> ; os_string_length -- Return length of a string
   870                              <1> ; IN: AX = string location
   871                              <1> ; OUT AX = length (other regs preserved)
   872                              <1> 
   873                              <1> os_string_length:
   874 000029B2 60                  <1> 	pusha
   875                              <1> 
   876 000029B3 89C3                <1> 	mov bx, ax			; Move location of string to BX
   877                              <1> 
   878 000029B5 31C9                <1> 	xor cx, cx			; Counter
   879                              <1> 
   880                              <1> .more:
   881 000029B7 803F00              <1> 	cmp byte [bx], 0		; Zero (end of string) yet?
   882 000029BA 7404                <1> 	je .done
   883 000029BC 43                  <1> 	inc bx				; If not, keep adding
   884 000029BD 41                  <1> 	inc cx
   885 000029BE EBF7                <1> 	jmp .more
   886                              <1> 
   887                              <1> 
   888                              <1> .done:
   889 000029C0 890E[C929]          <1> 	mov word [.tmp_counter], cx	; Store count before restoring other registers
   890 000029C4 61                  <1> 	popa
   891                              <1> 
   892 000029C5 A1[C929]            <1> 	mov ax, [.tmp_counter]		; Put count back into AX before returning
   893 000029C8 C3                  <1> 	ret
   894                              <1> 
   895                              <1> 
   896 000029C9 0000                <1> 	.tmp_counter	dw 0
   897                              <1> 
   898                              <1> 
   899                              <1> ; ------------------------------------------------------------------
   900                              <1> ; os_string_reverse -- Reverse the characters in a string
   901                              <1> ; IN: SI = string location
   902                              <1> 
   903                              <1> os_string_reverse:
   904 000029CB 60                  <1> 	pusha
   905                              <1> 
   906 000029CC 803C00              <1> 	cmp byte [si], 0		; Don't attempt to reverse empty string
   907 000029CF 7418                <1> 	je .end
   908                              <1> 
   909 000029D1 89F0                <1> 	mov ax, si
   910 000029D3 E8DCFF              <1> 	call os_string_length
   911                              <1> 
   912 000029D6 89F7                <1> 	mov di, si
   913 000029D8 01C7                <1> 	add di, ax
   914 000029DA 4F                  <1> 	dec di				; DI now points to last char in string
   915                              <1> 
   916                              <1> .loop:
   917 000029DB 8A04                <1> 	mov byte al, [si]		; Swap bytes
   918 000029DD 8A1D                <1> 	mov byte bl, [di]
   919                              <1> 
   920 000029DF 881C                <1> 	mov byte [si], bl
   921 000029E1 8805                <1> 	mov byte [di], al
   922                              <1> 
   923 000029E3 46                  <1> 	inc si				; Move towards string centre
   924 000029E4 4F                  <1> 	dec di
   925                              <1> 
   926 000029E5 39F7                <1> 	cmp di, si			; Both reached the centre?
   927 000029E7 77F2                <1> 	ja .loop
   928                              <1> 
   929                              <1> .end:
   930 000029E9 61                  <1> 	popa
   931 000029EA C3                  <1> 	ret
   932                              <1> 
   933                              <1> 
   934                              <1> ; ------------------------------------------------------------------
   935                              <1> ; os_find_char_in_string -- Find location of character in a string
   936                              <1> ; IN: SI = string location, AL = character to find
   937                              <1> ; OUT: AX = location in string, or 0 if char not present
   938                              <1> 
   939                              <1> os_find_char_in_string:
   940 000029EB 60                  <1> 	pusha
   941                              <1> 
   942 000029EC B90100              <1> 	mov cx, 1			; Counter -- start at first char (we count
   943                              <1> 					; from 1 in chars here, so that we can
   944                              <1> 					; return 0 if the source char isn't found)
   945                              <1> 
   946                              <1> .more:
   947 000029EF 3804                <1> 	cmp byte [si], al
   948 000029F1 7409                <1> 	je .done
   949 000029F3 803C00              <1> 	cmp byte [si], 0
   950 000029F6 740D                <1> 	je .notfound
   951 000029F8 46                  <1> 	inc si
   952 000029F9 41                  <1> 	inc cx
   953 000029FA EBF3                <1> 	jmp .more
   954                              <1> 
   955                              <1> .done:
   956 000029FC 890E[092A]          <1> 	mov [.tmp], cx
   957 00002A00 61                  <1> 	popa
   958 00002A01 A1[092A]            <1> 	mov ax, [.tmp]
   959 00002A04 C3                  <1> 	ret
   960                              <1> 
   961                              <1> .notfound:
   962 00002A05 61                  <1> 	popa
   963 00002A06 31C0                <1> 	xor ax, ax
   964 00002A08 C3                  <1> 	ret
   965                              <1> 
   966                              <1> 
   967 00002A09 0000                <1> 	.tmp	dw 0
   968                              <1> 
   969                              <1> 
   970                              <1> ; ------------------------------------------------------------------
   971                              <1> ; os_string_uppercase -- Convert zero-terminated string to upper case
   972                              <1> ; IN/OUT: AX = string location
   973                              <1> 
   974                              <1> os_string_uppercase:
   975 00002A0B 60                  <1> 	pusha
   976                              <1> 
   977 00002A0C 89C6                <1> 	mov si, ax			; Use SI to access string
   978                              <1> 
   979                              <1> .more:
   980 00002A0E 803C00              <1> 	cmp byte [si], 0		; Zero-termination of string?
   981 00002A11 7413                <1> 	je .done			; If so, quit
   982                              <1> 
   983 00002A13 803C61              <1> 	cmp byte [si], 'a'		; In the lower case A to Z range?
   984 00002A16 720B                <1> 	jb .noatoz
   985 00002A18 803C7A              <1> 	cmp byte [si], 'z'
   986 00002A1B 7706                <1> 	ja .noatoz
   987                              <1> 
   988 00002A1D 802C20              <1> 	sub byte [si], 20h		; If so, convert input char to upper case
   989                              <1> 
   990 00002A20 46                  <1> 	inc si
   991 00002A21 EBEB                <1> 	jmp .more
   992                              <1> 
   993                              <1> .noatoz:
   994 00002A23 46                  <1> 	inc si
   995 00002A24 EBE8                <1> 	jmp .more
   996                              <1> 
   997                              <1> .done:
   998 00002A26 61                  <1> 	popa
   999 00002A27 C3                  <1> 	ret
  1000                              <1> 
  1001                              <1> 
  1002                              <1> ; ------------------------------------------------------------------
  1003                              <1> ; os_string_lowercase -- Convert zero-terminated string to lower case
  1004                              <1> ; IN/OUT: AX = string location
  1005                              <1> 
  1006                              <1> os_string_lowercase:
  1007 00002A28 60                  <1> 	pusha
  1008                              <1> 
  1009 00002A29 89C6                <1> 	mov si, ax			; Use SI to access string
  1010                              <1> 
  1011                              <1> .more:
  1012 00002A2B 803C00              <1> 	cmp byte [si], 0		; Zero-termination of string?
  1013 00002A2E 7413                <1> 	je .done			; If so, quit
  1014                              <1> 
  1015 00002A30 803C41              <1> 	cmp byte [si], 'A'		; In the upper case A to Z range?
  1016 00002A33 720B                <1> 	jb .noatoz
  1017 00002A35 803C5A              <1> 	cmp byte [si], 'Z'
  1018 00002A38 7706                <1> 	ja .noatoz
  1019                              <1> 
  1020 00002A3A 800420              <1> 	add byte [si], 20h		; If so, convert input char to lower case
  1021                              <1> 
  1022 00002A3D 46                  <1> 	inc si
  1023 00002A3E EBEB                <1> 	jmp .more
  1024                              <1> 
  1025                              <1> .noatoz:
  1026 00002A40 46                  <1> 	inc si
  1027 00002A41 EBE8                <1> 	jmp .more
  1028                              <1> 
  1029                              <1> .done:
  1030 00002A43 61                  <1> 	popa
  1031 00002A44 C3                  <1> 	ret
  1032                              <1> 
  1033                              <1> 
  1034                              <1> ; ------------------------------------------------------------------
  1035                              <1> ; os_string_copy -- Copy one string into another
  1036                              <1> ; IN/OUT: SI = source, DI = destination (programmer ensure sufficient room)
  1037                              <1> 
  1038                              <1> os_string_copy:
  1039 00002A45 60                  <1> 	pusha
  1040                              <1> 
  1041                              <1> .more:
  1042 00002A46 AC                  <1> 	lodsb
  1043 00002A47 AA                  <1> 	stosb
  1044 00002A48 3C00                <1> 	cmp byte al, 0			; If source string is empty, quit out
  1045 00002A4A 75FA                <1> 	jne .more
  1046 00002A4C 61                  <1> 	popa
  1047 00002A4D C3                  <1> 	ret
  1048                              <1> 
  1049                              <1> 
  1050                              <1> ; ------------------------------------------------------------------
  1051                              <1> ; os_string_join -- Join two strings into a third string
  1052                              <1> ; IN/OUT: AX = string one, BX = string two, CX = destination string
  1053                              <1> 
  1054                              <1> os_string_join:
  1055 00002A4E 60                  <1> 	pusha
  1056                              <1> 
  1057 00002A4F 89C6                <1> 	mov si, ax
  1058 00002A51 89CF                <1> 	mov di, cx
  1059 00002A53 E8EFFF              <1> 	call os_string_copy
  1060                              <1> 
  1061 00002A56 E859FF              <1> 	call os_string_length		; Get length of first string
  1062                              <1> 
  1063 00002A59 01C1                <1> 	add cx, ax			; Position at end of first string
  1064                              <1> 
  1065 00002A5B 89DE                <1> 	mov si, bx			; Add second string onto it
  1066 00002A5D 89CF                <1> 	mov di, cx
  1067 00002A5F E8E3FF              <1> 	call os_string_copy
  1068                              <1> 
  1069 00002A62 61                  <1> 	popa
  1070 00002A63 C3                  <1> 	ret
  1071                              <1> 
  1072                              <1> 
  1073                              <1> ; ------------------------------------------------------------------
  1074                              <1> ; os_string_chomp -- Strip leading and trailing spaces from a string
  1075                              <1> ; IN: AX = string location
  1076                              <1> 
  1077                              <1> os_string_chomp:
  1078 00002A64 60                  <1> 	pusha
  1079                              <1> 
  1080 00002A65 89C2                <1> 	mov dx, ax			; Save string location
  1081                              <1> 
  1082 00002A67 89C7                <1> 	mov di, ax			; Put location into DI
  1083 00002A69 31C9                <1> 	xor cx, cx			; Space counter
  1084                              <1> 
  1085                              <1> .keepcounting:				; Get number of leading spaces into BX
  1086 00002A6B 803D20              <1> 	cmp byte [di], ' '
  1087 00002A6E 7504                <1> 	jne .counted
  1088 00002A70 41                  <1> 	inc cx
  1089 00002A71 47                  <1> 	inc di
  1090 00002A72 EBF7                <1> 	jmp .keepcounting
  1091                              <1> 
  1092                              <1> .counted:
  1093 00002A74 83F900              <1> 	cmp cx, 0			; No leading spaces?
  1094 00002A77 7410                <1> 	je .finished_copy
  1095                              <1> 
  1096 00002A79 89FE                <1> 	mov si, di			; Address of first non-space character
  1097 00002A7B 89D7                <1> 	mov di, dx			; DI = original string start
  1098                              <1> 
  1099                              <1> .keep_copying:
  1100 00002A7D 8A04                <1> 	mov al, [si]			; Copy SI into DI
  1101 00002A7F 8805                <1> 	mov [di], al			; Including terminator
  1102 00002A81 3C00                <1> 	cmp al, 0
  1103 00002A83 7404                <1> 	je .finished_copy
  1104 00002A85 46                  <1> 	inc si
  1105 00002A86 47                  <1> 	inc di
  1106 00002A87 EBF4                <1> 	jmp .keep_copying
  1107                              <1> 
  1108                              <1> .finished_copy:
  1109 00002A89 89D0                <1> 	mov ax, dx			; AX = original string start
  1110                              <1> 
  1111 00002A8B E824FF              <1> 	call os_string_length
  1112 00002A8E 83F800              <1> 	cmp ax, 0			; If empty or all blank, done, return 'null'
  1113 00002A91 740F                <1> 	je .done
  1114                              <1> 
  1115 00002A93 89D6                <1> 	mov si, dx
  1116 00002A95 01C6                <1> 	add si, ax			; Move to end of string
  1117                              <1> 
  1118                              <1> .more:
  1119 00002A97 4E                  <1> 	dec si
  1120 00002A98 803C20              <1> 	cmp byte [si], ' '
  1121 00002A9B 7505                <1> 	jne .done
  1122 00002A9D C60400              <1> 	mov byte [si], 0		; Fill end spaces with 0s
  1123 00002AA0 EBF5                <1> 	jmp .more			; (First 0 will be the string terminator)
  1124                              <1> 
  1125                              <1> .done:
  1126 00002AA2 61                  <1> 	popa
  1127 00002AA3 C3                  <1> 	ret
  1128                              <1> 
  1129                              <1> 
  1130                              <1> ; ------------------------------------------------------------------
  1131                              <1> ; os_string_compare -- See if two strings match
  1132                              <1> ; IN: SI = string one, DI = string two
  1133                              <1> ; OUT: carry set if same, clear if different
  1134                              <1> 
  1135                              <1> os_string_compare:
  1136 00002AA4 60                  <1> 	pusha
  1137                              <1> 
  1138                              <1> .more:
  1139 00002AA5 8A04                <1> 	mov al, [si]			; Retrieve string contents
  1140 00002AA7 8A1D                <1> 	mov bl, [di]
  1141                              <1> 
  1142 00002AA9 38D8                <1> 	cmp al, bl			; Compare characters at current location
  1143 00002AAB 7508                <1> 	jne .not_same
  1144                              <1> 
  1145 00002AAD 3C00                <1> 	cmp al, 0			; End of first string? Must also be end of second
  1146 00002AAF 7407                <1> 	je .terminated
  1147                              <1> 
  1148 00002AB1 46                  <1> 	inc si
  1149 00002AB2 47                  <1> 	inc di
  1150 00002AB3 EBF0                <1> 	jmp .more
  1151                              <1> 
  1152                              <1> 
  1153                              <1> .not_same:				; If unequal lengths with same beginning, the byte
  1154 00002AB5 61                  <1> 	popa				; comparison fails at shortest string terminator
  1155 00002AB6 F8                  <1> 	clc				; Clear carry flag
  1156 00002AB7 C3                  <1> 	ret
  1157                              <1> 
  1158                              <1> 
  1159                              <1> .terminated:				; Both strings terminated at the same position
  1160 00002AB8 61                  <1> 	popa
  1161 00002AB9 F9                  <1> 	stc				; Set carry flag
  1162 00002ABA C3                  <1> 	ret
  1163                              <1> 
  1164                              <1> 
  1165                              <1> ; ------------------------------------------------------------------
  1166                              <1> ; os_string_parse -- Take string (eg "run foo bar baz") and return
  1167                              <1> ; pointers to zero-terminated strings (eg AX = "run", BX = "foo" etc.)
  1168                              <1> ; IN: SI = string; OUT: AX, BX, CX, DX = individual strings
  1169                              <1> 
  1170                              <1> os_string_parse:
  1171 00002ABB 56                  <1> 	push si
  1172                              <1> 
  1173 00002ABC 89F0                <1> 	mov ax, si			; AX = start of first string
  1174                              <1> 
  1175 00002ABE 31DB                <1> 	xor bx, bx			; By default, other strings start empty
  1176 00002AC0 31C9                <1> 	xor cx, cx
  1177 00002AC2 31D2                <1> 	xor dx, dx
  1178                              <1> 
  1179 00002AC4 50                  <1> 	push ax				; Save to retrieve at end
  1180                              <1> 
  1181                              <1> .loop1:
  1182 00002AC5 AC                  <1> 	lodsb				; Get a byte
  1183 00002AC6 3C00                <1> 	cmp al, 0			; End of string?
  1184 00002AC8 742B                <1> 	je .finish
  1185 00002ACA 3C20                <1> 	cmp al, ' '			; A space?
  1186 00002ACC 75F7                <1> 	jne .loop1
  1187 00002ACE 4E                  <1> 	dec si
  1188 00002ACF C60400              <1> 	mov byte [si], 0		; If so, zero-terminate this bit of the string
  1189                              <1> 
  1190 00002AD2 46                  <1> 	inc si				; Store start of next string in BX
  1191 00002AD3 89F3                <1> 	mov bx, si
  1192                              <1> 
  1193                              <1> .loop2:					; Repeat the above for CX and DX...
  1194 00002AD5 AC                  <1> 	lodsb
  1195 00002AD6 3C00                <1> 	cmp al, 0
  1196 00002AD8 741B                <1> 	je .finish
  1197 00002ADA 3C20                <1> 	cmp al, ' '
  1198 00002ADC 75F7                <1> 	jne .loop2
  1199 00002ADE 4E                  <1> 	dec si
  1200 00002ADF C60400              <1> 	mov byte [si], 0
  1201                              <1> 
  1202 00002AE2 46                  <1> 	inc si
  1203 00002AE3 89F1                <1> 	mov cx, si
  1204                              <1> 
  1205                              <1> .loop3:
  1206 00002AE5 AC                  <1> 	lodsb
  1207 00002AE6 3C00                <1> 	cmp al, 0
  1208 00002AE8 740B                <1> 	je .finish
  1209 00002AEA 3C20                <1> 	cmp al, ' '
  1210 00002AEC 75F7                <1> 	jne .loop3
  1211 00002AEE 4E                  <1> 	dec si
  1212 00002AEF C60400              <1> 	mov byte [si], 0
  1213                              <1> 
  1214 00002AF2 46                  <1> 	inc si
  1215 00002AF3 89F2                <1> 	mov dx, si
  1216                              <1> 
  1217                              <1> .finish:
  1218 00002AF5 58                  <1> 	pop ax
  1219                              <1> 
  1220 00002AF6 5E                  <1> 	pop si
  1221 00002AF7 C3                  <1> 	ret
  1222                              <1> 
  1223                              <1> 
  1224                              <1> ; ------------------------------------------------------------------
  1225                              <1> ; os_string_to_int -- Convert decimal string to integer value
  1226                              <1> ; IN: SI = string location (max 5 chars, up to '65535')
  1227                              <1> ; OUT: AX = number
  1228                              <1> 
  1229                              <1> os_string_to_int:
  1230 00002AF8 E88E01              <1> 	call os_string_to_32int		; This function only exists for compatibility reasons
  1231 00002AFB C3                  <1> 	ret
  1232                              <1> 
  1233                              <1> ; ------------------------------------------------------------------
  1234                              <1> ; os_string_to_hex -- Convert hexadecimal string to integer value
  1235                              <1> ; IN: SI = string location (max 8 chars, up to 'FFFFFFFF')
  1236                              <1> ; OUT: EAX = number
  1237                              <1> 
  1238                              <1> os_string_to_hex:
  1239 00002AFC 6660                <1> 	pushad
  1240                              <1> 	
  1241 00002AFE 89F0                <1> 	mov ax, si			; First, uppercase the string
  1242 00002B00 E808FF              <1> 	call os_string_uppercase
  1243                              <1> 
  1244 00002B03 6631C0              <1> 	xor eax, eax				; Temporary 32-bit integer
  1245                              <1> 	
  1246                              <1> .loop:
  1247 00002B06 6650                <1> 	push eax
  1248 00002B08 AC                  <1> 	lodsb					; Load a byte from SI
  1249 00002B09 88C1                <1> 	mov cl, al
  1250 00002B0B 6658                <1> 	pop eax
  1251 00002B0D 80F900              <1> 	cmp cl, 0				; Have we reached the end?
  1252 00002B10 0F842000            <1> 	je near .exit			; If we have, exit
  1253                              <1> 	
  1254 00002B14 80F939              <1> 	cmp cl, '9'
  1255 00002B17 7E03                <1> 	jle .no_change
  1256                              <1> 	
  1257 00002B19 80E907              <1> 	sub cl, 7
  1258                              <1> 	
  1259                              <1> .no_change:
  1260 00002B1C 80E930              <1> 	sub cl, '0'				; Convert the value to decimal
  1261 00002B1F 6681E1FF000000      <1> 	and ecx, 255			; Keep the low 8 bits only
  1262 00002B26 66BB10000000        <1> 	mov ebx, 16 
  1263 00002B2C 66F7E3              <1> 	mul ebx					; Multiply EAX by 16
  1264 00002B2F 6601C8              <1> 	add eax, ecx			; Add the value to the integer
  1265 00002B32 EBD2                <1> 	jmp .loop				; Loop again
  1266                              <1> 	
  1267                              <1> .exit:
  1268 00002B34 66A3[3F2B]          <1> 	mov [.tmp_dword], eax
  1269 00002B38 6661                <1> 	popad
  1270 00002B3A 66A1[3F2B]          <1> 	mov eax, [.tmp_dword]
  1271 00002B3E C3                  <1> 	ret
  1272                              <1> 	
  1273 00002B3F 00000000            <1> 	.tmp_dword	dd 0
  1274                              <1> 
  1275                              <1> ; ------------------------------------------------------------------
  1276                              <1> ; os_int_to_string -- Convert unsigned integer to string
  1277                              <1> ; IN: AX = unsigned int
  1278                              <1> ; OUT: AX = string location
  1279                              <1> 
  1280                              <1> os_int_to_string:
  1281 00002B43 60                  <1> 	pusha
  1282                              <1> 
  1283 00002B44 31C9                <1> 	xor cx, cx
  1284 00002B46 BB0A00              <1> 	mov bx, 10			; Set BX 10, for division and mod
  1285 00002B49 BF[6A2B]            <1> 	mov di, .t			; Get our pointer ready
  1286                              <1> 
  1287                              <1> .push:
  1288 00002B4C 31D2                <1> 	xor dx, dx
  1289 00002B4E F7F3                <1> 	div bx				; Remainder in DX, quotient in AX
  1290 00002B50 41                  <1> 	inc cx				; Increase pop loop counter
  1291 00002B51 52                  <1> 	push dx				; Push remainder, so as to reverse order when popping
  1292 00002B52 85C0                <1> 	test ax, ax			; Is quotient zero?
  1293 00002B54 75F6                <1> 	jnz .push			; If not, loop again
  1294                              <1> .pop:
  1295 00002B56 5A                  <1> 	pop dx				; Pop off values in reverse order, and add 48 to make them digits
  1296 00002B57 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
  1297 00002B5A 2E8815              <1> 	mov [cs:di], dl
  1298 00002B5D 47                  <1> 	inc di
  1299 00002B5E 49                  <1> 	dec cx
  1300 00002B5F 75F5                <1> 	jnz .pop
  1301                              <1> 
  1302 00002B61 2EC60500            <1> 	mov byte [cs:di], 0		; Zero-terminate string
  1303                              <1> 
  1304 00002B65 61                  <1> 	popa
  1305 00002B66 B8[6A2B]            <1> 	mov ax, .t			; Return location of string
  1306 00002B69 C3                  <1> 	ret
  1307                              <1> 
  1308                              <1> 
  1309 00002B6A 00<rep 7h>          <1> 	.t times 7 db 0
  1310                              <1> 
  1311                              <1> 
  1312                              <1> ; ------------------------------------------------------------------
  1313                              <1> ; os_sint_to_string -- Convert signed integer to string
  1314                              <1> ; IN: AX = signed int
  1315                              <1> ; OUT: AX = string location
  1316                              <1> 
  1317                              <1> os_sint_to_string:
  1318 00002B71 60                  <1> 	pusha
  1319                              <1> 
  1320 00002B72 31C9                <1> 	xor cx, cx
  1321 00002B74 BB0A00              <1> 	mov bx, 10			; Set BX 10, for division and mod
  1322 00002B77 BF[A42B]            <1> 	mov di, .t			; Get our pointer ready
  1323                              <1> 
  1324 00002B7A 85C0                <1> 	test ax, ax			; Find out if X > 0 or not, force a sign
  1325 00002B7C 7802                <1> 	js .neg				; If negative...
  1326 00002B7E EB08                <1> 	jmp .push			; ...or if positive
  1327                              <1> .neg:
  1328 00002B80 F7D8                <1> 	neg ax				; Make AX positive
  1329 00002B82 C606[A42B]2D        <1> 	mov byte [.t], '-'		; Add a minus sign to our string
  1330 00002B87 47                  <1> 	inc di				; Update the index
  1331                              <1> .push:
  1332 00002B88 31D2                <1> 	xor dx, dx
  1333 00002B8A F7F3                <1> 	div bx				; Remainder in DX, quotient in AX
  1334 00002B8C 41                  <1> 	inc cx				; Increase pop loop counter
  1335 00002B8D 52                  <1> 	push dx				; Push remainder, so as to reverse order when popping
  1336 00002B8E 85C0                <1> 	test ax, ax			; Is quotient zero?
  1337 00002B90 75F6                <1> 	jnz .push			; If not, loop again
  1338                              <1> .pop:
  1339 00002B92 5A                  <1> 	pop dx				; Pop off values in reverse order, and add 48 to make them digits
  1340 00002B93 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
  1341 00002B96 8815                <1> 	mov [di], dl
  1342 00002B98 47                  <1> 	inc di
  1343 00002B99 49                  <1> 	dec cx
  1344 00002B9A 75F6                <1> 	jnz .pop
  1345                              <1> 
  1346 00002B9C C60500              <1> 	mov byte [di], 0		; Zero-terminate string
  1347                              <1> 
  1348 00002B9F 61                  <1> 	popa
  1349 00002BA0 B8[A42B]            <1> 	mov ax, .t			; Return location of string
  1350 00002BA3 C3                  <1> 	ret
  1351                              <1> 
  1352                              <1> 
  1353 00002BA4 00<rep 7h>          <1> 	.t times 7 db 0
  1354                              <1> 
  1355                              <1> ; ------------------------------------------------------------------
  1356                              <1> ; os_get_time_string -- Get current time in a string (eg '10:25')
  1357                              <1> ; IN/OUT: BX = string location
  1358                              <1> 
  1359                              <1> os_get_time_string:
  1360 00002BAB 60                  <1> 	pusha
  1361                              <1> 	
  1362 00002BAC 89DF                <1> 	mov di, bx			; Location to place the string
  1363                              <1> 
  1364 00002BAE B402                <1> 	mov ah, 02h			; Get the current time
  1365 00002BB0 E805EB              <1> 	call os_int_1Ah
  1366                              <1> 	
  1367 00002BB3 723B                <1> 	jc .exit
  1368                              <1> 
  1369 00002BB5 51                  <1> 	push cx	
  1370                              <1> 
  1371 00002BB6 88E8                <1> 	mov al, ch
  1372 00002BB8 E847E8              <1> 	call os_bcd_to_int
  1373 00002BBB 83F80A              <1> 	cmp ax, 10
  1374 00002BBE 7D05                <1> 	jge .hour_10
  1375                              <1> 	
  1376 00002BC0 50                  <1> 	push ax
  1377 00002BC1 B030                <1> 	mov al, '0'
  1378 00002BC3 AA                  <1> 	stosb
  1379 00002BC4 58                  <1> 	pop ax
  1380                              <1> 	
  1381                              <1> .hour_10:
  1382 00002BC5 E87BFF              <1> 	call os_int_to_string
  1383 00002BC8 89C6                <1> 	mov si, ax
  1384                              <1> 	
  1385                              <1> .hour_loop:	
  1386 00002BCA AC                  <1> 	lodsb
  1387 00002BCB 3C00                <1> 	cmp al, 0
  1388 00002BCD 7403                <1> 	je .hour_loop_end
  1389 00002BCF AA                  <1> 	stosb
  1390 00002BD0 EBF8                <1> 	jmp .hour_loop
  1391                              <1> 	
  1392                              <1> .hour_loop_end:
  1393 00002BD2 B03A                <1> 	mov al, ':'			; Insert the time separator (or whatever it's called)
  1394 00002BD4 AA                  <1> 	stosb
  1395                              <1> 		
  1396 00002BD5 59                  <1> 	pop cx
  1397 00002BD6 88C8                <1> 	mov al, cl
  1398 00002BD8 E827E8              <1> 	call os_bcd_to_int
  1399 00002BDB 83F80A              <1> 	cmp ax, 10
  1400 00002BDE 7D05                <1> 	jge .minute_10
  1401                              <1> 	
  1402 00002BE0 50                  <1> 	push ax
  1403 00002BE1 B030                <1> 	mov al, '0'
  1404 00002BE3 AA                  <1> 	stosb
  1405 00002BE4 58                  <1> 	pop ax
  1406                              <1> 	
  1407                              <1> .minute_10:
  1408 00002BE5 E85BFF              <1> 	call os_int_to_string
  1409 00002BE8 89C6                <1> 	mov si, ax
  1410                              <1> 		
  1411                              <1> .minute_loop:	
  1412 00002BEA AC                  <1> 	lodsb
  1413 00002BEB AA                  <1> 	stosb
  1414                              <1> 	
  1415 00002BEC 3C00                <1> 	cmp al, 0
  1416 00002BEE 75FA                <1> 	jne .minute_loop
  1417                              <1> 
  1418                              <1> .exit:
  1419 00002BF0 61                  <1> 	popa
  1420 00002BF1 C3                  <1> 	ret
  1421                              <1> 
  1422                              <1> ; ------------------------------------------------------------------
  1423                              <1> ; os_get_date_string -- Get current date in a string (eg '12/31/2007')
  1424                              <1> ; IN/OUT: BX = string location
  1425                              <1> 
  1426                              <1> os_get_date_string:
  1427 00002BF2 60                  <1> 	pusha
  1428                              <1> 
  1429 00002BF3 89DF                <1> 	mov di, bx
  1430                              <1> 	
  1431 00002BF5 F8                  <1> 	clc				; For buggy BIOSes
  1432 00002BF6 B404                <1> 	mov ah, 4			; Get date data from BIOS in BCD format
  1433 00002BF8 E8BDEA              <1> 	call os_int_1Ah
  1434 00002BFB 7306                <1> 	jnc .fmt1_day
  1435                              <1> 
  1436 00002BFD F8                  <1> 	clc
  1437 00002BFE B404                <1> 	mov ah, 4			; BIOS was updating (~1 in 500 chance), so try again
  1438 00002C00 E8B5EA              <1> 	call os_int_1Ah
  1439                              <1> 
  1440                              <1> .fmt1_day:
  1441 00002C03 88D4                <1> 	mov ah, dl			; Day
  1442 00002C05 E81A00              <1> 	call .add_2digits
  1443                              <1> 
  1444 00002C08 B02F                <1> 	mov al, '/'
  1445 00002C0A AA                  <1> 	stosb				; Day-month separator
  1446                              <1> 
  1447                              <1> .fmt1_month:
  1448 00002C0B 88F4                <1> 	mov ah,	dh			; Month
  1449 00002C0D E81200              <1> 	call .add_2digits
  1450                              <1> 
  1451 00002C10 B02F                <1> 	mov al, '/'
  1452 00002C12 AA                  <1> 	stosb
  1453                              <1> 
  1454                              <1> .fmt1_century:
  1455 00002C13 88EC                <1> 	mov ah,	ch			; Century
  1456 00002C15 E80A00              <1> 	call .add_2digits
  1457                              <1> 
  1458                              <1> .fmt1_year:
  1459 00002C18 88CC                <1> 	mov ah, cl			; Year
  1460 00002C1A E80500              <1> 	call .add_2digits
  1461                              <1> 
  1462 00002C1D B000                <1> 	mov al, 0			; Terminate date string
  1463 00002C1F AA                  <1> 	stosb
  1464                              <1> 
  1465 00002C20 61                  <1> 	popa
  1466 00002C21 C3                  <1> 	ret
  1467                              <1> 
  1468                              <1> .add_2digits:
  1469 00002C22 88E0                <1> 	mov al, ah			; Convert AH to 2 ASCII digits
  1470 00002C24 C0E804              <1> 	shr al, 4
  1471 00002C27 E80800              <1> 	call .add_digit
  1472 00002C2A 88E0                <1> 	mov al, ah
  1473 00002C2C 240F                <1> 	and al, 0Fh
  1474 00002C2E E80100              <1> 	call .add_digit
  1475 00002C31 C3                  <1> 	ret
  1476                              <1> 
  1477                              <1> .add_digit:
  1478 00002C32 0430                <1> 	add al, '0'			; Convert AL to ASCII
  1479 00002C34 AA                  <1> 	stosb				; Put into string buffer
  1480 00002C35 C3                  <1> 	ret
  1481                              <1> 	
  1482                              <1> 	
  1483                              <1> ; ------------------------------------------------------------------
  1484                              <1> ; os_string_tokenize -- Reads tokens separated by specified char from
  1485                              <1> ; a string. Returns pointer to next token, or 0 if none left
  1486                              <1> ; IN: AL = separator char, SI = beginning; OUT: DI = next token or 0 if none
  1487                              <1> 
  1488                              <1> os_string_tokenize:
  1489 00002C36 56                  <1> 	push si
  1490                              <1> 
  1491                              <1> .next_char:
  1492 00002C37 3804                <1> 	cmp byte [si], al
  1493 00002C39 7408                <1> 	je .return_token
  1494 00002C3B 803C00              <1> 	cmp byte [si], 0
  1495 00002C3E 740B                <1> 	jz .no_more
  1496 00002C40 46                  <1> 	inc si
  1497 00002C41 EBF4                <1> 	jmp .next_char
  1498                              <1> 
  1499                              <1> .return_token:
  1500 00002C43 C60400              <1> 	mov byte [si], 0
  1501 00002C46 46                  <1> 	inc si
  1502 00002C47 89F7                <1> 	mov di, si
  1503 00002C49 5E                  <1> 	pop si
  1504 00002C4A C3                  <1> 	ret
  1505                              <1> 
  1506                              <1> .no_more:
  1507 00002C4B 31FF                <1> 	xor di, di
  1508 00002C4D 5E                  <1> 	pop si
  1509 00002C4E C3                  <1> 	ret
  1510                              <1> 
  1511                              <1> ; Converts an unsigned 32-bit integer into a string.
  1512                              <1> ; IN: EAX = unsigned int
  1513                              <1> ; OUT: AX = string location
  1514                              <1> 
  1515                              <1> os_32int_to_string:
  1516 00002C4F 6660                <1> 	pushad
  1517                              <1> 
  1518 00002C51 31C9                <1> 	xor cx, cx
  1519 00002C53 66BB0A000000        <1> 	mov ebx, 10			; Set BX 10, for division and mod
  1520 00002C59 BF[7E2C]            <1> 	mov di, .t			; Get our pointer ready
  1521                              <1> 
  1522                              <1> .push:
  1523 00002C5C 6631D2              <1> 	xor edx, edx
  1524 00002C5F 66F7F3              <1> 	div ebx				; Remainder in DX, quotient in AX
  1525 00002C62 41                  <1> 	inc cx				; Increase pop loop counter
  1526 00002C63 6652                <1> 	push edx			; Push remainder, so as to reverse order when popping
  1527 00002C65 6685C0              <1> 	test eax, eax		; Is quotient zero?
  1528 00002C68 75F2                <1> 	jnz .push			; If not, loop again
  1529                              <1> 
  1530                              <1> .pop:
  1531 00002C6A 665A                <1> 	pop edx				; Pop off values in reverse order, and add 48 to make them digits
  1532 00002C6C 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
  1533 00002C6F 8815                <1> 	mov [di], dl
  1534 00002C71 47                  <1> 	inc di
  1535 00002C72 49                  <1> 	dec cx
  1536 00002C73 75F5                <1> 	jnz .pop
  1537                              <1> 
  1538 00002C75 C60500              <1> 	mov byte [di], 0		; Zero-terminate string
  1539                              <1> 
  1540 00002C78 6661                <1> 	popad
  1541 00002C7A B8[7E2C]            <1> 	mov ax, .t			; Return location of string
  1542 00002C7D C3                  <1> 	ret
  1543                              <1> 
  1544                              <1> 
  1545 00002C7E 00<rep Bh>          <1> 	.t times 11 db 0
  1546                              <1> 
  1547                              <1> ; Converts a string into a 32-bit integer.
  1548                              <1> ; IN: SI = string location
  1549                              <1> ; OUT: EAX = unsigned integer
  1550                              <1> 
  1551                              <1> os_string_to_32int:
  1552 00002C89 6660                <1> 	pushad
  1553 00002C8B 6631C0              <1> 	xor eax, eax				; Temporary 32-bit integer
  1554                              <1> 	
  1555                              <1> .loop:
  1556 00002C8E 6650                <1> 	push eax
  1557 00002C90 AC                  <1> 	lodsb					; Load a byte from SI
  1558 00002C91 88C1                <1> 	mov cl, al
  1559 00002C93 6658                <1> 	pop eax
  1560 00002C95 80F900              <1> 	cmp cl, 0				; Have we reached the end?
  1561 00002C98 0F841400            <1> 	je near .exit			; If we have, exit
  1562 00002C9C 80E930              <1> 	sub cl, '0'				; Convert the value to decimal
  1563 00002C9F 6681E1FF000000      <1> 	and ecx, 255			; Keep the low 8 bits only
  1564 00002CA6 66F726[BF2C]        <1> 	mul dword [.divisor]	; Multiply EAX by 10
  1565 00002CAB 6601C8              <1> 	add eax, ecx			; Add the value to the integer
  1566 00002CAE EBDE                <1> 	jmp .loop				; Loop again
  1567                              <1> 	
  1568                              <1> .exit:
  1569 00002CB0 66A3[BB2C]          <1> 	mov [.tmp_dword], eax
  1570 00002CB4 6661                <1> 	popad
  1571 00002CB6 66A1[BB2C]          <1> 	mov eax, [.tmp_dword]
  1572 00002CBA C3                  <1> 	ret
  1573                              <1> 	
  1574 00002CBB 00000000            <1> 	.tmp_dword	dd 0
  1575 00002CBF 0A000000            <1> 	.divisor	dd 10
  1576                              <1> 	
  1577                              <1> ; Prints a 32 bit integer in decimal.
  1578                              <1> ; IN: EAX = unsigned integer
  1579                              <1> ; OUT: nothing
  1580                              <1> 
  1581                              <1> os_print_32int:
  1582 00002CC3 6660                <1> 	pushad
  1583 00002CC5 E887FF              <1> 	call os_32int_to_string
  1584 00002CC8 89C6                <1> 	mov si, ax
  1585 00002CCA E827EB              <1> 	call os_print_string
  1586 00002CCD 6661                <1> 	popad
  1587 00002CCF C3                  <1> 	ret
  1588                              <1> 	
  1589                              <1> ; ==================================================================
  1590                              <1> 
   818                                  	%INCLUDE "drivers/basic.asm"
   819                              <1> ; ==================================================================
   820                              <1> ; BASIC CODE INTERPRETER (4.5)
   821                              <1> ; ==================================================================
   822                              <1> 
   823                              <1> ; ------------------------------------------------------------------
   824                              <1> ; Token types
   825                              <1> 
   826                              <1> %DEFINE VARIABLE 1
   827                              <1> %DEFINE STRING_VAR 2
   828                              <1> %DEFINE NUMBER 3
   829                              <1> %DEFINE STRING 4
   830                              <1> %DEFINE QUOTE 5
   831                              <1> %DEFINE CHAR 6
   832                              <1> %DEFINE UNKNOWN 7
   833                              <1> %DEFINE LABEL 8
   834                              <1> 
   835                              <1> ; ------------------------------------------------------------------
   836                              <1> ; The BASIC interpreter execution starts here -- a parameter string
   837                              <1> ; is passed in SI and copied into the first string, unless SI = 0
   838                              <1> 
   839                              <1> os_run_basic:
   840 00002CD0 C606820001          <1> 	mov byte [0082h], 1
   841                              <1> 	
   842 00002CD5 8926[E745]          <1> 	mov word [orig_stack], sp		; Save stack pointer -- we might jump to the
   843                              <1> 						; error printing code and quit in the middle
   844                              <1> 						; some nested loops, and we want to preserve
   845                              <1> 						; the stack
   846                              <1> 
   847 00002CD9 A3[ED45]            <1> 	mov word [load_point], ax		; AX was passed as starting location of code
   848                              <1> 
   849 00002CDC A3[E945]            <1> 	mov word [prog], ax			; prog = pointer to current execution point in code
   850                              <1> 
   851 00002CDF 01C3                <1> 	add bx, ax				; We were passed the .BAS byte size in BX
   852 00002CE1 4B                  <1> 	dec bx
   853 00002CE2 4B                  <1> 	dec bx
   854 00002CE3 891E[EB45]          <1> 	mov word [prog_end], bx			; Make note of program end point
   855                              <1> 
   856                              <1> 
   857 00002CE7 E81D02              <1> 	call clear_ram				; Clear variables etc. from previous run
   858                              <1> 						; of a BASIC program
   859                              <1> 
   860 00002CEA 83FE00              <1> 	cmp si, 0				; Passed a parameter string?
   861 00002CED 7406                <1> 	je mainloop
   862                              <1> 
   863 00002CEF BF007C              <1> 	mov di, string_vars			; If so, copy it into $1
   864 00002CF2 E850FD              <1> 	call os_string_copy
   865                              <1> 
   866                              <1> 
   867                              <1> 
   868                              <1> mainloop:
   869 00002CF5 E86D17              <1> 	call get_token				; Get a token from the start of the line
   870                              <1> 
   871 00002CF8 83F804              <1> 	cmp ax, STRING				; Is the type a string of characters?
   872 00002CFB 7418                <1> 	je .keyword				; If so, let's see if it's a keyword to process
   873                              <1> 
   874 00002CFD 83F801              <1> 	cmp ax, VARIABLE			; If it's a variable at the start of the line,
   875 00002D00 0F844702            <1> 	je near assign				; this is an assign (eg "X = Y + 5")
   876                              <1> 
   877 00002D04 83F802              <1> 	cmp ax, STRING_VAR			; Same for a string variable (eg $1)
   878 00002D07 0F844002            <1> 	je near assign
   879                              <1> 
   880 00002D0B 83F808              <1> 	cmp ax, LABEL				; Don't need to do anything here - skip
   881 00002D0E 74E5                <1> 	je mainloop
   882                              <1> 
   883 00002D10 B314                <1> 	mov bl, err_syntax			; Otherwise show an error and quit
   884 00002D12 E96918              <1> 	jmp error
   885                              <1> 
   886                              <1> 
   887                              <1> .keyword:
   888 00002D15 BE007B              <1> 	mov si, token				; Start trying to match commands
   889                              <1> 
   890 00002D18 BF[F545]            <1> 	mov di, alert_cmd
   891 00002D1B E886FD              <1> 	call os_string_compare
   892 00002D1E 0F82CD04            <1> 	jc near do_alert
   893                              <1> 
   894 00002D22 BF[FB45]            <1> 	mov di, askfile_cmd
   895 00002D25 E87CFD              <1> 	call os_string_compare
   896 00002D28 0F820005            <1> 	jc near do_askfile
   897                              <1> 
   898 00002D2C BF[0346]            <1> 	mov di, break_cmd
   899 00002D2F E872FD              <1> 	call os_string_compare
   900 00002D32 0F823105            <1> 	jc near do_break
   901                              <1> 
   902 00002D36 BF[0E46]            <1> 	mov di, case_cmd
   903 00002D39 E868FD              <1> 	call os_string_compare
   904 00002D3C 0F825305            <1> 	jc near do_case
   905                              <1> 
   906 00002D40 BF[0946]            <1> 	mov di, call_cmd
   907 00002D43 E85EFD              <1> 	call os_string_compare
   908 00002D46 0F822205            <1> 	jc near do_call
   909                              <1> 
   910 00002D4A BF[1346]            <1> 	mov di, cls_cmd
   911 00002D4D E854FD              <1> 	call os_string_compare
   912 00002D50 0F829105            <1> 	jc near do_cls
   913                              <1> 
   914 00002D54 BF[1746]            <1> 	mov di, cursor_cmd
   915 00002D57 E84AFD              <1> 	call os_string_compare
   916 00002D5A 0F829B05            <1> 	jc near do_cursor
   917                              <1> 
   918 00002D5E BF[1E46]            <1> 	mov di, curschar_cmd
   919 00002D61 E840FD              <1> 	call os_string_compare
   920 00002D64 0F82C205            <1> 	jc near do_curschar
   921                              <1> 
   922 00002D68 BF[2746]            <1> 	mov di, curscol_cmd
   923 00002D6B E836FD              <1> 	call os_string_compare
   924 00002D6E 0F82E005            <1> 	jc near do_curscol
   925                              <1> 
   926 00002D72 BF[2F46]            <1> 	mov di, curspos_cmd
   927 00002D75 E82CFD              <1> 	call os_string_compare
   928 00002D78 0F82FE05            <1> 	jc near do_curspos
   929                              <1> 	
   930 00002D7C BF[3746]            <1> 	mov di, delete_cmd
   931 00002D7F E822FD              <1> 	call os_string_compare
   932 00002D82 0F822C06            <1> 	jc near do_delete
   933                              <1> 	
   934 00002D86 BF[3E46]            <1> 	mov di, do_cmd
   935 00002D89 E818FD              <1> 	call os_string_compare
   936 00002D8C 0F827906            <1> 	jc near do_do
   937                              <1> 
   938 00002D90 BF[4646]            <1> 	mov di, end_cmd
   939 00002D93 E80EFD              <1> 	call os_string_compare
   940 00002D96 0F82B606            <1> 	jc near do_end
   941                              <1> 
   942 00002D9A BF[4146]            <1> 	mov di, else_cmd
   943 00002D9D E804FD              <1> 	call os_string_compare
   944 00002DA0 0F828D06            <1> 	jc near do_else
   945                              <1> 
   946 00002DA4 BF[4A46]            <1> 	mov di, files_cmd
   947 00002DA7 E8FAFC              <1> 	call os_string_compare
   948 00002DAA 0F82B706            <1> 	jc near do_files
   949                              <1> 
   950 00002DAE BF[5046]            <1> 	mov di, for_cmd
   951 00002DB1 E8F0FC              <1> 	call os_string_compare
   952 00002DB4 0F821107            <1> 	jc near do_for
   953                              <1> 
   954 00002DB8 BF[5F46]            <1> 	mov di, getkey_cmd
   955 00002DBB E8E6FC              <1> 	call os_string_compare
   956 00002DBE 0F82B507            <1> 	jc near do_getkey
   957                              <1> 
   958 00002DC2 BF[5446]            <1> 	mov di, gosub_cmd
   959 00002DC5 E8DCFC              <1> 	call os_string_compare
   960 00002DC8 0F82F307            <1> 	jc near do_gosub
   961                              <1> 
   962 00002DCC BF[5A46]            <1> 	mov di, goto_cmd
   963 00002DCF E8D2FC              <1> 	call os_string_compare
   964 00002DD2 0F828608            <1> 	jc near do_goto
   965                              <1> 
   966 00002DD6 BF[6646]            <1> 	mov di, if_cmd
   967 00002DD9 E8C8FC              <1> 	call os_string_compare
   968 00002DDC 0F82FC08            <1> 	jc near do_if
   969                              <1> 
   970 00002DE0 BF[6946]            <1> 	mov di, include_cmd
   971 00002DE3 E8BEFC              <1> 	call os_string_compare
   972 00002DE6 0F82490A            <1> 	jc near do_include
   973                              <1> 
   974 00002DEA BF[7146]            <1> 	mov di, ink_cmd
   975 00002DED E8B4FC              <1> 	call os_string_compare
   976 00002DF0 0F826E0A            <1> 	jc near do_ink
   977                              <1> 
   978 00002DF4 BF[7546]            <1> 	mov di, input_cmd
   979 00002DF7 E8AAFC              <1> 	call os_string_compare
   980 00002DFA 0F82870A            <1> 	jc near do_input
   981                              <1> 	
   982 00002DFE BF[7B46]            <1> 	mov di, len_cmd
   983 00002E01 E8A0FC              <1> 	call os_string_compare
   984 00002E04 0F82E90A            <1> 	jc near do_len
   985                              <1> 
   986 00002E08 BF[7F46]            <1> 	mov di, listbox_cmd
   987 00002E0B E896FC              <1> 	call os_string_compare
   988 00002E0E 0F82270B            <1> 	jc near do_listbox
   989                              <1> 
   990 00002E12 BF[8746]            <1> 	mov di, load_cmd
   991 00002E15 E88CFC              <1> 	call os_string_compare
   992 00002E18 0F82B60B            <1> 	jc near do_load
   993                              <1> 
   994 00002E1C BF[8C46]            <1> 	mov di, loop_cmd
   995 00002E1F E882FC              <1> 	call os_string_compare
   996 00002E22 0F821E0C            <1> 	jc near do_loop
   997                              <1> 
   998 00002E26 BF[9146]            <1> 	mov di, move_cmd
   999 00002E29 E878FC              <1> 	call os_string_compare
  1000 00002E2C 0F82080D            <1> 	jc near do_move
  1001                              <1> 
  1002 00002E30 BF[9646]            <1> 	mov di, next_cmd
  1003 00002E33 E86EFC              <1> 	call os_string_compare
  1004 00002E36 0F82410D            <1> 	jc near do_next
  1005                              <1> 
  1006 00002E3A BF[9B46]            <1> 	mov di, number_cmd
  1007 00002E3D E864FC              <1> 	call os_string_compare
  1008 00002E40 0F82840D            <1> 	jc near do_number
  1009                              <1> 
  1010 00002E44 BF[A246]            <1> 	mov di, page_cmd
  1011 00002E47 E85AFC              <1> 	call os_string_compare
  1012 00002E4A 0F82E50D            <1> 	jc near do_page
  1013                              <1> 
  1014 00002E4E BF[A746]            <1> 	mov di, pause_cmd
  1015 00002E51 E850FC              <1> 	call os_string_compare
  1016 00002E54 0F820A0E            <1> 	jc near do_pause
  1017                              <1> 
  1018 00002E58 BF[AD46]            <1> 	mov di, peek_cmd
  1019 00002E5B E846FC              <1> 	call os_string_compare
  1020 00002E5E 0F821E0E            <1> 	jc near do_peek
  1021                              <1> 
  1022 00002E62 BF[B246]            <1> 	mov di, peekint_cmd
  1023 00002E65 E83CFC              <1> 	call os_string_compare
  1024 00002E68 0F82560E            <1> 	jc near do_peekint
  1025                              <1> 	
  1026 00002E6C BF[BA46]            <1> 	mov di, poke_cmd
  1027 00002E6F E832FC              <1> 	call os_string_compare
  1028 00002E72 0F82860E            <1> 	jc near do_poke
  1029                              <1> 	
  1030 00002E76 BF[BF46]            <1> 	mov di, pokeint_cmd
  1031 00002E79 E828FC              <1> 	call os_string_compare
  1032 00002E7C 0F82D40E            <1> 	jc near do_pokeint
  1033                              <1> 
  1034 00002E80 BF[C746]            <1> 	mov di, port_cmd
  1035 00002E83 E81EFC              <1> 	call os_string_compare
  1036 00002E86 0F820F0F            <1> 	jc near do_port
  1037                              <1> 
  1038 00002E8A BF[CC46]            <1> 	mov di, print_cmd
  1039 00002E8D E814FC              <1> 	call os_string_compare
  1040 00002E90 0F82870F            <1> 	jc near do_print
  1041                              <1> 
  1042 00002E94 BF[D246]            <1> 	mov di, rand_cmd
  1043 00002E97 E80AFC              <1> 	call os_string_compare
  1044 00002E9A 0F82AA10            <1> 	jc near do_rand
  1045                              <1> 
  1046 00002E9E BF[D746]            <1> 	mov di, read_cmd
  1047 00002EA1 E800FC              <1> 	call os_string_compare
  1048 00002EA4 0F82F210            <1> 	jc near do_read
  1049                              <1> 
  1050 00002EA8 BF[DC46]            <1> 	mov di, rem_cmd
  1051 00002EAB E8F6FB              <1> 	call os_string_compare
  1052 00002EAE 0F82BE11            <1> 	jc near do_rem
  1053                              <1> 
  1054 00002EB2 BF[E046]            <1> 	mov di, rename_cmd
  1055 00002EB5 E8ECFB              <1> 	call os_string_compare
  1056 00002EB8 0F82C511            <1> 	jc near do_rename
  1057                              <1> 
  1058 00002EBC BF[E746]            <1> 	mov di, return_cmd
  1059 00002EBF E8E2FB              <1> 	call os_string_compare
  1060 00002EC2 0F827012            <1> 	jc near do_return
  1061                              <1> 
  1062 00002EC6 BF[EE46]            <1> 	mov di, save_cmd
  1063 00002EC9 E8D8FB              <1> 	call os_string_compare
  1064 00002ECC 0F828712            <1> 	jc near do_save
  1065                              <1> 
  1066 00002ED0 BF[F346]            <1> 	mov di, serial_cmd
  1067 00002ED3 E8CEFB              <1> 	call os_string_compare
  1068 00002ED6 0F823C13            <1> 	jc near do_serial
  1069                              <1> 
  1070 00002EDA BF[FA46]            <1> 	mov di, size_cmd
  1071 00002EDD E8C4FB              <1> 	call os_string_compare
  1072 00002EE0 0F82D613            <1> 	jc near do_size
  1073                              <1> 
  1074 00002EE4 BF[FF46]            <1> 	mov di, sound_cmd
  1075 00002EE7 E8BAFB              <1> 	call os_string_compare
  1076 00002EEA 0F822114            <1> 	jc near do_sound
  1077                              <1> 	
  1078 00002EEE BF[0547]            <1> 	mov di, string_cmd
  1079 00002EF1 E8B0FB              <1> 	call os_string_compare
  1080 00002EF4 0F825314            <1> 	jc near do_string
  1081                              <1> 
  1082 00002EF8 BF[0C47]            <1> 	mov di, waitkey_cmd
  1083 00002EFB E8A6FB              <1> 	call os_string_compare
  1084 00002EFE 0F82FE14            <1> 	jc near do_waitkey
  1085                              <1> 
  1086 00002F02 B301                <1> 	mov bl, err_cmd_unknown			; Command not found?
  1087 00002F04 E97716              <1> 	jmp error
  1088                              <1> 
  1089                              <1> 
  1090                              <1> ; ------------------------------------------------------------------
  1091                              <1> ; CLEAR RAM
  1092                              <1> 
  1093                              <1> clear_ram:
  1094 00002F07 60                  <1> 	pusha
  1095 00002F08 B000                <1> 	mov al, 0
  1096                              <1> 
  1097 00002F0A BF4C7A              <1> 	mov di, variables
  1098 00002F0D B93400              <1> 	mov cx, 52
  1099 00002F10 F3AA                <1> 	rep stosb
  1100                              <1> 
  1101 00002F12 BF187A              <1> 	mov di, for_variables
  1102 00002F15 B93400              <1> 	mov cx, 52
  1103 00002F18 F3AA                <1> 	rep stosb
  1104                              <1> 
  1105 00002F1A BFE479              <1> 	mov di, for_code_points
  1106 00002F1D B93400              <1> 	mov cx, 52
  1107 00002F20 F3AA                <1> 	rep stosb
  1108                              <1> 	
  1109 00002F22 BFD079              <1> 	mov di, do_loop_store
  1110 00002F25 B90A00              <1> 	mov cx, 10
  1111 00002F28 F3AA                <1> 	rep stosb
  1112                              <1> 
  1113 00002F2A C606[6047]00        <1> 	mov byte [gosub_depth], 0
  1114 00002F2F C606[F045]00        <1> 	mov byte [loop_in], 0
  1115                              <1> 
  1116 00002F34 BFBC79              <1> 	mov di, gosub_points
  1117 00002F37 B91400              <1> 	mov cx, 20
  1118 00002F3A F3AA                <1> 	rep stosb
  1119                              <1> 
  1120 00002F3C BF007C              <1> 	mov di, string_vars
  1121 00002F3F B90004              <1> 	mov cx, 1024
  1122 00002F42 F3AA                <1> 	rep stosb
  1123                              <1> 
  1124 00002F44 C606[F245]07        <1> 	mov byte [ink_colour], 7		; White ink
  1125                              <1> 
  1126 00002F49 61                  <1> 	popa
  1127 00002F4A C3                  <1> 	ret
  1128                              <1> 
  1129                              <1> 
  1130                              <1> ; ------------------------------------------------------------------
  1131                              <1> ; ASSIGNMENT
  1132                              <1> 
  1133                              <1> assign:
  1134 00002F4B 83F801              <1> 	cmp ax, VARIABLE			; Are we starting with a number var?
  1135 00002F4E 0F84A700            <1> 	je .do_num_var
  1136                              <1> 
  1137 00002F52 BF007C              <1> 	mov di, string_vars			; Otherwise it's a string var
  1138 00002F55 B88000              <1> 	mov ax, 128
  1139 00002F58 F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
  1140 00002F5A 01C7                <1> 	add di, ax
  1141                              <1> 
  1142 00002F5C 57                  <1> 	push di
  1143                              <1> 
  1144 00002F5D E80515              <1> 	call get_token
  1145 00002F60 A0007B              <1> 	mov byte al, [token]
  1146 00002F63 3C3D                <1> 	cmp al, '='
  1147 00002F65 0F857D02            <1> 	jne near .error
  1148                              <1> 
  1149 00002F69 E8F914              <1> 	call get_token				; See if second is quote
  1150 00002F6C 83F805              <1> 	cmp ax, QUOTE
  1151 00002F6F 7417                <1> 	je .second_is_quote
  1152                              <1> 
  1153 00002F71 83F802              <1> 	cmp ax, STRING_VAR
  1154 00002F74 0F856E02            <1> 	jne near .error
  1155                              <1> 
  1156 00002F78 BE007C              <1> 	mov si, string_vars			; Otherwise it's a string var
  1157 00002F7B B88000              <1> 	mov ax, 128
  1158 00002F7E F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
  1159 00002F80 01C6                <1> 	add si, ax
  1160                              <1> 
  1161 00002F82 5F                  <1> 	pop di
  1162 00002F83 E8BFFA              <1> 	call os_string_copy
  1163                              <1> 
  1164 00002F86 EB07                <1> 	jmp .string_check_for_more
  1165                              <1> 
  1166                              <1> 
  1167                              <1> .second_is_quote:
  1168 00002F88 BE007B              <1> 	mov si, token
  1169 00002F8B 5F                  <1> 	pop di
  1170 00002F8C E8B6FA              <1> 	call os_string_copy
  1171                              <1> 
  1172                              <1> 
  1173                              <1> .string_check_for_more:
  1174 00002F8F 57                  <1> 	push di
  1175 00002F90 A1[E945]            <1> 	mov word ax, [prog]			; Save code location in case there's no delimiter
  1176 00002F93 A3[EC31]            <1> 	mov word [.tmp_loc], ax
  1177                              <1> 
  1178 00002F96 E8CC14              <1> 	call get_token				; Any more to deal with in this assignment?
  1179 00002F99 A0007B              <1> 	mov byte al, [token]
  1180 00002F9C 3C2B                <1> 	cmp al, '+'
  1181 00002F9E 740A                <1> 	je .string_theres_more
  1182                              <1> 
  1183 00002FA0 A1[EC31]            <1> 	mov word ax, [.tmp_loc]			; Not a delimiter, so step back before the token
  1184 00002FA3 A3[E945]            <1> 	mov word [prog], ax			; that we just grabbed
  1185                              <1> 
  1186 00002FA6 5F                  <1> 	pop di
  1187 00002FA7 E94BFD              <1> 	jmp mainloop				; And go back to the code interpreter!
  1188                              <1> 
  1189                              <1> 
  1190                              <1> .string_theres_more:
  1191 00002FAA E8B814              <1> 	call get_token
  1192 00002FAD 83F802              <1> 	cmp ax, STRING_VAR
  1193 00002FB0 740D                <1> 	je .another_string_var
  1194 00002FB2 83F805              <1> 	cmp ax, QUOTE
  1195 00002FB5 741E                <1> 	je .another_quote
  1196 00002FB7 83F801              <1> 	cmp ax, VARIABLE
  1197 00002FBA 7426                <1> 	je .add_number_var
  1198 00002FBC E92702              <1> 	jmp .error
  1199                              <1> 
  1200                              <1> 
  1201                              <1> .another_string_var:
  1202 00002FBF 5F                  <1> 	pop di
  1203                              <1> 
  1204 00002FC0 BE007C              <1> 	mov si, string_vars
  1205 00002FC3 B88000              <1> 	mov ax, 128
  1206 00002FC6 F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
  1207 00002FC8 01C6                <1> 	add si, ax
  1208                              <1> 
  1209 00002FCA 89F8                <1> 	mov ax, di
  1210 00002FCC 89F9                <1> 	mov cx, di
  1211 00002FCE 89F3                <1> 	mov bx, si
  1212 00002FD0 E87BFA              <1> 	call os_string_join
  1213                              <1> 
  1214 00002FD3 EBBA                <1> 	jmp .string_check_for_more
  1215                              <1> 
  1216                              <1> 
  1217                              <1> 
  1218                              <1> .another_quote:
  1219 00002FD5 5F                  <1> 	pop di
  1220                              <1> 
  1221 00002FD6 89F8                <1> 	mov ax, di
  1222 00002FD8 89F9                <1> 	mov cx, di
  1223 00002FDA BB007B              <1> 	mov bx, token
  1224 00002FDD E86EFA              <1> 	call os_string_join
  1225                              <1> 
  1226 00002FE0 EBAD                <1> 	jmp .string_check_for_more
  1227                              <1> 
  1228                              <1> 
  1229                              <1> .add_number_var:
  1230 00002FE2 31C0                <1> 	xor ax, ax
  1231 00002FE4 A0007B              <1> 	mov byte al, [token]
  1232 00002FE7 E85F14              <1> 	call get_var
  1233 00002FEA E856FB              <1> 	call os_int_to_string
  1234                              <1> 
  1235 00002FED 89C3                <1> 	mov bx, ax
  1236 00002FEF 5F                  <1> 	pop di
  1237 00002FF0 89F8                <1> 	mov ax, di
  1238 00002FF2 89F9                <1> 	mov cx, di
  1239 00002FF4 E857FA              <1> 	call os_string_join
  1240                              <1> 
  1241 00002FF7 EB96                <1> 	jmp .string_check_for_more
  1242                              <1> 	
  1243                              <1> 
  1244                              <1> 
  1245                              <1> 
  1246                              <1> .do_num_var:
  1247 00002FF9 31C0                <1> 	xor ax, ax
  1248 00002FFB A0007B              <1> 	mov byte al, [token]
  1249 00002FFE A2[EB31]            <1> 	mov byte [.tmp], al
  1250                              <1> 
  1251 00003001 E86114              <1> 	call get_token
  1252 00003004 A0007B              <1> 	mov byte al, [token]
  1253 00003007 3C3D                <1> 	cmp al, '='
  1254 00003009 0F85D901            <1> 	jne near .error
  1255                              <1> 
  1256 0000300D E85514              <1> 	call get_token
  1257 00003010 83F803              <1> 	cmp ax, NUMBER
  1258 00003013 744D                <1> 	je .second_is_num
  1259                              <1> 
  1260 00003015 83F801              <1> 	cmp ax, VARIABLE
  1261 00003018 7436                <1> 	je .second_is_variable
  1262                              <1> 
  1263 0000301A 83F804              <1> 	cmp ax, STRING
  1264 0000301D 0F842F01            <1> 	je near .second_is_string
  1265                              <1> 
  1266 00003021 83F807              <1> 	cmp ax, UNKNOWN
  1267 00003024 0F85BE01            <1> 	jne near .error
  1268                              <1> 
  1269 00003028 A0007B              <1> 	mov byte al, [token]			; Address of string var?
  1270 0000302B 3C26                <1> 	cmp al, '&'
  1271 0000302D 0F85B501            <1> 	jne near .error
  1272                              <1> 
  1273 00003031 E83114              <1> 	call get_token				; Let's see if there's a string var
  1274 00003034 83F802              <1> 	cmp ax, STRING_VAR
  1275 00003037 0F85AB01            <1> 	jne near .error
  1276                              <1> 
  1277 0000303B BF007C              <1> 	mov di, string_vars
  1278 0000303E B88000              <1> 	mov ax, 128
  1279 00003041 F7E3                <1> 	mul bx
  1280 00003043 01C7                <1> 	add di, ax
  1281                              <1> 
  1282 00003045 89FB                <1> 	mov bx, di
  1283                              <1> 
  1284 00003047 A0[EB31]            <1> 	mov byte al, [.tmp]
  1285 0000304A E80914              <1> 	call set_var
  1286                              <1> 
  1287 0000304D E9A5FC              <1> 	jmp mainloop
  1288                              <1> 
  1289                              <1> 
  1290                              <1> .second_is_variable:
  1291 00003050 31C0                <1> 	xor ax, ax
  1292 00003052 A0007B              <1> 	mov byte al, [token]
  1293                              <1> 
  1294 00003055 E8F113              <1> 	call get_var
  1295 00003058 89C3                <1> 	mov bx, ax
  1296 0000305A A0[EB31]            <1> 	mov byte al, [.tmp]
  1297 0000305D E8F613              <1> 	call set_var
  1298                              <1> 
  1299 00003060 EB10                <1> 	jmp .check_for_more
  1300                              <1> 
  1301                              <1> 
  1302                              <1> .second_is_num:
  1303 00003062 BE007B              <1> 	mov si, token
  1304 00003065 E890FA              <1> 	call os_string_to_int
  1305                              <1> 
  1306 00003068 89C3                <1> 	mov bx, ax				; Number to insert in variable table
  1307                              <1> 
  1308 0000306A 31C0                <1> 	xor ax, ax
  1309 0000306C A0[EB31]            <1> 	mov byte al, [.tmp]
  1310                              <1> 
  1311 0000306F E8E413              <1> 	call set_var
  1312                              <1> 
  1313                              <1> 
  1314                              <1> 	; The assignment could be simply "X = 5" etc. Or it could be
  1315                              <1> 	; "X = Y + 5" -- ie more complicated. So here we check to see if
  1316                              <1> 	; there's a delimiter...
  1317                              <1> 
  1318                              <1> .check_for_more:
  1319 00003072 A1[E945]            <1> 	mov word ax, [prog]			; Save code location in case there's no delimiter
  1320 00003075 A3[EC31]            <1> 	mov word [.tmp_loc], ax
  1321                              <1> 
  1322 00003078 E8EA13              <1> 	call get_token				; Any more to deal with in this assignment?
  1323 0000307B A0007B              <1> 	mov byte al, [token]
  1324 0000307E 3C2B                <1> 	cmp al, '+'
  1325 00003080 7419                <1> 	je .theres_more
  1326 00003082 3C2D                <1> 	cmp al, '-'
  1327 00003084 7415                <1> 	je .theres_more
  1328 00003086 3C2A                <1> 	cmp al, '*'
  1329 00003088 7411                <1> 	je .theres_more
  1330 0000308A 3C2F                <1> 	cmp al, '/'
  1331 0000308C 740D                <1> 	je .theres_more
  1332 0000308E 3C25                <1> 	cmp al, '%'
  1333 00003090 7409                <1> 	je .theres_more
  1334                              <1> 
  1335 00003092 A1[EC31]            <1> 	mov word ax, [.tmp_loc]			; Not a delimiter, so step back before the token
  1336 00003095 A3[E945]            <1> 	mov word [prog], ax			; that we just grabbed
  1337                              <1> 
  1338 00003098 E95AFC              <1> 	jmp mainloop				; And go back to the code interpreter!
  1339                              <1> 
  1340                              <1> 
  1341                              <1> .theres_more:
  1342 0000309B A2[EE31]            <1> 	mov byte [.delim], al
  1343                              <1> 
  1344 0000309E E8C413              <1> 	call get_token
  1345 000030A1 83F801              <1> 	cmp ax, VARIABLE
  1346 000030A4 7459                <1> 	je .handle_variable
  1347                              <1> 
  1348 000030A6 BE007B              <1> 	mov si, token
  1349 000030A9 E84CFA              <1> 	call os_string_to_int
  1350 000030AC 89C3                <1> 	mov bx, ax
  1351                              <1> 
  1352 000030AE 31C0                <1> 	xor ax, ax
  1353 000030B0 A0[EB31]            <1> 	mov byte al, [.tmp]
  1354                              <1> 
  1355 000030B3 E89313              <1> 	call get_var				; This also points SI at right place in variable table
  1356                              <1> 
  1357 000030B6 803E[EE31]2B        <1> 	cmp byte [.delim], '+'
  1358 000030BB 7504                <1> 	jne .not_plus
  1359                              <1> 
  1360 000030BD 01D8                <1> 	add ax, bx
  1361 000030BF EB2E                <1> 	jmp .finish
  1362                              <1> 
  1363                              <1> .not_plus:
  1364 000030C1 803E[EE31]2D        <1> 	cmp byte [.delim], '-'
  1365 000030C6 7504                <1> 	jne .not_minus
  1366                              <1> 
  1367 000030C8 29D8                <1> 	sub ax, bx
  1368 000030CA EB23                <1> 	jmp .finish
  1369                              <1> 
  1370                              <1> .not_minus:
  1371 000030CC 803E[EE31]2A        <1> 	cmp byte [.delim], '*'
  1372 000030D1 7504                <1> 	jne .not_times
  1373                              <1> 
  1374 000030D3 F7E3                <1> 	mul bx
  1375 000030D5 EB18                <1> 	jmp .finish
  1376                              <1> 
  1377                              <1> .not_times:
  1378 000030D7 803E[EE31]2F        <1> 	cmp byte [.delim], '/'
  1379 000030DC 750B                <1> 	jne .not_divide
  1380                              <1> 
  1381 000030DE 83FB00              <1> 	cmp bx, 0
  1382 000030E1 7417                <1> 	je .divide_zero
  1383                              <1> 	
  1384 000030E3 31D2                <1> 	xor dx, dx
  1385 000030E5 F7F3                <1> 	div bx
  1386 000030E7 EB06                <1> 	jmp .finish
  1387                              <1> 
  1388                              <1> .not_divide:
  1389 000030E9 31D2                <1> 	xor dx, dx
  1390 000030EB F7F3                <1> 	div bx
  1391 000030ED 89D0                <1> 	mov ax, dx				; Get remainder
  1392                              <1> 
  1393                              <1> .finish:
  1394 000030EF 89C3                <1> 	mov bx, ax
  1395 000030F1 A0[EB31]            <1> 	mov byte al, [.tmp]
  1396 000030F4 E85F13              <1> 	call set_var
  1397                              <1> 
  1398 000030F7 E978FF              <1> 	jmp .check_for_more
  1399                              <1> 
  1400                              <1> .divide_zero:
  1401 000030FA B302                <1> 	mov bl, err_divide_by_zero
  1402 000030FC E97F14              <1> 	jmp error
  1403                              <1> 	
  1404                              <1> .handle_variable:
  1405 000030FF 31C0                <1> 	xor ax, ax
  1406 00003101 A0007B              <1> 	mov byte al, [token]
  1407                              <1> 
  1408 00003104 E84213              <1> 	call get_var
  1409                              <1> 
  1410 00003107 89C3                <1> 	mov bx, ax
  1411                              <1> 
  1412 00003109 31C0                <1> 	xor ax, ax
  1413 0000310B A0[EB31]            <1> 	mov byte al, [.tmp]
  1414                              <1> 
  1415 0000310E E83813              <1> 	call get_var
  1416                              <1> 
  1417 00003111 803E[EE31]2B        <1> 	cmp byte [.delim], '+'
  1418 00003116 7504                <1> 	jne .vnot_plus
  1419                              <1> 
  1420 00003118 01D8                <1> 	add ax, bx
  1421 0000311A EB29                <1> 	jmp .vfinish
  1422                              <1> 
  1423                              <1> .vnot_plus:
  1424 0000311C 803E[EE31]2D        <1> 	cmp byte [.delim], '-'
  1425 00003121 7504                <1> 	jne .vnot_minus
  1426                              <1> 
  1427 00003123 29D8                <1> 	sub ax, bx
  1428 00003125 EB1E                <1> 	jmp .vfinish
  1429                              <1> 
  1430                              <1> .vnot_minus:
  1431 00003127 803E[EE31]2A        <1> 	cmp byte [.delim], '*'
  1432 0000312C 7504                <1> 	jne .vnot_times
  1433                              <1> 
  1434 0000312E F7E3                <1> 	mul bx
  1435 00003130 EB13                <1> 	jmp .vfinish
  1436                              <1> 
  1437                              <1> .vnot_times:
  1438 00003132 803E[EE31]2F        <1> 	cmp byte [.delim], '/'
  1439 00003137 7506                <1> 	jne .vnot_divide
  1440                              <1> 
  1441 00003139 31D2                <1> 	xor dx, dx
  1442 0000313B F7F3                <1> 	div bx
  1443 0000313D EBB0                <1> 	jmp .finish
  1444                              <1> 
  1445                              <1> .vnot_divide:
  1446 0000313F 31D2                <1> 	xor dx, dx
  1447 00003141 F7F3                <1> 	div bx
  1448 00003143 89D0                <1> 	mov ax, dx				; Get remainder
  1449                              <1> 
  1450                              <1> .vfinish:
  1451 00003145 89C3                <1> 	mov bx, ax
  1452 00003147 A0[EB31]            <1> 	mov byte al, [.tmp]
  1453 0000314A E80913              <1> 	call set_var
  1454                              <1> 
  1455 0000314D E922FF              <1> 	jmp .check_for_more
  1456                              <1> 
  1457                              <1> 
  1458                              <1> .second_is_string:				; These are "X = word" functions
  1459 00003150 BF007B              <1> 	mov di, token
  1460                              <1> 	
  1461 00003153 BE[3147]            <1> 	mov si, ink_keyword
  1462 00003156 E84BF9              <1> 	call os_string_compare
  1463 00003159 742A                <1> 	je .is_ink
  1464                              <1> 	
  1465 0000315B BE[3547]            <1> 	mov si, progstart_keyword
  1466 0000315E E843F9              <1> 	call os_string_compare
  1467 00003161 7433                <1> 	je .is_progstart
  1468                              <1> 
  1469 00003163 BE[3F47]            <1> 	mov si, ramstart_keyword
  1470 00003166 E83BF9              <1> 	call os_string_compare
  1471 00003169 743A                <1> 	je .is_ramstart
  1472                              <1> 
  1473 0000316B BE[4847]            <1> 	mov si, timer_keyword
  1474 0000316E E833F9              <1> 	call os_string_compare
  1475 00003171 7444                <1> 	je .is_timer
  1476                              <1> 	
  1477 00003173 BE[4E47]            <1> 	mov si, variables_keyword
  1478 00003176 E82BF9              <1> 	call os_string_compare
  1479 00003179 744E                <1> 	je .is_variables
  1480                              <1> 	
  1481 0000317B BE[5847]            <1> 	mov si, version_keyword
  1482 0000317E E823F9              <1> 	call os_string_compare
  1483 00003181 7454                <1> 	je .is_version
  1484                              <1> 
  1485 00003183 EB61                <1> 	jmp .error
  1486                              <1> 
  1487                              <1> 
  1488                              <1> .is_ink:
  1489 00003185 0FB606[EB31]        <1> 	movzx ax, byte [.tmp]
  1490                              <1> 	
  1491 0000318A 31C0                <1> 	xor ax, ax
  1492 0000318C 8A1E[F245]          <1> 	mov byte bl, [ink_colour]
  1493 00003190 E8C312              <1> 	call set_var
  1494                              <1> 	
  1495 00003193 E95FFB              <1> 	jmp mainloop
  1496                              <1> 
  1497                              <1> 
  1498                              <1> .is_progstart:
  1499 00003196 0FB606[EB31]        <1> 	movzx ax, byte [.tmp]
  1500                              <1> 
  1501 0000319B 8B1E[ED45]          <1> 	mov word bx, [load_point]
  1502 0000319F E8B412              <1> 	call set_var
  1503                              <1> 
  1504 000031A2 E950FB              <1> 	jmp mainloop
  1505                              <1> 
  1506                              <1> 
  1507                              <1> .is_ramstart:
  1508 000031A5 31C0                <1> 	xor ax, ax
  1509 000031A7 A0[EB31]            <1> 	mov byte al, [.tmp]
  1510                              <1> 
  1511 000031AA 8B1E[EB45]          <1> 	mov word bx, [prog_end]
  1512 000031AE 43                  <1> 	inc bx
  1513 000031AF 43                  <1> 	inc bx
  1514 000031B0 43                  <1> 	inc bx
  1515 000031B1 E8A212              <1> 	call set_var
  1516                              <1> 
  1517 000031B4 E93EFB              <1> 	jmp mainloop
  1518                              <1> 
  1519                              <1> 
  1520                              <1> .is_timer:
  1521 000031B7 B400                <1> 	mov ah, 0
  1522 000031B9 E8FCE4              <1> 	call os_int_1Ah
  1523 000031BC 89D3                <1> 	mov bx, dx
  1524                              <1> 
  1525 000031BE 31C0                <1> 	xor ax, ax
  1526 000031C0 A0[EB31]            <1> 	mov byte al, [.tmp]
  1527 000031C3 E89012              <1> 	call set_var
  1528                              <1> 
  1529 000031C6 E92CFB              <1> 	jmp mainloop
  1530                              <1> 
  1531                              <1> 
  1532                              <1> .is_variables:
  1533 000031C9 BB[F045]            <1> 	mov bx, vars_loc
  1534 000031CC 31C0                <1> 	xor ax, ax
  1535 000031CE A0[EB31]            <1> 	mov byte al, [.tmp]
  1536 000031D1 E88212              <1> 	call set_var
  1537                              <1> 
  1538 000031D4 E91EFB              <1> 	jmp mainloop
  1539                              <1> 
  1540                              <1> 
  1541                              <1> .is_version:
  1542 000031D7 B0FF                <1> 	mov al, 255
  1543                              <1> 	
  1544 000031D9 B700                <1> 	mov bh, 0
  1545 000031DB 88C3                <1> 	mov bl, al
  1546 000031DD A0[EB31]            <1> 	mov al, [.tmp]
  1547 000031E0 E87312              <1> 	call set_var
  1548                              <1> 	
  1549 000031E3 E90FFB              <1> 	jmp mainloop 
  1550                              <1> 
  1551                              <1> 
  1552                              <1> .error:
  1553 000031E6 B314                <1> 	mov bl, err_syntax
  1554 000031E8 E99313              <1> 	jmp error
  1555                              <1> 
  1556                              <1> 
  1557 000031EB 00                  <1> 	.tmp		db 0
  1558 000031EC 0000                <1> 	.tmp_loc	dw 0
  1559 000031EE 00                  <1> 	.delim		db 0
  1560                              <1> 
  1561                              <1> 
  1562                              <1> ; ==================================================================
  1563                              <1> ; SPECIFIC COMMAND CODE STARTS HERE
  1564                              <1> 
  1565                              <1> ; ------------------------------------------------------------------
  1566                              <1> ; ALERT
  1567                              <1> 
  1568                              <1> do_alert:
  1569 000031EF 8A3E[F345]          <1> 	mov bh, [work_page]			; Store the cursor position
  1570 000031F3 B403                <1> 	mov ah, 03h
  1571 000031F5 CD10                <1> 	int 10h
  1572                              <1> 
  1573 000031F7 E86B12              <1> 	call get_token
  1574                              <1> 
  1575 000031FA 83F805              <1> 	cmp ax, QUOTE
  1576 000031FD 7416                <1> 	je .is_quote
  1577                              <1> 	
  1578 000031FF 83F802              <1> 	cmp ax, STRING_VAR
  1579 00003202 7405                <1> 	je .is_string
  1580                              <1> 
  1581 00003204 B314                <1> 	mov bl, err_syntax
  1582 00003206 E97513              <1> 	jmp error
  1583                              <1> 
  1584                              <1> .is_string:
  1585 00003209 BE007C              <1> 	mov si, string_vars
  1586 0000320C B88000              <1> 	mov ax, 128
  1587 0000320F F7E3                <1> 	mul bx
  1588 00003211 01F0                <1> 	add ax, si
  1589 00003213 EB03                <1> 	jmp .display_message
  1590                              <1> 	
  1591                              <1> .is_quote:
  1592 00003215 B8007B              <1> 	mov ax, token				; First string for alert box
  1593                              <1> 	
  1594                              <1> .display_message:
  1595 00003218 31DB                <1> 	xor bx, bx				; Others are blank
  1596 0000321A 31C9                <1> 	xor cx, cx
  1597 0000321C 31D2                <1> 	xor dx, dx				; One-choice box
  1598 0000321E E816EE              <1> 	call os_dialog_box
  1599                              <1> 	
  1600 00003221 8A3E[F345]          <1> 	mov bh, [work_page]			; Move the cursor back
  1601 00003225 B402                <1> 	mov ah, 02h
  1602 00003227 CD10                <1> 	int 10h
  1603                              <1> 	
  1604 00003229 E9C9FA              <1> 	jmp mainloop
  1605                              <1> 
  1606                              <1> 
  1607                              <1> ;-------------------------------------------------------------------
  1608                              <1> ; ASKFILE
  1609                              <1> 
  1610                              <1> do_askfile:
  1611 0000322C 8A3E[F345]          <1> 	mov bh, [work_page]			; Store the cursor position
  1612 00003230 B403                <1> 	mov ah, 03h
  1613 00003232 CD10                <1> 	int 10h
  1614                              <1> 	
  1615 00003234 E82E12              <1> 	call get_token
  1616                              <1> 	
  1617 00003237 83F802              <1> 	cmp ax, STRING_VAR
  1618 0000323A 7524                <1> 	jne .error
  1619                              <1> 	
  1620 0000323C BE007C              <1> 	mov si, string_vars			; Get the string location
  1621 0000323F B88000              <1> 	mov ax, 128
  1622 00003242 F7E3                <1> 	mul bx
  1623 00003244 01F0                <1> 	add ax, si
  1624 00003246 A3[6532]            <1> 	mov word [.tmp], ax
  1625                              <1> 	
  1626 00003249 E87BE6              <1> 	call os_file_selector			; Present the selector
  1627                              <1> 	
  1628 0000324C 8B3E[6532]          <1> 	mov word di, [.tmp]			; Copy the string
  1629 00003250 89C6                <1> 	mov si, ax
  1630 00003252 E8F0F7              <1> 	call os_string_copy
  1631                              <1> 
  1632 00003255 8A3E[F345]          <1> 	mov bh, [work_page]			; Move the cursor back
  1633 00003259 B402                <1> 	mov ah, 02h
  1634 0000325B CD10                <1> 	int 10h
  1635                              <1> 	
  1636 0000325D E995FA              <1> 	jmp mainloop
  1637                              <1> 	
  1638                              <1> .error:
  1639 00003260 B314                <1> 	mov bl, err_syntax
  1640 00003262 E91913              <1> 	jmp error
  1641                              <1> 
  1642                              <1> .data:
  1643 00003265 0000                <1> 	.tmp					dw 0
  1644                              <1> 
  1645                              <1> 
  1646                              <1> ; ------------------------------------------------------------------
  1647                              <1> ; BREAK
  1648                              <1> 
  1649                              <1> do_break:
  1650 00003267 B3[D1]              <1> 	mov bl, err_break
  1651 00003269 E91213              <1> 	jmp error
  1652                              <1> 
  1653                              <1> 
  1654                              <1> ; ------------------------------------------------------------------
  1655                              <1> ; CALL
  1656                              <1> 
  1657                              <1> do_call:
  1658 0000326C E8F611              <1> 	call get_token
  1659 0000326F 83F803              <1> 	cmp ax, NUMBER
  1660 00003272 740A                <1> 	je .is_number
  1661                              <1> 
  1662 00003274 31C0                <1> 	xor ax, ax
  1663 00003276 A0007B              <1> 	mov byte al, [token]
  1664 00003279 E8CD11              <1> 	call get_var
  1665 0000327C EB06                <1> 	jmp .execute_call
  1666                              <1> 
  1667                              <1> .is_number:
  1668 0000327E BE007B              <1> 	mov si, token
  1669 00003281 E874F8              <1> 	call os_string_to_int
  1670                              <1> 
  1671                              <1> .execute_call:
  1672 00003284 31DB                <1> 	xor bx, bx
  1673 00003286 31C9                <1> 	xor cx, cx
  1674 00003288 31D2                <1> 	xor dx, dx
  1675 0000328A 31FF                <1> 	xor di, di
  1676 0000328C 31F6                <1> 	xor si, si
  1677                              <1> 
  1678 0000328E FFD0                <1> 	call ax
  1679                              <1> 
  1680 00003290 E962FA              <1> 	jmp mainloop
  1681                              <1> 
  1682                              <1> 
  1683                              <1> ; ------------------------------------------------------------------
  1684                              <1> ; CASE
  1685                              <1> 
  1686                              <1> do_case:
  1687 00003293 E8CF11              <1> 	call get_token
  1688 00003296 83F804              <1> 	cmp ax, STRING
  1689 00003299 7545                <1> 	jne .error
  1690                              <1> 	
  1691 0000329B BE007B              <1> 	mov si, token
  1692                              <1> 
  1693 0000329E BF[2B47]            <1> 	mov di, upper_keyword
  1694 000032A1 E800F8              <1> 	call os_string_compare
  1695 000032A4 720A                <1> 	jc .uppercase
  1696                              <1> 	
  1697 000032A6 BF[2547]            <1> 	mov di, lower_keyword
  1698 000032A9 E8F8F7              <1> 	call os_string_compare
  1699 000032AC 721A                <1> 	jc .lowercase
  1700                              <1> 	
  1701 000032AE EB30                <1> 	jmp .error
  1702                              <1> 	
  1703                              <1> .uppercase:
  1704 000032B0 E8B211              <1> 	call get_token
  1705 000032B3 83F802              <1> 	cmp ax, STRING_VAR
  1706 000032B6 7528                <1> 	jne .error
  1707                              <1> 	
  1708 000032B8 BE007C              <1> 	mov si, string_vars
  1709 000032BB B88000              <1> 	mov ax, 128
  1710 000032BE F7E3                <1> 	mul bx
  1711 000032C0 01F0                <1> 	add ax, si
  1712                              <1> 	
  1713 000032C2 E846F7              <1> 	call os_string_uppercase
  1714                              <1> 	
  1715 000032C5 E92DFA              <1> 	jmp mainloop
  1716                              <1> 	
  1717                              <1> .lowercase:
  1718 000032C8 E89A11              <1> 	call get_token
  1719 000032CB 83F802              <1> 	cmp ax, STRING_VAR
  1720 000032CE 7510                <1> 	jne .error
  1721                              <1> 	
  1722 000032D0 BE007C              <1> 	mov si, string_vars
  1723 000032D3 B88000              <1> 	mov ax, 128
  1724 000032D6 F7E3                <1> 	mul bx
  1725 000032D8 01F0                <1> 	add ax, si
  1726                              <1> 	
  1727 000032DA E84BF7              <1> 	call os_string_lowercase
  1728                              <1> 	
  1729 000032DD E915FA              <1> 	jmp mainloop
  1730                              <1> 	
  1731                              <1> .error:
  1732 000032E0 B314                <1> 	mov bl, err_syntax
  1733 000032E2 E99912              <1> 	jmp error
  1734                              <1> 
  1735                              <1> 
  1736                              <1> ; ------------------------------------------------------------------
  1737                              <1> ; CLS
  1738                              <1> 
  1739                              <1> do_cls:
  1740 000032E5 B405                <1> 	mov ah, 5
  1741 000032E7 A0[F345]            <1> 	mov byte al, [work_page]
  1742 000032EA CD10                <1> 	int 10h
  1743                              <1> 
  1744 000032EC E860E5              <1> 	call os_clear_screen
  1745                              <1> 
  1746 000032EF B405                <1> 	mov ah, 5
  1747 000032F1 A0[F445]            <1> 	mov byte al, [disp_page]
  1748 000032F4 CD10                <1> 	int 10h
  1749                              <1> 
  1750 000032F6 E9FCF9              <1> 	jmp mainloop
  1751                              <1> 
  1752                              <1> 
  1753                              <1> 
  1754                              <1> ; ------------------------------------------------------------------
  1755                              <1> ; CURSOR
  1756                              <1> 
  1757                              <1> do_cursor:
  1758 000032F9 E86911              <1> 	call get_token
  1759                              <1> 
  1760 000032FC BE007B              <1> 	mov si, token
  1761 000032FF BF[2333]            <1> 	mov di, .on_str
  1762 00003302 E89FF7              <1> 	call os_string_compare
  1763 00003305 7210                <1> 	jc .turn_on
  1764                              <1> 
  1765 00003307 BE007B              <1> 	mov si, token
  1766 0000330A BF[2633]            <1> 	mov di, .off_str
  1767 0000330D E894F7              <1> 	call os_string_compare
  1768 00003310 720B                <1> 	jc .turn_off
  1769                              <1> 
  1770 00003312 B314                <1> 	mov bl, err_syntax
  1771 00003314 E96712              <1> 	jmp error
  1772                              <1> 
  1773                              <1> .turn_on:
  1774 00003317 E880E5              <1> 	call os_show_cursor
  1775 0000331A E9D8F9              <1> 	jmp mainloop
  1776                              <1> 
  1777                              <1> .turn_off:
  1778 0000331D E885E5              <1> 	call os_hide_cursor
  1779 00003320 E9D2F9              <1> 	jmp mainloop
  1780                              <1> 
  1781                              <1> 
  1782 00003323 4F4E00              <1> 	.on_str db "ON", 0
  1783 00003326 4F464600            <1> 	.off_str db "OFF", 0
  1784                              <1> 
  1785                              <1> 
  1786                              <1> ; ------------------------------------------------------------------
  1787                              <1> ; CURSCHAR
  1788                              <1> 
  1789                              <1> do_curschar:
  1790 0000332A E83811              <1> 	call get_token
  1791                              <1> 
  1792 0000332D 83F801              <1> 	cmp ax, VARIABLE
  1793 00003330 7405                <1> 	je .is_variable
  1794                              <1> 
  1795 00003332 B314                <1> 	mov bl, err_syntax
  1796 00003334 E94712              <1> 	jmp error
  1797                              <1> 
  1798                              <1> .is_variable:
  1799 00003337 31C0                <1> 	xor ax, ax
  1800 00003339 A0007B              <1> 	mov byte al, [token]
  1801                              <1> 
  1802 0000333C 50                  <1> 	push ax				; Store variable we're going to use
  1803                              <1> 
  1804 0000333D B408                <1> 	mov ah, 08h
  1805 0000333F 31DB                <1> 	xor bx, bx
  1806 00003341 8A3E[F345]          <1> 	mov byte bh, [work_page]
  1807 00003345 CD10                <1> 	int 10h				; Get char at current cursor location
  1808                              <1> 
  1809 00003347 31DB                <1> 	xor bx, bx			; We only want the lower byte (the char, not attribute)
  1810 00003349 88C3                <1> 	mov bl, al
  1811                              <1> 
  1812 0000334B 58                  <1> 	pop ax				; Get the variable back
  1813                              <1> 
  1814 0000334C E80711              <1> 	call set_var			; And store the value
  1815                              <1> 
  1816 0000334F E9A3F9              <1> 	jmp mainloop
  1817                              <1> 
  1818                              <1> 
  1819                              <1> ; ------------------------------------------------------------------
  1820                              <1> ; CURSCOL
  1821                              <1> 
  1822                              <1> do_curscol:
  1823 00003352 E81011              <1> 	call get_token
  1824                              <1> 
  1825 00003355 83F801              <1> 	cmp ax, VARIABLE
  1826 00003358 751B                <1> 	jne .error
  1827                              <1> 
  1828 0000335A B400                <1> 	mov ah, 0
  1829 0000335C A0007B              <1> 	mov byte al, [token]
  1830 0000335F 50                  <1> 	push ax
  1831                              <1> 
  1832 00003360 B408                <1> 	mov ah, 8
  1833 00003362 31DB                <1> 	xor bx, bx
  1834 00003364 8A3E[F345]          <1> 	mov byte bh, [work_page]
  1835 00003368 CD10                <1> 	int 10h
  1836 0000336A B700                <1> 	mov bh, 0
  1837 0000336C 88E3                <1> 	mov bl, ah			; Get colour for higher byte; ignore lower byte (char)
  1838                              <1> 
  1839 0000336E 58                  <1> 	pop ax
  1840 0000336F E8E410              <1> 	call set_var
  1841                              <1> 
  1842 00003372 E980F9              <1> 	jmp mainloop
  1843                              <1> 
  1844                              <1> .error:
  1845 00003375 B314                <1> 	mov bl, err_syntax
  1846 00003377 E90412              <1> 	jmp error
  1847                              <1> 
  1848                              <1> 
  1849                              <1> ; ------------------------------------------------------------------
  1850                              <1> ; CURSPOS
  1851                              <1> 
  1852                              <1> do_curspos:
  1853 0000337A 8A3E[F345]          <1> 	mov byte bh, [work_page]
  1854 0000337E B403                <1> 	mov ah, 3
  1855 00003380 CD10                <1> 	int 10h
  1856                              <1> 
  1857 00003382 E8E010              <1> 	call get_token
  1858 00003385 83F801              <1> 	cmp ax, VARIABLE
  1859 00003388 7523                <1> 	jne .error
  1860                              <1> 
  1861 0000338A 0FB606007B          <1> 	movzx ax, byte [token]
  1862 0000338F 31DB                <1> 	xor bx, bx
  1863 00003391 88D3                <1> 	mov bl, dl
  1864 00003393 E8C010              <1> 	call set_var
  1865                              <1> 
  1866 00003396 E8CC10              <1> 	call get_token
  1867 00003399 83F801              <1> 	cmp ax, VARIABLE
  1868 0000339C 750F                <1> 	jne .error
  1869                              <1> 
  1870 0000339E 0FB606007B          <1> 	movzx ax, byte [token]
  1871 000033A3 31DB                <1> 	xor bx, bx
  1872 000033A5 88F3                <1> 	mov bl, dh
  1873 000033A7 E8AC10              <1> 	call set_var
  1874                              <1> 
  1875 000033AA E948F9              <1> 	jmp mainloop
  1876                              <1> 
  1877                              <1> .error:
  1878 000033AD B314                <1> 	mov bl, err_syntax
  1879 000033AF E9CC11              <1> 	jmp error
  1880                              <1> 
  1881                              <1> 
  1882                              <1> ; ------------------------------------------------------------------
  1883                              <1> ; DELETE
  1884                              <1> 
  1885                              <1> do_delete:
  1886 000033B2 E8B010              <1> 	call get_token
  1887 000033B5 83F805              <1> 	cmp ax, QUOTE
  1888 000033B8 7413                <1> 	je .is_quote
  1889                              <1> 
  1890 000033BA 83F802              <1> 	cmp ax, STRING_VAR
  1891 000033BD 0F854300            <1> 	jne near .error
  1892                              <1> 
  1893 000033C1 BE007C              <1> 	mov si, string_vars
  1894 000033C4 B88000              <1> 	mov ax, 128
  1895 000033C7 F7E3                <1> 	mul bx
  1896 000033C9 01C6                <1> 	add si, ax
  1897 000033CB EB03                <1> 	jmp .get_filename
  1898                              <1> 
  1899                              <1> .is_quote:
  1900 000033CD BE007B              <1> 	mov si, token
  1901                              <1> 
  1902                              <1> .get_filename:
  1903 000033D0 89F0                <1> 	mov ax, si
  1904 000033D2 E8FBDA              <1> 	call os_file_exists
  1905 000033D5 7207                <1> 	jc .no_file
  1906                              <1> 
  1907 000033D7 E8F5DB              <1> 	call os_remove_file
  1908 000033DA 721B                <1> 	jc .del_fail
  1909                              <1> 
  1910 000033DC EB0D                <1> 	jmp .returngood
  1911                              <1> 
  1912                              <1> .no_file:
  1913 000033DE 31C0                <1> 	xor ax, ax
  1914 000033E0 B052                <1> 	mov byte al, 'R'
  1915 000033E2 BB0200              <1> 	mov bx, 2
  1916 000033E5 E86E10              <1> 	call set_var
  1917 000033E8 E90AF9              <1> 	jmp mainloop
  1918                              <1> 
  1919                              <1> .returngood:
  1920 000033EB 31C0                <1> 	xor ax, ax
  1921 000033ED B052                <1> 	mov byte al, 'R'
  1922 000033EF 31DB                <1> 	xor bx, bx
  1923 000033F1 E86210              <1> 	call set_var
  1924 000033F4 E9FEF8              <1> 	jmp mainloop
  1925                              <1> 
  1926                              <1> .del_fail:
  1927 000033F7 31C0                <1> 	xor ax, ax
  1928 000033F9 B052                <1> 	mov byte al, 'R'
  1929 000033FB BB0100              <1> 	mov bx, 1
  1930 000033FE E85510              <1> 	call set_var
  1931 00003401 E9F1F8              <1> 	jmp mainloop
  1932                              <1> 
  1933                              <1> .error:
  1934 00003404 B314                <1> 	mov bl, err_syntax
  1935 00003406 E97511              <1> 	jmp error
  1936                              <1> 	
  1937                              <1> 
  1938                              <1> ; ------------------------------------------------------------------
  1939                              <1> ; DO
  1940                              <1> 
  1941                              <1> do_do:
  1942 00003409 803E[F045]14        <1> 	cmp byte [loop_in], 20
  1943 0000340E 741C                <1> 	je .loop_max
  1944 00003410 BFD079              <1> 	mov word di, do_loop_store
  1945 00003413 A0[F045]            <1> 	mov byte al, [loop_in]
  1946 00003416 B400                <1> 	mov ah, 0
  1947 00003418 01C7                <1> 	add di, ax
  1948 0000341A A1[E945]            <1> 	mov word ax, [prog]
  1949 0000341D 83E803              <1> 	sub ax, 3
  1950 00003420 AB                  <1> 	stosw
  1951 00003421 FE06[F045]          <1> 	inc byte [loop_in]
  1952 00003425 FE06[F045]          <1> 	inc byte [loop_in]
  1953 00003429 E9C9F8              <1> 	jmp mainloop
  1954                              <1> 
  1955                              <1> .loop_max:
  1956 0000342C B303                <1> 	mov bl, err_doloop_maximum
  1957 0000342E E94D11              <1> 	jmp error
  1958                              <1> 
  1959                              <1> 	
  1960                              <1> ;-------------------------------------------------------------------
  1961                              <1> ; ELSE
  1962                              <1> 
  1963                              <1> do_else:
  1964 00003431 803E[F145]01        <1> 	cmp byte [last_if_true], 1
  1965 00003436 7407                <1> 	je .last_true
  1966                              <1> 	
  1967 00003438 FF06[E945]          <1> 	inc word [prog]
  1968 0000343C E9B6F8              <1> 	jmp mainloop
  1969                              <1> 	
  1970                              <1> .last_true:
  1971 0000343F 8B36[E945]          <1> 	mov word si, [prog]
  1972                              <1> 	
  1973                              <1> .next_line:
  1974 00003443 AC                  <1> 	lodsb
  1975 00003444 3C0A                <1> 	cmp al, 10
  1976 00003446 75FB                <1> 	jne .next_line
  1977                              <1> 	
  1978 00003448 4E                  <1> 	dec si
  1979 00003449 8936[E945]          <1> 	mov word [prog], si
  1980                              <1> 	
  1981 0000344D E9A5F8              <1> 	jmp mainloop
  1982                              <1> 
  1983                              <1> 
  1984                              <1> ; ------------------------------------------------------------------
  1985                              <1> ; END
  1986                              <1> 
  1987                              <1> do_end:
  1988 00003450 B405                <1> 	mov ah, 5				; Restore active page
  1989 00003452 B000                <1> 	mov al, 0
  1990 00003454 CD10                <1> 	int 10h
  1991                              <1> 
  1992 00003456 C606[F345]00        <1> 	mov byte [work_page], 0
  1993 0000345B C606[F445]00        <1> 	mov byte [disp_page], 0
  1994                              <1> 
  1995 00003460 8B26[E745]          <1> 	mov word sp, [orig_stack]
  1996 00003464 C3                  <1> 	ret
  1997                              <1> 
  1998                              <1> 
  1999                              <1> ; ------------------------------------------------------------------
  2000                              <1> ; FILES
  2001                              <1> 
  2002                              <1> do_files:
  2003 00003465 B800FA              <1> 	mov ax, .filelist			; get a copy of the filelist
  2004 00003468 E8F4D5              <1> 	call os_get_file_list
  2005                              <1> 	
  2006 0000346B 89C6                <1> 	mov si, ax
  2007                              <1> 
  2008 0000346D E8FEE3              <1> 	call os_get_cursor_pos			; move cursor to start of line
  2009 00003470 B200                <1> 	mov dl, 0
  2010 00003472 E8F0E3              <1> 	call os_move_cursor
  2011                              <1> 	
  2012 00003475 B409                <1> 	mov ah, 9				; print character function
  2013 00003477 8A3E[F345]          <1> 	mov bh, [work_page]			; define parameters (page, colour, times)
  2014 0000347B 8A1E[F245]          <1> 	mov bl, [ink_colour]
  2015 0000347F B90100              <1> 	mov cx, 1
  2016                              <1> .file_list_loop:
  2017 00003482 AC                  <1> 	lodsb					; get a byte from the list
  2018 00003483 3C2C                <1> 	cmp al, ','				; a comma means the next file, so create a new line for it
  2019 00003485 7410                <1> 	je .nextfile
  2020                              <1> 	
  2021 00003487 3C00                <1> 	cmp al, 0				; the list is null terminated
  2022 00003489 7438                <1> 	je .end_of_list
  2023                              <1> 	
  2024 0000348B CD10                <1> 	int 10h					; okay, it's not a comma or a null so print it
  2025                              <1> 
  2026 0000348D E8DEE3              <1> 	call os_get_cursor_pos			; find the location of the cursor
  2027 00003490 FEC2                <1> 	inc dl					; move the cursor forward
  2028 00003492 E8D0E3              <1> 	call os_move_cursor
  2029                              <1> 
  2030 00003495 EBEB                <1> 	jmp .file_list_loop			; keep going until the list is finished
  2031                              <1> 	
  2032                              <1> .nextfile:
  2033 00003497 E8D4E3              <1> 	call os_get_cursor_pos			; if the column is over 60 we need a new line
  2034 0000349A 80FA3C              <1> 	cmp dl, 60
  2035 0000349D 7D1F                <1> 	jge .newline
  2036                              <1> 
  2037                              <1> .next_column:					; print spaces until the next column
  2038 0000349F B020                <1> 	mov al, ' '
  2039 000034A1 CD10                <1> 	int 10h
  2040                              <1> 	
  2041 000034A3 FEC2                <1> 	inc dl
  2042 000034A5 E8BDE3              <1> 	call os_move_cursor
  2043                              <1> 	
  2044 000034A8 80FA0F              <1> 	cmp dl, 15
  2045 000034AB 74D5                <1> 	je .file_list_loop
  2046                              <1> 	
  2047 000034AD 80FA1E              <1> 	cmp dl, 30
  2048 000034B0 74D0                <1> 	je .file_list_loop
  2049                              <1> 	
  2050 000034B2 80FA2D              <1> 	cmp dl, 45
  2051 000034B5 74CB                <1> 	je .file_list_loop
  2052                              <1> 	
  2053 000034B7 80FA3C              <1> 	cmp dl, 60
  2054 000034BA 74C6                <1> 	je .file_list_loop
  2055                              <1> 	
  2056 000034BC EBE1                <1> 	jmp .next_column
  2057                              <1> 	
  2058                              <1> .newline:
  2059 000034BE E87CEA              <1> 	call os_print_newline			; create a new line
  2060 000034C1 EBBF                <1> 	jmp .file_list_loop
  2061                              <1> 	
  2062                              <1> .end_of_list:
  2063 000034C3 E877EA              <1> 	call os_print_newline
  2064 000034C6 E92CF8              <1> 	jmp mainloop				; preform next command
  2065                              <1> 	
  2066                              <1> .data:
  2067                              <1> 	.filelist		equ 64000
  2068                              <1> 	
  2069                              <1> 
  2070                              <1> 
  2071                              <1> ; ------------------------------------------------------------------
  2072                              <1> ; FOR
  2073                              <1> 
  2074                              <1> do_for:
  2075 000034C9 E8990F              <1> 	call get_token				; Get the variable we're using in this loop
  2076                              <1> 
  2077 000034CC 83F801              <1> 	cmp ax, VARIABLE
  2078 000034CF 0F859B00            <1> 	jne near .error
  2079                              <1> 
  2080 000034D3 0FB606007B          <1> 	movzx ax, byte [token]
  2081 000034D8 A2[7335]            <1> 	mov byte [.tmp_var], al			; Store it in a temporary location for now
  2082                              <1> 
  2083 000034DB E8870F              <1> 	call get_token
  2084                              <1> 
  2085 000034DE 0FB606007B          <1> 	movzx ax, byte [token]
  2086 000034E3 3C3D                <1> 	cmp al, '='
  2087 000034E5 0F858500            <1> 	jne .error
  2088                              <1> 
  2089 000034E9 E8790F              <1> 	call get_token				; Next we want a number
  2090                              <1> 
  2091 000034EC 83F801              <1> 	cmp ax, VARIABLE
  2092 000034EF 740D                <1> 	je .first_is_var
  2093                              <1> 
  2094 000034F1 83F803              <1> 	cmp ax, NUMBER
  2095 000034F4 7578                <1> 	jne .error
  2096                              <1> 
  2097 000034F6 BE007B              <1> 	mov si, token				; Convert it
  2098 000034F9 E8FCF5              <1> 	call os_string_to_int
  2099 000034FC EB08                <1> 	jmp .continue
  2100                              <1> 
  2101                              <1> .first_is_var:
  2102 000034FE 0FB606007B          <1> 	movzx ax, byte [token]
  2103 00003503 E8430F              <1> 	call get_var
  2104                              <1> 	
  2105                              <1> 	; At this stage, we've read something like "FOR X = 1"
  2106                              <1> 	; so let's store that 1 in the variable table
  2107                              <1> 
  2108                              <1> .continue:
  2109 00003506 89C3                <1> 	mov bx, ax
  2110 00003508 0FB606[7335]        <1> 	movzx ax, byte [.tmp_var]
  2111 0000350D E8460F              <1> 	call set_var
  2112                              <1> 
  2113                              <1> 
  2114 00003510 E8520F              <1> 	call get_token				; Next we're looking for "TO"
  2115                              <1> 
  2116 00003513 83F804              <1> 	cmp ax, STRING
  2117 00003516 7556                <1> 	jne .error
  2118                              <1> 
  2119 00003518 B8007B              <1> 	mov ax, token
  2120 0000351B E8EDF4              <1> 	call os_string_uppercase
  2121                              <1> 
  2122 0000351E BE007B              <1> 	mov si, token
  2123 00003521 BF[7435]            <1> 	mov di, .to_string
  2124 00003524 E87DF5              <1> 	call os_string_compare
  2125 00003527 7345                <1> 	jnc .error
  2126                              <1> 
  2127                              <1> 
  2128                              <1> 	; So now we're at "FOR X = 1 TO"
  2129                              <1> 
  2130 00003529 E8390F              <1> 	call get_token
  2131                              <1> 
  2132 0000352C 83F801              <1> 	cmp ax, VARIABLE
  2133 0000352F 740D                <1> 	je .second_is_var
  2134                              <1> 
  2135 00003531 83F803              <1> 	cmp ax, NUMBER
  2136 00003534 7538                <1> 	jne .error
  2137                              <1> 
  2138                              <1> .second_is_number:
  2139 00003536 BE007B              <1> 	mov si, token					; Get target number
  2140 00003539 E8BCF5              <1> 	call os_string_to_int
  2141 0000353C EB08                <1> 	jmp .continue2
  2142                              <1> 
  2143                              <1> .second_is_var:
  2144 0000353E 0FB606007B          <1> 	movzx ax, byte [token]
  2145 00003543 E8030F              <1> 	call get_var
  2146                              <1> 
  2147                              <1> .continue2:
  2148 00003546 89C3                <1> 	mov bx, ax
  2149                              <1> 
  2150 00003548 0FB606[7335]        <1> 	movzx ax, byte [.tmp_var]
  2151                              <1> 
  2152 0000354D 2C41                <1> 	sub al, 65					; Store target number in table
  2153 0000354F BF187A              <1> 	mov di, for_variables
  2154 00003552 01C7                <1> 	add di, ax
  2155 00003554 01C7                <1> 	add di, ax
  2156 00003556 89D8                <1> 	mov ax, bx
  2157 00003558 AB                  <1> 	stosw
  2158                              <1> 
  2159                              <1> 
  2160                              <1> 	; So we've got the variable, assigned it the starting number, and put into
  2161                              <1> 	; our table the limit it should reach. But we also need to store the point in
  2162                              <1> 	; code after the FOR line we should return to if NEXT X doesn't complete the loop...
  2163                              <1> 
  2164 00003559 0FB606[7335]        <1> 	movzx ax, byte [.tmp_var]
  2165                              <1> 
  2166 0000355E 2C41                <1> 	sub al, 65					; Store code position to return to in table
  2167 00003560 BFE479              <1> 	mov di, for_code_points
  2168 00003563 01C7                <1> 	add di, ax
  2169 00003565 01C7                <1> 	add di, ax
  2170 00003567 A1[E945]            <1> 	mov word ax, [prog]
  2171 0000356A AB                  <1> 	stosw
  2172                              <1> 
  2173 0000356B E987F7              <1> 	jmp mainloop
  2174                              <1> 
  2175                              <1> 
  2176                              <1> .error:
  2177 0000356E B314                <1> 	mov bl, err_syntax
  2178 00003570 E90B10              <1> 	jmp error
  2179                              <1> 
  2180                              <1> 
  2181 00003573 00                  <1> 	.tmp_var	db 0
  2182 00003574 544F00              <1> 	.to_string	db 'TO', 0
  2183                              <1> 
  2184                              <1> 
  2185                              <1> ; ------------------------------------------------------------------
  2186                              <1> ; GETKEY
  2187                              <1> 
  2188                              <1> do_getkey:
  2189 00003577 E8EB0E              <1> 	call get_token
  2190 0000357A 83F801              <1> 	cmp ax, VARIABLE
  2191 0000357D 7405                <1> 	je .is_variable
  2192                              <1> 
  2193 0000357F B314                <1> 	mov bl, err_syntax
  2194 00003581 E9FA0F              <1> 	jmp error
  2195                              <1> 
  2196                              <1> .is_variable:
  2197 00003584 0FB606007B          <1> 	movzx ax, byte [token]
  2198                              <1> 
  2199 00003589 50                  <1> 	push ax
  2200                              <1> 
  2201 0000358A E88FDD              <1> 	call os_check_for_key
  2202                              <1> 
  2203 0000358D 3DE048              <1> 	cmp ax, 48E0h
  2204 00003590 7419                <1> 	je .up_pressed
  2205                              <1> 
  2206 00003592 3DE050              <1> 	cmp ax, 50E0h
  2207 00003595 7419                <1> 	je .down_pressed
  2208                              <1> 
  2209 00003597 3DE04B              <1> 	cmp ax, 4BE0h
  2210 0000359A 7419                <1> 	je .left_pressed
  2211                              <1> 
  2212 0000359C 3DE04D              <1> 	cmp ax, 4DE0h
  2213 0000359F 7419                <1> 	je .right_pressed
  2214                              <1> 
  2215                              <1> .store:	
  2216 000035A1 0FB6D8              <1> 	movzx bx, al
  2217                              <1> 	
  2218 000035A4 58                  <1> 	pop ax
  2219                              <1> 
  2220 000035A5 E8AE0E              <1> 	call set_var
  2221                              <1> 
  2222 000035A8 E94AF7              <1> 	jmp mainloop
  2223                              <1> 
  2224                              <1> .up_pressed:
  2225 000035AB B80100              <1> 	mov ax, 1
  2226 000035AE EBF1                <1> 	jmp .store
  2227                              <1> 
  2228                              <1> .down_pressed:
  2229 000035B0 B80200              <1> 	mov ax, 2
  2230 000035B3 EBEC                <1> 	jmp .store
  2231                              <1> 
  2232                              <1> .left_pressed:
  2233 000035B5 B80300              <1> 	mov ax, 3
  2234 000035B8 EBE7                <1> 	jmp .store
  2235                              <1> 
  2236                              <1> .right_pressed:
  2237 000035BA B80400              <1> 	mov ax, 4
  2238 000035BD EBE2                <1> 	jmp .store
  2239                              <1> 
  2240                              <1> ; ------------------------------------------------------------------
  2241                              <1> ; GOSUB
  2242                              <1> 
  2243                              <1> do_gosub:
  2244 000035BF E8A30E              <1> 	call get_token				; Get the number (label)
  2245                              <1> 
  2246 000035C2 83F804              <1> 	cmp ax, STRING
  2247 000035C5 7405                <1> 	je .is_ok
  2248                              <1> 
  2249 000035C7 B305                <1> 	mov bl, err_goto_notlabel
  2250 000035C9 E9B20F              <1> 	jmp error
  2251                              <1> 
  2252                              <1> .is_ok:
  2253 000035CC BE007B              <1> 	mov si, token				; Back up this label
  2254 000035CF BF[3E36]            <1> 	mov di, .tmp_token
  2255 000035D2 E870F4              <1> 	call os_string_copy
  2256                              <1> 
  2257 000035D5 B8[3E36]            <1> 	mov ax, .tmp_token
  2258 000035D8 E8D7F3              <1> 	call os_string_length
  2259                              <1> 
  2260 000035DB BF[3E36]            <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  2261 000035DE 01C7                <1> 	add di, ax
  2262 000035E0 B03A                <1> 	mov al, ':'
  2263 000035E2 AA                  <1> 	stosb
  2264 000035E3 B000                <1> 	mov al, 0
  2265 000035E5 AA                  <1> 	stosb	
  2266                              <1> 
  2267                              <1> 
  2268 000035E6 FE06[6047]          <1> 	inc byte [gosub_depth]
  2269                              <1> 
  2270 000035EA 0FB606[6047]        <1> 	movzx ax, byte [gosub_depth]		; Get current GOSUB nest level
  2271                              <1> 
  2272 000035EF 3C09                <1> 	cmp al, 9
  2273 000035F1 7E05                <1> 	jle .within_limit
  2274                              <1> 
  2275 000035F3 B307                <1> 	mov bl, err_nest_limit
  2276 000035F5 E9860F              <1> 	jmp error
  2277                              <1> 
  2278                              <1> 
  2279                              <1> .within_limit:
  2280 000035F8 BFBC79              <1> 	mov di, gosub_points			; Move into our table of pointers
  2281 000035FB 01C7                <1> 	add di, ax				; Table is words (not bytes)
  2282 000035FD 01C7                <1> 	add di, ax
  2283 000035FF A1[E945]            <1> 	mov word ax, [prog]
  2284 00003602 AB                  <1> 	stosw					; Store current location before jump
  2285                              <1> 
  2286                              <1> 
  2287 00003603 A1[ED45]            <1> 	mov word ax, [load_point]
  2288 00003606 A3[E945]            <1> 	mov word [prog], ax			; Return to start of program to find label
  2289                              <1> 
  2290                              <1> .loop:
  2291 00003609 E8590E              <1> 	call get_token
  2292                              <1> 
  2293 0000360C 83F808              <1> 	cmp ax, LABEL
  2294 0000360F 750D                <1> 	jne .line_loop
  2295                              <1> 
  2296 00003611 BE007B              <1> 	mov si, token
  2297 00003614 BF[3E36]            <1> 	mov di, .tmp_token
  2298 00003617 E88AF4              <1> 	call os_string_compare
  2299 0000361A 0F82D7F6            <1> 	jc mainloop
  2300                              <1> 
  2301                              <1> 
  2302                              <1> .line_loop:					; Go to end of line
  2303 0000361E 8B36[E945]          <1> 	mov word si, [prog]
  2304 00003622 8A04                <1> 	mov byte al, [si]
  2305 00003624 FF06[E945]          <1> 	inc word [prog]
  2306 00003628 3C0A                <1> 	cmp al, 10
  2307 0000362A 75F2                <1> 	jne .line_loop
  2308                              <1> 
  2309 0000362C A1[E945]            <1> 	mov word ax, [prog]
  2310 0000362F 8B1E[EB45]          <1> 	mov word bx, [prog_end]
  2311 00003633 39D8                <1> 	cmp ax, bx
  2312 00003635 7F02                <1> 	jg .past_end
  2313                              <1> 
  2314 00003637 EBD0                <1> 	jmp .loop
  2315                              <1> 
  2316                              <1> 
  2317                              <1> .past_end:
  2318 00003639 B306                <1> 	mov bl, err_label_notfound
  2319 0000363B E9400F              <1> 	jmp error
  2320                              <1> 
  2321                              <1> 
  2322 0000363E 00<rep 1Eh>         <1> 	.tmp_token	times 30 db 0
  2323                              <1> 
  2324                              <1> 
  2325                              <1> ; ------------------------------------------------------------------
  2326                              <1> ; GOTO
  2327                              <1> 
  2328                              <1> do_goto:
  2329 0000365C E8060E              <1> 	call get_token				; Get the next token
  2330                              <1> 
  2331 0000365F 83F804              <1> 	cmp ax, STRING
  2332 00003662 7405                <1> 	je .is_ok
  2333                              <1> 
  2334 00003664 B305                <1> 	mov bl, err_goto_notlabel
  2335 00003666 E9150F              <1> 	jmp error
  2336                              <1> 
  2337                              <1> .is_ok:
  2338 00003669 BE007B              <1> 	mov si, token				; Back up this label
  2339 0000366C BF[BE36]            <1> 	mov di, .tmp_token
  2340 0000366F E8D3F3              <1> 	call os_string_copy
  2341                              <1> 
  2342 00003672 B8[BE36]            <1> 	mov ax, .tmp_token
  2343 00003675 E83AF3              <1> 	call os_string_length
  2344                              <1> 
  2345 00003678 BF[BE36]            <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  2346 0000367B 01C7                <1> 	add di, ax
  2347 0000367D B03A                <1> 	mov al, ':'
  2348 0000367F AA                  <1> 	stosb
  2349 00003680 B000                <1> 	mov al, 0
  2350 00003682 AA                  <1> 	stosb	
  2351                              <1> 
  2352 00003683 A1[ED45]            <1> 	mov word ax, [load_point]
  2353 00003686 A3[E945]            <1> 	mov word [prog], ax			; Return to start of program to find label
  2354                              <1> 
  2355                              <1> .loop:
  2356 00003689 E8D90D              <1> 	call get_token
  2357                              <1> 
  2358 0000368C 83F808              <1> 	cmp ax, LABEL
  2359 0000368F 750D                <1> 	jne .line_loop
  2360                              <1> 
  2361 00003691 BE007B              <1> 	mov si, token
  2362 00003694 BF[BE36]            <1> 	mov di, .tmp_token
  2363 00003697 E80AF4              <1> 	call os_string_compare
  2364 0000369A 0F8257F6            <1> 	jc mainloop
  2365                              <1> 
  2366                              <1> .line_loop:					; Go to end of line
  2367 0000369E 8B36[E945]          <1> 	mov word si, [prog]
  2368 000036A2 8A04                <1> 	mov byte al, [si]
  2369 000036A4 FF06[E945]          <1> 	inc word [prog]
  2370                              <1> 
  2371 000036A8 3C0A                <1> 	cmp al, 10
  2372 000036AA 75F2                <1> 	jne .line_loop
  2373                              <1> 
  2374 000036AC A1[E945]            <1> 	mov word ax, [prog]
  2375 000036AF 8B1E[EB45]          <1> 	mov word bx, [prog_end]
  2376 000036B3 39D8                <1> 	cmp ax, bx
  2377 000036B5 7F02                <1> 	jg .past_end
  2378                              <1> 
  2379 000036B7 EBD0                <1> 	jmp .loop
  2380                              <1> 
  2381                              <1> .past_end:
  2382 000036B9 B306                <1> 	mov bl, err_label_notfound
  2383 000036BB E9C00E              <1> 	jmp error
  2384                              <1> 
  2385                              <1> 
  2386 000036BE 00<rep 1Eh>         <1> 	.tmp_token 	times 30 db 0
  2387                              <1> 
  2388                              <1> 
  2389                              <1> ; ------------------------------------------------------------------
  2390                              <1> ; IF
  2391                              <1> 
  2392                              <1> do_if:
  2393 000036DC E8860D              <1> 	call get_token
  2394                              <1> 
  2395 000036DF 83F801              <1> 	cmp ax, VARIABLE			; If can only be followed by a variable
  2396 000036E2 740C                <1> 	je .num_var
  2397                              <1> 
  2398 000036E4 83F802              <1> 	cmp ax, STRING_VAR
  2399 000036E7 0F84B300            <1> 	je near .string_var
  2400                              <1> 
  2401 000036EB B314                <1> 	mov bl, err_syntax
  2402 000036ED E98E0E              <1> 	jmp error
  2403                              <1> 
  2404                              <1> .num_var:
  2405 000036F0 0FB606007B          <1> 	movzx ax, byte [token]
  2406 000036F5 E8510D              <1> 	call get_var
  2407                              <1> 
  2408 000036F8 89C2                <1> 	mov dx, ax				; Store value of first part of comparison
  2409                              <1> 
  2410 000036FA E8680D              <1> 	call get_token				; Get the delimiter
  2411 000036FD A0007B              <1> 	mov byte al, [token]
  2412 00003700 3C3D                <1> 	cmp al, '='
  2413 00003702 740D                <1> 	je .equals
  2414 00003704 3C3E                <1> 	cmp al, '>'
  2415 00003706 7447                <1> 	je .greater
  2416 00003708 3C3C                <1> 	cmp al, '<'
  2417 0000370A 746C                <1> 	je .less
  2418                              <1> 
  2419 0000370C B314                <1> 	mov bl, err_syntax			; If not one of the above, error out
  2420 0000370E E96D0E              <1> 	jmp error
  2421                              <1> 
  2422                              <1> .equals:
  2423 00003711 E8510D              <1> 	call get_token				; Is this 'X = Y' (equals another variable?)
  2424                              <1> 
  2425 00003714 83F806              <1> 	cmp ax, CHAR
  2426 00003717 7417                <1> 	je .equals_char
  2427                              <1> 
  2428 00003719 A0007B              <1> 	mov byte al, [token]
  2429 0000371C E8530E              <1> 	call is_letter
  2430 0000371F 721D                <1> 	jc .equals_var
  2431                              <1> 
  2432 00003721 BE007B              <1> 	mov si, token				; Otherwise it's, eg 'X = 1' (a number)
  2433 00003724 E8D1F3              <1> 	call os_string_to_int
  2434                              <1> 
  2435 00003727 39D0                <1> 	cmp ax, dx				; On to the THEN bit if 'X = num' matches
  2436 00003729 0F84C200            <1> 	je near .on_to_then
  2437                              <1> 
  2438 0000372D E9E700              <1> 	jmp .finish_line			; Otherwise skip the rest of the line
  2439                              <1> 
  2440                              <1> 
  2441                              <1> .equals_char:
  2442 00003730 0FB606007B          <1> 	movzx ax, byte [token]
  2443                              <1> 
  2444 00003735 39D0                <1> 	cmp ax, dx
  2445 00003737 0F84B400            <1> 	je near .on_to_then
  2446                              <1> 
  2447 0000373B E9D900              <1> 	jmp .finish_line
  2448                              <1> 
  2449                              <1> 
  2450                              <1> .equals_var:
  2451 0000373E 0FB606007B          <1> 	movzx ax, byte [token]
  2452                              <1> 
  2453 00003743 E8030D              <1> 	call get_var
  2454                              <1> 
  2455 00003746 39D0                <1> 	cmp ax, dx				; Do the variables match?
  2456 00003748 0F84A300            <1> 	je near .on_to_then				; On to the THEN bit if so
  2457                              <1> 
  2458 0000374C E9C800              <1> 	jmp .finish_line			; Otherwise skip the rest of the line
  2459                              <1> 
  2460                              <1> 
  2461                              <1> .greater:
  2462 0000374F E8130D              <1> 	call get_token				; Greater than a variable or number?
  2463 00003752 A0007B              <1> 	mov byte al, [token]
  2464 00003755 E81A0E              <1> 	call is_letter
  2465 00003758 720F                <1> 	jc .greater_var
  2466                              <1> 
  2467 0000375A BE007B              <1> 	mov si, token				; Must be a number here...
  2468 0000375D E898F3              <1> 	call os_string_to_int
  2469                              <1> 
  2470 00003760 39D0                <1> 	cmp ax, dx
  2471 00003762 0F8C8900            <1> 	jl near .on_to_then
  2472                              <1> 
  2473 00003766 E9AE00              <1> 	jmp .finish_line
  2474                              <1> 
  2475                              <1> .greater_var:					; Variable in this case
  2476 00003769 0FB606007B          <1> 	movzx ax, byte [token]
  2477                              <1> 
  2478 0000376E E8D80C              <1> 	call get_var
  2479                              <1> 
  2480 00003771 39D0                <1> 	cmp ax, dx				; Make the comparison!
  2481 00003773 7C7A                <1> 	jl .on_to_then
  2482                              <1> 
  2483 00003775 E99F00              <1> 	jmp .finish_line
  2484                              <1> 
  2485                              <1> .less:
  2486 00003778 E8EA0C              <1> 	call get_token
  2487 0000377B A0007B              <1> 	mov byte al, [token]
  2488 0000377E E8F10D              <1> 	call is_letter
  2489 00003781 720D                <1> 	jc .less_var
  2490                              <1> 
  2491 00003783 BE007B              <1> 	mov si, token
  2492 00003786 E86FF3              <1> 	call os_string_to_int
  2493                              <1> 
  2494 00003789 39D0                <1> 	cmp ax, dx
  2495 0000378B 7F62                <1> 	jg .on_to_then
  2496                              <1> 
  2497 0000378D E98700              <1> 	jmp .finish_line
  2498                              <1> 
  2499                              <1> .less_var:
  2500 00003790 0FB606007B          <1> 	movzx ax, byte [token]
  2501                              <1> 
  2502 00003795 E8B10C              <1> 	call get_var
  2503                              <1> 
  2504 00003798 39D0                <1> 	cmp ax, dx
  2505 0000379A 7F53                <1> 	jg .on_to_then
  2506                              <1> 
  2507 0000379C EB79                <1> 	jmp .finish_line
  2508                              <1> 
  2509                              <1> 
  2510                              <1> 
  2511                              <1> .string_var:
  2512 0000379E 881E[3238]          <1> 	mov byte [.tmp_string_var], bl
  2513                              <1> 
  2514 000037A2 E8C00C              <1> 	call get_token
  2515                              <1> 
  2516 000037A5 A0007B              <1> 	mov byte al, [token]
  2517 000037A8 3C3D                <1> 	cmp al, '='
  2518 000037AA 0F857F00            <1> 	jne .error
  2519                              <1> 
  2520 000037AE E8B40C              <1> 	call get_token
  2521 000037B1 83F802              <1> 	cmp ax, STRING_VAR
  2522 000037B4 7419                <1> 	je .second_is_string_var
  2523                              <1> 
  2524 000037B6 83F805              <1> 	cmp ax, QUOTE
  2525 000037B9 7572                <1> 	jne .error
  2526                              <1> 
  2527 000037BB BE007C              <1> 	mov si, string_vars
  2528 000037BE B88000              <1> 	mov ax, 128
  2529 000037C1 F7E3                <1> 	mul bx
  2530 000037C3 01C6                <1> 	add si, ax
  2531 000037C5 BF007B              <1> 	mov di, token
  2532 000037C8 E8D9F2              <1> 	call os_string_compare
  2533 000037CB 7422                <1> 	je .on_to_then
  2534                              <1> 
  2535 000037CD EB48                <1> 	jmp .finish_line
  2536                              <1> 
  2537                              <1> 
  2538                              <1> .second_is_string_var:
  2539 000037CF BE007C              <1> 	mov si, string_vars
  2540 000037D2 B88000              <1> 	mov ax, 128
  2541 000037D5 F7E3                <1> 	mul bx
  2542 000037D7 01C6                <1> 	add si, ax
  2543                              <1> 
  2544 000037D9 BF007C              <1> 	mov di, string_vars
  2545 000037DC 0FB61E[3238]        <1> 	movzx bx, byte [.tmp_string_var]
  2546 000037E1 B88000              <1> 	mov ax, 128
  2547 000037E4 F7E3                <1> 	mul bx
  2548 000037E6 01C7                <1> 	add di, ax
  2549                              <1> 
  2550 000037E8 E8B9F2              <1> 	call os_string_compare
  2551 000037EB 7202                <1> 	jc .on_to_then
  2552                              <1> 
  2553 000037ED EB28                <1> 	jmp .finish_line
  2554                              <1> 
  2555                              <1> 
  2556                              <1> .on_to_then:
  2557 000037EF E8730C              <1> 	call get_token
  2558                              <1> 
  2559 000037F2 BE007B              <1> 	mov si, token			; Look for AND for more comparison
  2560 000037F5 BF[1447]            <1> 	mov di, and_keyword
  2561 000037F8 E8A9F2              <1> 	call os_string_compare
  2562 000037FB 0F82DDFE            <1> 	jc do_if
  2563                              <1> 
  2564 000037FF BE007B              <1> 	mov si, token			; Look for THEN to perform more operations
  2565 00003802 BF[1847]            <1> 	mov di, then_keyword
  2566 00003805 E89CF2              <1> 	call os_string_compare
  2567 00003808 7205                <1> 	jc .then_present
  2568                              <1> 
  2569 0000380A B314                <1> 	mov bl, err_syntax
  2570 0000380C E96F0D              <1> 	jmp error
  2571                              <1> 
  2572                              <1> .then_present:				; Continue rest of line like any other command!
  2573 0000380F C606[F145]01        <1> 	mov byte [last_if_true], 1
  2574 00003814 E9DEF4              <1> 	jmp mainloop
  2575                              <1> 
  2576                              <1> 
  2577                              <1> .finish_line:				; IF wasn't fulfilled, so skip rest of line
  2578 00003817 8B36[E945]          <1> 	mov word si, [prog]
  2579 0000381B 8A04                <1> 	mov byte al, [si]
  2580 0000381D FF06[E945]          <1> 	inc word [prog]
  2581 00003821 3C0A                <1> 	cmp al, 10
  2582 00003823 75F2                <1> 	jne .finish_line
  2583                              <1> 
  2584 00003825 C606[F145]00        <1> 	mov byte [last_if_true], 0
  2585 0000382A E9C8F4              <1> 	jmp mainloop
  2586                              <1> 
  2587                              <1> 
  2588                              <1> .error:
  2589 0000382D B314                <1> 	mov bl, err_syntax
  2590 0000382F E94C0D              <1> 	jmp error
  2591                              <1> 
  2592                              <1> 
  2593 00003832 00                  <1> 	.tmp_string_var		db 0
  2594                              <1> 
  2595                              <1> 
  2596                              <1> ; ------------------------------------------------------------------
  2597                              <1> ; INCLUDE
  2598                              <1> 
  2599                              <1> do_include:
  2600 00003833 E82F0C              <1> 	call get_token
  2601 00003836 83F805              <1> 	cmp ax, QUOTE
  2602 00003839 7406                <1> 	je .is_ok
  2603                              <1> 
  2604 0000383B BE1400              <1> 	mov si, err_syntax
  2605 0000383E E93D0D              <1> 	jmp error
  2606                              <1> 
  2607                              <1> .is_ok:
  2608 00003841 B8007B              <1> 	mov ax, token
  2609 00003844 8B0E[EB45]          <1> 	mov word cx, [prog_end]
  2610 00003848 41                  <1> 	inc cx				; Add a bit of space after original code
  2611 00003849 41                  <1> 	inc cx
  2612 0000384A 41                  <1> 	inc cx
  2613 0000384B 51                  <1> 	push cx
  2614 0000384C E83DD3              <1> 	call os_load_file
  2615 0000384F 720A                <1> 	jc .load_fail
  2616                              <1> 
  2617 00003851 59                  <1> 	pop cx
  2618 00003852 01D9                <1> 	add cx, bx
  2619 00003854 890E[EB45]          <1> 	mov word [prog_end], cx
  2620                              <1> 
  2621 00003858 E99AF4              <1> 	jmp mainloop
  2622                              <1> 
  2623                              <1> 
  2624                              <1> .load_fail:
  2625 0000385B 59                  <1> 	pop cx
  2626 0000385C BE0400              <1> 	mov si, err_file_notfound
  2627 0000385F E91C0D              <1> 	jmp error
  2628                              <1> 
  2629                              <1> 
  2630                              <1> ; ------------------------------------------------------------------
  2631                              <1> ; INK
  2632                              <1> 
  2633                              <1> do_ink:
  2634 00003862 E8000C              <1> 	call get_token				; Get column
  2635                              <1> 
  2636 00003865 83F801              <1> 	cmp ax, VARIABLE
  2637 00003868 740C                <1> 	je .first_is_var
  2638                              <1> 
  2639 0000386A BE007B              <1> 	mov si, token
  2640 0000386D E888F2              <1> 	call os_string_to_int
  2641 00003870 A2[F245]            <1> 	mov byte [ink_colour], al
  2642 00003873 E97FF4              <1> 	jmp mainloop
  2643                              <1> 
  2644                              <1> .first_is_var:
  2645 00003876 B80000              <1> 	mov ax, 0
  2646 00003879 A0007B              <1> 	mov byte al, [token]
  2647 0000387C E8CA0B              <1> 	call get_var
  2648 0000387F A2[F245]            <1> 	mov byte [ink_colour], al
  2649 00003882 E970F4              <1> 	jmp mainloop
  2650                              <1> 
  2651                              <1> 
  2652                              <1> ; ------------------------------------------------------------------
  2653                              <1> ; INPUT
  2654                              <1> 
  2655                              <1> do_input:
  2656 00003885 B000                <1> 	mov al, 0				; Clear string from previous usage
  2657 00003887 BF807A              <1> 	mov di, .tmpstring
  2658 0000388A B98000              <1> 	mov cx, 128
  2659 0000388D F3AA                <1> 	rep stosb
  2660                              <1> 
  2661 0000388F E8D30B              <1> 	call get_token
  2662                              <1> 
  2663 00003892 83F801              <1> 	cmp ax, VARIABLE			; We can only INPUT to variables!
  2664 00003895 740B                <1> 	je .number_var
  2665                              <1> 
  2666 00003897 83F802              <1> 	cmp ax, STRING_VAR
  2667 0000389A 7437                <1> 	je .string_var
  2668                              <1> 
  2669 0000389C BE1400              <1> 	mov si, err_syntax
  2670 0000389F E9DC0C              <1> 	jmp error
  2671                              <1> 
  2672                              <1> .number_var:
  2673 000038A2 B8807A              <1> 	mov ax, .tmpstring			; Get input from the user
  2674 000038A5 E804E9              <1> 	call os_input_string
  2675                              <1> 
  2676 000038A8 B8807A              <1> 	mov ax, .tmpstring
  2677 000038AB E804F1              <1> 	call os_string_length
  2678 000038AE 83F800              <1> 	cmp ax, 0
  2679 000038B1 750A                <1> 	jne .char_entered
  2680                              <1> 
  2681 000038B3 C606807A30          <1> 	mov byte [.tmpstring], '0'		; If enter hit, fill variable with zero
  2682 000038B8 C606817A00          <1> 	mov byte [.tmpstring + 1], 0
  2683                              <1> 
  2684                              <1> .char_entered:
  2685 000038BD BE807A              <1> 	mov si, .tmpstring			; Convert to integer format
  2686 000038C0 E835F2              <1> 	call os_string_to_int
  2687 000038C3 89C3                <1> 	mov bx, ax
  2688                              <1> 
  2689 000038C5 0FB606007B          <1> 	movzx ax, byte [token]
  2690 000038CA E8890B              <1> 	call set_var				; ...and store it!
  2691                              <1> 
  2692 000038CD E86DE6              <1> 	call os_print_newline
  2693                              <1> 
  2694 000038D0 E922F4              <1> 	jmp mainloop
  2695                              <1> 
  2696                              <1> 
  2697                              <1> .string_var:
  2698 000038D3 53                  <1> 	push bx
  2699                              <1> 
  2700 000038D4 B8807A              <1> 	mov ax, .tmpstring
  2701 000038D7 E8D2E8              <1> 	call os_input_string
  2702                              <1> 
  2703 000038DA BE807A              <1> 	mov si, .tmpstring
  2704 000038DD BF007C              <1> 	mov di, string_vars
  2705                              <1> 
  2706 000038E0 5B                  <1> 	pop bx
  2707                              <1> 
  2708 000038E1 B88000              <1> 	mov ax, 128
  2709 000038E4 F7E3                <1> 	mul bx
  2710                              <1> 
  2711 000038E6 01C7                <1> 	add di, ax
  2712 000038E8 E85AF1              <1> 	call os_string_copy
  2713                              <1> 
  2714 000038EB E84FE6              <1> 	call os_print_newline
  2715                              <1> 
  2716 000038EE E904F4              <1> 	jmp mainloop
  2717                              <1> 
  2718                              <1> 
  2719                              <1> ;	.tmpstring	times 128 db 0
  2720                              <1> 	.tmpstring	equ 32768-1024-256-128
  2721                              <1> 
  2722                              <1> ; -----------------------------------------------------------
  2723                              <1> ; LEN
  2724                              <1> 
  2725                              <1> do_len:
  2726 000038F1 E8710B              <1> 	call get_token
  2727 000038F4 83F802              <1> 	cmp ax, STRING_VAR
  2728 000038F7 7538                <1> 	jne .error
  2729                              <1>  
  2730 000038F9 BE007C              <1> 	mov si, string_vars
  2731 000038FC B88000              <1> 	mov ax, 128
  2732 000038FF F7E3                <1> 	mul bx
  2733 00003901 01C6                <1> 	add si, ax
  2734                              <1> 
  2735 00003903 89F0                <1> 	mov ax, si
  2736 00003905 E8AAF0              <1> 	call os_string_length
  2737 00003908 A3[3739]            <1> 	mov word [.num1], ax
  2738                              <1> 
  2739 0000390B E8570B              <1> 	call get_token
  2740 0000390E 83F801              <1> 	cmp ax, VARIABLE
  2741 00003911 7406                <1> 	je .is_ok
  2742                              <1> 	
  2743 00003913 BE1400              <1> 	mov si, err_syntax
  2744 00003916 E9650C              <1> 	jmp error
  2745                              <1> 
  2746                              <1> .is_ok:
  2747 00003919 0FB606007B          <1> 	movzx ax, byte [token]
  2748 0000391E 88C3                <1> 	mov bl, al
  2749 00003920 EB00                <1> 	jmp .finish
  2750                              <1> 
  2751                              <1> .finish:	
  2752 00003922 8B1E[3739]          <1> 	mov bx, [.num1]
  2753 00003926 A0007B              <1> 	mov byte al, [token]
  2754 00003929 E82A0B              <1> 	call set_var
  2755 0000392C 31C0                <1> 	xor ax, ax
  2756 0000392E E9C4F3              <1> 	jmp mainloop
  2757                              <1>  
  2758                              <1> .error:
  2759 00003931 BE1400              <1> 	mov si, err_syntax
  2760 00003934 E9470C              <1> 	jmp error
  2761                              <1> 
  2762                              <1> 
  2763 00003937 0000                <1> 	.num1 dw 0
  2764                              <1> 
  2765                              <1> 
  2766                              <1> ; ------------------------------------------------------------------
  2767                              <1> ; LISTBOX
  2768                              <1> 
  2769                              <1> do_listbox:
  2770 00003939 8A3E[F345]          <1> 	mov bh, [work_page]			; Store the cursor position
  2771 0000393D B403                <1> 	mov ah, 03h
  2772 0000393F CD10                <1> 	int 10h
  2773                              <1> 	
  2774 00003941 E8210B              <1> 	call get_token
  2775 00003944 83F802              <1> 	cmp ax, STRING_VAR
  2776 00003947 757C                <1> 	jne .error
  2777                              <1> 
  2778 00003949 BE007C              <1> 	mov si, string_vars
  2779 0000394C B88000              <1> 	mov ax, 128
  2780 0000394F F7E3                <1> 	mul bx
  2781 00003951 01C6                <1> 	add si, ax
  2782                              <1> 
  2783 00003953 8936[CB39]          <1> 	mov word [.s1], si
  2784                              <1> 
  2785 00003957 E80B0B              <1> 	call get_token
  2786 0000395A 83F802              <1> 	cmp ax, STRING_VAR
  2787 0000395D 7566                <1> 	jne .error
  2788                              <1> 
  2789 0000395F BE007C              <1> 	mov si, string_vars
  2790 00003962 B88000              <1> 	mov ax, 128
  2791 00003965 F7E3                <1> 	mul bx
  2792 00003967 01C6                <1> 	add si, ax
  2793                              <1> 
  2794 00003969 8936[CD39]          <1> 	mov word [.s2], si
  2795                              <1> 
  2796 0000396D E8F50A              <1> 	call get_token
  2797 00003970 83F802              <1> 	cmp ax, STRING_VAR
  2798 00003973 7550                <1> 	jne .error
  2799                              <1> 
  2800 00003975 BE007C              <1> 	mov si, string_vars
  2801 00003978 B88000              <1> 	mov ax, 128
  2802 0000397B F7E3                <1> 	mul bx
  2803 0000397D 01C6                <1> 	add si, ax
  2804                              <1> 
  2805 0000397F 8936[CF39]          <1> 	mov word [.s3], si
  2806                              <1> 
  2807                              <1> 
  2808 00003983 E8DF0A              <1> 	call get_token
  2809 00003986 83F801              <1> 	cmp ax, VARIABLE
  2810 00003989 753A                <1> 	jne .error
  2811                              <1> 
  2812 0000398B A0007B              <1> 	mov byte al, [token]
  2813 0000398E A2[D139]            <1> 	mov byte [.var], al
  2814                              <1> 
  2815 00003991 A1[CB39]            <1> 	mov word ax, [.s1]
  2816 00003994 8B1E[CD39]          <1> 	mov word bx, [.s2]
  2817 00003998 8B0E[CF39]          <1> 	mov word cx, [.s3]
  2818                              <1> 
  2819 0000399C E814E2              <1> 	call os_list_dialog
  2820 0000399F 7217                <1> 	jc .esc_pressed
  2821                              <1> 
  2822 000039A1 60                  <1> 	pusha
  2823 000039A2 8A3E[F345]          <1> 	mov bh, [work_page]			; Move the cursor back
  2824 000039A6 B402                <1> 	mov ah, 02h
  2825 000039A8 CD10                <1> 	int 10h
  2826 000039AA 61                  <1> 	popa
  2827                              <1> 
  2828 000039AB 89C3                <1> 	mov bx, ax
  2829 000039AD 0FB606[D139]        <1> 	movzx ax, byte [.var]
  2830 000039B2 E8A10A              <1> 	call set_var
  2831                              <1> 
  2832 000039B5 E93DF3              <1> 	jmp mainloop
  2833                              <1> 
  2834                              <1> 
  2835                              <1> .esc_pressed:
  2836 000039B8 0FB606[D139]        <1> 	movzx ax, byte [.var]
  2837 000039BD 31DB                <1> 	xor bx, bx
  2838 000039BF E8940A              <1> 	call set_var
  2839 000039C2 E930F3              <1> 	jmp mainloop
  2840                              <1> 
  2841                              <1> 
  2842                              <1> .error:
  2843 000039C5 BE1400              <1> 	mov si, err_syntax
  2844 000039C8 E9B30B              <1> 	jmp error
  2845                              <1> 
  2846 000039CB 0000                <1> 	.s1 dw 0
  2847 000039CD 0000                <1> 	.s2 dw 0
  2848 000039CF 0000                <1> 	.s3 dw 0
  2849 000039D1 00                  <1> 	.var db 0
  2850                              <1> 
  2851                              <1> 
  2852                              <1> ; ------------------------------------------------------------------
  2853                              <1> ; LOAD
  2854                              <1> 
  2855                              <1> do_load:
  2856 000039D2 E8900A              <1> 	call get_token
  2857 000039D5 83F805              <1> 	cmp ax, QUOTE
  2858 000039D8 7411                <1> 	je .is_quote
  2859                              <1> 
  2860 000039DA 83F802              <1> 	cmp ax, STRING_VAR
  2861 000039DD 755F                <1> 	jne .error
  2862                              <1> 
  2863 000039DF BE007C              <1> 	mov si, string_vars
  2864 000039E2 B88000              <1> 	mov ax, 128
  2865 000039E5 F7E3                <1> 	mul bx
  2866 000039E7 01C6                <1> 	add si, ax
  2867 000039E9 EB03                <1> 	jmp .get_position
  2868                              <1> 
  2869                              <1> .is_quote:
  2870 000039EB BE007B              <1> 	mov si, token
  2871                              <1> 
  2872                              <1> .get_position:
  2873 000039EE 89F0                <1> 	mov ax, si
  2874 000039F0 E8DDD4              <1> 	call os_file_exists
  2875 000039F3 7239                <1> 	jc .file_not_exists
  2876                              <1> 
  2877 000039F5 89C2                <1> 	mov dx, ax			; Store for now
  2878                              <1> 
  2879 000039F7 E86B0A              <1> 	call get_token
  2880                              <1> 
  2881 000039FA 83F801              <1> 	cmp ax, VARIABLE
  2882 000039FD 7425                <1> 	je .second_is_var
  2883                              <1> 
  2884 000039FF 83F803              <1> 	cmp ax, NUMBER
  2885 00003A02 753A                <1> 	jne .error
  2886                              <1> 
  2887 00003A04 BE007B              <1> 	mov si, token
  2888 00003A07 E8EEF0              <1> 	call os_string_to_int
  2889                              <1> 
  2890                              <1> .load_part:
  2891 00003A0A 89C1                <1> 	mov cx, ax
  2892                              <1> 
  2893 00003A0C 89D0                <1> 	mov ax, dx
  2894                              <1> 
  2895 00003A0E E87BD1              <1> 	call os_load_file
  2896                              <1> 
  2897 00003A11 31C0                <1> 	xor ax, ax
  2898 00003A13 B053                <1> 	mov byte al, 'S'
  2899 00003A15 E83E0A              <1> 	call set_var
  2900                              <1> 
  2901 00003A18 31C0                <1> 	xor ax, ax
  2902 00003A1A B052                <1> 	mov byte al, 'R'
  2903 00003A1C 31DB                <1> 	xor bx, bx
  2904 00003A1E E8350A              <1> 	call set_var
  2905                              <1> 
  2906 00003A21 E9D1F2              <1> 	jmp mainloop
  2907                              <1> 
  2908                              <1> 
  2909                              <1> .second_is_var:
  2910 00003A24 0FB606007B          <1> 	movzx ax, byte [token]
  2911 00003A29 E81D0A              <1> 	call get_var
  2912 00003A2C EBDC                <1> 	jmp .load_part
  2913                              <1> 
  2914                              <1> 
  2915                              <1> .file_not_exists:
  2916 00003A2E 31C0                <1> 	xor ax, ax
  2917 00003A30 B052                <1> 	mov byte al, 'R'
  2918 00003A32 BB0100              <1> 	mov bx, 1
  2919 00003A35 E81E0A              <1> 	call set_var
  2920                              <1> 
  2921 00003A38 E82A0A              <1> 	call get_token				; Skip past the loading point -- unnecessary now
  2922                              <1> 
  2923 00003A3B E9B7F2              <1> 	jmp mainloop
  2924                              <1> 
  2925                              <1> 
  2926                              <1> .error:
  2927 00003A3E BE1400              <1> 	mov si, err_syntax
  2928 00003A41 E93A0B              <1> 	jmp error
  2929                              <1> 
  2930                              <1> 
  2931                              <1> ; ------------------------------------------------------------------
  2932                              <1> ; LOOP
  2933                              <1> 
  2934                              <1> do_loop:
  2935 00003A44 803E[F045]00        <1> 	cmp byte [loop_in], 0
  2936 00003A49 0F84CA00            <1> 	je .no_do
  2937                              <1> 
  2938 00003A4D 802E[F045]02        <1> 	sub byte [loop_in], 2
  2939                              <1> 
  2940 00003A52 31D2                <1> 	xor dx, dx
  2941                              <1> 
  2942 00003A54 E80E0A              <1> 	call get_token
  2943 00003A57 BF007B              <1> 	mov di, token
  2944                              <1> 	
  2945 00003A5A BE[2F3B]            <1> 	mov si, .endless_word
  2946 00003A5D E844F0              <1> 	call os_string_compare
  2947 00003A60 0F829C00            <1> 	jc .loop_back
  2948                              <1> 	
  2949 00003A64 BE[233B]            <1> 	mov si, .while_word
  2950 00003A67 E83AF0              <1> 	call os_string_compare
  2951 00003A6A 0F82A300            <1> 	jc .while_set
  2952                              <1> 	
  2953 00003A6E BE[293B]            <1> 	mov si, .until_word
  2954 00003A71 E830F0              <1> 	call os_string_compare
  2955 00003A74 0F83A500            <1> 	jnc .error
  2956                              <1> 	
  2957                              <1> .get_first_var:
  2958 00003A78 E8EA09              <1> 	call get_token
  2959 00003A7B 83F801              <1> 	cmp ax, VARIABLE
  2960 00003A7E 0F859B00            <1> 	jne .error
  2961                              <1> 	
  2962 00003A82 A0007B              <1> 	mov al, [token]
  2963 00003A85 E8C109              <1> 	call get_var
  2964 00003A88 89C1                <1> 	mov cx, ax
  2965                              <1> 	
  2966                              <1> .check_equals:
  2967 00003A8A E8D809              <1> 	call get_token
  2968 00003A8D 83F807              <1> 	cmp ax, UNKNOWN
  2969 00003A90 0F858900            <1> 	jne .error
  2970                              <1> 
  2971 00003A94 A1007B              <1> 	mov ax, [token]
  2972 00003A97 3C3D                <1> 	cmp al, '='
  2973 00003A99 740A                <1> 	je .sign_ok
  2974 00003A9B 3C3E                <1> 	cmp al, '>'
  2975 00003A9D 7406                <1> 	je .sign_ok
  2976 00003A9F 3C3C                <1> 	cmp al, '<'
  2977 00003AA1 7402                <1> 	je .sign_ok
  2978 00003AA3 EB78                <1> 	jmp .error
  2979                              <1> 	.sign_ok:
  2980 00003AA5 A2[373B]            <1> 	mov byte [.sign], al
  2981                              <1> 	
  2982                              <1> .get_second_var:
  2983 00003AA8 E8BA09              <1>  	call get_token
  2984                              <1> 
  2985 00003AAB 83F803              <1> 	cmp ax, NUMBER
  2986 00003AAE 7419                <1> 	je .second_is_num
  2987                              <1> 
  2988 00003AB0 83F801              <1> 	cmp ax, VARIABLE
  2989 00003AB3 740C                <1> 	je .second_is_var
  2990                              <1> 
  2991 00003AB5 83F806              <1> 	cmp ax, CHAR
  2992 00003AB8 7563                <1> 	jne .error
  2993                              <1> 
  2994                              <1> .second_is_char:
  2995 00003ABA B400                <1> 	mov ah, 0
  2996 00003ABC A0007B              <1> 	mov al, [token]
  2997 00003ABF EB0E                <1> 	jmp .check_true
  2998                              <1> 	
  2999                              <1> .second_is_var:
  3000 00003AC1 A0007B              <1> 	mov al, [token]
  3001 00003AC4 E88209              <1> 	call get_var
  3002 00003AC7 EB06                <1> 	jmp .check_true
  3003                              <1> 	
  3004                              <1> .second_is_num:
  3005 00003AC9 BE007B              <1> 	mov si, token
  3006 00003ACC E829F0              <1> 	call os_string_to_int
  3007                              <1> 	
  3008                              <1> .check_true:
  3009 00003ACF 8A1E[373B]          <1> 	mov byte bl, [.sign]
  3010 00003AD3 80FB3D              <1> 	cmp bl, '='
  3011 00003AD6 7407                <1> 	je .sign_equals
  3012                              <1> 	
  3013 00003AD8 80FB3E              <1> 	cmp bl, '>'
  3014 00003ADB 7408                <1> 	je .sign_greater
  3015                              <1> 	
  3016 00003ADD EB0C                <1> 	jmp .sign_lesser
  3017                              <1> 	
  3018                              <1> .sign_equals:
  3019 00003ADF 39C8                <1> 	cmp ax, cx
  3020 00003AE1 7516                <1> 	jne .false
  3021 00003AE3 EB0C                <1> 	jmp .true
  3022                              <1> 	
  3023                              <1> .sign_greater:
  3024 00003AE5 39C8                <1> 	cmp ax, cx
  3025 00003AE7 7D10                <1> 	jge .false
  3026 00003AE9 EB06                <1> 	jmp .true
  3027                              <1> 	
  3028                              <1> .sign_lesser:
  3029 00003AEB 39C8                <1> 	cmp ax, cx
  3030 00003AED 7E0A                <1> 	jle .false
  3031 00003AEF EB00                <1> 	jmp .true
  3032                              <1> .true:
  3033 00003AF1 83FA01              <1> 	cmp dx, 1
  3034 00003AF4 740A                <1> 	je .loop_back
  3035 00003AF6 E9FCF1              <1> 	jmp mainloop
  3036                              <1> .false:
  3037 00003AF9 83FA01              <1> 	cmp dx, 1
  3038 00003AFC 0F84F5F1            <1> 	je mainloop
  3039                              <1> 	
  3040                              <1> .loop_back:	
  3041 00003B00 BED079              <1> 	mov word si, do_loop_store
  3042 00003B03 A0[F045]            <1> 	mov byte al, [loop_in]
  3043 00003B06 B400                <1> 	mov ah, 0
  3044 00003B08 01C6                <1> 	add si, ax
  3045 00003B0A AD                  <1> 	lodsw
  3046 00003B0B A3[E945]            <1> 	mov word [prog], ax
  3047 00003B0E E9E4F1              <1> 	jmp mainloop
  3048                              <1> 	
  3049                              <1> .while_set:
  3050 00003B11 BA0100              <1> 	mov dx, 1
  3051 00003B14 E961FF              <1> 	jmp .get_first_var
  3052                              <1> 	
  3053                              <1> .no_do:
  3054 00003B17 BE0900              <1> 	mov si, err_loop
  3055 00003B1A E9610A              <1> 	jmp error
  3056                              <1> 
  3057                              <1> .error:
  3058 00003B1D BE1400              <1> 	mov si, err_syntax
  3059 00003B20 E95B0A              <1> 	jmp error
  3060                              <1> 	
  3061                              <1> .data:
  3062 00003B23 5748494C4500        <1> 	.while_word			db "WHILE", 0
  3063 00003B29 554E54494C00        <1> 	.until_word			db "UNTIL", 0
  3064 00003B2F 454E444C45535300    <1> 	.endless_word			db "ENDLESS", 0
  3065 00003B37 00                  <1> 	.sign				db 0
  3066                              <1> 	
  3067                              <1> 	
  3068                              <1> ; ------------------------------------------------------------------
  3069                              <1> ; MOVE
  3070                              <1> 
  3071                              <1> do_move:
  3072 00003B38 E82A09              <1> 	call get_token
  3073                              <1> 
  3074 00003B3B 83F801              <1> 	cmp ax, VARIABLE
  3075 00003B3E 740A                <1> 	je .first_is_var
  3076                              <1> 
  3077 00003B40 BE007B              <1> 	mov si, token
  3078 00003B43 E8B2EF              <1> 	call os_string_to_int
  3079 00003B46 88C2                <1> 	mov dl, al
  3080 00003B48 EB0A                <1> 	jmp .onto_second
  3081                              <1> 
  3082                              <1> .first_is_var:
  3083 00003B4A 0FB606007B          <1> 	movzx ax, byte [token]
  3084 00003B4F E8F708              <1> 	call get_var
  3085 00003B52 88C2                <1> 	mov dl, al
  3086                              <1> 
  3087                              <1> .onto_second:
  3088 00003B54 E80E09              <1> 	call get_token
  3089                              <1> 
  3090 00003B57 83F801              <1> 	cmp ax, VARIABLE
  3091 00003B5A 740A                <1> 	je .second_is_var
  3092                              <1> 
  3093 00003B5C BE007B              <1> 	mov si, token
  3094 00003B5F E896EF              <1> 	call os_string_to_int
  3095 00003B62 88C6                <1> 	mov dh, al
  3096 00003B64 EB0A                <1> 	jmp .finish
  3097                              <1> 
  3098                              <1> .second_is_var:
  3099 00003B66 0FB606007B          <1> 	movzx ax, byte [token]
  3100 00003B6B E8DB08              <1> 	call get_var
  3101 00003B6E 88C6                <1> 	mov dh, al
  3102                              <1> 
  3103                              <1> .finish:
  3104 00003B70 8A3E[F345]          <1> 	mov byte bh, [work_page]
  3105 00003B74 B402                <1> 	mov ah, 2
  3106 00003B76 CD10                <1> 	int 10h
  3107                              <1> 
  3108 00003B78 E97AF1              <1> 	jmp mainloop
  3109                              <1> 
  3110                              <1> 
  3111                              <1> ; ------------------------------------------------------------------
  3112                              <1> ; NEXT
  3113                              <1> 
  3114                              <1> do_next:
  3115 00003B7B E8E708              <1> 	call get_token
  3116                              <1> 
  3117 00003B7E 83F801              <1> 	cmp ax, VARIABLE			; NEXT must be followed by a variable
  3118 00003B81 753F                <1> 	jne .error
  3119                              <1> 
  3120 00003B83 0FB606007B          <1> 	movzx ax, byte [token]
  3121 00003B88 E8BE08              <1> 	call get_var
  3122                              <1> 
  3123 00003B8B 40                  <1> 	inc ax					; NEXT increments the variable, of course!
  3124                              <1> 
  3125 00003B8C 89C3                <1> 	mov bx, ax
  3126                              <1> 
  3127 00003B8E 0FB606007B          <1> 	movzx ax, byte [token]
  3128                              <1> 
  3129 00003B93 2C41                <1> 	sub al, 65
  3130 00003B95 BE187A              <1> 	mov si, for_variables
  3131 00003B98 01C6                <1> 	add si, ax
  3132 00003B9A 01C6                <1> 	add si, ax
  3133 00003B9C AD                  <1> 	lodsw					; Get the target number from the table
  3134                              <1> 
  3135 00003B9D 40                  <1> 	inc ax					; (Make the loop inclusive of target number)
  3136 00003B9E 39D8                <1> 	cmp ax, bx				; Do the variable and target match?
  3137 00003BA0 741D                <1> 	je .loop_finished
  3138                              <1> 
  3139 00003BA2 0FB606007B          <1> 	movzx ax, byte [token]
  3140 00003BA7 E8AC08              <1> 	call set_var
  3141                              <1> 
  3142 00003BAA 0FB606007B          <1> 	movzx ax, byte [token]
  3143 00003BAF 2C41                <1> 	sub al, 65
  3144 00003BB1 BEE479              <1> 	mov si, for_code_points
  3145 00003BB4 01C6                <1> 	add si, ax
  3146 00003BB6 01C6                <1> 	add si, ax
  3147 00003BB8 AD                  <1> 	lodsw
  3148                              <1> 
  3149 00003BB9 A3[E945]            <1> 	mov word [prog], ax
  3150 00003BBC E936F1              <1> 	jmp mainloop
  3151                              <1> 
  3152                              <1> 
  3153                              <1> .loop_finished:
  3154 00003BBF E933F1              <1> 	jmp mainloop
  3155                              <1> 
  3156                              <1> .error:
  3157 00003BC2 BE1400              <1> 	mov si, err_syntax
  3158 00003BC5 E9B609              <1> 	jmp error
  3159                              <1> 
  3160                              <1> 
  3161                              <1> 
  3162                              <1> ;-------------------------------------------------------------------
  3163                              <1> ; NUMBER
  3164                              <1> 
  3165                              <1> do_number:
  3166 00003BC8 E89A08              <1> 	call get_token			; Check if it's string to number, or number to string
  3167                              <1> 
  3168 00003BCB 83F802              <1> 	cmp ax, STRING_VAR
  3169 00003BCE 7407                <1> 	je .is_string
  3170                              <1> 
  3171 00003BD0 83F801              <1> 	cmp ax, VARIABLE
  3172 00003BD3 742C                <1> 	je .is_variable
  3173                              <1> 
  3174 00003BD5 EB54                <1> 	jmp .error
  3175                              <1> 
  3176                              <1> .is_string:
  3177                              <1> 
  3178 00003BD7 BE007C              <1> 	mov si, string_vars
  3179 00003BDA B88000              <1> 	mov ax, 128
  3180 00003BDD F7E3                <1> 	mul bx
  3181 00003BDF 01C6                <1> 	add si, ax
  3182 00003BE1 8936[313C]          <1> 	mov [.tmp], si
  3183                              <1> 
  3184 00003BE5 E87D08              <1> 	call get_token
  3185                              <1> 
  3186 00003BE8 8B36[313C]          <1> 	mov si, [.tmp]
  3187                              <1> 
  3188 00003BEC 83F801              <1> 	cmp ax, VARIABLE
  3189 00003BEF 753A                <1> 	jne .error
  3190                              <1> 
  3191 00003BF1 E804EF              <1> 	call os_string_to_int
  3192 00003BF4 89C3                <1> 	mov bx, ax
  3193                              <1> 
  3194 00003BF6 0FB606007B          <1> 	movzx ax, byte [token]
  3195 00003BFB E85808              <1> 	call set_var
  3196                              <1> 
  3197 00003BFE E9F4F0              <1> 	jmp mainloop
  3198                              <1> 
  3199                              <1> .is_variable:
  3200 00003C01 0FB606007B          <1> 	movzx ax, byte [token]
  3201 00003C06 E84008              <1> 	call get_var
  3202                              <1> 
  3203 00003C09 E837EF              <1> 	call os_int_to_string		; Convert to a string
  3204 00003C0C A3[313C]            <1> 	mov [.tmp], ax
  3205                              <1> 
  3206 00003C0F E85308              <1> 	call get_token			; Get the second parameter
  3207                              <1> 
  3208 00003C12 8B36[313C]          <1> 	mov si, [.tmp]
  3209                              <1> 
  3210 00003C16 83F802              <1> 	cmp ax, STRING_VAR		; Make sure it's a string variable
  3211 00003C19 7510                <1> 	jne .error
  3212                              <1> 
  3213 00003C1B BF007C              <1> 	mov di, string_vars		; Locate string variable
  3214 00003C1E B88000              <1> 	mov ax, 128
  3215 00003C21 F7E3                <1> 	mul bx
  3216 00003C23 01C7                <1> 	add di, ax
  3217                              <1> 
  3218 00003C25 E81DEE              <1> 	call os_string_copy		; Save converted string
  3219                              <1> 
  3220 00003C28 E9CAF0              <1> 	jmp mainloop
  3221                              <1> 
  3222                              <1> .error:
  3223 00003C2B BE1400              <1> 	mov si, err_syntax
  3224 00003C2E E94D09              <1> 	jmp error
  3225                              <1> 
  3226                              <1> 
  3227 00003C31 0000                <1> 	.tmp		dw 	0
  3228                              <1> 
  3229                              <1> 
  3230                              <1> ;-------------------------------------------------------------------
  3231                              <1> ; PAGE
  3232                              <1> 
  3233                              <1> do_page:
  3234 00003C33 E82F08              <1> 	call get_token
  3235 00003C36 83F803              <1> 	cmp ax, NUMBER
  3236 00003C39 7521                <1> 	jne .error
  3237                              <1> 
  3238 00003C3B BE007B              <1> 	mov si, token
  3239 00003C3E E8B7EE              <1> 	call os_string_to_int
  3240 00003C41 A2[F345]            <1> 	mov byte [work_page], al	; Set work page variable
  3241                              <1> 
  3242 00003C44 E81E08              <1> 	call get_token
  3243 00003C47 83F803              <1> 	cmp ax, NUMBER
  3244 00003C4A 7510                <1> 	jne .error
  3245                              <1> 
  3246 00003C4C BE007B              <1> 	mov si, token
  3247 00003C4F E8A6EE              <1> 	call os_string_to_int
  3248 00003C52 A2[F445]            <1> 	mov byte [disp_page], al	; Set display page variable
  3249                              <1> 
  3250                              <1> 	; Change display page -- AL should already be present from the os_string_to_int
  3251 00003C55 B405                <1> 	mov ah, 5
  3252 00003C57 CD10                <1> 	int 10h
  3253                              <1> 
  3254 00003C59 E999F0              <1> 	jmp mainloop
  3255                              <1> 
  3256                              <1> .error:
  3257 00003C5C BE1400              <1> 	mov si, err_syntax
  3258 00003C5F E91C09              <1> 	jmp error
  3259                              <1> 
  3260                              <1> 
  3261                              <1> ; ------------------------------------------------------------------
  3262                              <1> ; PAUSE
  3263                              <1> 
  3264                              <1> do_pause:
  3265 00003C62 E80008              <1> 	call get_token
  3266                              <1> 
  3267 00003C65 83F801              <1> 	cmp ax, VARIABLE
  3268 00003C68 7408                <1> 	je .is_var
  3269                              <1> 
  3270 00003C6A BE007B              <1> 	mov si, token
  3271 00003C6D E888EE              <1> 	call os_string_to_int
  3272 00003C70 EB08                <1> 	jmp .finish
  3273                              <1> 
  3274                              <1> .is_var:
  3275 00003C72 0FB606007B          <1> 	movzx ax, byte [token]
  3276 00003C77 E8CF07              <1> 	call get_var
  3277                              <1> 
  3278                              <1> .finish:
  3279 00003C7A E84ED8              <1> 	call os_pause
  3280 00003C7D E975F0              <1> 	jmp mainloop
  3281                              <1> 
  3282                              <1> 
  3283                              <1> ; ------------------------------------------------------------------
  3284                              <1> ; PEEK
  3285                              <1> 
  3286                              <1> do_peek:
  3287 00003C80 E8E207              <1> 	call get_token
  3288                              <1> 
  3289 00003C83 83F801              <1> 	cmp ax, VARIABLE
  3290 00003C86 7533                <1> 	jne .error
  3291                              <1> 
  3292 00003C88 0FB606007B          <1> 	movzx ax, byte [token]
  3293 00003C8D A2[C13C]            <1> 	mov byte [.tmp_var], al
  3294                              <1> 
  3295 00003C90 E8D207              <1> 	call get_token
  3296                              <1> 
  3297 00003C93 83F801              <1> 	cmp ax, VARIABLE
  3298 00003C96 741B                <1> 	je .dereference
  3299                              <1> 
  3300 00003C98 83F803              <1> 	cmp ax, NUMBER
  3301 00003C9B 751E                <1> 	jne .error
  3302                              <1> 
  3303 00003C9D BE007B              <1> 	mov si, token
  3304 00003CA0 E855EE              <1> 	call os_string_to_int
  3305                              <1> 
  3306                              <1> .store:
  3307 00003CA3 89C6                <1> 	mov si, ax
  3308 00003CA5 0FB61C              <1> 	movzx bx, byte [si]
  3309 00003CA8 0FB606[C13C]        <1> 	movzx ax, byte [.tmp_var]
  3310 00003CAD E8A607              <1> 	call set_var
  3311                              <1> 
  3312 00003CB0 E942F0              <1> 	jmp mainloop
  3313                              <1> 
  3314                              <1> .dereference:
  3315 00003CB3 A0007B              <1> 	mov byte al, [token]
  3316 00003CB6 E89007              <1> 	call get_var
  3317 00003CB9 EBE8                <1> 	jmp .store
  3318                              <1> 
  3319                              <1> .error:
  3320 00003CBB BE1400              <1> 	mov si, err_syntax
  3321 00003CBE E9BD08              <1> 	jmp error
  3322                              <1> 
  3323                              <1> 
  3324 00003CC1 00                  <1> 	.tmp_var	db 0
  3325                              <1> 	
  3326                              <1> 	
  3327                              <1> 	
  3328                              <1> ; ------------------------------------------------------------------
  3329                              <1> ; PEEKINT
  3330                              <1> 
  3331                              <1> do_peekint:
  3332 00003CC2 E8A007              <1> 	call get_token
  3333                              <1> 	
  3334 00003CC5 83F801              <1> 	cmp ax, VARIABLE
  3335 00003CC8 752C                <1> 	jne .error
  3336                              <1> 
  3337                              <1> .get_second:
  3338 00003CCA A0007B              <1> 	mov al, [token]
  3339 00003CCD 89C1                <1> 	mov cx, ax
  3340                              <1> 	
  3341 00003CCF E89307              <1> 	call get_token
  3342                              <1> 	
  3343 00003CD2 83F801              <1> 	cmp ax, VARIABLE
  3344 00003CD5 740D                <1> 	je .address_is_var
  3345                              <1> 	
  3346 00003CD7 83F803              <1> 	cmp ax, NUMBER
  3347 00003CDA 751A                <1> 	jne .error
  3348                              <1> 	
  3349                              <1> .address_is_number:
  3350 00003CDC BE007B              <1> 	mov si, token
  3351 00003CDF E816EE              <1> 	call os_string_to_int
  3352 00003CE2 EB06                <1> 	jmp .load_data
  3353                              <1> 	
  3354                              <1> .address_is_var:
  3355 00003CE4 A0007B              <1> 	mov al, [token]
  3356 00003CE7 E85F07              <1> 	call get_var
  3357                              <1> 	
  3358                              <1> .load_data:
  3359 00003CEA 89C6                <1> 	mov si, ax
  3360 00003CEC 8B1C                <1> 	mov bx, [si]
  3361 00003CEE 89C8                <1> 	mov ax, cx
  3362 00003CF0 E86307              <1> 	call set_var
  3363                              <1> 	
  3364 00003CF3 E9FFEF              <1> 	jmp mainloop
  3365                              <1> 	
  3366                              <1> .error:
  3367 00003CF6 BE1400              <1> 	mov si, err_syntax
  3368 00003CF9 E98208              <1> 	jmp error
  3369                              <1> 
  3370                              <1> 
  3371                              <1> 
  3372                              <1> ; ------------------------------------------------------------------
  3373                              <1> ; POKE
  3374                              <1> 
  3375                              <1> do_poke:
  3376 00003CFC E86607              <1> 	call get_token
  3377                              <1> 
  3378 00003CFF 83F801              <1> 	cmp ax, VARIABLE
  3379 00003D02 7415                <1> 	je .first_is_var
  3380                              <1> 
  3381 00003D04 83F803              <1> 	cmp ax, NUMBER
  3382 00003D07 7544                <1> 	jne .error
  3383                              <1> 
  3384 00003D09 BE007B              <1> 	mov si, token
  3385 00003D0C E8E9ED              <1> 	call os_string_to_int
  3386                              <1> 
  3387 00003D0F 3DFF00              <1> 	cmp ax, 255
  3388 00003D12 7F39                <1> 	jg .error
  3389                              <1> 
  3390 00003D14 A2[533D]            <1> 	mov byte [.first_value], al
  3391 00003D17 EB0B                <1> 	jmp .onto_second
  3392                              <1> 
  3393                              <1> 
  3394                              <1> .first_is_var:
  3395 00003D19 0FB606007B          <1> 	movzx ax, byte [token]
  3396 00003D1E E82807              <1> 	call get_var
  3397                              <1> 
  3398 00003D21 A2[533D]            <1> 	mov byte [.first_value], al
  3399                              <1> 
  3400                              <1> .onto_second:
  3401 00003D24 E83E07              <1> 	call get_token
  3402                              <1> 
  3403 00003D27 83F801              <1> 	cmp ax, VARIABLE
  3404 00003D2A 7417                <1> 	je .second_is_var
  3405                              <1> 
  3406 00003D2C 83F803              <1> 	cmp ax, NUMBER
  3407 00003D2F 751C                <1> 	jne .error
  3408                              <1> 
  3409 00003D31 BE007B              <1> 	mov si, token
  3410 00003D34 E8C1ED              <1> 	call os_string_to_int
  3411                              <1> 
  3412                              <1> .got_value:
  3413 00003D37 89C7                <1> 	mov di, ax
  3414 00003D39 0FB606[533D]        <1> 	movzx ax, byte [.first_value]
  3415 00003D3E 8805                <1> 	mov byte [di], al
  3416                              <1> 
  3417 00003D40 E9B2EF              <1> 	jmp mainloop
  3418                              <1> 
  3419                              <1> .second_is_var:
  3420 00003D43 0FB606007B          <1> 	movzx ax, byte [token]
  3421 00003D48 E8FE06              <1> 	call get_var
  3422 00003D4B EBEA                <1> 	jmp .got_value
  3423                              <1> 
  3424                              <1> .error:
  3425 00003D4D BE1400              <1> 	mov si, err_syntax
  3426 00003D50 E92B08              <1> 	jmp error
  3427                              <1> 
  3428                              <1> 
  3429 00003D53 00                  <1> 	.first_value	db 0
  3430                              <1> 
  3431                              <1> 
  3432                              <1> 
  3433                              <1> 
  3434                              <1> ; ------------------------------------------------------------------
  3435                              <1> ; POKEINT
  3436                              <1> 
  3437                              <1> do_pokeint:
  3438 00003D54 E80E07              <1> 	call get_token
  3439                              <1> 	
  3440 00003D57 83F801              <1> 	cmp ax, VARIABLE
  3441 00003D5A 740D                <1> 	je .data_is_var
  3442                              <1> 	
  3443 00003D5C 83F803              <1> 	cmp ax, NUMBER
  3444 00003D5F 7532                <1> 	jne .error
  3445                              <1> 
  3446                              <1> .data_is_num:
  3447 00003D61 BE007B              <1> 	mov si, token
  3448 00003D64 E891ED              <1> 	call os_string_to_int
  3449 00003D67 EB06                <1> 	jmp .get_second
  3450                              <1> 	
  3451                              <1> .data_is_var:
  3452 00003D69 A0007B              <1> 	mov al, [token]
  3453 00003D6C E8DA06              <1> 	call get_var
  3454                              <1> 	
  3455                              <1> .get_second:
  3456 00003D6F 89C1                <1> 	mov cx, ax
  3457                              <1> 	
  3458 00003D71 E8F106              <1> 	call get_token
  3459                              <1> 	
  3460 00003D74 83F801              <1> 	cmp ax, VARIABLE
  3461 00003D77 740D                <1> 	je .address_is_var
  3462                              <1> 	
  3463 00003D79 83F803              <1> 	cmp ax, NUMBER
  3464 00003D7C 7515                <1> 	jne .error
  3465                              <1> 	
  3466                              <1> .address_is_num:
  3467 00003D7E BE007B              <1> 	mov si, token
  3468 00003D81 E874ED              <1> 	call os_string_to_int
  3469 00003D84 EB06                <1> 	jmp .save_data
  3470                              <1> 	
  3471                              <1> .address_is_var:
  3472 00003D86 A0007B              <1> 	mov al, [token]
  3473 00003D89 E8BD06              <1> 	call get_var
  3474                              <1> 	
  3475                              <1> .save_data:
  3476 00003D8C 89C6                <1> 	mov si, ax
  3477 00003D8E 890C                <1> 	mov [si], cx
  3478                              <1> 	
  3479 00003D90 E962EF              <1> 	jmp mainloop
  3480                              <1> 	
  3481                              <1> .error:
  3482 00003D93 BE1400              <1> 	mov si, err_syntax
  3483 00003D96 E9E507              <1> 	jmp error
  3484                              <1> 
  3485                              <1> 
  3486                              <1> 
  3487                              <1> 
  3488                              <1> ; ------------------------------------------------------------------
  3489                              <1> ; PORT
  3490                              <1> 
  3491                              <1> do_port:
  3492 00003D99 E8C906              <1> 	call get_token
  3493 00003D9C BE007B              <1> 	mov si, token
  3494                              <1> 
  3495 00003D9F BF[143E]            <1> 	mov di, .out_cmd
  3496 00003DA2 E8FFEC              <1> 	call os_string_compare
  3497 00003DA5 720A                <1> 	jc .do_out_cmd
  3498                              <1> 
  3499 00003DA7 BF[183E]            <1> 	mov di, .in_cmd
  3500 00003DAA E8F7EC              <1> 	call os_string_compare
  3501 00003DAD 7237                <1> 	jc .do_in_cmd
  3502                              <1> 
  3503 00003DAF EB5D                <1> 	jmp .error
  3504                              <1> 
  3505                              <1> 
  3506                              <1> .do_out_cmd:
  3507 00003DB1 E8B106              <1> 	call get_token
  3508 00003DB4 83F803              <1> 	cmp ax, NUMBER
  3509 00003DB7 7555                <1> 	jne .error
  3510                              <1> 
  3511 00003DB9 BE007B              <1> 	mov si, token
  3512 00003DBC E839ED              <1> 	call os_string_to_int		; Now AX = port number
  3513 00003DBF 89C2                <1> 	mov dx, ax
  3514                              <1> 
  3515 00003DC1 E8A106              <1> 	call get_token
  3516 00003DC4 83F803              <1> 	cmp ax, NUMBER
  3517 00003DC7 7407                <1> 	je .out_is_num
  3518                              <1> 
  3519 00003DC9 83F801              <1> 	cmp ax, VARIABLE
  3520 00003DCC 740C                <1> 	je .out_is_var
  3521                              <1> 
  3522 00003DCE EB3E                <1> 	jmp .error
  3523                              <1> 
  3524                              <1> .out_is_num:
  3525 00003DD0 BE007B              <1> 	mov si, token
  3526 00003DD3 E822ED              <1> 	call os_string_to_int
  3527 00003DD6 EE                  <1> 	out dx, al
  3528 00003DD7 E91BEF              <1> 	jmp mainloop
  3529                              <1> 
  3530                              <1> .out_is_var:
  3531 00003DDA 0FB606007B          <1> 	movzx ax, byte [token]
  3532 00003DDF E86706              <1> 	call get_var
  3533                              <1> 
  3534 00003DE2 EE                  <1> 	out dx, al
  3535 00003DE3 E90FEF              <1> 	jmp mainloop
  3536                              <1> 
  3537                              <1> 
  3538                              <1> .do_in_cmd:
  3539 00003DE6 E87C06              <1> 	call get_token
  3540 00003DE9 83F803              <1> 	cmp ax, NUMBER
  3541 00003DEC 7520                <1> 	jne .error
  3542                              <1> 
  3543 00003DEE BE007B              <1> 	mov si, token
  3544 00003DF1 E804ED              <1> 	call os_string_to_int
  3545 00003DF4 89C2                <1> 	mov dx, ax
  3546                              <1> 
  3547 00003DF6 E86C06              <1> 	call get_token
  3548 00003DF9 83F801              <1> 	cmp ax, VARIABLE
  3549 00003DFC 7510                <1> 	jne .error
  3550                              <1> 
  3551 00003DFE 8A0E007B            <1> 	mov byte cl, [token]
  3552                              <1> 
  3553 00003E02 EC                  <1> 	in al, dx
  3554 00003E03 0FB6D8              <1> 	movzx bx, al
  3555                              <1> 
  3556 00003E06 88C8                <1> 	mov al, cl
  3557 00003E08 E84B06              <1> 	call set_var
  3558                              <1> 
  3559 00003E0B E9E7EE              <1> 	jmp mainloop
  3560                              <1> 
  3561                              <1> 
  3562                              <1> .error:
  3563 00003E0E BE1400              <1> 	mov si, err_syntax
  3564 00003E11 E96A07              <1> 	jmp error
  3565                              <1> 
  3566                              <1> 
  3567 00003E14 4F555400            <1> 	.out_cmd	db "OUT", 0
  3568 00003E18 494E00              <1> 	.in_cmd		db "IN", 0
  3569                              <1> 
  3570                              <1> 
  3571                              <1> ; ------------------------------------------------------------------
  3572                              <1> ; PRINT
  3573                              <1> 
  3574                              <1> do_print:
  3575 00003E1B E84706              <1> 	call get_token				; Get part after PRINT
  3576                              <1> 
  3577 00003E1E 83F805              <1> 	cmp ax, QUOTE				; What type is it?
  3578 00003E21 7428                <1> 	je .print_quote
  3579                              <1> 
  3580 00003E23 83F801              <1> 	cmp ax, VARIABLE			; Numerical variable (eg X)
  3581 00003E26 7410                <1> 	je .print_var
  3582                              <1> 
  3583 00003E28 83F802              <1> 	cmp ax, STRING_VAR			; String variable (eg $1)
  3584 00003E2B 7457                <1> 	je .print_string_var
  3585                              <1> 
  3586 00003E2D 83F804              <1> 	cmp ax, STRING				; Special keyword (eg CHR or HEX)
  3587 00003E30 745E                <1> 	je .print_keyword
  3588                              <1> 
  3589 00003E32 BE1000              <1> 	mov si, err_print_type			; We only print quoted strings and vars!
  3590 00003E35 E94607              <1> 	jmp error
  3591                              <1> 
  3592                              <1> 
  3593                              <1> .print_var:
  3594 00003E38 0FB606007B          <1> 	movzx ax, byte [token]
  3595 00003E3D E80906              <1> 	call get_var				; Get its value
  3596                              <1> 
  3597 00003E40 E800ED              <1> 	call os_int_to_string			; Convert to string
  3598 00003E43 89C6                <1> 	mov si, ax
  3599 00003E45 E8ACD9              <1> 	call os_print_string
  3600                              <1> 
  3601 00003E48 E9C500              <1> 	jmp .newline_or_not
  3602                              <1> 
  3603                              <1> 
  3604                              <1> .print_quote:					; If it's quoted text, print it
  3605 00003E4B BE007B              <1> 	mov si, token
  3606                              <1> .print_quote_loop:
  3607 00003E4E AC                  <1> 	lodsb
  3608 00003E4F 3C00                <1> 	cmp al, 0
  3609 00003E51 0F84BB00            <1> 	je .newline_or_not
  3610                              <1> 
  3611 00003E55 B409                <1> 	mov ah, 09h
  3612 00003E57 8A1E[F245]          <1> 	mov byte bl, [ink_colour]
  3613 00003E5B 8A3E[F345]          <1> 	mov byte bh, [work_page]
  3614 00003E5F B90100              <1> 	mov cx, 1
  3615 00003E62 CD10                <1> 	int 10h
  3616                              <1> 
  3617 00003E64 B403                <1> 	mov ah, 3
  3618 00003E66 CD10                <1> 	int 10h
  3619                              <1> 
  3620 00003E68 80FA4F              <1> 	cmp dl, 79
  3621 00003E6B 7D0C                <1> 	jge .quote_newline
  3622 00003E6D FEC2                <1> 	inc dl
  3623                              <1> 
  3624                              <1> .move_cur_quote:
  3625 00003E6F 8A3E[F345]          <1> 	mov byte bh, [work_page]
  3626 00003E73 B402                <1> 	mov ah, 02h
  3627 00003E75 CD10                <1> 	int 10h
  3628 00003E77 EBD5                <1> 	jmp .print_quote_loop
  3629                              <1> 
  3630                              <1> 
  3631                              <1> .quote_newline:
  3632 00003E79 80FE18              <1> 	cmp dh, 24
  3633 00003E7C 74F1                <1> 	je .move_cur_quote
  3634 00003E7E B200                <1> 	mov dl, 0
  3635 00003E80 FEC6                <1> 	inc dh
  3636 00003E82 EBEB                <1> 	jmp .move_cur_quote
  3637                              <1> 
  3638                              <1> .print_string_var:
  3639 00003E84 BE007C              <1> 	mov si, string_vars
  3640 00003E87 B88000              <1> 	mov ax, 128
  3641 00003E8A F7E3                <1> 	mul bx
  3642 00003E8C 01C6                <1> 	add si, ax
  3643                              <1> 
  3644 00003E8E EBBE                <1> 	jmp .print_quote_loop
  3645                              <1> 
  3646                              <1> 
  3647                              <1> .print_keyword:
  3648 00003E90 BE007B              <1> 	mov si, token
  3649 00003E93 BF[1D47]            <1> 	mov di, chr_keyword
  3650 00003E96 E80BEC              <1> 	call os_string_compare
  3651 00003E99 720E                <1> 	jc .is_chr
  3652                              <1> 
  3653 00003E9B BF[2147]            <1> 	mov di, hex_keyword
  3654 00003E9E E803EC              <1> 	call os_string_compare
  3655 00003EA1 7243                <1> 	jc .is_hex
  3656                              <1> 
  3657 00003EA3 BE1400              <1> 	mov si, err_syntax
  3658 00003EA6 E9D506              <1> 	jmp error
  3659                              <1> 
  3660                              <1> .is_chr:
  3661 00003EA9 E8B905              <1> 	call get_token
  3662                              <1> 
  3663 00003EAC 83F801              <1> 	cmp ax, VARIABLE
  3664 00003EAF 7405                <1> 	je .is_chr_variable
  3665                              <1> 	
  3666 00003EB1 83F803              <1> 	cmp ax, NUMBER
  3667 00003EB4 740A                <1> 	je .is_chr_number
  3668                              <1> 
  3669                              <1> .is_chr_variable:
  3670 00003EB6 0FB606007B          <1> 	movzx ax, byte [token]
  3671 00003EBB E88B05              <1> 	call get_var
  3672 00003EBE EB06                <1> 	jmp .print_chr
  3673                              <1> 	
  3674                              <1> .is_chr_number:
  3675 00003EC0 BE007B              <1> 	mov si, token
  3676 00003EC3 E832EC              <1> 	call os_string_to_int
  3677                              <1> 
  3678                              <1> .print_chr:
  3679 00003EC6 B409                <1> 	mov ah, 09h
  3680 00003EC8 8A1E[F245]          <1> 	mov byte bl, [ink_colour]
  3681 00003ECC 8A3E[F345]          <1> 	mov byte bh, [work_page]
  3682 00003ED0 B90100              <1> 	mov cx, 1
  3683 00003ED3 CD10                <1> 	int 10h
  3684                              <1> 
  3685 00003ED5 B403                <1> 	mov ah, 3		; Move the cursor forward
  3686 00003ED7 CD10                <1> 	int 10h
  3687 00003ED9 FEC2                <1> 	inc dl
  3688 00003EDB 80FA4F              <1> 	cmp dl, 79
  3689 00003EDE 7F1B                <1> 	jg .end_line		; If it's over the end of the line
  3690                              <1> .move_cur:
  3691 00003EE0 B402                <1> 	mov ah, 2
  3692 00003EE2 CD10                <1> 	int 10h
  3693                              <1> 
  3694 00003EE4 EB2A                <1> 	jmp .newline_or_not
  3695                              <1> 
  3696                              <1> 
  3697                              <1> .is_hex:
  3698 00003EE6 E87C05              <1> 	call get_token
  3699                              <1> 
  3700 00003EE9 83F801              <1> 	cmp ax, VARIABLE
  3701 00003EEC 751C                <1> 	jne .error
  3702                              <1> 
  3703 00003EEE 0FB606007B          <1> 	movzx ax, byte [token]
  3704 00003EF3 E85305              <1> 	call get_var
  3705                              <1> 
  3706 00003EF6 E898E2              <1> 	call os_print_2hex
  3707                              <1> 
  3708 00003EF9 EB15                <1> 	jmp .newline_or_not
  3709                              <1> 
  3710                              <1> .end_line:
  3711 00003EFB B200                <1> 	mov dl, 0
  3712 00003EFD FEC6                <1> 	inc dh
  3713 00003EFF 80FE19              <1> 	cmp dh, 25
  3714 00003F02 7CDC                <1> 	jl .move_cur
  3715 00003F04 B618                <1> 	mov dh, 24
  3716 00003F06 B24F                <1> 	mov dl, 79
  3717 00003F08 EBD6                <1> 	jmp .move_cur
  3718                              <1> 
  3719                              <1> .error:
  3720 00003F0A BE1400              <1> 	mov si, err_syntax
  3721 00003F0D E96E06              <1> 	jmp error
  3722                              <1> 	
  3723                              <1> 
  3724                              <1> 
  3725                              <1> .newline_or_not:
  3726                              <1> 	; We want to see if the command ends with ';' -- which means that
  3727                              <1> 	; we shouldn't print a newline after it finishes. So we store the
  3728                              <1> 	; current program location to pop ahead and see if there's the ';'
  3729                              <1> 	; character -- otherwise we put the program location back and resume
  3730                              <1> 	; the main loop
  3731                              <1> 
  3732 00003F10 A1[E945]            <1> 	mov word ax, [prog]
  3733 00003F13 A3[463F]            <1> 	mov word [.tmp_loc], ax
  3734                              <1> 
  3735 00003F16 E84C05              <1> 	call get_token
  3736 00003F19 83F807              <1> 	cmp ax, UNKNOWN
  3737 00003F1C 750C                <1> 	jne .ignore
  3738                              <1> 
  3739 00003F1E 0FB606007B          <1> 	movzx ax, byte [token]
  3740 00003F23 3C3B                <1> 	cmp al, ';'
  3741 00003F25 7503                <1> 	jne .ignore
  3742                              <1> 
  3743 00003F27 E9CBED              <1> 	jmp mainloop				; And go back to interpreting the code!
  3744                              <1> 
  3745                              <1> .ignore:
  3746 00003F2A B405                <1> 	mov ah, 5
  3747 00003F2C A0[F345]            <1> 	mov al, [work_page]
  3748 00003F2F CD10                <1> 	int 10h
  3749                              <1> 
  3750 00003F31 8A3E[F345]          <1> 	mov bh, [work_page]
  3751 00003F35 E805E0              <1> 	call os_print_newline
  3752                              <1> 
  3753 00003F38 B405                <1> 	mov ah, 5
  3754 00003F3A A0[F445]            <1> 	mov al, [disp_page]
  3755                              <1> 
  3756 00003F3D A1[463F]            <1> 	mov word ax, [.tmp_loc]
  3757 00003F40 A3[E945]            <1> 	mov word [prog], ax
  3758                              <1> 
  3759 00003F43 E9AFED              <1> 	jmp mainloop
  3760                              <1> 
  3761                              <1> 
  3762 00003F46 0000                <1> 	.tmp_loc	dw 0
  3763                              <1> 
  3764                              <1> 
  3765                              <1> ; ------------------------------------------------------------------
  3766                              <1> ; RAND
  3767                              <1> 
  3768                              <1> do_rand:
  3769 00003F48 E81A05              <1> 	call get_token
  3770 00003F4B 83F801              <1> 	cmp ax, VARIABLE
  3771 00003F4E 7544                <1> 	jne .error
  3772                              <1> 
  3773 00003F50 A0007B              <1> 	mov byte al, [token]
  3774 00003F53 A2[8F3F]            <1> 	mov byte [.tmp], al
  3775                              <1> 
  3776 00003F56 E80C05              <1> 	call get_token
  3777 00003F59 83F803              <1> 	cmp ax, NUMBER
  3778 00003F5C 7536                <1> 	jne .error
  3779                              <1> 
  3780 00003F5E BE007B              <1> 	mov si, token
  3781 00003F61 E894EB              <1> 	call os_string_to_int
  3782 00003F64 A3[903F]            <1> 	mov word [.num1], ax
  3783                              <1> 
  3784 00003F67 E8FB04              <1> 	call get_token
  3785 00003F6A 83F803              <1> 	cmp ax, NUMBER
  3786 00003F6D 7525                <1> 	jne .error
  3787                              <1> 
  3788 00003F6F BE007B              <1> 	mov si, token
  3789 00003F72 E883EB              <1> 	call os_string_to_int
  3790 00003F75 A3[923F]            <1> 	mov word [.num2], ax
  3791                              <1> 
  3792 00003F78 A1[903F]            <1> 	mov word ax, [.num1]
  3793 00003F7B 8B1E[923F]          <1> 	mov word bx, [.num2]
  3794 00003F7F E85BD4              <1> 	call os_get_random
  3795                              <1> 
  3796 00003F82 89CB                <1> 	mov bx, cx
  3797 00003F84 0FB606[8F3F]        <1> 	movzx ax, byte [.tmp]
  3798 00003F89 E8CA04              <1> 	call set_var
  3799                              <1> 
  3800 00003F8C E966ED              <1> 	jmp mainloop
  3801                              <1> 
  3802                              <1> 
  3803 00003F8F 00                  <1> 	.tmp	db 0
  3804 00003F90 0000                <1> 	.num1	dw 0
  3805 00003F92 0000                <1> 	.num2	dw 0
  3806                              <1> 
  3807                              <1> 
  3808                              <1> .error:
  3809 00003F94 BE1400              <1> 	mov si, err_syntax
  3810 00003F97 E9E405              <1> 	jmp error
  3811                              <1> 
  3812                              <1> 
  3813                              <1> ; ------------------------------------------------------------------
  3814                              <1> ; READ
  3815                              <1> 
  3816                              <1> do_read:
  3817 00003F9A E8C804              <1> 	call get_token				; Get the next token
  3818                              <1> 
  3819 00003F9D 83F804              <1> 	cmp ax, STRING				; Check for a label
  3820 00003FA0 7406                <1> 	je .is_ok
  3821                              <1> 
  3822 00003FA2 BE0500              <1> 	mov si, err_goto_notlabel
  3823 00003FA5 E9D605              <1> 	jmp error
  3824                              <1> 
  3825                              <1> .is_ok:
  3826 00003FA8 BE007B              <1> 	mov si, token				; Back up this label
  3827 00003FAB BFE27A              <1> 	mov di, .tmp_token
  3828 00003FAE E894EA              <1> 	call os_string_copy
  3829                              <1> 
  3830 00003FB1 B8E27A              <1> 	mov ax, .tmp_token
  3831 00003FB4 E8FBE9              <1> 	call os_string_length
  3832                              <1> 
  3833 00003FB7 BFE27A              <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  3834 00003FBA 01C7                <1> 	add di, ax
  3835 00003FBC B03A                <1> 	mov al, ':'
  3836 00003FBE AA                  <1> 	stosb
  3837 00003FBF B000                <1> 	mov al, 0
  3838 00003FC1 AA                  <1> 	stosb
  3839                              <1> 
  3840 00003FC2 E8A004              <1> 	call get_token				; Now get the offset variable
  3841 00003FC5 83F801              <1> 	cmp ax, VARIABLE
  3842 00003FC8 7406                <1> 	je .second_part_is_var
  3843                              <1> 
  3844 00003FCA BE1400              <1> 	mov si, err_syntax
  3845 00003FCD E9AE05              <1> 	jmp error
  3846                              <1> 
  3847                              <1> 
  3848                              <1> .second_part_is_var:
  3849 00003FD0 0FB606007B          <1> 	movzx ax, byte [token]
  3850 00003FD5 E87104              <1> 	call get_var
  3851                              <1> 
  3852 00003FD8 83F800              <1> 	cmp ax, 0				; Want to be searching for at least the first byte!
  3853 00003FDB 7F06                <1> 	jg .var_bigger_than_zero
  3854                              <1> 
  3855 00003FDD BE1400              <1> 	mov si, err_syntax
  3856 00003FE0 E99B05              <1> 	jmp error
  3857                              <1> 
  3858                              <1> 
  3859                              <1> .var_bigger_than_zero:
  3860 00003FE3 A3[6D40]            <1> 	mov word [.to_skip], ax
  3861                              <1> 
  3862                              <1> 
  3863 00003FE6 E87C04              <1> 	call get_token				; And now the var to store result into
  3864 00003FE9 83F801              <1> 	cmp ax, VARIABLE
  3865 00003FEC 7406                <1> 	je .third_part_is_var
  3866                              <1> 
  3867 00003FEE BE1400              <1> 	mov si, err_syntax
  3868 00003FF1 E98A05              <1> 	jmp error
  3869                              <1> 
  3870                              <1> 
  3871                              <1> .third_part_is_var:				; Keep it for later
  3872 00003FF4 0FB606007B          <1> 	movzx ax, byte [token]
  3873 00003FF9 A2[6F40]            <1> 	mov byte [.var_to_use], al
  3874                              <1> 
  3875                              <1> 
  3876                              <1> 
  3877                              <1> 	; OK, so now we have all the stuff we need. Let's search for the label
  3878                              <1> 
  3879 00003FFC A1[E945]            <1> 	mov word ax, [prog]			; Store current location
  3880 00003FFF A3[6B40]            <1> 	mov word [.curr_location], ax
  3881                              <1> 
  3882 00004002 A1[ED45]            <1> 	mov word ax, [load_point]
  3883 00004005 A3[E945]            <1> 	mov word [prog], ax			; Return to start of program to find label
  3884                              <1> 
  3885                              <1> .loop:
  3886 00004008 E85A04              <1> 	call get_token
  3887                              <1> 
  3888 0000400B 83F808              <1> 	cmp ax, LABEL
  3889 0000400E 750B                <1> 	jne .line_loop
  3890                              <1> 
  3891 00004010 BE007B              <1> 	mov si, token
  3892 00004013 BFE27A              <1> 	mov di, .tmp_token
  3893 00004016 E88BEA              <1> 	call os_string_compare
  3894 00004019 7221                <1> 	jc .found_label
  3895                              <1> 
  3896                              <1> .line_loop:					; Go to end of line
  3897 0000401B 8B36[E945]          <1> 	mov word si, [prog]
  3898 0000401F 8A04                <1> 	mov byte al, [si]
  3899 00004021 FF06[E945]          <1> 	inc word [prog]
  3900                              <1> 
  3901 00004025 3C0A                <1> 	cmp al, 10
  3902 00004027 75F2                <1> 	jne .line_loop
  3903                              <1> 
  3904 00004029 A1[E945]            <1> 	mov word ax, [prog]
  3905 0000402C 8B1E[EB45]          <1> 	mov word bx, [prog_end]
  3906 00004030 39D8                <1> 	cmp ax, bx
  3907 00004032 7F02                <1> 	jg .past_end
  3908                              <1> 
  3909 00004034 EBD2                <1> 	jmp .loop
  3910                              <1> 
  3911                              <1> .past_end:
  3912 00004036 BE0600              <1> 	mov si, err_label_notfound
  3913 00004039 E94205              <1> 	jmp error
  3914                              <1> 
  3915                              <1> 
  3916                              <1> .found_label:
  3917 0000403C 8B0E[6D40]          <1> 	mov word cx, [.to_skip]			; Skip requested number of data entries
  3918                              <1> 
  3919                              <1> .data_skip_loop:
  3920 00004040 51                  <1> 	push cx
  3921 00004041 E82104              <1> 	call get_token
  3922 00004044 59                  <1> 	pop cx
  3923 00004045 E2F9                <1> 	loop .data_skip_loop
  3924                              <1> 
  3925 00004047 83F803              <1> 	cmp ax, NUMBER
  3926 0000404A 7406                <1> 	je .data_is_num
  3927                              <1> 
  3928 0000404C BE1400              <1> 	mov si, err_syntax
  3929 0000404F E92C05              <1> 	jmp error
  3930                              <1> 
  3931                              <1> .data_is_num:
  3932 00004052 BE007B              <1> 	mov si, token
  3933 00004055 E8A0EA              <1> 	call os_string_to_int
  3934                              <1> 
  3935 00004058 89C3                <1> 	mov bx, ax
  3936 0000405A 0FB606[6F40]        <1> 	movzx ax, byte [.var_to_use]
  3937 0000405F E8F403              <1> 	call set_var
  3938                              <1> 
  3939 00004062 A1[6B40]            <1> 	mov word ax, [.curr_location]
  3940 00004065 A3[E945]            <1> 	mov word [prog], ax
  3941                              <1> 
  3942 00004068 E98AEC              <1> 	jmp mainloop
  3943                              <1> 
  3944                              <1> 
  3945 0000406B 0000                <1> 	.curr_location	dw 0
  3946                              <1> 
  3947 0000406D 0000                <1> 	.to_skip	dw 0
  3948 0000406F 00                  <1> 	.var_to_use	db 0
  3949                              <1> ;	.tmp_token 	times 30 db 0
  3950                              <1> 	.tmp_token 	equ 32768-1024-256-30
  3951                              <1> 
  3952                              <1> 
  3953                              <1> ; ------------------------------------------------------------------
  3954                              <1> ; REM
  3955                              <1> 
  3956                              <1> do_rem:
  3957 00004070 8B36[E945]          <1> 	mov word si, [prog]
  3958 00004074 8A04                <1> 	mov byte al, [si]
  3959 00004076 FF06[E945]          <1> 	inc word [prog]
  3960 0000407A 3C0A                <1> 	cmp al, 10			; Find end of line after REM
  3961 0000407C 75F2                <1> 	jne do_rem
  3962                              <1> 
  3963 0000407E E974EC              <1> 	jmp mainloop
  3964                              <1> 
  3965                              <1> 
  3966                              <1> ; ------------------------------------------------------------------
  3967                              <1> ; RENAME
  3968                              <1> 
  3969                              <1> do_rename:
  3970 00004081 E8E103              <1> 	call get_token
  3971                              <1> 
  3972 00004084 83F802              <1> 	cmp ax, STRING_VAR		; Is it a string or a quote?
  3973 00004087 7407                <1> 	je .first_is_string
  3974                              <1> 
  3975 00004089 83F805              <1> 	cmp ax, QUOTE
  3976 0000408C 740E                <1> 	je .first_is_quote
  3977                              <1> 
  3978 0000408E EB61                <1> 	jmp .error
  3979                              <1> 
  3980                              <1> .first_is_string:
  3981 00004090 BE007C              <1> 	mov si, string_vars		; Locate string
  3982 00004093 B88000              <1> 	mov ax, 128
  3983 00004096 F7E3                <1> 	mul bx
  3984 00004098 01C6                <1> 	add si, ax
  3985                              <1> 
  3986 0000409A EB03                <1> 	jmp .save_file1
  3987                              <1> 
  3988                              <1> .first_is_quote:
  3989 0000409C BE007B              <1> 	mov si, token			; The location of quotes is provided
  3990                              <1> 
  3991                              <1> .save_file1:
  3992 0000409F BF[1E41]            <1> 	mov word di, .file1		; The filename is saved to temporary strings because
  3993 000040A2 E8A0E9              <1> 	call os_string_copy		; getting a second quote will overwrite the previous
  3994                              <1> 	
  3995                              <1> .get_second:
  3996 000040A5 E8BD03              <1> 	call get_token
  3997                              <1> 
  3998 000040A8 83F802              <1> 	cmp ax, STRING_VAR
  3999 000040AB 7407                <1> 	je .second_is_string
  4000                              <1> 
  4001 000040AD 83F805              <1> 	cmp ax, QUOTE
  4002 000040B0 740E                <1> 	je .second_is_quote
  4003                              <1> 
  4004 000040B2 EB3D                <1> 	jmp .error
  4005                              <1> 
  4006                              <1> .second_is_string:
  4007 000040B4 BE007C              <1> 	mov si, string_vars		; Locate second string
  4008 000040B7 B88000              <1> 	mov ax, 128
  4009 000040BA F7E3                <1> 	mul bx
  4010 000040BC 01C6                <1> 	add si, ax
  4011                              <1> 
  4012 000040BE EB03                <1> 	jmp .save_file2
  4013                              <1> 
  4014                              <1> .second_is_quote:
  4015 000040C0 BE007B              <1> 	mov si, token
  4016                              <1> 
  4017                              <1> .save_file2:
  4018 000040C3 BF[2A41]            <1> 	mov word di, .file2
  4019 000040C6 E87CE9              <1> 	call os_string_copy
  4020                              <1> 	
  4021                              <1> .check_exists:
  4022 000040C9 B8[1E41]            <1> 	mov word ax, .file1		; Check if the source file exists
  4023 000040CC E801CE              <1> 	call os_file_exists
  4024 000040CF 7226                <1> 	jc .file_not_found		; If it doesn't exists set "R = 1"
  4025                              <1> 
  4026 000040D1 F8                  <1> 	clc
  4027 000040D2 B8[2A41]            <1> 	mov ax, .file2			; The second file is the destination and should not exist
  4028 000040D5 E8F8CD              <1> 	call os_file_exists
  4029 000040D8 7337                <1> 	jnc .file_exists		; If it exists set "R = 3"
  4030                              <1> 	
  4031                              <1> .rename:
  4032 000040DA B8[1E41]            <1> 	mov word ax, .file1		; Seem to be okay, lets rename
  4033 000040DD BB[2A41]            <1> 	mov word bx, .file2
  4034 000040E0 E86ECF              <1> 	call os_rename_file
  4035                              <1> 
  4036 000040E3 721F                <1> 	jc .rename_failed		; If it failed set "R = 2", usually caused by a read-only disk
  4037                              <1> 
  4038 000040E5 31C0                <1> 	xor ax, ax			; It worked sucessfully, so set "R = 0" to indicate no error
  4039 000040E7 B052                <1> 	mov byte al, 'R'
  4040 000040E9 31DB                <1> 	xor bx, bx
  4041 000040EB E86803              <1> 	call set_var
  4042                              <1> 
  4043 000040EE E904EC              <1> 	jmp mainloop
  4044                              <1> 
  4045                              <1> .error:
  4046 000040F1 BE1400              <1> 	mov si, err_syntax
  4047 000040F4 E98704              <1> 	jmp error
  4048                              <1> 
  4049                              <1> .file_not_found:
  4050 000040F7 31C0                <1> 	xor ax, ax			; Set R variable to 1
  4051 000040F9 B052                <1> 	mov byte al, 'R'
  4052 000040FB BB0100              <1> 	mov bx, 1
  4053 000040FE E85503              <1> 	call set_var
  4054                              <1> 
  4055 00004101 E9F1EB              <1> 	jmp mainloop
  4056                              <1> 
  4057                              <1> .rename_failed:
  4058 00004104 31C0                <1> 	xor ax, ax			; Set R variable to 2
  4059 00004106 B052                <1> 	mov byte al, 'R'
  4060 00004108 BB0200              <1> 	mov bx, 2
  4061 0000410B E84803              <1> 	call set_var
  4062                              <1> 
  4063 0000410E E9E4EB              <1> 	jmp mainloop
  4064                              <1> 
  4065                              <1> .file_exists:
  4066 00004111 31C0                <1> 	xor ax, ax
  4067 00004113 B052                <1> 	mov byte al, 'R'		; Set R variable to 3
  4068 00004115 BB0300              <1> 	mov bx, 3
  4069 00004118 E83B03              <1> 	call set_var
  4070                              <1> 
  4071 0000411B E9D7EB              <1> 	jmp mainloop
  4072                              <1> 
  4073                              <1> .data:
  4074 0000411E 00<rep Ch>          <1> 	.file1				times 12 db 0
  4075 0000412A 00<rep Ch>          <1> 	.file2				times 12 db 0
  4076                              <1> 
  4077                              <1> 
  4078                              <1> ; ------------------------------------------------------------------
  4079                              <1> ; RETURN
  4080                              <1> 
  4081                              <1> do_return:
  4082 00004136 0FB606[6047]        <1> 	movzx ax, byte [gosub_depth]
  4083 0000413B 3C00                <1> 	cmp al, 0
  4084 0000413D 7506                <1> 	jne .is_ok
  4085                              <1> 
  4086 0000413F BE1200              <1> 	mov si, err_return
  4087 00004142 E93904              <1> 	jmp error
  4088                              <1> 
  4089                              <1> .is_ok:
  4090 00004145 BEBC79              <1> 	mov si, gosub_points
  4091 00004148 01C6                <1> 	add si, ax				; Table is words (not bytes)
  4092 0000414A 01C6                <1> 	add si, ax
  4093 0000414C AD                  <1> 	lodsw
  4094 0000414D A3[E945]            <1> 	mov word [prog], ax
  4095 00004150 FE0E[6047]          <1> 	dec byte [gosub_depth]
  4096                              <1> 
  4097 00004154 E99EEB              <1> 	jmp mainloop	
  4098                              <1> 
  4099                              <1> 
  4100                              <1> ; ------------------------------------------------------------------
  4101                              <1> ; SAVE
  4102                              <1> 
  4103                              <1> do_save:
  4104 00004157 E80B03              <1> 	call get_token
  4105 0000415A 83F805              <1> 	cmp ax, QUOTE
  4106 0000415D 7413                <1> 	je .is_quote
  4107                              <1> 
  4108 0000415F 83F802              <1> 	cmp ax, STRING_VAR
  4109 00004162 0F859500            <1> 	jne near .error
  4110                              <1> 
  4111 00004166 BE007C              <1> 	mov si, string_vars
  4112 00004169 B88000              <1> 	mov ax, 128
  4113 0000416C F7E3                <1> 	mul bx
  4114 0000416E 01C6                <1> 	add si, ax
  4115 00004170 EB03                <1> 	jmp .get_position
  4116                              <1> 
  4117                              <1> .is_quote:
  4118 00004172 BE007B              <1> 	mov si, token
  4119                              <1> 
  4120                              <1> .get_position:
  4121 00004175 BF[0742]            <1> 	mov di, .tmp_filename
  4122 00004178 E8CAE8              <1> 	call os_string_copy
  4123                              <1> 
  4124 0000417B E8E702              <1> 	call get_token
  4125                              <1> 
  4126 0000417E 83F801              <1> 	cmp ax, VARIABLE
  4127 00004181 744A                <1> 	je .second_is_var
  4128                              <1> 
  4129 00004183 83F803              <1> 	cmp ax, NUMBER
  4130 00004186 7573                <1> 	jne .error
  4131                              <1> 
  4132 00004188 BE007B              <1> 	mov si, token
  4133 0000418B E86AE9              <1> 	call os_string_to_int
  4134                              <1> 
  4135                              <1> .set_data_loc:
  4136 0000418E A3[0342]            <1> 	mov word [.data_loc], ax
  4137                              <1> 
  4138 00004191 E8D102              <1> 	call get_token
  4139                              <1> 
  4140 00004194 83F801              <1> 	cmp ax, VARIABLE
  4141 00004197 743E                <1> 	je .third_is_var
  4142                              <1> 
  4143 00004199 83F803              <1> 	cmp ax, NUMBER
  4144 0000419C 755D                <1> 	jne .error
  4145                              <1> 
  4146 0000419E BE007B              <1> 	mov si, token
  4147 000041A1 E854E9              <1> 	call os_string_to_int
  4148                              <1> 
  4149                              <1> .check_exists:
  4150 000041A4 A3[0542]            <1> 	mov word [.data_size], ax
  4151 000041A7 B8[0742]            <1> 	mov word ax, .tmp_filename
  4152 000041AA E823CD              <1> 	call os_file_exists
  4153 000041AD 7202                <1> 	jc .write_file
  4154 000041AF EB30                <1> 	jmp .file_exists_fail
  4155                              <1> 	
  4156                              <1> .write_file:
  4157                              <1> 
  4158 000041B1 B8[0742]            <1> 	mov word ax, .tmp_filename
  4159 000041B4 8B1E[0342]          <1> 	mov word bx, [.data_loc]
  4160 000041B8 8B0E[0542]          <1> 	mov word cx, [.data_size]
  4161                              <1> 	
  4162 000041BC E82FCB              <1> 	call os_write_file
  4163 000041BF 722D                <1> 	jc .save_failure
  4164                              <1> 
  4165 000041C1 31C0                <1> 	xor ax, ax
  4166 000041C3 B052                <1> 	mov byte al, 'R'
  4167 000041C5 31DB                <1> 	xor bx, bx
  4168 000041C7 E88C02              <1> 	call set_var
  4169                              <1> 
  4170 000041CA E928EB              <1> 	jmp mainloop
  4171                              <1> 
  4172                              <1> 
  4173                              <1> .second_is_var:
  4174 000041CD 0FB606007B          <1> 	movzx ax, byte [token]
  4175 000041D2 E87402              <1> 	call get_var
  4176 000041D5 EBB7                <1> 	jmp .set_data_loc
  4177                              <1> 
  4178                              <1> 
  4179                              <1> .third_is_var:
  4180 000041D7 0FB606007B          <1> 	movzx ax, byte [token]
  4181 000041DC E86A02              <1> 	call get_var
  4182 000041DF EBC3                <1> 	jmp .check_exists
  4183                              <1> 
  4184                              <1> .file_exists_fail:
  4185 000041E1 31C0                <1> 	xor ax, ax
  4186 000041E3 B052                <1> 	mov byte al, 'R'
  4187 000041E5 BB0200              <1> 	mov bx, 2
  4188 000041E8 E86B02              <1> 	call set_var
  4189 000041EB E907EB              <1> 	jmp mainloop
  4190                              <1> 	
  4191                              <1> .save_failure:
  4192 000041EE 31C0                <1> 	xor ax, ax
  4193 000041F0 B052                <1> 	mov byte al, 'R'
  4194 000041F2 BB0100              <1> 	mov bx, 1
  4195 000041F5 E85E02              <1> 	call set_var
  4196                              <1> 
  4197 000041F8 E9FAEA              <1> 	jmp mainloop
  4198                              <1> 
  4199                              <1> .error:
  4200 000041FB BE1400              <1> 	mov si, err_syntax
  4201 000041FE E97D03              <1> 	jmp error
  4202                              <1> 
  4203                              <1> 
  4204 00004201 0000                <1> 	.filename_loc	dw 0
  4205 00004203 0000                <1> 	.data_loc	dw 0
  4206 00004205 0000                <1> 	.data_size	dw 0
  4207                              <1> 
  4208 00004207 00<rep Fh>          <1> 	.tmp_filename	times 15 db 0
  4209                              <1> 
  4210                              <1> 
  4211                              <1> ; ------------------------------------------------------------------
  4212                              <1> ; SERIAL
  4213                              <1> 
  4214                              <1> do_serial:
  4215 00004216 E84C02              <1> 	call get_token
  4216 00004219 BE007B              <1> 	mov si, token
  4217                              <1> 
  4218 0000421C BF[AE42]            <1> 	mov di, .on_cmd
  4219 0000421F E882E8              <1> 	call os_string_compare
  4220 00004222 7212                <1> 	jc .do_on_cmd
  4221                              <1> 
  4222 00004224 BF[B142]            <1> 	mov di, .send_cmd
  4223 00004227 E87AE8              <1> 	call os_string_compare
  4224 0000422A 7237                <1> 	jc .do_send_cmd
  4225                              <1> 
  4226 0000422C BF[B642]            <1> 	mov di, .rec_cmd
  4227 0000422F E872E8              <1> 	call os_string_compare
  4228 00004232 7258                <1> 	jc .do_rec_cmd
  4229                              <1> 
  4230 00004234 EB72                <1> 	jmp .error
  4231                              <1> 
  4232                              <1> .do_on_cmd:
  4233 00004236 E82C02              <1> 	call get_token
  4234 00004239 83F803              <1> 	cmp ax, NUMBER
  4235 0000423C 7402                <1> 	je .do_on_cmd_ok
  4236 0000423E EB68                <1> 	jmp .error
  4237                              <1> 
  4238                              <1> .do_on_cmd_ok:
  4239 00004240 BE007B              <1> 	mov si, token
  4240 00004243 E8B2E8              <1> 	call os_string_to_int
  4241 00004246 3DB004              <1> 	cmp ax, 1200
  4242 00004249 740F                <1> 	je .on_cmd_slow_mode
  4243 0000424B 3D8025              <1> 	cmp ax, 9600
  4244 0000424E 7402                <1> 	je .on_cmd_fast_mode
  4245                              <1> 
  4246 00004250 EB56                <1> 	jmp .error
  4247                              <1> 
  4248                              <1> .on_cmd_fast_mode:
  4249 00004252 31C0                <1> 	xor ax, ax
  4250 00004254 E852D5              <1> 	call os_serial_port_enable
  4251 00004257 E99BEA              <1> 	jmp mainloop
  4252                              <1> 
  4253                              <1> .on_cmd_slow_mode:
  4254 0000425A B80100              <1> 	mov ax, 1
  4255 0000425D E849D5              <1> 	call os_serial_port_enable
  4256 00004260 E992EA              <1> 	jmp mainloop
  4257                              <1> 
  4258                              <1> 
  4259                              <1> .do_send_cmd:
  4260 00004263 E8FF01              <1> 	call get_token
  4261 00004266 83F803              <1> 	cmp ax, NUMBER
  4262 00004269 7407                <1> 	je .send_number
  4263                              <1> 
  4264 0000426B 83F801              <1> 	cmp ax, VARIABLE
  4265 0000426E 740E                <1> 	je .send_variable
  4266                              <1> 
  4267 00004270 EB36                <1> 	jmp .error
  4268                              <1> 
  4269                              <1> .send_number:
  4270 00004272 BE007B              <1> 	mov si, token
  4271 00004275 E880E8              <1> 	call os_string_to_int
  4272 00004278 E842D5              <1> 	call os_send_via_serial
  4273 0000427B E977EA              <1> 	jmp mainloop
  4274                              <1> 
  4275                              <1> .send_variable:
  4276 0000427E 0FB606007B          <1> 	movzx ax, byte [token]
  4277 00004283 E8C301              <1> 	call get_var
  4278 00004286 E834D5              <1> 	call os_send_via_serial
  4279 00004289 E969EA              <1> 	jmp mainloop
  4280                              <1> 
  4281                              <1> 
  4282                              <1> .do_rec_cmd:
  4283 0000428C E8D601              <1> 	call get_token
  4284 0000428F 83F801              <1> 	cmp ax, VARIABLE
  4285 00004292 7514                <1> 	jne .error
  4286                              <1> 
  4287 00004294 A0007B              <1> 	mov byte al, [token]
  4288                              <1> 
  4289 00004297 0FB6C8              <1> 	movzx cx, al
  4290 0000429A E832D5              <1> 	call os_get_via_serial
  4291                              <1> 
  4292 0000429D 0FB6D8              <1> 	movzx bx, al
  4293 000042A0 88C8                <1> 	mov al, cl
  4294 000042A2 E8B101              <1> 	call set_var
  4295                              <1> 
  4296 000042A5 E94DEA              <1> 	jmp mainloop
  4297                              <1> 
  4298                              <1> 
  4299                              <1> .error:
  4300 000042A8 BE1400              <1> 	mov si, err_syntax
  4301 000042AB E9D002              <1> 	jmp error
  4302                              <1> 
  4303                              <1> 
  4304 000042AE 4F4E00              <1> 	.on_cmd		db "ON", 0
  4305 000042B1 53454E4400          <1> 	.send_cmd	db "SEND", 0
  4306 000042B6 52454300            <1> 	.rec_cmd	db "REC", 0
  4307                              <1> 
  4308                              <1> 
  4309                              <1> ; ------------------------------------------------------------------
  4310                              <1> ; SIZE
  4311                              <1> 
  4312                              <1> do_size:
  4313 000042BA E8A801              <1> 	call get_token
  4314                              <1> 
  4315 000042BD 83F802              <1> 	cmp ax, STRING_VAR
  4316 000042C0 7407                <1> 	je .is_string
  4317                              <1> 
  4318 000042C2 83F805              <1> 	cmp ax, QUOTE
  4319 000042C5 7410                <1> 	je .is_quote
  4320                              <1> 
  4321 000042C7 EB29                <1> 	jmp .error
  4322                              <1> 
  4323                              <1> .is_string:
  4324 000042C9 BE007C              <1> 	mov si, string_vars
  4325 000042CC B88000              <1> 	mov ax, 128
  4326 000042CF F7E3                <1> 	mul bx
  4327 000042D1 01C6                <1> 	add si, ax
  4328                              <1> 
  4329 000042D3 89F0                <1> 	mov ax, si
  4330 000042D5 EB03                <1> 	jmp .get_size
  4331                              <1> 
  4332                              <1> .is_quote:
  4333 000042D7 B8007B              <1> 	mov ax, token
  4334                              <1> 
  4335                              <1> .get_size:
  4336 000042DA E8A9CD              <1> 	call os_get_file_size
  4337 000042DD 7219                <1> 	jc .file_not_found
  4338                              <1> 
  4339 000042DF 31C0                <1> 	xor ax, ax
  4340 000042E1 B053                <1> 	mov al, 'S'
  4341 000042E3 E87001              <1> 	call set_var
  4342                              <1> 
  4343 000042E6 31C0                <1> 	xor ax, ax
  4344 000042E8 B052                <1> 	mov al, 'R'
  4345 000042EA 31DB                <1> 	xor bx, bx
  4346 000042EC E86701              <1> 	call set_var
  4347                              <1> 
  4348 000042EF E903EA              <1> 	jmp mainloop
  4349                              <1> 
  4350                              <1> .error:
  4351 000042F2 BE1400              <1> 	mov si, err_syntax
  4352 000042F5 E98602              <1> 	jmp error
  4353                              <1> 
  4354                              <1> .file_not_found:
  4355 000042F8 0FB606007B          <1> 	movzx ax, byte [token]
  4356 000042FD 89DB                <1> 	mov bx, bx
  4357 000042FF E85401              <1> 	call set_var
  4358                              <1> 
  4359 00004302 31C0                <1> 	xor ax, ax
  4360 00004304 B052                <1> 	mov al, 'R'
  4361 00004306 BB0100              <1> 	mov bx, 1
  4362 00004309 E84A01              <1>  	call set_var
  4363                              <1>  	
  4364 0000430C E9E6E9              <1> 	jmp mainloop
  4365                              <1> 
  4366                              <1> 
  4367                              <1> 
  4368                              <1> ; ------------------------------------------------------------------
  4369                              <1> ; SOUND
  4370                              <1> 
  4371                              <1> do_sound:
  4372 0000430F E85301              <1> 	call get_token
  4373                              <1> 
  4374 00004312 83F801              <1> 	cmp ax, VARIABLE
  4375 00004315 7408                <1> 	je .first_is_var
  4376                              <1> 
  4377 00004317 BE007B              <1> 	mov si, token
  4378 0000431A E8DBE7              <1> 	call os_string_to_int
  4379 0000431D EB08                <1> 	jmp .done_first
  4380                              <1> 
  4381                              <1> .first_is_var:
  4382 0000431F 0FB606007B          <1> 	movzx ax, byte [token]
  4383 00004324 E82201              <1> 	call get_var
  4384                              <1> 
  4385                              <1> .done_first:
  4386 00004327 E8FFE2              <1> 	call os_speaker_tone
  4387                              <1> 
  4388 0000432A E83801              <1> 	call get_token
  4389                              <1> 
  4390 0000432D 83F801              <1> 	cmp ax, VARIABLE
  4391 00004330 7408                <1> 	je .second_is_var
  4392                              <1> 
  4393 00004332 BE007B              <1> 	mov si, token
  4394 00004335 E8C0E7              <1> 	call os_string_to_int
  4395 00004338 EB08                <1> 	jmp .finish
  4396                              <1> 
  4397                              <1> .second_is_var:
  4398 0000433A 0FB606007B          <1> 	movzx ax, byte [token]
  4399 0000433F E80701              <1> 	call get_var
  4400                              <1> 
  4401                              <1> .finish:
  4402 00004342 E886D1              <1> 	call os_pause
  4403 00004345 E821E3              <1> 	call os_speaker_off
  4404                              <1> 
  4405 00004348 E9AAE9              <1> 	jmp mainloop
  4406                              <1> 
  4407                              <1> 
  4408                              <1> ;-------------------------------------------------------------------
  4409                              <1> ; STRING
  4410                              <1> do_string:
  4411 0000434B E81701              <1> 	call get_token			; The first parameter is the word 'GET' or 'SET'
  4412 0000434E BE007B              <1> 	mov si, token
  4413                              <1> 	
  4414 00004351 BF[F543]            <1> 	mov di, .get_cmd
  4415 00004354 E84DE7              <1> 	call os_string_compare
  4416 00004357 720B                <1> 	jc .set_str
  4417                              <1> 		
  4418 00004359 BF[F943]            <1> 	mov di, .set_cmd
  4419 0000435C E845E7              <1> 	call os_string_compare
  4420 0000435F 7208                <1> 	jc .get_str
  4421                              <1> 	
  4422 00004361 E98500              <1> 	jmp .error
  4423                              <1> 	
  4424                              <1> 	.set_str:
  4425 00004364 B90100              <1> 	mov cx, 1
  4426 00004367 EB03                <1> 	jmp .check_second
  4427                              <1> 	.get_str:
  4428 00004369 B90200              <1> 	mov cx, 2
  4429                              <1> 
  4430                              <1> .check_second:
  4431 0000436C E8F600              <1> 	call get_token			; The next should be a string variable, locate it
  4432                              <1> 	
  4433 0000436F 83F802              <1> 	cmp ax, STRING_VAR
  4434 00004372 7575                <1> 	jne .error
  4435                              <1> 	
  4436 00004374 BE007C              <1> 	mov si, string_vars
  4437 00004377 B88000              <1> 	mov ax, 128
  4438 0000437A F7E3                <1> 	mul bx
  4439 0000437C 01C6                <1> 	add si, ax
  4440 0000437E 8936[FD43]          <1> 	mov word [.string_loc], si
  4441                              <1> 	
  4442                              <1> .check_third:
  4443 00004382 E8E000              <1> 	call get_token			; Now there should be a number
  4444                              <1> 	
  4445 00004385 83F803              <1> 	cmp ax, NUMBER
  4446 00004388 7407                <1> 	je .third_is_number
  4447                              <1> 	
  4448 0000438A 83F801              <1> 	cmp ax, VARIABLE
  4449 0000438D 740A                <1> 	je .third_is_variable
  4450                              <1> 	
  4451 0000438F EB58                <1> 	jmp .error
  4452                              <1> 	
  4453                              <1> .third_is_number:	
  4454 00004391 BE007B              <1> 	mov si, token
  4455 00004394 E861E7              <1> 	call os_string_to_int
  4456 00004397 EB0A                <1> 	jmp .got_number	
  4457                              <1> 
  4458                              <1> .third_is_variable:
  4459 00004399 B400                <1> 	mov ah, 0
  4460 0000439B A0007B              <1> 	mov al, [token]
  4461 0000439E E8A800              <1> 	call get_var
  4462 000043A1 EB00                <1> 	jmp .got_number
  4463                              <1> 
  4464                              <1> .got_number:
  4465 000043A3 3D8000              <1> 	cmp ax, 128
  4466 000043A6 7F47                <1> 	jg .outrange
  4467 000043A8 83F800              <1> 	cmp ax, 0
  4468 000043AB 7442                <1> 	je .outrange
  4469 000043AD 83E801              <1> 	sub ax, 1
  4470 000043B0 89C2                <1> 	mov dx, ax
  4471                              <1> 	
  4472                              <1> .check_forth:
  4473 000043B2 E8B000              <1> 	call get_token			; Next a numerical variable
  4474                              <1> 	
  4475 000043B5 83F801              <1> 	cmp ax, VARIABLE
  4476 000043B8 752F                <1> 	jne .error
  4477                              <1> 	
  4478 000043BA A0007B              <1> 	mov byte al, [token]
  4479 000043BD A2[FF43]            <1> 	mov byte [.tmp], al
  4480                              <1> 	
  4481 000043C0 83F902              <1> 	cmp cx, 2
  4482 000043C3 7414                <1> 	je .set_var
  4483                              <1> 	
  4484                              <1> .get_var:
  4485 000043C5 8B36[FD43]          <1> 	mov word si, [.string_loc]	; Move to string location
  4486 000043C9 01D6                <1> 	add si, dx			; Add offset
  4487 000043CB AC                  <1> 	lodsb				; Load data
  4488 000043CC B400                <1> 	mov ah, 0
  4489 000043CE 89C3                <1> 	mov bx, ax			; Set data in numerical variable
  4490 000043D0 A0[FF43]            <1> 	mov byte al, [.tmp]
  4491 000043D3 E88000              <1> 	call set_var
  4492 000043D6 E91CE9              <1> 	jmp mainloop
  4493                              <1> 	
  4494                              <1> .set_var:
  4495 000043D9 A0[FF43]            <1> 	mov byte al, [.tmp]		; Retrieve the variable
  4496 000043DC E86A00              <1> 	call get_var			; Get it's value
  4497 000043DF 8B3E[FD43]          <1> 	mov di, [.string_loc]		; Locate the string
  4498 000043E3 01D7                <1> 	add di, dx			; Add the offset
  4499 000043E5 AA                  <1> 	stosb				; Store data
  4500 000043E6 E90CE9              <1> 	jmp mainloop
  4501                              <1> 	
  4502                              <1> .error:
  4503 000043E9 BE1400              <1> 	mov si, err_syntax
  4504 000043EC E98F01              <1> 	jmp error
  4505                              <1> 	
  4506                              <1> .outrange:
  4507 000043EF BE1300              <1> 	mov si, err_string_range
  4508 000043F2 E98901              <1> 	jmp error
  4509                              <1> 
  4510                              <1> .data:
  4511 000043F5 47455400            <1> 	.get_cmd		db "GET", 0
  4512 000043F9 53455400            <1> 	.set_cmd		db "SET", 0
  4513 000043FD 0000                <1> 	.string_loc		dw 0
  4514 000043FF 00                  <1> 	.tmp			db 0
  4515                              <1> 
  4516                              <1> 
  4517                              <1> 
  4518                              <1> ; ------------------------------------------------------------------
  4519                              <1> ; WAITKEY
  4520                              <1> 
  4521                              <1> do_waitkey:
  4522 00004400 E86200              <1> 	call get_token
  4523 00004403 83F801              <1> 	cmp ax, VARIABLE
  4524 00004406 7406                <1> 	je .is_variable
  4525                              <1> 
  4526 00004408 BE1400              <1> 	mov si, err_syntax
  4527 0000440B E97001              <1> 	jmp error
  4528                              <1> 
  4529                              <1> .is_variable:
  4530 0000440E 0FB606007B          <1> 	movzx ax, byte [token]
  4531                              <1> 
  4532 00004413 50                  <1> 	push ax
  4533                              <1> 
  4534 00004414 E862CE              <1> 	call os_wait_for_key
  4535                              <1> 
  4536 00004417 80FC48              <1> 	cmp ah, 48h
  4537 0000441A 7419                <1> 	je .up_pressed
  4538                              <1> 	
  4539 0000441C 80FC50              <1> 	cmp ah, 50h
  4540 0000441F 7419                <1> 	je .down_pressed
  4541                              <1> 
  4542 00004421 80FC4B              <1> 	cmp ah, 4Bh
  4543 00004424 7419                <1> 	je .left_pressed
  4544                              <1> 
  4545 00004426 80FC4D              <1> 	cmp ah, 4Dh
  4546 00004429 7419                <1> 	je .right_pressed
  4547                              <1> 
  4548                              <1> .store:
  4549 0000442B 0FB6D8              <1> 	movzx bx, al
  4550                              <1> 
  4551 0000442E 58                  <1> 	pop ax
  4552                              <1> 
  4553 0000442F E82400              <1> 	call set_var
  4554                              <1> 
  4555 00004432 E9C0E8              <1> 	jmp mainloop
  4556                              <1> 
  4557                              <1> 
  4558                              <1> .up_pressed:
  4559 00004435 B80100              <1> 	mov ax, 1
  4560 00004438 EBF1                <1> 	jmp .store
  4561                              <1> 
  4562                              <1> .down_pressed:
  4563 0000443A B80200              <1> 	mov ax, 2
  4564 0000443D EBEC                <1> 	jmp .store
  4565                              <1> 
  4566                              <1> .left_pressed:
  4567 0000443F B80300              <1> 	mov ax, 3
  4568 00004442 EBE7                <1> 	jmp .store
  4569                              <1> 
  4570                              <1> .right_pressed:
  4571 00004444 B80400              <1> 	mov ax, 4
  4572 00004447 EBE2                <1> 	jmp .store
  4573                              <1> 
  4574                              <1> 
  4575                              <1> ; ==================================================================
  4576                              <1> ; INTERNAL ROUTINES FOR INTERPRETER
  4577                              <1> 
  4578                              <1> ; ------------------------------------------------------------------
  4579                              <1> ; Get value of variable character specified in AL (eg 'A')
  4580                              <1> 
  4581                              <1> get_var:
  4582 00004449 B400                <1> 	mov ah, 0
  4583 0000444B 2C41                <1> 	sub al, 65
  4584 0000444D BE4C7A              <1> 	mov si, variables
  4585 00004450 01C6                <1> 	add si, ax
  4586 00004452 01C6                <1> 	add si, ax
  4587 00004454 AD                  <1> 	lodsw
  4588 00004455 C3                  <1> 	ret
  4589                              <1> 
  4590                              <1> 
  4591                              <1> ; ------------------------------------------------------------------
  4592                              <1> ; Set value of variable character specified in AL (eg 'A')
  4593                              <1> ; with number specified in BX
  4594                              <1> 
  4595                              <1> set_var:
  4596 00004456 B400                <1> 	mov ah, 0
  4597 00004458 2C41                <1> 	sub al, 65				; Remove ASCII codes before 'A'
  4598                              <1> 
  4599 0000445A BF4C7A              <1> 	mov di, variables			; Find position in table (of words)
  4600 0000445D 01C7                <1> 	add di, ax
  4601 0000445F 01C7                <1> 	add di, ax
  4602 00004461 89D8                <1> 	mov ax, bx
  4603 00004463 AB                  <1> 	stosw
  4604 00004464 C3                  <1> 	ret
  4605                              <1> 
  4606                              <1> 
  4607                              <1> ; ------------------------------------------------------------------
  4608                              <1> ; Get token from current position in prog
  4609                              <1> 
  4610                              <1> get_token:
  4611 00004465 8B36[E945]          <1> 	mov word si, [prog]
  4612 00004469 AC                  <1> 	lodsb
  4613                              <1> 
  4614 0000446A 3C0A                <1> 	cmp al, 10
  4615 0000446C 741A                <1> 	je .newline
  4616                              <1> 
  4617 0000446E 3C20                <1> 	cmp al, ' '
  4618 00004470 7416                <1> 	je .newline
  4619                              <1> 
  4620 00004472 E8F100              <1> 	call is_number
  4621 00004475 7217                <1> 	jc get_number_token
  4622                              <1> 
  4623 00004477 3C22                <1> 	cmp al, '"'
  4624 00004479 745F                <1> 	je get_quote_token
  4625                              <1> 
  4626 0000447B 3C27                <1> 	cmp al, 39			; Quote mark (')
  4627 0000447D 7438                <1> 	je get_char_token
  4628                              <1> 
  4629 0000447F 3C24                <1> 	cmp al, '$'
  4630 00004481 0F848000            <1> 	je near get_string_var_token
  4631                              <1> 
  4632 00004485 E99000              <1> 	jmp get_string_token
  4633                              <1> 
  4634                              <1> 
  4635                              <1> .newline:
  4636 00004488 FF06[E945]          <1> 	inc word [prog]
  4637 0000448C EBD7                <1> 	jmp get_token
  4638                              <1> 
  4639                              <1> 
  4640                              <1> 
  4641                              <1> get_number_token:
  4642 0000448E 8B36[E945]          <1> 	mov word si, [prog]
  4643 00004492 BF007B              <1> 	mov di, token
  4644                              <1> 
  4645                              <1> .loop:
  4646 00004495 AC                  <1> 	lodsb
  4647 00004496 3C0A                <1> 	cmp al, 10
  4648 00004498 7416                <1> 	je .done
  4649 0000449A 3C20                <1> 	cmp al, ' '
  4650 0000449C 7412                <1> 	je .done
  4651 0000449E E8C500              <1> 	call is_number
  4652 000044A1 7206                <1> 	jc .fine
  4653                              <1> 
  4654 000044A3 BE0000              <1> 	mov si, err_char_in_num
  4655 000044A6 E9D500              <1> 	jmp error
  4656                              <1> 
  4657                              <1> .fine:
  4658 000044A9 AA                  <1> 	stosb
  4659 000044AA FF06[E945]          <1> 	inc word [prog]
  4660 000044AE EBE5                <1> 	jmp .loop
  4661                              <1> 
  4662                              <1> .done:
  4663 000044B0 B000                <1> 	mov al, 0			; Zero-terminate the token
  4664 000044B2 AA                  <1> 	stosb
  4665                              <1> 
  4666 000044B3 B80300              <1> 	mov ax, NUMBER			; Pass back the token type
  4667 000044B6 C3                  <1> 	ret
  4668                              <1> 
  4669                              <1> 
  4670                              <1> get_char_token:
  4671 000044B7 FF06[E945]          <1> 	inc word [prog]			; Move past first quote (')
  4672                              <1> 
  4673 000044BB 8B36[E945]          <1> 	mov word si, [prog]
  4674 000044BF AC                  <1> 	lodsb
  4675                              <1> 
  4676 000044C0 A2007B              <1> 	mov byte [token], al
  4677                              <1> 
  4678 000044C3 AC                  <1> 	lodsb
  4679 000044C4 3C27                <1> 	cmp al, 39			; Needs to finish with another quote
  4680 000044C6 7406                <1> 	je .is_ok
  4681                              <1> 
  4682 000044C8 BE1100              <1> 	mov si, err_quote_term
  4683 000044CB E9B000              <1> 	jmp error
  4684                              <1> 
  4685                              <1> .is_ok:
  4686 000044CE FF06[E945]          <1> 	inc word [prog]
  4687 000044D2 FF06[E945]          <1> 	inc word [prog]
  4688                              <1> 
  4689 000044D6 B80600              <1> 	mov ax, CHAR
  4690 000044D9 C3                  <1> 	ret
  4691                              <1> 
  4692                              <1> 
  4693                              <1> get_quote_token:
  4694 000044DA FF06[E945]          <1> 	inc word [prog]			; Move past first quote (") char
  4695 000044DE 8B36[E945]          <1> 	mov word si, [prog]
  4696 000044E2 BF007B              <1> 	mov di, token
  4697                              <1> .loop:
  4698 000044E5 AC                  <1> 	lodsb
  4699 000044E6 3C22                <1> 	cmp al, '"'
  4700 000044E8 740B                <1> 	je .done
  4701 000044EA 3C0A                <1> 	cmp al, 10
  4702 000044EC 7412                <1> 	je .error
  4703 000044EE AA                  <1> 	stosb
  4704 000044EF FF06[E945]          <1> 	inc word [prog]
  4705 000044F3 EBF0                <1> 	jmp .loop
  4706                              <1> 
  4707                              <1> .done:
  4708 000044F5 B000                <1> 	mov al, 0			; Zero-terminate the token
  4709 000044F7 AA                  <1> 	stosb
  4710 000044F8 FF06[E945]          <1> 	inc word [prog]			; Move past final quote
  4711                              <1> 
  4712 000044FC B80500              <1> 	mov ax, QUOTE			; Pass back token type
  4713 000044FF C3                  <1> 	ret
  4714                              <1> 
  4715                              <1> .error:
  4716 00004500 BE1100              <1> 	mov si, err_quote_term
  4717 00004503 EB79                <1> 	jmp error
  4718                              <1> 
  4719                              <1> 
  4720                              <1> get_string_var_token:
  4721 00004505 AC                  <1> 	lodsb
  4722 00004506 0FB6D8              <1> 	movzx bx, al
  4723 00004509 80EB31              <1> 	sub bl, 49
  4724                              <1> 
  4725 0000450C FF06[E945]          <1> 	inc word [prog]
  4726 00004510 FF06[E945]          <1> 	inc word [prog]
  4727                              <1> 
  4728 00004514 B80200              <1> 	mov ax, STRING_VAR
  4729 00004517 C3                  <1> 	ret
  4730                              <1> 	
  4731                              <1> 
  4732                              <1> get_string_token:
  4733 00004518 8B36[E945]          <1> 	mov word si, [prog]
  4734 0000451C BF007B              <1> 	mov di, token
  4735                              <1> .loop:
  4736 0000451F AC                  <1> 	lodsb
  4737 00004520 3C0A                <1> 	cmp al, 10
  4738 00004522 740B                <1> 	je .done
  4739 00004524 3C20                <1> 	cmp al, ' '
  4740 00004526 7407                <1> 	je .done
  4741 00004528 AA                  <1> 	stosb
  4742 00004529 FF06[E945]          <1> 	inc word [prog]
  4743 0000452D EBF0                <1> 	jmp .loop
  4744                              <1> .done:
  4745 0000452F B000                <1> 	mov al, 0			; Zero-terminate the token
  4746 00004531 AA                  <1> 	stosb
  4747                              <1> 
  4748 00004532 B8007B              <1> 	mov ax, token
  4749 00004535 E8D3E4              <1> 	call os_string_uppercase
  4750                              <1> 
  4751 00004538 B8007B              <1> 	mov ax, token
  4752 0000453B E874E4              <1> 	call os_string_length		; How long was the token?
  4753 0000453E 83F801              <1> 	cmp ax, 1			; If 1 char, it's a variable or delimiter
  4754 00004541 7413                <1> 	je .is_not_string
  4755                              <1> 
  4756 00004543 BE007B              <1> 	mov si, token			; If the token ends with ':', it's a label
  4757 00004546 01C6                <1> 	add si, ax
  4758 00004548 4E                  <1> 	dec si
  4759 00004549 AC                  <1> 	lodsb
  4760 0000454A 3C3A                <1> 	cmp al, ':'
  4761 0000454C 7404                <1> 	je .is_label
  4762                              <1> 
  4763 0000454E B80400              <1> 	mov ax, STRING			; Otherwise it's a general string of characters
  4764 00004551 C3                  <1> 	ret
  4765                              <1> 
  4766                              <1> .is_label:
  4767 00004552 B80800              <1> 	mov ax, LABEL
  4768 00004555 C3                  <1> 	ret
  4769                              <1> 
  4770                              <1> 
  4771                              <1> .is_not_string:
  4772 00004556 A0007B              <1> 	mov byte al, [token]
  4773 00004559 E81600              <1> 	call is_letter
  4774 0000455C 7204                <1> 	jc .is_var
  4775                              <1> 
  4776 0000455E B80700              <1> 	mov ax, UNKNOWN
  4777 00004561 C3                  <1> 	ret
  4778                              <1> 
  4779                              <1> .is_var:
  4780 00004562 B80100              <1> 	mov ax, VARIABLE		; Otherwise probably a variable
  4781 00004565 C3                  <1> 	ret
  4782                              <1> 
  4783                              <1> 
  4784                              <1> ; ------------------------------------------------------------------
  4785                              <1> ; Set carry flag if AL contains ASCII number
  4786                              <1> 
  4787                              <1> is_number:
  4788 00004566 3C30                <1> 	cmp al, 48
  4789 00004568 7C06                <1> 	jl .not_number
  4790 0000456A 3C39                <1> 	cmp al, 57
  4791 0000456C 7F02                <1> 	jg .not_number
  4792 0000456E F9                  <1> 	stc
  4793 0000456F C3                  <1> 	ret
  4794                              <1> .not_number:
  4795 00004570 F8                  <1> 	clc
  4796 00004571 C3                  <1> 	ret
  4797                              <1> 
  4798                              <1> 
  4799                              <1> ; ------------------------------------------------------------------
  4800                              <1> ; Set carry flag if AL contains ASCII letter
  4801                              <1> 
  4802                              <1> is_letter:
  4803 00004572 3C41                <1> 	cmp al, 65
  4804 00004574 7C06                <1> 	jl .not_letter
  4805 00004576 3C5A                <1> 	cmp al, 90
  4806 00004578 7F02                <1> 	jg .not_letter
  4807 0000457A F9                  <1> 	stc
  4808 0000457B C3                  <1> 	ret
  4809                              <1> 
  4810                              <1> .not_letter:
  4811 0000457C F8                  <1> 	clc
  4812 0000457D C3                  <1> 	ret
  4813                              <1> 
  4814                              <1> 
  4815                              <1> ; ------------------------------------------------------------------
  4816                              <1> ; Print error message and quit out
  4817                              <1> 
  4818                              <1> error:
  4819 0000457E B80005              <1> 	mov ax, 5 * 256			; Revert display page
  4820 00004581 CD10                <1> 	int 10h
  4821                              <1> 
  4822 00004583 E8B7D9              <1> 	call os_print_newline
  4823 00004586 BE[CA45]            <1> 	mov si, err_msg
  4824 00004589 E868D2              <1> 	call os_print_string
  4825                              <1> 	
  4826 0000458C 88D8                <1> 	mov al, bl
  4827 0000458E E800DC              <1> 	call os_print_2hex
  4828                              <1> 	
  4829 00004591 C606[F345]00        <1> 	mov byte [work_page], 0
  4830 00004596 C606[F445]00        <1> 	mov byte [disp_page], 0
  4831                              <1> 
  4832 0000459B BE[DE45]            <1> 	mov si, line_num_starter
  4833 0000459E E853D2              <1> 	call os_print_string
  4834                              <1> 
  4835                              <1> 
  4836                              <1> 	; And now print the line number where the error occurred. We do this
  4837                              <1> 	; by working from the start of the program to the current point,
  4838                              <1> 	; counting the number of newline characters along the way
  4839                              <1> 
  4840 000045A1 8B36[ED45]          <1> 	mov word si, [load_point]
  4841 000045A5 8B1E[E945]          <1> 	mov word bx, [prog]
  4842 000045A9 B90100              <1> 	mov cx, 1
  4843                              <1> 
  4844                              <1> .loop:
  4845 000045AC AC                  <1> 	lodsb
  4846 000045AD 3C0A                <1> 	cmp al, 10
  4847 000045AF 7501                <1> 	jne .not_newline
  4848 000045B1 41                  <1> 	inc cx
  4849                              <1> .not_newline:
  4850 000045B2 39DE                <1> 	cmp si, bx
  4851 000045B4 7402                <1> 	je .finish
  4852 000045B6 EBF4                <1> 	jmp .loop
  4853                              <1> .finish:
  4854                              <1> 
  4855 000045B8 89C8                <1> 	mov ax, cx
  4856 000045BA E886E5              <1> 	call os_int_to_string
  4857 000045BD 89C6                <1> 	mov si, ax
  4858 000045BF E832D2              <1> 	call os_print_string
  4859                              <1> 
  4860                              <1> 
  4861 000045C2 E878D9              <1> 	call os_print_newline
  4862                              <1> 
  4863 000045C5 8B26[E745]          <1> 	mov word sp, [orig_stack]	; Restore the stack to as it was when BASIC started
  4864                              <1> 
  4865 000045C9 C3                  <1> 	ret				; And finish
  4866                              <1> 
  4867                              <1> 
  4868                              <1> 	; Error messages text...
  4869                              <1> 
  4870                              <1> 	err_char_in_num		equ 00h
  4871                              <1> 	err_cmd_unknown		equ 01h
  4872                              <1> 	err_divide_by_zero	equ 02h
  4873                              <1> 	err_doloop_maximum	equ 03h
  4874                              <1> 	err_file_notfound	equ 04h
  4875                              <1> 	err_goto_notlabel	equ 05h
  4876                              <1> 	err_label_notfound	equ 06h
  4877                              <1> 	err_nest_limit		equ 07h
  4878                              <1> 	err_next			equ 08h
  4879                              <1> 	err_loop			equ 09h
  4880                              <1> 	err_print_type		equ 10h
  4881                              <1> 	err_quote_term		equ 11h
  4882                              <1> 	err_return			equ 12h
  4883                              <1> 	err_string_range	equ 13h
  4884                              <1> 	err_syntax			equ 14h
  4885                              <1> 
  4886 000045CA 4572726F722000      <1> 	err_msg				db "Error ", 0
  4887                              <1> 
  4888 000045D1 425245414B2043414C- <1> 	err_break			db "BREAK CALLED", 0
  4888 000045DA 4C454400            <1>
  4889                              <1> 
  4890 000045DE 202D206C696E652000  <1> 	line_num_starter	db " - line ", 0
  4891                              <1> 
  4892                              <1> 
  4893                              <1> ; ==================================================================
  4894                              <1> ; DATA SECTION
  4895                              <1> 
  4896 000045E7 0000                <1> 	orig_stack		dw 0		; Original stack location when BASIC started
  4897                              <1> 
  4898 000045E9 0000                <1> 	prog			dw 0		; Pointer to current location in BASIC code
  4899 000045EB 0000                <1> 	prog_end		dw 0		; Pointer to final byte of BASIC code
  4900                              <1> 
  4901 000045ED 0000                <1> 	load_point		dw 0
  4902                              <1> 
  4903 000045EF 00                  <1> 	token_type		db 0		; Type of last token read (eg NUMBER, VARIABLE)
  4904                              <1> 	token			equ 32768-1024-256
  4905                              <1> 
  4906                              <1> vars_loc:
  4907                              <1> ;	variables		times 26 dw 0	; Storage space for variables A to Z
  4908                              <1> 	variables		equ 32768-1024-384-52	; Storage space for variables A to Z
  4909                              <1> 
  4910                              <1> ;	for_variables		times 26 dw 0	; Storage for FOR loops
  4911                              <1> 	for_variables		equ 32768-1024-384-104	; Storage for FOR loops
  4912                              <1> ;	for_code_points		times 26 dw 0	; Storage for code positions where FOR loops start
  4913                              <1> 	for_code_points		equ 32768-1024-384-156	; Storage for code positions where FOR loops start
  4914                              <1> 	
  4915                              <1> ;	do_loop_store		times 10 dw 0	; Storage for DO loops
  4916                              <1> 	do_loop_store		equ 32768-1024-384-176	; Storage for DO loops
  4917 000045F0 00                  <1> 	loop_in			db 0		; Loop level
  4918                              <1> 
  4919 000045F1 01                  <1> 	last_if_true		db 1		; Checking for 'ELSE'
  4920                              <1> 
  4921 000045F2 00                  <1> 	ink_colour		db 0		; Text printing colour
  4922 000045F3 00                  <1> 	work_page		db 0		; Page to print to
  4923 000045F4 00                  <1> 	disp_page		db 0		; Page to display
  4924                              <1> 	
  4925 000045F5 414C45525400        <1> 	alert_cmd			db "ALERT", 0
  4926 000045FB 41534B46494C4500    <1> 	askfile_cmd			db "ASKFILE", 0
  4927 00004603 425245414B00        <1> 	break_cmd			db "BREAK", 0
  4928 00004609 43414C4C00          <1> 	call_cmd			db "CALL", 0
  4929 0000460E 4341534500          <1> 	case_cmd			db "CASE", 0
  4930 00004613 434C5300            <1> 	cls_cmd				db "CLS", 0
  4931 00004617 435552534F5200      <1> 	cursor_cmd			db "CURSOR", 0
  4932 0000461E 435552534348415200  <1> 	curschar_cmd		db "CURSCHAR", 0
  4933 00004627 43555253434F4C00    <1> 	curscol_cmd			db "CURSCOL", 0
  4934 0000462F 43555253504F5300    <1> 	curspos_cmd			db "CURSPOS", 0
  4935 00004637 44454C45544500      <1> 	delete_cmd			db "DELETE", 0
  4936 0000463E 444F00              <1> 	do_cmd				db "DO", 0
  4937 00004641 454C534500          <1> 	else_cmd			db "ELSE", 0
  4938 00004646 454E4400            <1> 	end_cmd				db "END", 0
  4939 0000464A 46494C455300        <1> 	files_cmd			db "FILES", 0
  4940 00004650 464F5200            <1> 	for_cmd 			db "FOR", 0
  4941 00004654 474F53554200        <1> 	gosub_cmd			db "GOSUB", 0
  4942 0000465A 474F544F00          <1> 	goto_cmd			db "GOTO", 0
  4943 0000465F 4745544B455900      <1> 	getkey_cmd			db "GETKEY", 0
  4944 00004666 494600              <1> 	if_cmd 				db "IF", 0
  4945 00004669 494E434C55444500    <1> 	include_cmd			db "INCLUDE", 0
  4946 00004671 494E4B00            <1> 	ink_cmd				db "INK", 0
  4947 00004675 494E50555400        <1> 	input_cmd 			db "INPUT", 0
  4948 0000467B 4C454E00            <1> 	len_cmd				db "LEN", 0
  4949 0000467F 4C495354424F5800    <1> 	listbox_cmd			db "LISTBOX", 0
  4950 00004687 4C4F414400          <1> 	load_cmd			db "LOAD", 0
  4951 0000468C 4C4F4F5000          <1> 	loop_cmd			db "LOOP", 0
  4952 00004691 4D4F564500          <1> 	move_cmd 			db "MOVE", 0
  4953 00004696 4E45585400          <1> 	next_cmd 			db "NEXT", 0
  4954 0000469B 4E554D42455200      <1> 	number_cmd			db "NUMBER", 0
  4955 000046A2 5041474500          <1> 	page_cmd			db "PAGE", 0
  4956 000046A7 504155534500        <1> 	pause_cmd 			db "PAUSE", 0
  4957 000046AD 5045454B00          <1> 	peek_cmd			db "PEEK", 0
  4958 000046B2 5045454B494E5400    <1> 	peekint_cmd			db "PEEKINT", 0
  4959 000046BA 504F4B4500          <1> 	poke_cmd			db "POKE", 0
  4960 000046BF 504F4B45494E5400    <1> 	pokeint_cmd			db "POKEINT", 0
  4961 000046C7 504F525400          <1> 	port_cmd			db "PORT", 0
  4962 000046CC 5052494E5400        <1> 	print_cmd 			db "PRINT", 0
  4963 000046D2 52414E4400          <1> 	rand_cmd			db "RAND", 0
  4964 000046D7 5245414400          <1> 	read_cmd			db "READ", 0
  4965 000046DC 52454D00            <1> 	rem_cmd				db "REM", 0
  4966 000046E0 52454E414D4500      <1> 	rename_cmd			db "RENAME", 0
  4967 000046E7 52455455524E00      <1> 	return_cmd			db "RETURN", 0
  4968 000046EE 5341564500          <1> 	save_cmd			db "SAVE", 0
  4969 000046F3 53455249414C00      <1> 	serial_cmd			db "SERIAL", 0
  4970 000046FA 53495A4500          <1> 	size_cmd			db "SIZE", 0
  4971 000046FF 534F554E4400        <1> 	sound_cmd 			db "SOUND", 0
  4972 00004705 535452494E4700      <1> 	string_cmd			db "STRING", 0
  4973 0000470C 574149544B455900    <1> 	waitkey_cmd			db "WAITKEY", 0
  4974                              <1> 
  4975 00004714 414E4400            <1> 	and_keyword			db "AND", 0
  4976 00004718 5448454E00          <1> 	then_keyword		db "THEN", 0
  4977 0000471D 43485200            <1> 	chr_keyword			db "CHR", 0
  4978 00004721 48455800            <1> 	hex_keyword			db "HEX", 0
  4979                              <1> 	
  4980 00004725 4C4F57455200        <1> 	lower_keyword		db "LOWER", 0
  4981 0000472B 555050455200        <1> 	upper_keyword		db "UPPER", 0
  4982                              <1> 
  4983 00004731 494E4B00            <1> 	ink_keyword			db "INK", 0
  4984 00004735 50524F475354415254- <1> 	progstart_keyword	db "PROGSTART", 0
  4984 0000473E 00                  <1>
  4985 0000473F 52414D535441525400  <1> 	ramstart_keyword	db "RAMSTART", 0
  4986 00004748 54494D455200        <1> 	timer_keyword		db "TIMER", 0
  4987 0000474E 5641524941424C4553- <1> 	variables_keyword	db "VARIABLES", 0
  4987 00004757 00                  <1>
  4988 00004758 56455253494F4E00    <1> 	version_keyword		db "VERSION", 0
  4989                              <1> 
  4990 00004760 00                  <1> 	gosub_depth		db 0
  4991                              <1> 	gosub_points		equ 32768-1024-384-196	; Points in code to RETURN to
  4992                              <1> 
  4993                              <1> 	string_vars		equ 32768-1024
  4994                              <1> 
  4995                              <1> ; ------------------------------------------------------------------
  4996                              <1> 
   819                                  	%INCLUDE "drivers/int.asm"
   820                              <1> ; -----------------------------------------------------------------
   821                              <1> ; os_modify_int_handler -- Change location of interrupt handler
   822                              <1> ; IN: CL = int number, DI:SI = handler location
   823                              <1> 
   824                              <1> os_modify_int_handler:
   825 00004761 60                  <1> 	pusha
   826                              <1> 
   827 00004762 FA                  <1> 	cli
   828                              <1> 
   829 00004763 06                  <1> 	push es
   830                              <1> 	
   831 00004764 8E06[F205]          <1> 	mov es, [driversgmt]
   832                              <1> 	
   833 00004768 0FB6D9              <1> 	movzx bx, cl			; Move supplied int into BX
   834                              <1> 
   835 0000476B C1E302              <1> 	shl bx, 2			; Multiply by four to get position
   836                              <1> 	
   837 0000476E 268937              <1> 	mov [es:bx], si		; First store offset
   838                              <1> 
   839 00004771 83C302              <1> 	add bx, 2
   840                              <1> 	
   841 00004774 26893F              <1> 	mov [es:bx], di		; Then segment of our handler
   842                              <1> 
   843 00004777 07                  <1> 	pop es
   844                              <1> 	
   845 00004778 FB                  <1> 	sti
   846                              <1> 
   847 00004779 61                  <1> 	popa
   848 0000477A C3                  <1> 	ret
   849                              <1> 
   850                              <1> ; -----------------------------------------------------------------
   851                              <1> ; os_get_int_handler -- Change location of interrupt handler
   852                              <1> ; IN: CL = int number; OUT: DI:SI = handler location
   853                              <1> 
   854                              <1> os_get_int_handler:
   855 0000477B 60                  <1> 	pusha
   856                              <1> 
   857 0000477C 1E                  <1> 	push ds
   858                              <1> 	
   859 0000477D 8E1E[F205]          <1> 	mov ds, [driversgmt]
   860                              <1> 	
   861 00004781 0FB6D9              <1> 	movzx bx, cl			; Move supplied int into BX
   862                              <1> 
   863 00004784 C1E302              <1> 	shl bx, 2			; Multiply by four to get position
   864                              <1> 	
   865 00004787 3E8B37              <1> 	mov si, [ds:bx]		; First store offset
   866 0000478A 83C302              <1> 	add bx, 2
   867                              <1> 
   868 0000478D 3E8B3F              <1> 	mov di, [ds:bx]		; Then segment of our handler
   869                              <1> 
   870 00004790 1F                  <1> 	pop ds
   871                              <1> 
   872 00004791 8936[A347]          <1> 	mov [.tmp_word], si
   873 00004795 893E[A547]          <1> 	mov [.tmp_sgmt], di
   874 00004799 61                  <1> 	popa
   875 0000479A 8B36[A347]          <1> 	mov si, [.tmp_word]
   876 0000479E 8B3E[A547]          <1> 	mov di, [.tmp_sgmt]
   877 000047A2 C3                  <1> 	ret
   878                              <1> 
   879 000047A3 0000                <1> 	.tmp_word	dw 0
   880 000047A5 0000                <1> 	.tmp_sgmt	dw 0
   881                              <1> 	
   882                              <1> ; -----------------------------------------------------------------
   883                              <1> ; os_attach_timer_interrupt -- Attach a timer interrupt to an application and sets the timer speed
   884                              <1> ; Formula: speed = (105000000 / 88) / frequency
   885                              <1> ; IN: SI = handler location, CX = speed
   886                              <1> 
   887                              <1> os_attach_app_timer:
   888 000047A7 60                  <1> 	pusha
   889 000047A8 8936[B048]          <1> 	mov [timer_application_offset], si
   890 000047AC C606[AF48]01        <1> 	mov byte [timer_application_attached], 1
   891                              <1> 	
   892 000047B1 E81A00              <1> 	call os_set_timer_speed
   893 000047B4 61                  <1> 	popa
   894 000047B5 C3                  <1> 	ret
   895                              <1> 	
   896                              <1> ; -----------------------------------------------------------------
   897                              <1> ; os_return_timer_interrupt -- Returns the timer interrupt back to the system and resets the timer speed
   898                              <1> ; IN: nothing
   899                              <1> 
   900                              <1> os_return_app_timer:
   901 000047B6 60                  <1> 	pusha
   902 000047B7 C606[AF48]00        <1> 	mov byte [timer_application_attached], 0
   903                              <1> 	
   904 000047BC B90000              <1> 	mov cx, 0
   905 000047BF E80C00              <1> 	call os_set_timer_speed
   906                              <1> 	
   907 000047C2 B11C                <1> 	mov cl, 1Ch					; RTC handler
   908 000047C4 BE[7748]            <1> 	mov si, os_compat_int1C
   909 000047C7 8CCF                <1> 	mov di, cs
   910 000047C9 E895FF              <1> 	call os_modify_int_handler
   911 000047CC 61                  <1> 	popa
   912 000047CD C3                  <1> 	ret
   913                              <1> 	
   914                              <1> ; -----------------------------------------------------------------
   915                              <1> ; os_set_timer_speed -- Sets the timer's trigger speed.
   916                              <1> ; Formula: speed = (105000000 / 88) / frequency
   917                              <1> ; IN: CX = speed
   918                              <1> 
   919                              <1> os_set_timer_speed:
   920 000047CE 60                  <1> 	pusha
   921                              <1> 	
   922 000047CF 890E[B248]          <1> 	mov [current_timer_speed], cx
   923                              <1> 	
   924 000047D3 B036                <1> 	mov al, 00110110b	; Timer 0, square wave
   925 000047D5 E643                <1> 	out 43h, al
   926 000047D7 88C8                <1> 	mov al, cl
   927 000047D9 E640                <1> 	out 40h, al
   928 000047DB 88E8                <1> 	mov al, ch
   929 000047DD E640                <1> 	out 40h, al
   930                              <1> 	
   931 000047DF 61                  <1> 	popa
   932 000047E0 C3                  <1> 	ret
   933                              <1> 	
   934                              <1> ; -----------------------------------------------------------------
   935                              <1> ; Interrupt call parsers
   936                              <1> 
   937                              <1> ; Division by 0 error handler
   938                              <1> os_compat_int00:
   939 000047E1 B8[E747]            <1> 	mov ax, .msg
   940 000047E4 E9B8CD              <1> 	jmp os_fatal_error
   941                              <1> 
   942 000047E7 4350553A2044697669- <1> 	.msg db 'CPU: Division by zero error', 0
   942 000047F0 73696F6E206279207A- <1>
   942 000047F9 65726F206572726F72- <1>
   942 00004802 00                  <1>
   943                              <1> 
   944                              <1> os_compat_int05:
   945 00004803 B8[0948]            <1> 	mov ax, .msg
   946 00004806 E996CD              <1> 	jmp os_fatal_error
   947                              <1> 
   948 00004809 557365722074726967- <1> 	.msg db 'User triggered crash', 0
   948 00004812 676572656420637261- <1>
   948 0000481B 736800              <1>
   949                              <1> 
   950                              <1> os_compat_int0C:
   951 0000481E FA                  <1> 	cli
   952 0000481F BCFEFF              <1> 	mov sp, 0FFFEh
   953 00004822 FB                  <1> 	sti
   954                              <1> 	
   955 00004823 B8[2948]            <1> 	mov ax, .msg
   956 00004826 E976CD              <1> 	jmp os_fatal_error
   957                              <1> 	
   958 00004829 537461636B206F7665- <1> 	.msg db 'Stack overflow', 0
   958 00004832 72666C6F7700        <1>
   959                              <1> 	
   960                              <1> ; Invalid opcode handler
   961                              <1> os_compat_int06:
   962 00004838 B8[3E48]            <1> 	mov ax, .msg
   963 0000483B E961CD              <1> 	jmp os_fatal_error
   964                              <1> 
   965 0000483E 4350553A20496E7661- <1> 	.msg db 'CPU: Invalid opcode', 0
   965 00004847 6C6964206F70636F64- <1>
   965 00004850 6500                <1>
   966                              <1> 
   967                              <1> ; Processor extension error handler
   968                              <1> os_compat_int07:
   969 00004852 B8[5848]            <1> 	mov ax, .msg
   970 00004855 E947CD              <1> 	jmp os_fatal_error
   971                              <1> 
   972 00004858 4350553A2050726F63- <1> 	.msg db 'CPU: Processor extension error', 0
   972 00004861 6573736F7220657874- <1>
   972 0000486A 656E73696F6E206572- <1>
   972 00004873 726F7200            <1>
   973                              <1> 
   974                              <1> ; System timer handler (8253/8254)
   975                              <1> os_compat_int1C:
   976 00004877 FA                  <1> 	cli
   977 00004878 6660                <1> 	pushad
   978 0000487A 1E                  <1> 	push ds
   979 0000487B 06                  <1> 	push es
   980                              <1> 	
   981 0000487C 8CC8                <1> 	mov ax, cs
   982 0000487E 8ED8                <1> 	mov ds, ax
   983 00004880 8EC0                <1> 	mov es, ax
   984                              <1> 	
   985 00004882 803E820001          <1> 	cmp byte [0082h], 1
   986 00004887 740E                <1> 	je .no_update
   987                              <1> 	
   988 00004889 833E[B448]00        <1> 	cmp word [screensaver_timer], 0
   989 0000488E 7404                <1> 	je .no_update_screensaver
   990                              <1> 	
   991 00004890 FF0E[B448]          <1> 	dec word [screensaver_timer]
   992                              <1> 	
   993                              <1> .no_update_screensaver:	
   994 00004894 E8B2CC              <1> 	call os_update_clock
   995                              <1> 
   996                              <1> .no_update:
   997 00004897 2E803E[AF48]01      <1> 	cmp byte [cs:timer_application_attached], 1
   998 0000489D 7406                <1> 	je .app_routine
   999                              <1> 
  1000 0000489F 07                  <1> 	pop es
  1001 000048A0 1F                  <1> 	pop ds
  1002 000048A1 6661                <1> 	popad
  1003 000048A3 FB                  <1> 	sti
  1004 000048A4 CF                  <1> 	iret
  1005                              <1> 
  1006                              <1> .app_routine:
  1007 000048A5 2EFF16[B048]        <1> 	call [cs:timer_application_offset]
  1008                              <1> 	
  1009 000048AA 07                  <1> 	pop es
  1010 000048AB 1F                  <1> 	pop ds	
  1011 000048AC 6661                <1> 	popad
  1012 000048AE CF                  <1> 	iret
  1013                              <1> 
  1014 000048AF 00                  <1> 	timer_application_attached	db 0
  1015 000048B0 0000                <1> 	timer_application_offset	dw 0
  1016                              <1> 	
  1017 000048B2 0000                <1> 	current_timer_speed			dw 0
  1018                              <1> 	
  1019 000048B4 0000                <1> 	screensaver_timer			dw 0
   820                                  	%INCLUDE "drivers/graphics.asm"
   821                              <1> 
   822                              <1> ; Puts a pixel on the screen.
   823                              <1> ; IN: AL = Color; BH = Page; CX = X position; DX = Y position
   824                              <1> ; OUT: nothing
   825                              <1> os_put_pixel:
   826 000048B6 60                  <1> 	pusha
   827 000048B7 B40C                <1> 	mov ah, 0Ch
   828 000048B9 CD10                <1> 	int 10h
   829 000048BB 61                  <1> 	popa
   830 000048BC C3                  <1> 	ret
   831                              <1> 	
   832                              <1> ; Gets a pixel from the screen.
   833                              <1> ; IN: BH = Page; CX = X position; DX = Y position
   834                              <1> ; OUT: AL = Color
   835                              <1> os_get_pixel:
   836 000048BD 60                  <1> 	pusha
   837 000048BE B40D                <1> 	mov ah, 0Dh
   838 000048C0 CD10                <1> 	int 10h
   839 000048C2 A2[CA48]            <1> 	mov [.tmp_byte], al
   840 000048C5 61                  <1> 	popa
   841 000048C6 A0[CA48]            <1> 	mov al, [.tmp_byte]
   842 000048C9 C3                  <1> 	ret
   843                              <1> 	
   844 000048CA 00                  <1> 	.tmp_byte	db 0
   845                              <1> 
   846                              <1> os_set_pixel:
   847 000048CB 60                  <1> 	pusha
   848 000048CC 89CA                <1> 	mov dx, cx
   849 000048CE 89C1                <1> 	mov cx, ax
   850 000048D0 88D8                <1> 	mov al, bl
   851 000048D2 B700                <1> 	mov bh, 0
   852 000048D4 E8DFFF              <1> 	call os_put_pixel
   853 000048D7 61                  <1> 	popa
   854 000048D8 C3                  <1> 	ret
   855                              <1> 	
   856                              <1> ; Implementation of Bresenham's line algorithm. Translated from an implementation in C (http://www.edepot.com/linebresenham.html)
   857                              <1> ; IN: CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour
   858                              <1> ; OUT: None, registers preserved
   859                              <1> os_draw_line:
   860 000048D9 60                  <1> 	pusha				; Save parameters
   861                              <1> 	
   862 000048DA 31C0                <1> 	xor ax, ax			; Clear variables
   863 000048DC BF[3F4A]            <1> 	mov di, .x1
   864 000048DF B90B00              <1> 	mov cx, 11
   865 000048E2 F3AB                <1> 	rep stosw
   866                              <1> 	
   867 000048E4 61                  <1> 	popa				; Restore and save parameters
   868 000048E5 60                  <1> 	pusha
   869                              <1> 	
   870 000048E6 890E[3F4A]          <1> 	mov [.x1], cx			; Save points
   871 000048EA 890E[474A]          <1> 	mov [.x], cx
   872 000048EE 8916[414A]          <1> 	mov [.y1], dx
   873 000048F2 8916[494A]          <1> 	mov [.y], dx
   874 000048F6 8936[434A]          <1> 	mov [.x2], si
   875 000048FA 893E[454A]          <1> 	mov [.y2], di
   876                              <1> 	
   877 000048FE 881E[554A]          <1> 	mov [.colour], bl		; Save the colour
   878                              <1> 	
   879 00004902 8B1E[434A]          <1> 	mov bx, [.x2]
   880 00004906 A1[3F4A]            <1> 	mov ax, [.x1]
   881 00004909 39C3                <1> 	cmp bx, ax
   882 0000490B 7C0E                <1> 	jl .x1gtx2
   883                              <1> 	
   884 0000490D 29C3                <1> 	sub bx, ax
   885 0000490F 891E[4B4A]          <1> 	mov [.dx], bx
   886 00004913 B80100              <1> 	mov ax, 1
   887 00004916 A3[4F4A]            <1> 	mov [.incx], ax
   888 00004919 EB0B                <1> 	jmp .test2
   889                              <1> 	
   890                              <1> .x1gtx2:
   891 0000491B 29D8                <1> 	sub ax, bx
   892 0000491D A3[4B4A]            <1> 	mov [.dx], ax
   893 00004920 B8FFFF              <1> 	mov ax, -1
   894 00004923 A3[4F4A]            <1> 	mov [.incx], ax
   895                              <1> 	
   896                              <1> .test2:
   897 00004926 8B1E[454A]          <1> 	mov bx, [.y2]
   898 0000492A A1[414A]            <1> 	mov ax, [.y1]
   899 0000492D 39C3                <1> 	cmp bx, ax
   900 0000492F 7C0E                <1> 	jl .y1gty2
   901                              <1> 	
   902 00004931 29C3                <1> 	sub bx, ax
   903 00004933 891E[4D4A]          <1> 	mov [.dy], bx
   904 00004937 B80100              <1> 	mov ax, 1
   905 0000493A A3[514A]            <1> 	mov [.incy], ax
   906 0000493D EB0B                <1> 	jmp .test3
   907                              <1> 	
   908                              <1> .y1gty2:
   909 0000493F 29D8                <1> 	sub ax, bx
   910 00004941 A3[4D4A]            <1> 	mov [.dy], ax
   911 00004944 B8FFFF              <1> 	mov ax, -1
   912 00004947 A3[514A]            <1> 	mov [.incy], ax
   913                              <1> 	
   914                              <1> .test3:
   915 0000494A 8B1E[4B4A]          <1> 	mov bx, [.dx]
   916 0000494E A1[4D4A]            <1> 	mov ax, [.dy]
   917 00004951 39C3                <1> 	cmp bx, ax
   918 00004953 7C6E                <1> 	jl .dygtdx
   919                              <1> 	
   920 00004955 A1[4D4A]            <1> 	mov ax, [.dy]
   921 00004958 D1E0                <1> 	shl ax, 1
   922 0000495A A3[4D4A]            <1> 	mov [.dy], ax
   923                              <1> 	
   924 0000495D 8B1E[4B4A]          <1> 	mov bx, [.dx]
   925 00004961 29D8                <1> 	sub ax, bx
   926 00004963 A3[534A]            <1> 	mov [.balance], ax
   927                              <1> 	
   928 00004966 D1E3                <1> 	shl bx, 1
   929 00004968 891E[4B4A]          <1> 	mov [.dx], bx
   930                              <1> 	
   931                              <1> .xloop:
   932 0000496C A1[474A]            <1> 	mov ax, [.x]
   933 0000496F 8B1E[434A]          <1> 	mov bx, [.x2]
   934 00004973 39D8                <1> 	cmp ax, bx
   935 00004975 0F84B600            <1> 	je .done
   936                              <1> 	
   937 00004979 A1[474A]            <1> 	mov ax, [.x]
   938 0000497C 8B0E[494A]          <1> 	mov cx, [.y]
   939 00004980 8A1E[554A]          <1> 	mov bl, [.colour]
   940 00004984 E844FF              <1> 	call os_set_pixel
   941                              <1> 	
   942 00004987 31F6                <1> 	xor si, si
   943 00004989 8B3E[534A]          <1> 	mov di, [.balance]
   944 0000498D 39F7                <1> 	cmp di, si
   945 0000498F 7C18                <1> 	jl .xloop1
   946                              <1> 	
   947 00004991 A1[494A]            <1> 	mov ax, [.y]
   948 00004994 8B1E[514A]          <1> 	mov bx, [.incy]
   949 00004998 01D8                <1> 	add ax, bx
   950 0000499A A3[494A]            <1> 	mov [.y], ax
   951                              <1> 	
   952 0000499D A1[534A]            <1> 	mov ax, [.balance]
   953 000049A0 8B1E[4B4A]          <1> 	mov bx, [.dx]
   954 000049A4 29D8                <1> 	sub ax, bx
   955 000049A6 A3[534A]            <1> 	mov [.balance], ax
   956                              <1> 	
   957                              <1> .xloop1:
   958 000049A9 A1[534A]            <1> 	mov ax, [.balance]
   959 000049AC 8B1E[4D4A]          <1> 	mov bx, [.dy]
   960 000049B0 01D8                <1> 	add ax, bx
   961 000049B2 A3[534A]            <1> 	mov [.balance], ax
   962                              <1> 	
   963 000049B5 A1[474A]            <1> 	mov ax, [.x]
   964 000049B8 8B1E[4F4A]          <1> 	mov bx, [.incx]
   965 000049BC 01D8                <1> 	add ax, bx
   966 000049BE A3[474A]            <1> 	mov [.x], ax
   967                              <1> 	
   968 000049C1 EBA9                <1> 	jmp .xloop
   969                              <1> 	
   970                              <1> .dygtdx:
   971 000049C3 A1[4B4A]            <1> 	mov ax, [.dx]
   972 000049C6 D1E0                <1> 	shl ax, 1
   973 000049C8 A3[4B4A]            <1> 	mov [.dx], ax
   974                              <1> 	
   975 000049CB 8B1E[4D4A]          <1> 	mov bx, [.dy]
   976 000049CF 29D8                <1> 	sub ax, bx
   977 000049D1 A3[534A]            <1> 	mov [.balance], ax
   978                              <1> 	
   979 000049D4 D1E3                <1> 	shl bx, 1
   980 000049D6 891E[4D4A]          <1> 	mov [.dy], bx
   981                              <1> 	
   982                              <1> .yloop:
   983 000049DA A1[494A]            <1> 	mov ax, [.y]
   984 000049DD 8B1E[454A]          <1> 	mov bx, [.y2]
   985 000049E1 39D8                <1> 	cmp ax, bx
   986 000049E3 744A                <1> 	je .done
   987                              <1> 	
   988 000049E5 A1[474A]            <1> 	mov ax, [.x]
   989 000049E8 8B0E[494A]          <1> 	mov cx, [.y]
   990 000049EC 8A1E[554A]          <1> 	mov bl, [.colour]
   991 000049F0 E8D8FE              <1> 	call os_set_pixel
   992                              <1> 	
   993 000049F3 31F6                <1> 	xor si, si
   994 000049F5 8B3E[534A]          <1> 	mov di, [.balance]
   995 000049F9 39F7                <1> 	cmp di, si
   996 000049FB 7C18                <1> 	jl .yloop1
   997                              <1> 	
   998 000049FD A1[474A]            <1> 	mov ax, [.x]
   999 00004A00 8B1E[4F4A]          <1> 	mov bx, [.incx]
  1000 00004A04 01D8                <1> 	add ax, bx
  1001 00004A06 A3[474A]            <1> 	mov [.x], ax
  1002                              <1> 	
  1003 00004A09 A1[534A]            <1> 	mov ax, [.balance]
  1004 00004A0C 8B1E[4D4A]          <1> 	mov bx, [.dy]
  1005 00004A10 29D8                <1> 	sub ax, bx
  1006 00004A12 A3[534A]            <1> 	mov [.balance], ax
  1007                              <1> 	
  1008                              <1> .yloop1:
  1009 00004A15 A1[534A]            <1> 	mov ax, [.balance]
  1010 00004A18 8B1E[4B4A]          <1> 	mov bx, [.dx]
  1011 00004A1C 01D8                <1> 	add ax, bx
  1012 00004A1E A3[534A]            <1> 	mov [.balance], ax
  1013                              <1> 	
  1014 00004A21 A1[494A]            <1> 	mov ax, [.y]
  1015 00004A24 8B1E[514A]          <1> 	mov bx, [.incy]
  1016 00004A28 01D8                <1> 	add ax, bx
  1017 00004A2A A3[494A]            <1> 	mov [.y], ax
  1018                              <1> 	
  1019 00004A2D EBAB                <1> 	jmp .yloop
  1020                              <1> 	
  1021                              <1> .done:
  1022 00004A2F A1[474A]            <1> 	mov ax, [.x]
  1023 00004A32 8B0E[494A]          <1> 	mov cx, [.y]
  1024 00004A36 8A1E[554A]          <1> 	mov bl, [.colour]
  1025 00004A3A E88EFE              <1> 	call os_set_pixel
  1026                              <1> 	
  1027 00004A3D 61                  <1> 	popa
  1028 00004A3E C3                  <1> 	ret
  1029                              <1> 	
  1030                              <1> 	
  1031 00004A3F 0000                <1> 	.x1 dw 0
  1032 00004A41 0000                <1> 	.y1 dw 0
  1033 00004A43 0000                <1> 	.x2 dw 0
  1034 00004A45 0000                <1> 	.y2 dw 0
  1035                              <1> 	
  1036 00004A47 0000                <1> 	.x dw 0
  1037 00004A49 0000                <1> 	.y dw 0
  1038 00004A4B 0000                <1> 	.dx dw 0
  1039 00004A4D 0000                <1> 	.dy dw 0
  1040 00004A4F 0000                <1> 	.incx dw 0
  1041 00004A51 0000                <1> 	.incy dw 0
  1042 00004A53 0000                <1> 	.balance dw 0
  1043 00004A55 00                  <1> 	.colour db 0
  1044 00004A56 00                  <1> 	.pad db 0
  1045                              <1> 	
  1046                              <1> ; Draw (straight) rectangle
  1047                              <1> ; IN: CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour, CF = set if filled or clear if not
  1048                              <1> ; OUT: None, registers preserved
  1049                              <1> os_draw_rectangle:
  1050 00004A57 60                  <1> 	pusha
  1051 00004A58 9C                  <1> 	pushf
  1052                              <1> 	
  1053 00004A59 890E[E34A]          <1> 	mov word [.x1], cx
  1054 00004A5D 8916[E74A]          <1> 	mov word [.y1], dx
  1055 00004A61 8936[E54A]          <1> 	mov word [.x2], si
  1056 00004A65 893E[E94A]          <1> 	mov word [.y2], di
  1057                              <1> 	
  1058 00004A69 9D                  <1> 	popf
  1059 00004A6A 7302                <1> 	jnc .draw_line
  1060                              <1> 
  1061 00004A6C EB4E                <1> 	jmp .fill_shape
  1062                              <1> 	
  1063                              <1> .draw_line:
  1064                              <1> 	; top line
  1065 00004A6E 8B0E[E34A]          <1> 	mov cx, [.x1]
  1066 00004A72 8B16[E74A]          <1> 	mov dx, [.y1]
  1067 00004A76 8B36[E54A]          <1> 	mov si, [.x2]
  1068 00004A7A 8B3E[E74A]          <1> 	mov di, [.y1]
  1069 00004A7E E858FE              <1> 	call os_draw_line
  1070                              <1> 	
  1071                              <1> 	; left line
  1072 00004A81 8B0E[E34A]          <1> 	mov cx, [.x1]
  1073 00004A85 8B16[E74A]          <1> 	mov dx, [.y1]
  1074 00004A89 8B36[E34A]          <1> 	mov si, [.x1]
  1075 00004A8D 8B3E[E94A]          <1> 	mov di, [.y2]
  1076 00004A91 E845FE              <1> 	call os_draw_line
  1077                              <1> 	
  1078                              <1> 	; right line
  1079 00004A94 8B0E[E54A]          <1> 	mov cx, [.x2]
  1080 00004A98 8B16[E74A]          <1> 	mov dx, [.y1]
  1081 00004A9C 8B36[E54A]          <1> 	mov si, [.x2]
  1082 00004AA0 8B3E[E94A]          <1> 	mov di, [.y2]
  1083 00004AA4 E832FE              <1> 	call os_draw_line
  1084                              <1> 
  1085                              <1> 	; bottom line
  1086 00004AA7 8B0E[E34A]          <1> 	mov cx, [.x1]
  1087 00004AAB 8B16[E94A]          <1> 	mov dx, [.y2]
  1088 00004AAF 8B36[E54A]          <1> 	mov si, [.x2]
  1089 00004AB3 8B3E[E94A]          <1> 	mov di, [.y2]
  1090 00004AB7 E81FFE              <1> 	call os_draw_line
  1091                              <1> 		
  1092 00004ABA EB25                <1> 	jmp .finished_fill
  1093                              <1> 		
  1094                              <1> .fill_shape:
  1095 00004ABC 88D8                <1> 	mov al, bl
  1096                              <1> 
  1097 00004ABE 39F1                <1> 	cmp cx, si		; Is X1 smaller than X2?
  1098 00004AC0 7C02                <1> 	jl .x_good
  1099 00004AC2 87CE                <1> 	xchg cx, si		; If not, exchange them
  1100                              <1> .x_good:
  1101 00004AC4 39FA                <1> 	cmp dx, di		; Is Y1 smaller than Y2?
  1102 00004AC6 7C02                <1> 	jl .y_good
  1103 00004AC8 87D7                <1> 	xchg dx, di		; If not, exchange them
  1104                              <1> .y_good:
  1105 00004ACA 890E[E34A]          <1> 	mov [.x1], cx
  1106 00004ACE B700                <1> 	mov bh, 0
  1107                              <1> .x_loop:
  1108 00004AD0 E8E3FD              <1> 	call os_put_pixel
  1109 00004AD3 41                  <1> 	inc cx
  1110                              <1> 	
  1111 00004AD4 39F1                <1> 	cmp cx, si
  1112 00004AD6 7CF8                <1> 	jl .x_loop
  1113                              <1> 	
  1114 00004AD8 42                  <1> 	inc dx
  1115 00004AD9 8B0E[E34A]          <1> 	mov cx, [.x1]
  1116                              <1> 	
  1117 00004ADD 39FA                <1> 	cmp dx, di
  1118 00004ADF 7CEF                <1> 	jl .x_loop
  1119                              <1> 		
  1120                              <1> .finished_fill:
  1121 00004AE1 61                  <1> 	popa
  1122 00004AE2 C3                  <1> 	ret
  1123                              <1> 	
  1124 00004AE3 0000                <1> 	.x1				dw 0
  1125 00004AE5 0000                <1> 	.x2				dw 0
  1126 00004AE7 0000                <1> 	.y1				dw 0
  1127 00004AE9 0000                <1> 	.y2				dw 0
  1128                              <1> 
  1129                              <1> ; Draw freeform shape
  1130                              <1> ; IN: BH = number of points, BL = colour, SI = location of shape points data
  1131                              <1> ; OUT: None, registers preserved
  1132                              <1> ; DATA FORMAT: x1, y1, x2, y2, x3, y3, etc
  1133                              <1> os_draw_polygon:
  1134 00004AEB 60                  <1> 	pusha
  1135                              <1> 	
  1136 00004AEC FECF                <1> 	dec bh
  1137 00004AEE 883E[594B]          <1> 	mov byte [.points], bh
  1138                              <1> 	
  1139 00004AF2 648B04              <1> 	mov word ax, [fs:si]
  1140 00004AF5 83C602              <1> 	add si, 2
  1141 00004AF8 A3[514B]            <1> 	mov word [.xi], ax
  1142 00004AFB A3[554B]            <1> 	mov word [.xl], ax
  1143                              <1> 	
  1144 00004AFE 648B04              <1> 	mov word ax, [fs:si]
  1145 00004B01 83C602              <1> 	add si, 2
  1146 00004B04 A3[534B]            <1> 	mov word [.yi], ax
  1147 00004B07 A3[574B]            <1> 	mov word [.yl], ax
  1148                              <1> 	
  1149                              <1> 	.draw_points:
  1150 00004B0A 8B0E[554B]          <1> 		mov cx, [.xl]
  1151 00004B0E 8B16[574B]          <1> 		mov dx, [.yl]
  1152                              <1> 		
  1153 00004B12 648B04              <1> 		mov word ax, [fs:si]
  1154 00004B15 83C602              <1> 		add si, 2
  1155 00004B18 A3[554B]            <1> 		mov word [.xl], ax
  1156                              <1> 		
  1157 00004B1B 648B04              <1> 		mov word ax, [fs:si]
  1158 00004B1E 83C602              <1> 		add si, 2
  1159 00004B21 A3[574B]            <1> 		mov word [.yl], ax
  1160                              <1> 		
  1161 00004B24 56                  <1> 		push si
  1162                              <1> 		
  1163 00004B25 8B36[554B]          <1> 		mov si, [.xl]
  1164 00004B29 8B3E[574B]          <1> 		mov di, [.yl]
  1165                              <1> 		
  1166 00004B2D E8A9FD              <1> 		call os_draw_line
  1167                              <1> 		
  1168 00004B30 5E                  <1> 		pop si
  1169                              <1> 		
  1170 00004B31 FE0E[594B]          <1> 		dec byte [.points]
  1171 00004B35 803E[594B]00        <1> 		cmp byte [.points], 0
  1172 00004B3A 75CE                <1> 		jne .draw_points
  1173                              <1> 		
  1174 00004B3C 8B0E[554B]          <1> 	mov cx, [.xl]
  1175 00004B40 8B16[574B]          <1> 	mov dx, [.yl]
  1176 00004B44 8B36[514B]          <1> 	mov si, [.xi]
  1177 00004B48 8B3E[534B]          <1> 	mov di, [.yi]
  1178 00004B4C E88AFD              <1> 	call os_draw_line
  1179                              <1> 	
  1180 00004B4F 61                  <1> 	popa
  1181 00004B50 C3                  <1> 	ret
  1182                              <1> 	
  1183 00004B51 0000                <1> 	.xi				dw 0
  1184 00004B53 0000                <1> 	.yi				dw 0
  1185 00004B55 0000                <1> 	.xl				dw 0
  1186 00004B57 0000                <1> 	.yl				dw 0
  1187 00004B59 00                  <1> 	.points				db 0
  1188                              <1> 	
  1189                              <1> 
  1190                              <1> ; Clear the screen by setting all pixels to a single colour
  1191                              <1> ; BL = colour to set
  1192                              <1> os_clear_graphics:
  1193 00004B5A 60                  <1> 	pusha
  1194 00004B5B 06                  <1> 	push es
  1195                              <1> 	
  1196 00004B5C B800A0              <1> 	mov ax, 0xA000
  1197 00004B5F 8EC0                <1> 	mov es, ax
  1198                              <1> 
  1199 00004B61 88D8                <1> 	mov al, bl
  1200 00004B63 BF0000              <1> 	mov di, 0
  1201 00004B66 B900FA              <1> 	mov cx, 64000
  1202 00004B69 F3AA                <1> 	rep stosb
  1203                              <1> 
  1204 00004B6B 07                  <1> 	pop es
  1205 00004B6C 61                  <1> 	popa
  1206 00004B6D C3                  <1> 	ret
  1207                              <1> 	
  1208                              <1> 	
  1209                              <1> ; ----------------------------------------
  1210                              <1> ; os_draw_circle -- draw a circular shape
  1211                              <1> ; IN: AL = colour, BX = radius, CX = middle X, DX = middle y
  1212                              <1> 
  1213                              <1> os_draw_circle:
  1214 00004B6E 60                  <1> 	pusha
  1215 00004B6F A2[304C]            <1> 	mov [.colour], al
  1216 00004B72 891E[354C]          <1> 	mov [.radius], bx
  1217 00004B76 890E[314C]          <1> 	mov [.x0], cx
  1218 00004B7A 8916[334C]          <1> 	mov [.y0], dx
  1219                              <1> 
  1220 00004B7E 891E[374C]          <1> 	mov [.x], bx
  1221 00004B82 C706[394C]0000      <1> 	mov word [.y], 0
  1222 00004B88 B80100              <1> 	mov ax, 1
  1223 00004B8B D1E3                <1> 	shl bx, 1
  1224 00004B8D 29D8                <1> 	sub ax, bx
  1225 00004B8F A3[3B4C]            <1> 	mov [.xChange], ax
  1226 00004B92 C706[3D4C]0000      <1> 	mov word [.yChange], 0
  1227 00004B98 C706[3F4C]0000      <1> 	mov word [.radiusError], 0
  1228                              <1> 
  1229                              <1> .next_point:
  1230 00004B9E 8B0E[374C]          <1> 	mov cx, [.x]
  1231 00004BA2 8B16[394C]          <1> 	mov dx, [.y]
  1232 00004BA6 39D1                <1> 	cmp cx, dx
  1233 00004BA8 0F8C8200            <1> 	jl .finish
  1234                              <1> 
  1235                              <1> 	;ax bx - function points
  1236                              <1> 	;cx = x 
  1237                              <1> 	;dx = y
  1238                              <1> 	;si = -x
  1239                              <1> 	;di = -y
  1240                              <1> 
  1241 00004BAC 89CE                <1> 	mov si, cx
  1242 00004BAE 83F6FF              <1> 	xor si, 0xFFFF
  1243 00004BB1 46                  <1> 	inc si
  1244 00004BB2 89D7                <1> 	mov di, dx
  1245 00004BB4 83F7FF              <1> 	xor di, 0xFFFF
  1246 00004BB7 47                  <1> 	inc di
  1247                              <1> 
  1248                              <1> 	; (x + x0, y + y0)
  1249 00004BB8 89C8                <1> 	mov ax, cx
  1250 00004BBA 89D3                <1> 	mov bx, dx
  1251 00004BBC E85B00              <1> 	call .draw_point
  1252                              <1> 
  1253                              <1> 	; (y + x0, x + y0)
  1254 00004BBF 93                  <1> 	xchg ax, bx
  1255 00004BC0 E85700              <1> 	call .draw_point
  1256                              <1> 
  1257                              <1> 	; (-x + x0, y + y0)
  1258 00004BC3 89F0                <1> 	mov ax, si
  1259 00004BC5 89D3                <1> 	mov bx, dx
  1260 00004BC7 E85000              <1> 	call .draw_point
  1261                              <1> 
  1262                              <1> 	; (-y + x0, x + y0)
  1263 00004BCA 89F8                <1> 	mov ax, di
  1264 00004BCC 89CB                <1> 	mov bx, cx
  1265 00004BCE E84900              <1> 	call .draw_point
  1266                              <1> 
  1267                              <1> 	; (-x + x0, -y + y0)
  1268 00004BD1 89F0                <1> 	mov ax, si
  1269 00004BD3 89FB                <1> 	mov bx, di
  1270 00004BD5 E84200              <1> 	call .draw_point
  1271                              <1> 
  1272                              <1> 	; (-y + x0, -x + y0)
  1273 00004BD8 93                  <1> 	xchg ax, bx
  1274 00004BD9 E83E00              <1> 	call .draw_point
  1275                              <1> 
  1276                              <1> 	; (x + x0, -y + y0)
  1277 00004BDC 89C8                <1> 	mov ax, cx
  1278 00004BDE 89FB                <1> 	mov bx, di
  1279 00004BE0 E83700              <1> 	call .draw_point
  1280                              <1> 
  1281                              <1> 	; (y + x0, -x + y0)
  1282 00004BE3 89D0                <1> 	mov ax, dx
  1283 00004BE5 89F3                <1> 	mov bx, si
  1284 00004BE7 E83000              <1> 	call .draw_point
  1285                              <1> 	
  1286 00004BEA FF06[394C]          <1> 	inc word [.y]
  1287 00004BEE A1[3D4C]            <1> 	mov ax, [.yChange]
  1288 00004BF1 0106[3F4C]          <1> 	add [.radiusError], ax
  1289 00004BF5 8306[3D4C]02        <1> 	add word [.yChange], 2
  1290                              <1> 	
  1291 00004BFA A1[3F4C]            <1> 	mov ax, [.radiusError]
  1292 00004BFD D1E0                <1> 	shl ax, 1
  1293 00004BFF 0306[3B4C]          <1> 	add ax, [.xChange]
  1294                              <1> 	
  1295 00004C03 83F800              <1> 	cmp ax, 0
  1296 00004C06 7E96                <1> 	jle .next_point
  1297                              <1> 	
  1298 00004C08 FF0E[374C]          <1> 	dec word [.x]
  1299 00004C0C A1[3B4C]            <1> 	mov ax, [.xChange]
  1300 00004C0F 0106[3F4C]          <1> 	add [.radiusError], ax
  1301 00004C13 8306[3B4C]02        <1> 	add word [.xChange], 2
  1302                              <1> 
  1303 00004C18 EB84                <1> 	jmp .next_point
  1304                              <1> 
  1305                              <1> .draw_point:
  1306                              <1> 	; AX = X, BX = Y
  1307 00004C1A 60                  <1> 	pusha
  1308 00004C1B 0306[314C]          <1> 	add ax, [.x0]
  1309 00004C1F 031E[334C]          <1> 	add bx, [.y0]
  1310 00004C23 89D9                <1> 	mov cx, bx
  1311 00004C25 8A1E[304C]          <1> 	mov bl, [.colour]
  1312 00004C29 E89FFC              <1> 	call os_set_pixel
  1313 00004C2C 61                  <1> 	popa
  1314 00004C2D C3                  <1> 	ret
  1315                              <1> 	
  1316                              <1> .finish:
  1317 00004C2E 61                  <1> 	popa
  1318 00004C2F C3                  <1> 	ret
  1319                              <1> 	
  1320                              <1> 
  1321                              <1> 
  1322 00004C30 00                  <1> .colour				db 0
  1323 00004C31 0000                <1> .x0					dw 0
  1324 00004C33 0000                <1> .y0					dw 0
  1325 00004C35 0000                <1> .radius				dw 0
  1326 00004C37 0000                <1> .x					dw 0
  1327 00004C39 0000                <1> .y					dw 0
  1328 00004C3B 0000                <1> .xChange			dw 0
  1329 00004C3D 0000                <1> .yChange			dw 0
  1330 00004C3F 0000                <1> .radiusError		dw 0
   821                                  	%INCLUDE "drivers/name.asm"
   822                              <1> 
   823 00004C41 43726570654F532076- <1> 	osname	db 'CrepeOS v0.7b1', 0
   823 00004C4A 302E37623100        <1>
   822                                  	%INCLUDE "drivers/shutdown.asm"
   823                              <1> 
   824                              <1> os_shutdown:
   825 00004C50 C606820001          <1> 	mov byte [0082h], 1
   826 00004C55 E84DCC              <1> 	call os_hide_cursor
   827 00004C58 E8E000              <1> 	call .drawbackground
   828 00004C5B E87E00              <1> 	call .drawwindow
   829 00004C5E E81200              <1> 	call .selector
   830                              <1> 	
   831 00004C61 3C01                <1> 	cmp al, 1
   832 00004C63 0F841101            <1> 	je near .shutdown
   833                              <1> 	
   834 00004C67 3C02                <1> 	cmp al, 2
   835 00004C69 0F840601            <1> 	je near .reset
   836                              <1> 	
   837 00004C6D 3C03                <1> 	cmp al, 3
   838 00004C6F 0F8460B6            <1> 	je near checkformenu
   839                              <1> 	
   840                              <1> .selector:
   841 00004C73 BA1C0B              <1> 	mov dx, 11 * 256 + 28
   842 00004C76 E8ECCB              <1> 	call os_move_cursor
   843                              <1> 
   844                              <1> .selectorloop:
   845 00004C79 E87000              <1> 	call .drawcontents
   846 00004C7C E83A00              <1> 	call .invert
   847                              <1> 	
   848 00004C7F E8F7C5              <1> 	call os_wait_for_key
   849                              <1> 	
   850 00004C82 80FC50              <1> 	cmp ah, 80
   851 00004C85 7417                <1> 	je .selectdown
   852                              <1> 	
   853 00004C87 80FC48              <1> 	cmp ah, 72
   854 00004C8A 741D                <1> 	je .selectup
   855                              <1> 	
   856 00004C8C 3C0D                <1> 	cmp al, 13
   857 00004C8E 7424                <1> 	je .select
   858                              <1> 	
   859 00004C90 3C1B                <1> 	cmp al, 27
   860 00004C92 7402                <1> 	je .return
   861                              <1> 	
   862 00004C94 EBE3                <1> 	jmp .selectorloop
   863                              <1> 
   864                              <1> .return:
   865 00004C96 B003                <1> 	mov al, 3
   866 00004C98 C606820001          <1> 	mov byte [0082h], 1
   867 00004C9D C3                  <1> 	ret
   868                              <1> 
   869                              <1> .selectdown:
   870 00004C9E 80FE0D              <1> 	cmp dh, 13
   871 00004CA1 0F84D4FF            <1> 	je near .selectorloop
   872 00004CA5 FEC6                <1> 	inc dh
   873 00004CA7 EBD0                <1> 	jmp .selectorloop
   874                              <1> 
   875                              <1> .selectup:
   876 00004CA9 80FE0B              <1> 	cmp dh, 11
   877 00004CAC 0F84C9FF            <1> 	je near .selectorloop
   878 00004CB0 FECE                <1> 	dec dh
   879 00004CB2 EBC5                <1> 	jmp .selectorloop
   880                              <1> 
   881                              <1> .select:
   882 00004CB4 88F0                <1> 	mov al, dh
   883 00004CB6 2C0A                <1> 	sub al, 10
   884 00004CB8 C3                  <1> 	ret
   885                              <1> 	
   886                              <1> .invert:
   887 00004CB9 B21C                <1> 	mov dl, 28
   888                              <1> 
   889                              <1> .invertloop:
   890 00004CBB E8A7CB              <1> 	call os_move_cursor
   891 00004CBE B408                <1> 	mov ah, 08h
   892 00004CC0 B700                <1> 	mov bh, 0
   893 00004CC2 CD10                <1> 	int 10h
   894                              <1> 
   895 00004CC4 BBF000              <1> 	mov bx, 240			; Black on white
   896 00004CC7 B409                <1> 	mov ah, 09h
   897 00004CC9 B90100              <1> 	mov cx, 1
   898 00004CCC CD10                <1> 	int 10h
   899                              <1> 
   900 00004CCE FEC2                <1> 	inc dl
   901 00004CD0 80FA3C              <1> 	cmp dl, 60
   902 00004CD3 0F840200            <1> 	je near .invertend
   903 00004CD7 EBE2                <1> 	jmp .invertloop
   904                              <1> 	
   905                              <1> .invertend:
   906 00004CD9 B21C                <1> 	mov dl, 28
   907 00004CDB C3                  <1> 	ret
   908                              <1> 	
   909                              <1> .drawwindow:
   910 00004CDC BA1309              <1> 	mov dx, 9 * 256 + 19			; First, draw white background box
   911 00004CDF 8A1EA9DE            <1> 	mov bl, [57001]
   912 00004CE3 BE2A00              <1> 	mov si, 42
   913 00004CE6 BF0F00              <1> 	mov di, 15
   914 00004CE9 E8C3CB              <1> 	call os_draw_block
   915                              <1> 
   916                              <1> .drawcontents:
   917 00004CEC 60                  <1> 	pusha
   918 00004CED 8A1EA9DE            <1> 	mov bl, [57001]
   919 00004CF1 BA140A              <1> 	mov dx, 10 * 256 + 20
   920 00004CF4 E86ECB              <1> 	call os_move_cursor
   921                              <1> 
   922 00004CF7 BE[144E]            <1> 	mov si, .dialogmsg1
   923 00004CFA E821CB              <1> 	call os_format_string
   924 00004CFD BECCDE              <1> 	mov si, 57036
   925 00004D00 E81BCB              <1> 	call os_format_string
   926 00004D03 BE[1E4E]            <1> 	mov si, .dialogmsg2
   927 00004D06 E815CB              <1> 	call os_format_string
   928                              <1> 
   929 00004D09 BA140B              <1> 	mov dx, 11 * 256 + 20
   930 00004D0C E856CB              <1> 	call os_move_cursor
   931 00004D0F BE[B14F]            <1> 	mov si, .logo0
   932 00004D12 E809CB              <1> 	call os_format_string
   933                              <1> 
   934 00004D15 BA140C              <1> 	mov dx, 12 * 256 + 20
   935 00004D18 E84ACB              <1> 	call os_move_cursor
   936 00004D1B BE[DA4F]            <1> 	mov si, .logo1
   937 00004D1E E8FDCA              <1> 	call os_format_string
   938                              <1> 
   939 00004D21 BA140D              <1> 	mov dx, 13 * 256 + 20
   940 00004D24 E83ECB              <1> 	call os_move_cursor
   941 00004D27 BE[0350]            <1> 	mov si, .logo2
   942 00004D2A E8F1CA              <1> 	call os_format_string
   943                              <1> 
   944 00004D2D BA140E              <1> 	mov dx, 14 * 256 + 20
   945 00004D30 E832CB              <1> 	call os_move_cursor
   946 00004D33 BE[2C50]            <1> 	mov si, .logo3
   947 00004D36 E8E5CA              <1> 	call os_format_string
   948 00004D39 61                  <1> 	popa
   949 00004D3A C3                  <1> 	ret
   950                              <1> 
   951                              <1> .drawbackground:
   952 00004D3B E811CB              <1> 	call os_clear_screen
   953 00004D3E BA0000              <1> 	mov dx, 0
   954 00004D41 E821CB              <1> 	call os_move_cursor
   955                              <1> 	
   956 00004D44 B82009              <1> 	mov ax, 0920h
   957 00004D47 BB7000              <1> 	mov bx, 112			; Black on gray
   958 00004D4A B95000              <1> 	mov cx, 80
   959 00004D4D CD10                <1> 	int 10h
   960                              <1> 	
   961 00004D4F BA0001              <1> 	mov dx, 1 * 256
   962 00004D52 E810CB              <1> 	call os_move_cursor
   963                              <1> 	
   964 00004D55 8A1EA8DE            <1> 	mov bl, [57000]		; Color from RAM
   965 00004D59 80E3F0              <1> 	and bl, 11110000b
   966 00004D5C B93007              <1> 	mov cx, 1840
   967 00004D5F B0B1                <1> 	mov al, 177
   968 00004D61 CD10                <1> 	int 10h
   969                              <1> 	
   970 00004D63 BA0018              <1> 	mov dx, 24 * 256
   971 00004D66 E8FCCA              <1> 	call os_move_cursor
   972 00004D69 B370                <1> 	mov bl, 112			; Black on gray
   973 00004D6B B95000              <1> 	mov cx, 80
   974 00004D6E B020                <1> 	mov al, 32
   975 00004D70 CD10                <1> 	int 10h
   976 00004D72 C3                  <1> 	ret
   977                              <1> 	
   978                              <1> .reset:
   979 00004D73 EA0000FFFF          <1> 	jmp 0FFFFh:0
   980                              <1> 
   981                              <1> .shutdown:
   982 00004D78 E8D4CA              <1> 	call os_clear_screen
   983 00004D7B E81CCB              <1> 	call os_show_cursor
   984                              <1> 
   985 00004D7E BE[E34E]            <1> 	mov si, .apmmsg
   986 00004D81 E870CA              <1> 	call os_print_string
   987                              <1> 	
   988 00004D84 BE[084F]            <1> 	mov si, .dbgmsg1
   989 00004D87 E86ACA              <1> 	call os_print_string
   990                              <1> 	
   991 00004D8A B80053              <1> 	mov ax, 5300h
   992 00004D8D 31DB                <1> 	xor bx, bx
   993 00004D8F CD15                <1> 	int 15h				; check if APM is present
   994 00004D91 724F                <1> 	jc .APM_missing
   995                              <1> 
   996 00004D93 BE[1A4F]            <1> 	mov si, .dbgmsg2
   997 00004D96 E85BCA              <1> 	call os_print_string
   998                              <1> 
   999 00004D99 B80453              <1> 	mov ax, 5304h
  1000 00004D9C 31DB                <1> 	xor bx, bx
  1001 00004D9E CD15                <1> 	int 15h				; disconnect any previous APM interface	
  1002                              <1> 	
  1003 00004DA0 BE[484F]            <1> 	mov si, .dbgmsg2_1
  1004 00004DA3 E84ECA              <1> 	call os_print_string
  1005                              <1> 	
  1006 00004DA6 B80E53              <1> 	mov ax, 530Eh		; Set APM to version 1.2
  1007 00004DA9 31DB                <1> 	xor bx, bx
  1008 00004DAB B90201              <1> 	mov cx, 0102h
  1009 00004DAE CD15                <1> 	int 15h
  1010                              <1> 
  1011 00004DB0 BE[684F]            <1> 	mov si, .dbgmsg3
  1012 00004DB3 E83ECA              <1> 	call os_print_string
  1013                              <1> 
  1014 00004DB6 B80153              <1> 	mov ax, 5301h
  1015 00004DB9 31DB                <1> 	xor bx, bx
  1016 00004DBB 31C9                <1> 	xor cx, cx
  1017 00004DBD CD15                <1> 	int 15h				; open an interface with APM
  1018 00004DBF 7231                <1> 	jc .APM_interface
  1019                              <1> 
  1020 00004DC1 BE[7F4F]            <1> 	mov si, .dbgmsg4
  1021 00004DC4 E82DCA              <1> 	call os_print_string
  1022                              <1> 
  1023 00004DC7 B80753              <1> 	mov ax, 5307h
  1024 00004DCA BB0100              <1> 	mov bx, 1
  1025 00004DCD B90300              <1> 	mov cx, 3
  1026 00004DD0 CD15                <1> 	int 15h				; do a power off
  1027                              <1> 	
  1028                              <1> .APM_error:
  1029 00004DD2 B8[204E]            <1> 	mov ax, .errormsg1
  1030 00004DD5 BB[844E]            <1> 	mov bx, .errormsg4
  1031 00004DD8 B9[AB4E]            <1> 	mov cx, .errormsg45
  1032 00004DDB 31D2                <1> 	xor dx, dx
  1033 00004DDD E857D2              <1> 	call os_dialog_box
  1034                              <1> 	
  1035 00004DE0 EB91                <1> 	jmp .reset
  1036                              <1> 	
  1037                              <1> .APM_missing:
  1038 00004DE2 B8[424E]            <1> 	mov ax, .errormsg2
  1039 00004DE5 BB[844E]            <1> 	mov bx, .errormsg4
  1040 00004DE8 B9[AB4E]            <1> 	mov cx, .errormsg45
  1041 00004DEB 31D2                <1> 	xor dx, dx
  1042 00004DED E847D2              <1> 	call os_dialog_box
  1043                              <1> 	
  1044 00004DF0 EB81                <1> 	jmp .reset
  1045                              <1> 	
  1046                              <1> .APM_interface:
  1047 00004DF2 B8[664E]            <1> 	mov ax, .errormsg3
  1048 00004DF5 BB[844E]            <1> 	mov bx, .errormsg4
  1049 00004DF8 B9[AB4E]            <1> 	mov cx, .errormsg45
  1050 00004DFB 31D2                <1> 	xor dx, dx
  1051 00004DFD E837D2              <1> 	call os_dialog_box
  1052                              <1> 	
  1053 00004E00 E970FF              <1> 	jmp .reset
  1054                              <1> 	
  1055                              <1> .APM_pwrmgmt:
  1056 00004E03 B8[C24E]            <1> 	mov ax, .errormsg5
  1057 00004E06 BB[844E]            <1> 	mov bx, .errormsg4
  1058 00004E09 B9[AB4E]            <1> 	mov cx, .errormsg45
  1059 00004E0C 31D2                <1> 	xor dx, dx
  1060 00004E0E E826D2              <1> 	call os_dialog_box
  1061                              <1> 	
  1062 00004E11 E95FFF              <1> 	jmp .reset
  1063                              <1> 
  1064                              <1> 	
  1065 00004E14 476F6F646279652C20- <1> 	.dialogmsg1	db 'Goodbye, ', 0
  1065 00004E1D 00                  <1>
  1066 00004E1E 2E00                <1> 	.dialogmsg2	db '.', 0
  1067 00004E20 4572726F7220736875- <1> 	.errormsg1	db 'Error shutting down the computer.', 0
  1067 00004E29 7474696E6720646F77- <1>
  1067 00004E32 6E2074686520636F6D- <1>
  1067 00004E3B 70757465722E00      <1>
  1068 00004E42 5468697320636F6D70- <1> 	.errormsg2	db 'This computer does not support APM.', 0
  1068 00004E4B 7574657220646F6573- <1>
  1068 00004E54 206E6F742073757070- <1>
  1068 00004E5D 6F72742041504D2E00  <1>
  1069 00004E66 4572726F7220636F6D- <1> 	.errormsg3	db 'Error communicating with APM.', 0
  1069 00004E6F 6D756E69636174696E- <1>
  1069 00004E78 672077697468204150- <1>
  1069 00004E81 4D2E00              <1>
  1070 00004E84 506C65617365207475- <1> 	.errormsg4	db 'Please turn off the computer manually,', 0
  1070 00004E8D 726E206F6666207468- <1>
  1070 00004E96 6520636F6D70757465- <1>
  1070 00004E9F 72206D616E75616C6C- <1>
  1070 00004EA8 792C00              <1>
  1071 00004EAB 6F7220707265737320- <1> 	.errormsg45	db 'or press OK to reboot.', 0
  1071 00004EB4 4F4B20746F20726562- <1>
  1071 00004EBD 6F6F742E00          <1>
  1072 00004EC2 4572726F7220656E61- <1> 	.errormsg5	db 'Error enabling power management.', 0
  1072 00004ECB 626C696E6720706F77- <1>
  1072 00004ED4 6572206D616E616765- <1>
  1072 00004EDD 6D656E742E00        <1>
  1073                              <1> 	
  1074 00004EE3 417474656D7074696E- <1> 	.apmmsg		db 'Attempting shutdown through APM...', 13, 10, 0
  1074 00004EEC 672073687574646F77- <1>
  1074 00004EF5 6E207468726F756768- <1>
  1074 00004EFE 2041504D2E2E2E0D0A- <1>
  1074 00004F07 00                  <1>
  1075                              <1> 	
  1076                              <1> 	
  1077 00004F08 436865636B696E6720- <1> 	.dbgmsg1	db 'Checking APM...', 13, 10, 0
  1077 00004F11 41504D2E2E2E0D0A00  <1>
  1078 00004F1A 446973636F6E6E6563- <1> 	.dbgmsg2	db 'Disconnecting any previous APM interface...', 13, 10, 0
  1078 00004F23 74696E6720616E7920- <1>
  1078 00004F2C 70726576696F757320- <1>
  1078 00004F35 41504D20696E746572- <1>
  1078 00004F3E 666163652E2E2E0D0A- <1>
  1078 00004F47 00                  <1>
  1079 00004F48 53657474696E672041- <1> 	.dbgmsg2_1	db 'Setting APM version to 1.2...', 13, 10, 0
  1079 00004F51 504D2076657273696F- <1>
  1079 00004F5A 6E20746F20312E322E- <1>
  1079 00004F63 2E2E0D0A00          <1>
  1080 00004F68 436F6E6E656374696E- <1> 	.dbgmsg3	db 'Connecting to APM...', 13, 10, 0
  1080 00004F71 6720746F2041504D2E- <1>
  1080 00004F7A 2E2E0D0A00          <1>
  1081 00004F7F 456E61626C696E6720- <1> 	.dbgmsg4	db 'Enabling power management...', 13, 10, 0
  1081 00004F88 706F776572206D616E- <1>
  1081 00004F91 6167656D656E742E2E- <1>
  1081 00004F9A 2E0D0A00            <1>
  1082 00004F9E 5368757474696E6720- <1> 	.dbgmsg5	db 'Shutting down...', 13, 10, 0
  1082 00004FA7 646F776E2E2E2E0D0A- <1>
  1082 00004FB0 00                  <1>
  1083                              <1> 	
  1084 00004FB1 DAC4C4B3C4C4BF2020- <1> 	.logo0		db 218, 196, 196, 179, 196, 196, 191, '  Shut down the computer         ', 0
  1084 00004FBA 5368757420646F776E- <1>
  1084 00004FC3 2074686520636F6D70- <1>
  1084 00004FCC 757465722020202020- <1>
  1084 00004FD5 2020202000          <1>
  1085 00004FDA B32020B32020B32020- <1> 	.logo1		db 179, 32, 32, 179, 32, 32, 179,     '  Soft reboot the computer       ', 0
  1085 00004FE3 536F6674207265626F- <1>
  1085 00004FEC 6F742074686520636F- <1>
  1085 00004FF5 6D7075746572202020- <1>
  1085 00004FFE 2020202000          <1>
  1086 00005003 B32020202020B32020- <1> 	.logo2		db 179, 32, 32, 32, 32, 32, 179,      '  Go back                        ', 0
  1086 0000500C 476F206261636B2020- <1>
  1086 00005015 202020202020202020- <1>
  1086 0000501E 202020202020202020- <1>
  1086 00005027 2020202000          <1>
  1087 0000502C C0C4C4C4C4C4D900    <1> 	.logo3		db 192, 196, 196, 196, 196, 196, 217, 0
   823                                  
   824                                  ; ==================================================================
   825                                  ; END OF KERNEL
   826                                  ; ==================================================================
   827                                  
   828                                  os_kernel_end:
