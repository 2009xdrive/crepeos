     1                                  
     2                                  	BITS 16
     3                                  	
     4                                  	ORG 32768
     5                                  	
     6                                  ; ------------------------------------------------------------------
     7                                  ; MACROS
     8                                  ; ------------------------------------------------------------------
     9                                  	
    10                                  %macro clr 1
    11                                  	xor %1, %1
    12                                  %endmacro
    13                                  
    14                                  %macro mov16 3
    15                                  	mov %1, (%2 + %3 * 256)
    16                                  %endmacro
    17                                  
    18                                  %define ADLIB_BUFFER 0500h
    19                                  %define DESKTOP_BACKGROUND 0600h
    20                                  %define SYSTEM_FONT 1600h
    21                                  %define FILE_MANAGER 2600h
    22                                  %define disk_buffer 0E000h
    23                                  
    24                                  ; ------------------------------------------------------------------
    25                                  ; crepeOS memory map:
    26                                  ; Segment 0000h:
    27                                  ;   - 0000h - 03FFh = Interrupt vector table
    28                                  ;   - 0400h - 04FFh = BIOS data area
    29                                  ;   - 0500h - 05FFh = AdLib register buffer
    30                                  ;   - 0600h - 15FFh = Desktop background (BG.ASC)
    31                                  ;   - 1600h - 25FFh = System font (FONT.SYS)
    32                                  ;   - 2600h - 35FFh = File manager (FILEMAN.APP)
    33                                  ; Segment 0360h:
    34                                  ;   - 0000h - 00FFh = System variables
    35                                  ;      - 0000h = RET instruction
    36                                  ;      - 0001h - 0050h = Footer buffer
    37                                  ;      - 0051h - 0081h = File selector filter buffer
    38                                  ;      - 0082h = System state (byte)
    39                                  ;         - 0 if a GUI application is running
    40                                  ;         - 1 if a non-GUI application is running (no header/footer)
    41                                  ;      - 0083h = Sound state (byte)
    42                                  ;         - 0 if sound disabled
    43                                  ;         - 1 if sound enabled
    44                                  ;      - 0084h = Default boot device (byte)
    45                                  ;      - 0085h = Default button for os_dialog_box (0 = OK, 1 = Cancel) (byte)
    46                                  ;      - 0086h = int_filename_convert error status (byte)
    47                                  ;         - 0 if filename too long
    48                                  ;         - 1 if filename empty
    49                                  ;         - 2 if no extension found
    50                                  ;         - 3 if no basename found
    51                                  ;         - 4 if extension too short
    52                                  ;      - 0087h = Flag for os_file_selector input (byte)
    53                                  ;      - 0088h = Maximum number of characters that os_input_string can input (byte)
    54                                  ;      - 0089h = Width of os_list_dialog (word)
    55                                  ;      - 00E0h - 00EFh - parameters for an app (eg. a file to open when an app launches)
    56                                  ;      - 00F0h - 00FFh - temporary buffer for storing apps' filenames
    57                                  ;   - 0100h - 7FFEh = Application
    58                                  ;   - 7FFEh - Application return flag
    59                                  ;      - 0 = return to the desktop after an application quits
    60                                  ;      - 1 = launch another application (00F0h-00FFh) after an application quits
    61                                  ;      (example: when a user opens an app through Terminal, then terminal stores its name to 00F0h-00FFh so it starts after the requested application exits)
    62                                  ;   - 7FFFh - Application launch flag
    63                                  ;      - 0 = return to the desktop after an application quits
    64                                  ;      - 1 = launch another application (filename passed in AX) after an application quits
    65                                  ;         - Note: after launching another application this flag is set to 0
    66                                  ;   - 8000h - DEA7h = crepeOS kernel
    67                                  ;   - DEA8h - DFFFh = Configuration file (SYSTEM.CFG)
    68                                  ;      - described in CONFIG.ASM
    69                                  ;   - E000h - FFFFh = Disk buffer
    70                                  ; End of memory: 2048 bytes stack
    71                                  ; ------------------------------------------------------------------
    72                                  
    73                                  ; ------------------------------------------------------------------
    74                                  ; OS CALL VECTORS
    75                                  
    76                                  os_call_vectors:
    77 00000000 E95601                  	jmp os_main					; 8000h -- Called from bootloader
    78 00000003 E9EF17                  	jmp os_print_string			; 8003h
    79 00000006 E95D18                  	jmp os_move_cursor			; 8006h
    80 00000009 E94418                  	jmp os_clear_screen			; 8009h
    81 0000000C E97318                  	jmp os_print_horiz_line		; 800Ch
    82 0000000F E92C1F                  	jmp os_print_newline		; 800Fh
    83 00000012 E96512                  	jmp os_wait_for_key			; 8012h
    84 00000015 E90513                  	jmp os_check_for_key		; 8015h
    85 00000018 E9292B                  	jmp os_int_to_string		; 8018h
    86 0000001B E90C26                  	jmp os_speaker_tone			; 801Bh
    87 0000001E E94926                  	jmp os_speaker_off			; 801Eh
    88 00000021 E9690B                  	jmp os_load_file			; 8021h
    89 00000024 E9A514                  	jmp os_pause				; 8024h
    90 00000027 E97615                  	jmp os_fatal_error			; 8027h
    91 0000002A E9441E                  	jmp os_draw_background		; 802Ah
    92 0000002D E98329                  	jmp os_string_length		; 802Dh
    93 00000030 E9D929                  	jmp os_string_uppercase		; 8030h
    94 00000033 E9F329                  	jmp os_string_lowercase		; 8033h
    95 00000036 E97421                  	jmp os_input_string			; 8036h
    96 00000039 E90A2A                  	jmp os_string_copy			; 8039h
    97 0000003C E9F91F                  	jmp os_dialog_box			; 803Ch
    98 0000003F E90D2A                  	jmp os_string_join			; 803Fh
    99 00000042 E91B0A                  	jmp os_get_file_list		; 8042h
   100 00000045 E95D2A                  	jmp os_string_compare		; 8045h
   101 00000048 E91A2A                  	jmp os_string_chomp			; 8048h
   102 0000004B E9AF2A                  	jmp os_string_to_hex		; 804Bh
   103 0000004E E9E326                  	jmp os_adlib_regwrite		; 804Eh
   104 00000051 E9AF13                  	jmp os_bcd_to_int			; 8051h
   105 00000054 E9552B                  	jmp os_get_time_string		; 8054h
   106 00000057 E9B123                  	jmp os_draw_logo			; 8057h
   107 0000005A E96B18                  	jmp os_file_selector		; 805Ah
   108 0000005D E9932B                  	jmp os_get_date_string		; 805Dh
   109 00000060 E95B17                  	jmp os_send_via_serial		; 8060h
   110 00000063 E96A17                  	jmp os_get_via_serial		; 8063h
   111 00000066 E98329                  	jmp os_find_char_in_string	; 8066h
   112 00000069 E90318                  	jmp os_get_cursor_pos		; 8069h
   113 0000006C E90021                  	jmp os_print_space			; 806Ch
   114 0000006F E92824                  	jmp os_option_menu			; 806Fh
   115 00000072 E90221                  	jmp os_print_digit			; 8072h
   116 00000075 E91121                  	jmp os_print_1hex			; 8075h
   117 00000078 E91721                  	jmp os_print_2hex			; 8078h
   118 0000007B E92221                  	jmp os_print_4hex			; 807Bh
   119 0000007E E94E47                  	jmp os_set_timer_speed		; 807Eh
   120 00000081 E96509                  	jmp os_report_free_space	; 8081h
   121 00000084 E91D29                  	jmp os_string_add			; 8084h
   122 00000087 E9D225                  	jmp os_speaker_note_length	; 8087h
   123 0000008A E90E18                  	jmp os_show_cursor			; 808Ah
   124 0000008D E91618                  	jmp os_hide_cursor			; 808Dh
   125 00000090 E9B81E                  	jmp os_dump_registers		; 8090h
   126 00000093 E9E11A                  	jmp os_list_dialog_tooltip	; 8093h
   127 00000096 E9560C                  	jmp os_write_file			; 8096h
   128 00000099 E9350E                  	jmp os_file_exists			; 8099h
   129 0000009C E9530E                  	jmp os_create_file			; 809Ch
   130 0000009F E92E0F                  	jmp os_remove_file			; 809Fh
   131 000000A2 E9AD0F                  	jmp os_rename_file			; 80A2h
   132 000000A5 E9DF0F                  	jmp os_get_file_size		; 80A5h
   133 000000A8 E9F71E                  	jmp os_input_dialog			; 80A8h
   134 000000AB E9061B                  	jmp os_list_dialog			; 80ABh
   135 000000AE E91B29                  	jmp os_string_reverse		; 80AEh
   136 000000B1 E9452A                  	jmp os_string_to_int		; 80B1h
   137 000000B4 E9F917                  	jmp os_draw_block			; 80B4h
   138 000000B7 E92413                  	jmp os_get_random			; 80B7h
   139 000000BA E9072C                  	jmp os_print_32int			; 80BAh
   140 000000BD E9EA16                  	jmp os_serial_port_enable	; 80BDh
   141 000000C0 E9AF2A                  	jmp os_sint_to_string		; 80C0h
   142 000000C3 E9F629                  	jmp os_string_parse			; 80C3h
   143 000000C6 E9082C                  	jmp os_run_basic			; 80C6h
   144 000000C9 E92328                  	jmp os_adlib_calcfreq		; 80C9h
   145 000000CC E9D946                  	jmp os_attach_app_timer		; 80CCh
   146 000000CF E9652B                  	jmp os_string_tokenize		; 80CFh
   147 000000D2 E93714                  	jmp os_clear_registers		; 80D2h
   148 000000D5 E94717                  	jmp os_format_string		; 80D5h
   149 000000D8 E90617                  	jmp os_putchar				; 80D8h
   150 000000DB E99525                  	jmp os_start_adlib			; 80DBh
   151 000000DE E9D646                  	jmp os_return_app_timer		; 80DEh
   152 000000E1 E90323                  	jmp os_reset_font			; 80E1h
   153 000000E4 E91B17                  	jmp os_print_string_box		; 80E4h
   154 000000E7 E9FE16                  	jmp os_put_chars			; 80E7h
   155 000000EA E92526                  	jmp os_check_adlib			; 80EAh
   156 000000ED E9EA47                  	jmp os_draw_line			; 80EDh
   157 000000F0 E9F949                  	jmp os_draw_polygon			; 80F0h
   158 000000F3 E9794A                  	jmp os_draw_circle			; 80F3h
   159 000000F6 E9624A                  	jmp os_clear_graphics		; 80F6h
   160 000000F9 E9B90F                  	jmp os_get_file_datetime	; 80F9h
   161 000000FC E98028                  	jmp os_string_encrypt		; 80FCh
   162 000000FF E9B547                  	jmp os_put_pixel			; 80FFh
   163 00000102 E9B947                  	jmp os_get_pixel			; 8102h
   164 00000105 E91D23                  	jmp os_draw_icon			; 8105h
   165 00000108 E9B725                  	jmp os_stop_adlib			; 8108h
   166 0000010B E94D28                  	jmp os_adlib_noteoff		; 810Bh
   167 0000010E E9A815                  	jmp os_int_1Ah				; 810Eh
   168 00000111 E90A13                  	jmp os_int_to_bcd			; 8111h
   169 00000114 E90814                  	jmp os_illegal_call			; 8114h ; FREE!!!!!!!!!!!!!!!!!!!
   170 00000117 E9D21E                  	jmp os_password_dialog		; 8117h
   171 0000011A E9D426                  	jmp os_adlib_mute			; 811Ah
   172 0000011D E93849                  	jmp os_draw_rectangle		; 811Dh
   173 00000120 E97715                  	jmp os_get_memory			; 8120h
   174 00000123 E96421                  	jmp os_color_selector		; 8123h
   175 00000126 E93946                  	jmp os_modify_int_handler	; 8126h
   176 00000129 E9242B                  	jmp os_32int_to_string		; 8129h
   177 0000012C E95322                  	jmp os_print_footer			; 812Ch
   178 0000012F E9FE21                  	jmp os_print_8hex			; 812Fh
   179 00000132 E9552B                  	jmp os_string_to_32int		; 8132h
   180 00000135 E90013                  	jmp os_math_power			; 8135h
   181 00000138 E94213                  	jmp os_math_root			; 8138h
   182 0000013B E9D920                  	jmp os_input_password		; 813Bh
   183 0000013E E93B46                  	jmp os_get_int_handler		; 813Eh
   184 00000141 E9DB13                  	jmp os_illegal_call			; 8141h ; FREE!!!!!!!!!!!!!!!!!!!
   185 00000144 E9FC21                  	jmp os_temp_box				; 8144h
   186 00000147 E9CB26                  	jmp os_adlib_unmute			; 8147h
   187 0000014A E9EB08                  	jmp os_read_root			; 814Ah
   188 0000014D E9CF13                  	jmp os_illegal_call			; 814Dh ; FREE!!!!!!!!!!!!!!!!!!!
   189 00000150 E9CC13                  	jmp os_illegal_call			; 8150h ; FREE!!!!!!!!!!!!!!!!!!!
   190 00000153 E9C913                  	jmp os_illegal_call			; 8153h ; FREE!!!!!!!!!!!!!!!!!!!
   191 00000156 E9F110                  	jmp disk_convert_l2hts		; 8156h
   192                                  	
   193                                  ; ------------------------------------------------------------------
   194                                  ; START OF MAIN KERNEL CODE
   195                                  
   196                                  os_main:
   197 00000159 CD12                    	int 12h						; Get RAM size
   198 0000015B 48                      	dec ax						; Some BIOSes round up, so we have to sacrifice 1 kB :(
   199 0000015C C1E006                  	shl ax, 6					; Convert kB to segments
   200                                  
   201 0000015F FA                      	cli
   202                                  
   203 00000160 2D0010                  	sub ax, 65536 / 16			; Set the stack to the top of the memory
   204 00000163 8ED0                    	mov ss, ax
   205 00000165 BCFEFF                  	mov sp, 0FFFEh
   206                                  
   207                                  ;	xor ax, ax
   208                                  ;	mov ss, ax					; Set stack segment and pointer
   209                                  ;	mov sp, 0FFFEh
   210                                  
   211 00000168 FB                      	sti
   212                                  
   213 00000169 FC                      	cld							; The default direction for string operations
   214                                  								; will be 'up' - incrementing address in RAM
   215                                  
   216 0000016A 8CC8                    	mov ax, cs					; Set all segments to match where kernel is loaded
   217 0000016C 8ED8                    	mov ds, ax			
   218 0000016E 8EC0                    	mov es, ax
   219 00000170 8E26[F205]              	mov fs, [driversgmt]
   220 00000174 050010                  	add ax, 1000h
   221 00000177 8EE8                    	mov gs, ax
   222                                  	
   223 00000179 C6060000C3              	mov byte [0000h], 0xC3
   224 0000017E 88168400                	mov [0084h], dl
   225 00000182 8816[7912]              	mov [bootdev], dl			; Save boot device number
   226 00000186 C6068800FF              	mov byte [0088h], 255
   227 0000018B C70689004C00            	mov word [0089h], 76
   228 00000191 C606E00000              	mov byte [00E0h], 0
   229                                  
   230 00000196 891E[7512]              	mov [Sides], bx
   231 0000019A 890E[7712]              	mov [SecsPerTrack], cx
   232                                  
   233                                  	clr ax
    11 0000019E 31C0                <1>  xor %1, %1
   234 000001A0 E80716                  	call os_serial_port_enable
   235                                  
   236                                  	; Load the files
   237                                  	
   238 000001A3 06                      	push es
   239 000001A4 8E06[F205]              	mov es, [driversgmt]
   240                                  	
   241 000001A8 B8[0807]                	mov ax, fileman_name
   242 000001AB B90026                  	mov cx, FILE_MANAGER
   243 000001AE E8DC09                  	call os_load_file
   244                                  	
   245 000001B1 B8[0107]                	mov ax, bg_name
   246 000001B4 B90006                  	mov cx, DESKTOP_BACKGROUND
   247 000001B7 E8D309                  	call os_load_file
   248 000001BA 7305                    	jnc .background_ok
   249                                  	
   250 000001BC C606000600              	mov byte [DESKTOP_BACKGROUND], 0
   251                                  	
   252                                  .background_ok:	
   253 000001C1 B8[2C07]                	mov ax, font_name
   254 000001C4 B90016                  	mov cx, SYSTEM_FONT
   255 000001C7 E8C309                  	call os_load_file
   256                                  	
   257 000001CA 07                      	pop es
   258                                  	
   259 000001CB FA                      	cli
   260                                  
   261 000001CC 8CCF                    	mov di, cs
   262                                  
   263 000001CE B100                    	mov cl, 00h					; Divide by 0 error handler
   264 000001D0 BE[E247]                	mov si, os_compat_int00
   265 000001D3 E88C45                  	call os_modify_int_handler
   266                                  
   267 000001D6 B10C                    	mov cl, 0Ch					; Stack overflow
   268 000001D8 BE[1F48]                	mov si, os_compat_int0C
   269 000001DB E88445                  	call os_modify_int_handler
   270                                  
   271 000001DE B105                    	mov cl, 05h					; Debugger
   272 000001E0 BE[0448]                	mov si, os_compat_int05
   273 000001E3 E87C45                  	call os_modify_int_handler
   274                                  	
   275 000001E6 B106                    	mov cl, 06h					; Bad instruction error handler
   276 000001E8 BE[3948]                	mov si, os_compat_int06
   277 000001EB E87445                  	call os_modify_int_handler
   278                                  
   279 000001EE B107                    	mov cl, 07h					; Processor extension error handler
   280 000001F0 BE[5348]                	mov si, os_compat_int07
   281 000001F3 E86C45                  	call os_modify_int_handler
   282                                  
   283 000001F6 B11C                    	mov cl, 1Ch					; RTC handler
   284 000001F8 BE[7848]                	mov si, os_compat_int1C
   285 000001FB E86445                  	call os_modify_int_handler
   286                                  	
   287 000001FE FB                      	sti
   288                                  
   289                                  ;	int 5
   290                                  	
   291 000001FF E8BC11                  	call os_seed_random
   292                                  
   293 00000202 BF0001                  	mov di, 100h
   294 00000205 B000                    	mov al, 0
   295 00000207 B9FF7E                  	mov cx, 7EFFh
   296 0000020A F3AA                    	rep stosb
   297                                  
   298 0000020C E8D821                  	call os_reset_font
   299                                  
   300 0000020F B80310                  	mov ax, 1003h				; Set text output with certain attributes
   301 00000212 B300                    	mov bl, 0					; to be bright, and not blinking
   302 00000214 CD10                    	int 10h
   303                                  	
   304 00000216 B80503                  	mov ax, 0305h
   305 00000219 BB0401                  	mov bx, 0104h
   306 0000021C CD16                    	int 16h
   307                                  	
   308 0000021E C606820000              	mov byte [0082h], 0
   309                                  	
   310 00000223 B8[2107]                	mov ax, system_cfg			; Try to load SYSTEM.CFG
   311 00000226 B9A8DE                  	mov cx, 57000
   312 00000229 E86109                  	call os_load_file
   313                                  
   314 0000022C A0EDDE                  	mov al, [57069]				; Copy the default sound volume (on/off)
   315 0000022F A28300                  	mov [0083h], al
   316                                  	
   317 00000232 0F82E902                	jc load_demotour			; If failed, it doesn't exist, so the system is run for the first time
   318                                  	
   319                                  logoinput:
   320 00000236 B8[424C]                	mov ax, osname				; Set up the welcome screen
   321 00000239 BB[4907]                	mov bx, empty_string
   322 0000023C B90700                  	mov cx, 07h					; Colour: black
   323 0000023F E82F1C                  	call os_draw_background
   324                                  
   325 00000242 BA0009                  	mov dx, 9 * 256
   326 00000245 E81E16                  	call os_move_cursor
   327                                  
   328 00000248 B82009                  	mov ax, 0920h
   329 0000024B BB0400                  	mov bx, 00000100b
   330 0000024E B93002                  	mov cx, 560
   331 00000251 CD10                    	int 10h
   332                                  
   333 00000253 BE[6909]                	mov si, logo
   334 00000256 E8CC21                  	call os_draw_icon
   335                                  
   336 00000259 BE[EA02]                	mov si, ver_msg
   337 0000025C E89615                  	call os_print_string
   338                                  
   339 0000025F BA0216                  	mov dx, 22 * 256 + 2
   340 00000262 E80116                  	call os_move_cursor
   341                                  
   342 00000265 BE[2F03]                	mov si, passwordmsg
   343 00000268 E88A15                  	call os_print_string
   344 0000026B E83816                  	call os_hide_cursor
   345                                  
   346 0000026E B80B02                  	mov ax, 523
   347 00000271 B90200                  	mov cx, 2
   348 00000274 E8E523                  	call os_speaker_note_length
   349 00000277 B80503                  	mov ax, 773
   350 0000027A B90200                  	mov cx, 2
   351 0000027D E8DC23                  	call os_speaker_note_length
   352 00000280 B86202                  	mov ax, 610
   353 00000283 B90500                  	mov cx, 5
   354 00000286 E8D323                  	call os_speaker_note_length
   355                                  
   356 00000289 E8EE0F                  	call os_wait_for_key
   357                                  	
   358                                  enterpressed:
   359 0000028C E80C16                  	call os_show_cursor
   360 0000028F 803EAADE00              	cmp byte [57002], 0				; Is the password disabled?
   361 00000294 743D                    	je checkformenu				; If it is, continue
   362                                  
   363                                  .try:	
   364 00000296 BA0016                  	mov dx, 22 * 256					; Clean the text on the screen
   365 00000299 E8CA15                  	call os_move_cursor
   366                                  
   367 0000029C B82009                  	mov ax, 0920h
   368 0000029F BB0700                  	mov bx, 7
   369 000002A2 B95000                  	mov cx, 80
   370 000002A5 CD10                    	int 10h
   371                                  	
   372 000002A7 BA0216                  	mov dx, 22 * 256 + 2					; Ask for the password
   373 000002AA E8B915                  	call os_move_cursor
   374 000002AD BE[4A03]                	mov si, passentermsg
   375 000002B0 E84215                  	call os_print_string
   376                                  	
   377 000002B3 B80001                  	mov ax, 100h
   378 000002B6 B307                    	mov bl, 7
   379 000002B8 C606880020              	mov byte [0088h], 32
   380 000002BD E8571F                  	call os_input_password
   381 000002C0 C6068800FF              	mov byte [0088h], 255
   382                                  
   383 000002C5 BE0001                  	mov si, 100h
   384 000002C8 E8B426                  	call os_string_encrypt
   385                                  
   386 000002CB BFABDE                  	mov di, 57003
   387 000002CE E8D427                  	call os_string_compare
   388 000002D1 73C3                    	jnc .try
   389                                  	
   390                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;end LOGO!
   391                                  	
   392                                  checkformenu:
   393 000002D3 E8D015                  	call os_hide_cursor
   394 000002D6 E8F702                  	call background
   395                                  
   396                                  checkformenuloop:	
   397 000002D9 E89E0F                  	call os_wait_for_key
   398 000002DC 3C20                    	cmp al, 32					; Space pressed?
   399 000002DE 0F84C500                	je near option_screen		; Open the menu
   400 000002E2 3C61                    	cmp al, 'a'					; a pressed?
   401 000002E4 0F842402                	je near load_fileman		; Open the file manager
   402 000002E8 EBEF                    	jmp checkformenuloop
   403                                  	
   404 000002EA 202020202020202020-     	ver_msg			db '                                                              v0.7b2',0
   404 000002F3 202020202020202020-
   404 000002FC 202020202020202020-
   404 00000305 202020202020202020-
   404 0000030E 202020202020202020-
   404 00000317 202020202020202020-
   404 00000320 202020202020202076-
   404 00000329 302E37623200       
   405 0000032F 507265737320616E79-     	passwordmsg		db 'Press any key to log in...', 0
   405 00000338 206B657920746F206C-
   405 00000341 6F6720696E2E2E2E00 
   406 0000034A 456E74657220796F75-     	passentermsg		db 'Enter your password: ', 0
   406 00000353 722070617373776F72-
   406 0000035C 643A2000           
   407                                  
   408 00000360 63726570654F532044-     	os_init_msg			db 'crepeOS Desktop', 0
   408 00000369 65736B746F7000     
   409 00000370 5B53706163655D204F-     	os_version_msg		db '[Space] Open the system menu [A] Open the file manager', 0
   409 00000379 70656E207468652073-
   409 00000382 797374656D206D656E-
   409 0000038B 75205B415D204F7065-
   409 00000394 6E207468652066696C-
   409 0000039D 65206D616E61676572-
   409 000003A6 00                 
   410                                  
   411                                  ; TODO: THE FOLLOWING CODE NEEDS TO BE REWRITTEN
   412                                  	
   413                                  option_screen:
   414 000003A7 E83502                  	call menu_background
   415                                  
   416 000003AA B8[4A07]                	mov ax, menuoptions
   417 000003AD BB0D00                  	mov bx, 13
   418 000003B0 E8E720                  	call os_option_menu
   419                                  
   420 000003B3 0F821CFF                	jc checkformenu
   421                                  	
   422 000003B7 83F801                  	cmp ax, 1
   423 000003BA 0F841500                	je near app_selector
   424                                  
   425 000003BE 83F802                  	cmp ax, 2
   426 000003C1 0F848000                	je near game_selector
   427                                  	
   428 000003C5 83F803                  	cmp ax, 3
   429 000003C8 0F846AFE                	je near logoinput
   430                                  	
   431 000003CC 83F804                  	cmp ax, 4
   432 000003CF 0F847E48                	je near os_shutdown
   433                                  
   434                                  app_selector:
   435 000003D3 E80902                  	call menu_background
   436                                  
   437 000003D6 B8[1A08]                	mov ax, progoptions
   438 000003D9 BB1400                  	mov bx, 20
   439 000003DC E8BB20                  	call os_option_menu
   440                                  
   441 000003DF 72C6                    	jc option_screen
   442                                  
   443 000003E1 83F801                  	cmp ax, 1
   444 000003E4 0F842401                	je near load_fileman
   445                                  
   446 000003E8 83F80D                  	cmp ax, 13
   447 000003EB 0F842500                	je near debug_stuff
   448                                  	
   449 000003EF 89C6                    	mov si, ax
   450 000003F1 83EE02                  	sub si, 2
   451 000003F4 D1E6                    	shl si, 1
   452 000003F6 81C6[2B06]              	add si, appindex1
   453 000003FA AD                      	lodsw
   454 000003FB 89C6                    	mov si, ax
   455 000003FD BF0001                  	mov di, 0100h
   456 00000400 E84326                  	call os_string_copy
   457                                  	
   458 00000403 B80001                  	mov ax, 0100h
   459 00000406 BB[F806]                	mov bx, app_prefix
   460 00000409 B9F000                  	mov cx, 00F0h
   461 0000040C E84026                  	call os_string_join
   462                                  	
   463 0000040F 89CB                    	mov bx, cx
   464 00000411 E93201                  	jmp start_program
   465                                  	
   466                                  debug_stuff:
   467 00000414 E8C801                  	call menu_background
   468                                  
   469 00000417 B8[8807]                	mov ax, debugoptions
   470 0000041A BB1F00                  	mov bx, 31
   471 0000041D E87A20                  	call os_option_menu
   472                                  	
   473 00000420 72B1                    	jc app_selector
   474                                  	
   475 00000422 89C6                    	mov si, ax
   476 00000424 4E                      	dec si
   477 00000425 D1E6                    	shl si, 1
   478 00000427 81C6[3F06]              	add si, debugindex1
   479 0000042B AD                      	lodsw
   480 0000042C 89C6                    	mov si, ax
   481 0000042E BF0001                  	mov di, 0100h
   482 00000431 E81226                  	call os_string_copy
   483                                  	
   484 00000434 B80001                  	mov ax, 0100h
   485 00000437 BB[F806]                	mov bx, app_prefix
   486 0000043A B9F000                  	mov cx, 00F0h
   487 0000043D E80F26                  	call os_string_join
   488                                  	
   489 00000440 89CB                    	mov bx, cx
   490 00000442 E90101                  	jmp start_program
   491                                  	
   492                                  	
   493                                  game_selector:
   494 00000445 E89701                  	call menu_background
   495                                  
   496 00000448 B8[6B07]                	mov ax, gameoptions
   497 0000044B BB1300                  	mov bx, 19
   498 0000044E E84920                  	call os_option_menu
   499                                  
   500 00000451 0F8252FF                	jc option_screen
   501                                  
   502 00000455 89C6                    	mov si, ax
   503 00000457 4E                      	dec si
   504 00000458 D1E6                    	shl si, 1
   505 0000045A 81C6[4F06]              	add si, gameindex1
   506 0000045E AD                      	lodsw
   507                                  	
   508                                  launch_program:
   509 0000045F C606FF7F00              	mov byte [32767], 0
   510                                  
   511 00000464 E86901                  	call background
   512                                  	
   513 00000467 60                      	pusha
   514 00000468 89C6                    	mov si, ax
   515 0000046A 89F3                    	mov bx, si
   516 0000046C 89F0                    	mov ax, si
   517 0000046E E84225                  	call os_string_length
   518 00000471 89DE                    	mov si, bx
   519 00000473 01C6                    	add si, ax				; SI now points to end of filename...
   520 00000475 4E                      	dec si
   521 00000476 4E                      	dec si
   522 00000477 4E                      	dec si					; ...and now to start of extension!
   523 00000478 BF[F906]                	mov di, app_ext
   524 0000047B B90300                  	mov cx, 3
   525 0000047E F3A6                    	rep cmpsb				; Are final 3 chars 'APP'?
   526 00000480 7521                    	jne launch_basic		; If not, try 'BAS'
   527 00000482 61                      	popa
   528                                  	
   529 00000483 B90001                  	mov cx, 100h			; Where to load the program file
   530 00000486 E80407                  	call os_load_file		; Load filename pointed to by AX
   531                                  
   532 00000489 0F8246FE                	jc checkformenu
   533                                  	
   534 0000048D 60                      	pusha
   535 0000048E B9FD7E                  	mov cx, 7EFDh
   536 00000491 29D9                    	sub cx, bx
   537 00000493 BF0001                  	mov di, 100h
   538 00000496 01DF                    	add di, bx
   539 00000498 B000                    	mov al, 0
   540 0000049A F3AA                    	rep stosb
   541 0000049C 61                      	popa
   542                                  	
   543 0000049D E8FB13                  	call os_show_cursor
   544                                  	
   545 000004A0 E9CB00                  	jmp execute_bin_program
   546                                  
   547                                  launch_basic:
   548 000004A3 61                      	popa
   549                                  	
   550 000004A4 60                      	pusha
   551 000004A5 89C6                    	mov si, ax
   552 000004A7 89F3                    	mov bx, si
   553 000004A9 89F0                    	mov ax, si
   554 000004AB E80525                  	call os_string_length
   555 000004AE 89DE                    	mov si, bx
   556 000004B0 01C6                    	add si, ax				; SI now points to end of filename...
   557 000004B2 4E                      	dec si
   558 000004B3 4E                      	dec si
   559 000004B4 4E                      	dec si					; ...and now to start of extension!
   560 000004B5 BF[FD06]                	mov di, bas_ext
   561 000004B8 B90300                  	mov cx, 3
   562 000004BB F3A6                    	rep cmpsb				; Are final 3 chars 'BAS'?
   563 000004BD 753A                    	jne program_error		; If not, error out
   564 000004BF 61                      	popa
   565                                  
   566 000004C0 B90001                  	mov cx, 100h			; Where to load the program file
   567 000004C3 E8C706                  	call os_load_file		; Load filename pointed to by AX
   568                                  
   569 000004C6 0F8209FE                	jc checkformenu
   570                                  	
   571 000004CA 60                      	pusha
   572 000004CB B9FD7E                  	mov cx, 7EFDh
   573 000004CE 29D9                    	sub cx, bx
   574 000004D0 BF0001                  	mov di, 100h
   575 000004D3 01DF                    	add di, bx
   576 000004D5 B000                    	mov al, 0
   577 000004D7 F3AA                    	rep stosb
   578 000004D9 61                      	popa
   579                                  
   580 000004DA E8BE13                  	call os_show_cursor
   581                                  	
   582 000004DD B80001                  	mov ax, 100h
   583                                  	clr si
    11 000004E0 31F6                <1>  xor %1, %1
   584 000004E2 E8EC27                  	call os_run_basic
   585                                  
   586 000004E5 BE[3507]                	mov si, basic_finished_msg
   587 000004E8 E80A13                  	call os_print_string
   588 000004EB E88C0D                  	call os_wait_for_key
   589                                  
   590 000004EE E85F13                  	call os_clear_screen
   591                                  	
   592 000004F1 C606820000              	mov byte [0082h], 0
   593                                  	
   594 000004F6 E9DAFD                  	jmp checkformenu
   595                                  	
   596                                  program_error:
   597 000004F9 61                      	popa
   598 000004FA E8D300                  	call background
   599 000004FD B8[F405]                	mov ax, prog_msg
   600                                  	clr bx
    11 00000500 31DB                <1>  xor %1, %1
   601                                  	clr cx
    11 00000502 31C9                <1>  xor %1, %1
   602                                  	clr dx
    11 00000504 31D2                <1>  xor %1, %1
   603 00000506 E82F1B                  	call os_dialog_box
   604 00000509 E9C7FD                  	jmp checkformenu
   605                                  	
   606                                  load_fileman:
   607 0000050C 1E                      	push ds
   608 0000050D 8E1E[F205]              	mov ds, [driversgmt]
   609 00000511 BE0026                  	mov si, FILE_MANAGER
   610 00000514 BF0001                  	mov di, 0100h
   611 00000517 B90010                  	mov cx, 1000h
   612 0000051A F3A4                    	rep movsb
   613 0000051C 1F                      	pop ds
   614 0000051D EB4F                    	jmp execute_bin_program
   615                                  	
   616                                  load_demotour:
   617 0000051F C606830001              	mov byte [0083h], 1
   618 00000524 B8[1407]                	mov ax, demotour_name
   619 00000527 B90001                  	mov cx, 100h
   620 0000052A E86006                  	call os_load_file
   621 0000052D E8DC0F                  	call os_clear_registers
   622 00000530 E8(0001)                	call 100h
   623 00000533 E900FD                  	jmp logoinput
   624                                  	
   625                                  load_command:
   626 00000536 B8[6C06]                	mov ax, cmd_name
   627 00000539 BB[F806]                	mov bx, app_prefix
   628 0000053C B9F000                  	mov cx, 00F0h
   629 0000053F E80D25                  	call os_string_join
   630 00000542 89CB                    	mov bx, cx
   631 00000544 EB00                    	jmp start_program
   632                                  	
   633                                  start_program:				; BX = program name
   634 00000546 60                      	pusha
   635 00000547 B9FD7E                  	mov cx, 7EFDh
   636 0000054A BF0001                  	mov di, 100h
   637 0000054D B000                    	mov al, 0
   638 0000054F F3AA                    	rep stosb
   639 00000551 61                      	popa
   640                                  	
   641 00000552 89D8                    	mov ax, bx
   642 00000554 B90001                  	mov cx, 100h			; Where to load the program file
   643 00000557 E83306                  	call os_load_file		; Load filename pointed to by AX
   644                                  
   645 0000055A 0F828E00                	jc systemfilemissing
   646                                  	
   647 0000055E E83A13                  	call os_show_cursor
   648                                  
   649 00000561 EB0B                    	jmp execute_bin_program
   650                                  	
   651                                  return_to_app:
   652 00000563 B8F000                  	mov ax, 00F0h
   653 00000566 B90001                  	mov cx, 100h			; Where to load the program file
   654 00000569 E82106                  	call os_load_file		; Load filename pointed to by AX
   655                                  
   656 0000056C 727E                    	jc systemfilemissing	
   657                                  
   658                                  execute_bin_program:
   659 0000056E E8DF12                  	call os_clear_screen	; Clear the screen before running
   660                                  
   661 00000571 C606820000              	mov byte [0082h], 0
   662                                  	
   663 00000576 C606[B408]01            	mov byte [app_running], 1
   664                                  
   665 0000057B 8926[B208]              	mov [origstack], sp
   666                                  	
   667 0000057F E88A0F                  	call os_clear_registers
   668                                  	
   669 00000582 E8(0001)                	call 100h	
   670                                  	
   671                                  finish:
   672 00000585 C606[B408]00            	mov byte [app_running], 0
   673                                  	
   674 0000058A E83521                  	call os_stop_adlib		; Reset everything (in case the app crashed or something)
   675 0000058D E8DA20                  	call os_speaker_off
   676                                  
   677 00000590 50                      	push ax
   678 00000591 8CC8                    	mov ax, cs
   679 00000593 8ED8                    	mov ds, ax
   680 00000595 8EC0                    	mov es, ax
   681 00000597 58                      	pop ax
   682                                  	
   683 00000598 60                      	pusha
   684 00000599 B40F                    	mov ah, 0Fh				; Get the current video mode
   685 0000059B CD10                    	int 10h
   686                                  	
   687 0000059D 3C03                    	cmp al, 3
   688 0000059F 7405                    	je .skip_gfx
   689                                  	
   690 000005A1 B80300                  	mov ax, 3
   691 000005A4 CD10                    	int 10h
   692                                  
   693                                  .skip_gfx:
   694 000005A6 B80310                  	mov ax, 1003h			; Set text output with certain attributes
   695                                  	clr bx					; to be bright, and not blinking
    11 000005A9 31DB                <1>  xor %1, %1
   696 000005AB CD10                    	int 10h
   697                                  
   698 000005AD C606820000              	mov byte [0082h], 0
   699 000005B2 C606850000              	mov byte [0085h], 0
   700                                  	
   701 000005B7 E82D1E                  	call os_reset_font
   702 000005BA 61                      	popa
   703                                  	
   704 000005BB 803EFF7F01              	cmp byte [7FFFh], 1
   705 000005C0 0F849BFE                	je near launch_program
   706                                  	
   707 000005C4 803EFE7F01              	cmp byte [7FFEh], 1
   708 000005C9 0F8496FF                	je near return_to_app
   709                                  	
   710 000005CD E903FD                  	jmp checkformenu		; When finished, go back to the program list
   711                                  
   712                                  	
   713                                  ; TODO: THE CODE ABOVE NEEDS TO BE REWRITTEN
   714                                  	
   715                                  background:
   716 000005D0 60                      	pusha
   717 000005D1 B8[6003]                	mov ax, os_init_msg		; Draw main screen layout
   718 000005D4 BB[7003]                	mov bx, os_version_msg
   719 000005D7 B90001                  	mov cx, 256				; Colour: white text on light blue
   720 000005DA E89418                  	call os_draw_background
   721 000005DD 61                      	popa
   722 000005DE C3                      	ret
   723                                  
   724                                  menu_background:
   725 000005DF 60                      	pusha
   726 000005E0 803EEFDE01              	cmp byte [57071], 1
   727 000005E5 7403                    	je .done
   728                                  	
   729 000005E7 E8E6FF                  	call background
   730                                  	
   731                                  .done:
   732 000005EA 61                      	popa
   733 000005EB C3                      	ret
   734                                  	
   735                                  systemfilemissing:
   736 000005EC B8[1506]                	mov ax, noprogerror
   737 000005EF E8AE0F                  	call os_fatal_error
   738                                  	
   739                                  	; And now data for the above code...
   740                                  
   741 000005F2 0000                    	driversgmt				dw 0000h
   742                                  	
   743 000005F4 546869732066696C65-     	prog_msg				db 'This file is not an application.', 0
   743 000005FD 206973206E6F742061-
   743 00000606 6E206170706C696361-
   743 0000060F 74696F6E2E00       
   744                                  
   745 00000615 53797374656D206669-     	noprogerror				db 'System file not found', 0
   745 0000061E 6C65206E6F7420666F-
   745 00000627 756E6400           
   746                                  
   747 0000062B [5506][5A06][6106]-     	appindex1				dw edit_name, viewer_name, calc_name, clock_name, cmd_name, config_name, ascii_name, pixel_name, player_name, hwcheck_name
   747 00000631 [6606][6C06][7506]-
   747 00000637 [7C06][8506][8B06]-
   747 0000063D [9206]             
   748 0000063F [A006][A906][B106]-     	debugindex1				dw debug1_name, debug2_name, debug3_name, debug4_name, debug5_name, debug6_name, debug7_name, debug8_name
   748 00000645 [B906][C106][C706]-
   748 0000064B [CC06][D206]       
   749 0000064F [D906][E006][EC06]      	gameindex1				dw cf_name, hangman_name, tetris_name
   750                                  	
   751 00000655 4544495400              	edit_name				db 'EDIT', 0
   752 0000065A 56494557455200          	viewer_name				db 'VIEWER', 0
   753 00000661 43414C4300              	calc_name				db 'CALC', 0
   754 00000666 434C4F434B00            	clock_name				db 'CLOCK', 0
   755 0000066C 5445524D494E414C00      	cmd_name				db 'TERMINAL', 0
   756 00000675 434F4E46494700          	config_name				db 'CONFIG', 0
   757 0000067C 415343494941525400      	ascii_name				db 'ASCIIART', 0
   758 00000685 504958454C00            	pixel_name				db 'PIXEL', 0
   759 0000068B 504C4159455200          	player_name				db 'PLAYER', 0
   760 00000692 4857434845434B00        	hwcheck_name				db 'HWCHECK', 0
   761 0000069A 41424F555400            	about_name				db 'ABOUT', 0
   762                                  
   763 000006A0 4449534B5445535400      	debug1_name				db 'DISKTEST', 0
   764 000006A9 4B42445445535400        	debug2_name				db 'KBDTEST', 0
   765 000006B1 5254435445535400        	debug3_name				db 'RTCTEST', 0
   766 000006B9 4D454D4544495400        	debug4_name				db 'MEMEDIT', 0
   767 000006C1 424F58455300            	debug5_name				db 'BOXES', 0
   768 000006C7 444F545300              	debug6_name				db 'DOTS', 0
   769 000006CC 524454534300            	debug7_name				db 'RDTSC', 0
   770 000006D2 53544154494300          	debug8_name				db 'STATIC', 0
   771                                  	
   772 000006D9 43462E42415300          	cf_name					db 'CF.BAS', 0
   773 000006E0 48414E474D414E2E41-     	hangman_name				db 'HANGMAN.APP', 0
   773 000006E9 505000             
   774 000006EC 41534D545249532E41-     	tetris_name				db 'ASMTRIS.APP', 0
   774 000006F5 505000             
   775                                  	
   776 000006F8 2E                      	app_prefix				db '.'
   777 000006F9 41505000                	app_ext					db 'APP', 0
   778 000006FD 42415300                	bas_ext					db 'BAS', 0
   779                                  
   780 00000701 42472E53595300          	bg_name					db 'BG.SYS', 0
   781 00000708 46494C454D414E2E41-     	fileman_name				db 'FILEMAN.APP', 0
   781 00000711 505000             
   782 00000714 44454D4F544F55522E-     	demotour_name				db 'DEMOTOUR.APP', 0
   782 0000071D 41505000           
   783 00000721 53595354454D2E4346-     	system_cfg				db 'SYSTEM.CFG', 0
   783 0000072A 4700               
   784 0000072C 464F4E542E53595300      	font_name				db 'FONT.SYS', 0
   785                                  
   786 00000735 42415349432070726F-     	basic_finished_msg		db 'BASIC program ended', 0
   786 0000073E 6772616D20656E6465-
   786 00000747 6400               
   787                                  
   788 00000749 00                      	empty_string			db 0
   789                                  	
   790 0000074A 50726F6772616D732C-     	menuoptions				db 'Programs,Games,Log out,Shut down', 0
   790 00000753 47616D65732C4C6F67-
   790 0000075C 206F75742C53687574-
   790 00000765 20646F776E00       
   791 0000076B 436F736D696320466C-     	gameoptions				db 'Cosmic Flight,Hangman,Tetris', 0
   791 00000774 696768742C48616E67-
   791 0000077D 6D616E2C5465747269-
   791 00000786 7300               
   792 00000788 4469736B2064657465-     	debugoptions			db 'Disk detection test,Keyboard tester,RTC clock tester,Disk Sector inspector,Memory editor,Boxes,Dots,TSC register tester,TV static generator (CGA)', 0
   792 00000791 6374696F6E20746573-
   792 0000079A 742C4B6579626F6172-
   792 000007A3 64207465737465722C-
   792 000007AC 52544320636C6F636B-
   792 000007B5 207465737465722C44-
   792 000007BE 69736B20536563746F-
   792 000007C7 7220696E7370656374-
   792 000007D0 6F722C4D656D6F7279-
   792 000007D9 20656469746F722C42-
   792 000007E2 6F7865732C446F7473-
   792 000007EB 2C5453432072656769-
   792 000007F4 737465722074657374-
   792 000007FD 65722C545620737461-
   792 00000806 7469632067656E6572-
   792 0000080F 61746F722028434741-
   792 00000818 2900               
   793 0000081A 46696C65206D616E61-     	progoptions				db 'File manager,Text editor,Image viewer,Calculator,Clock,Terminal,Settings,ASCII art editor,Pixel art editor,Music player,Hardware checker,Other stuff...', 0
   793 00000823 6765722C5465787420-
   793 0000082C 656469746F722C496D-
   793 00000835 616765207669657765-
   793 0000083E 722C43616C63756C61-
   793 00000847 746F722C436C6F636B-
   793 00000850 2C5465726D696E616C-
   793 00000859 2C53657474696E6773-
   793 00000862 2C4153434949206172-
   793 0000086B 7420656469746F722C-
   793 00000874 506978656C20617274-
   793 0000087D 20656469746F722C4D-
   793 00000886 7573696320706C6179-
   793 0000088F 65722C486172647761-
   793 00000898 726520636865636B65-
   793 000008A1 722C4F746865722073-
   793 000008AA 747566662E2E2E00   
   794                                  	
   795                                  ; ------------------------------------------------------------------
   796                                  ; SYSTEM VARIABLES -- Settings for programs and system calls
   797                                  
   798                                  	; System runtime variables
   799                                  								
   800 000008B2 0000                    	origstack		dw 0		; SP before launching a program
   801                                  
   802 000008B4 00                      	app_running		db 0		; Is a program running?
   803                                  	
   804                                  ;	program_drawn	db 0		; Is the program already drawn by os_draw_background?
   805                                  	
   806                                  ; ------------------------------------------------------------------
   807                                  ; FEATURES -- Code to pull into the kernel
   808                                  
   809                                  	%INCLUDE "drivers/icons.asm"
   810                              <1> 
   811 000008B5 0910                <1> 	bomblogo	db 9, 16
   812 000008B7 000000000020006000  <1> 				db 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00100000b, 00000000b, 01100000b, 00000000b
   813 000008C0 000000000402018000  <1> 				db 00000000b, 00000000b, 00000000b, 00000000b, 00000100b, 00000010b, 00000001b, 10000000b, 00000000b
   814 000008C9 000000000084800000  <1> 				db 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 10000100b, 10000000b, 00000000b, 00000000b
   815 000008D2 0000006AA501508880  <1> 				db 00000000b, 00000000b, 00000000b, 01101010b, 10100101b, 00000001b, 01010000b, 10001000b, 10000000b
   816 000008DB 0000030000A8004000  <1> 				db 00000000b, 00000000b, 00000011b, 00000000b, 00000000b, 10101000b, 00000000b, 01000000b, 00000000b
   817 000008E4 000057540018202400  <1> 				db 00000000b, 00000000b, 01010111b, 01010100b, 00000000b, 00011000b, 00100000b, 00100100b, 00000000b
   818 000008ED 0000FFFC0080200200  <1> 				db 00000000b, 00000000b, 11111111b, 11111100b, 00000000b, 10000000b, 00100000b, 00000010b, 00000000b
   819 000008F6 005FFFFFD400200000  <1> 				db 00000000b, 01011111b, 11111111b, 11111111b, 11010100b, 00000000b, 00100000b, 00000000b, 00000000b
   820 000008FF 01FFFFFFFD00000000  <1> 				db 00000001b, 11111111b, 11111111b, 11111111b, 11111101b, 00000000b, 00000000b, 00000000b, 00000000b
   821 00000908 07FFFFFFFF40000000  <1> 				db 00000111b, 11111111b, 11111111b, 11111111b, 11111111b, 01000000b, 00000000b, 00000000b, 00000000b
   822 00000911 0FFFFFFFFFC0000000  <1> 				db 00001111b, 11111111b, 11111111b, 11111111b, 11111111b, 11000000b, 00000000b, 00000000b, 00000000b
   823 0000091A 0FFFFFFFFFC0000000  <1> 				db 00001111b, 11111111b, 11111111b, 11111111b, 11111111b, 11000000b, 00000000b, 00000000b, 00000000b
   824 00000923 0FFFFFFFFFC0000000  <1> 				db 00001111b, 11111111b, 11111111b, 11111111b, 11111111b, 11000000b, 00000000b, 00000000b, 00000000b
   825 0000092C 03FFFFFFFF00000000  <1> 				db 00000011b, 11111111b, 11111111b, 11111111b, 11111111b, 00000000b, 00000000b, 00000000b, 00000000b
   826 00000935 00FFFFFFFC00000000  <1> 				db 00000000b, 11111111b, 11111111b, 11111111b, 11111100b, 00000000b, 00000000b, 00000000b, 00000000b
   827 0000093E 000AFFFE8000000000  <1> 				db 00000000b, 00001010b, 11111111b, 11111110b, 10000000b, 00000000b, 00000000b, 00000000b, 00000000b
   828                              <1> 
   829 00000947 0408                <1> 	filelogo	db 4, 8
   830 00000949 0EAAD000            <1> 				db 00001110b, 10101010b, 11010000b, 00000000b
   831 0000094D 0C00C900            <1> 				db 00001100b, 00000000b, 11001001b, 00000000b
   832 00000951 0C00AAC0            <1> 				db 00001100b, 00000000b, 10101010b, 11000000b
   833 00000955 0C5500C0            <1> 				db 00001100b, 01010101b, 00000000b, 11000000b
   834 00000959 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
   835 0000095D 0C5554C0            <1> 				db 00001100b, 01010101b, 01010100b, 11000000b
   836 00000961 0C0000C0            <1> 				db 00001100b, 00000000b, 00000000b, 11000000b
   837 00000965 0D5555C0            <1> 				db 00001101b, 01010101b, 01010101b, 11000000b
   838                              <1> 	
   839 00000969 1207                <1> 	logo	db 18, 7
   840 0000096B 00000FFFFF00000000- <1> 				db 00000000b, 00000000b, 00001111b, 11111111b, 11111111b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 11111111b, 00001111b, 11110000b
   840 00000974 000000000000FF0FF0  <1>
   841 0000097D 00000F000000000000- <1> 				db 00000000b, 00000000b, 00001111b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b, 11000011b, 00001111b, 00000000b
   841 00000986 000000000000C30F00  <1>
   842 0000098F 00000F000007FFC7FF- <1> 				db 00000000b, 00000000b, 00001111b, 00000000b, 00000000b, 00000111b, 11111111b, 11000111b, 11111111b, 11110000b, 01111111b, 11110000b, 01111111b, 11111111b, 00000000b, 11000011b, 00001111b, 11110000b
   842 00000998 F07FF07FFF00C30FF0  <1>
   843 000009A1 00000F00000F000F00- <1> 				db 00000000b, 00000000b, 00001111b, 00000000b, 00000000b, 00001111b, 00000000b, 00001111b, 00000000b, 11110000b, 11110000b, 11110000b, 11110000b, 00001111b, 00000000b, 11000011b, 00000000b, 11110000b
   843 000009AA F0F0F0F00F00C300F0  <1>
   844 000009B3 00000F00000F000F0F- <1> 				db 00000000b, 00000000b, 00001111b, 00000000b, 00000000b, 00001111b, 00000000b, 00001111b, 00001111b, 11110000b, 11111111b, 11100000b, 11110000b, 11111111b, 00000000b, 11111111b, 00001111b, 11110000b
   844 000009BC F0FFE0F0FF00FF0FF0  <1>
   845 000009C5 00000F00000F000F00- <1> 				db 00000000b, 00000000b, 00001111b, 00000000b, 00000000b, 00001111b, 00000000b, 00001111b, 00000000b, 00000000b, 11110000b, 00000000b, 11110000b, 00000000b, 00000000b, 00000000b, 00000000b, 00000000b
   845 000009CE 00F000F00000000000  <1>
   846 000009D7 00000FFFFF0F000FFF- <1> 				db 00000000b, 00000000b, 00001111b, 11111111b, 11111111b, 00001111b, 00000000b, 00001111b, 11111111b, 11110000b, 11110000b, 00000000b, 11111111b, 11111111b, 00000000b, 00000000b, 00000000b, 00000000b
   846 000009E0 F0F000FFFF00000000  <1>
   847                              <1> 			
   810                                   	%INCLUDE "drivers/disk.asm"
   811                              <1> ; ==================================================================
   812                              <1> ; FAT12 FLOPPY DISK ROUTINES
   813                              <1> ; ==================================================================
   814                              <1> 
   815                              <1> ; os_report_free_space -- Returns the amount of free space on disk
   816                              <1> ; OUT: AX = Number of sectors free
   817                              <1> 
   818                              <1> os_report_free_space:
   819 000009E9 60                  <1> 	pusha
   820 000009EA C706[340A]0000      <1> 	mov word [.counter], 0
   821 000009F0 C706[360A]0000      <1> 	mov word [.sectors_read], 0
   822                              <1> 	
   823 000009F6 E8AE07              <1> 	call disk_read_fat				; Read the FAT into memory
   824 000009F9 BE00E0              <1> 	mov si, disk_buffer
   825                              <1> 	
   826                              <1> .loop:
   827                              <1> 	; 0 = nothing, 1 = 1st nibble, 2 = 2nd nibble, 3 = 3rd nibble, G = data we don't care about
   828                              <1> 
   829 000009FC 8B04                <1> 	mov ax, [si]					; AX = 3333GGGG11112222
   830 000009FE 8A7C01              <1> 	mov bh, [si + 1]				; BX = GGGG111122223333
   831 00000A01 8A5C02              <1> 	mov bl, [si + 2]
   832                              <1> 	
   833 00000A04 C1C004              <1> 	rol ax, 4						; AX = GGGG111122223333
   834                              <1> 	
   835 00000A07 80E40F              <1> 	and ah, 0Fh						; AX = 0000111122223333
   836 00000A0A 80E70F              <1> 	and bh, 0Fh						; BX = 0000111122223333
   837                              <1> 		
   838 00000A0D 83F800              <1> 	cmp ax, 0
   839 00000A10 7504                <1> 	jne .no_increment_1
   840                              <1> 	
   841 00000A12 FF06[340A]          <1> 	inc word [.counter]
   842                              <1> 	
   843                              <1> .no_increment_1:
   844 00000A16 83FB00              <1> 	cmp bx, 0
   845                              <1> 		
   846 00000A19 7504                <1> 	jne .no_increment_2
   847                              <1> 	
   848 00000A1B FF06[340A]          <1> 	inc word [.counter]
   849                              <1> 	
   850                              <1> .no_increment_2:
   851 00000A1F 83C603              <1> 	add si, 3						; Increment the pointer
   852 00000A22 8306[360A]02        <1> 	add word [.sectors_read], 2		; Increment the counter of sectors
   853                              <1> 	
   854 00000A27 813E[360A]1F0B      <1> 	cmp word [.sectors_read], 2847	; Are we done? (33 of the sectors are the bootloader, FAT and root dir)
   855 00000A2D 7CCD                <1> 	jl .loop
   856                              <1> 	
   857 00000A2F 61                  <1> 	popa
   858 00000A30 A1[340A]            <1> 	mov ax, [.counter]
   859                              <1> 
   860 00000A33 C3                  <1> 	ret
   861                              <1> 	
   862 00000A34 0000                <1> 	.counter		dw 0
   863 00000A36 0000                <1> 	.sectors_read	dw 0
   864                              <1> 	
   865                              <1> ; --------------------------------------------------------------------------
   866                              <1> ; os_read_root -- Get the root directory contents
   867                              <1> ; IN: SI = where to store the root directory; OUT: carry set if error
   868                              <1> 
   869                              <1> os_read_root:
   870 00000A38 60                  <1> 	pusha
   871                              <1> 
   872 00000A39 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   873 00000A3C E80B08              <1> 	call disk_convert_l2hts
   874                              <1> 
   875 00000A3F 8CDB                <1> 	mov bx, ds
   876 00000A41 8EC3                <1> 	mov es, bx
   877 00000A43 89F3                <1> 	mov bx, si
   878                              <1> 
   879 00000A45 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
   880 00000A47 B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
   881                              <1> 
   882 00000A49 60                  <1> 	pusha				; Prepare to enter loop
   883                              <1> 
   884                              <1> 
   885                              <1> .read_root_dir_loop:
   886 00000A4A 61                  <1> 	popa
   887 00000A4B 60                  <1> 	pusha
   888                              <1> 
   889 00000A4C F9                  <1> 	stc				; A few BIOSes do not set properly on error
   890 00000A4D CD13                <1> 	int 13h				; Read sectors
   891                              <1> 
   892 00000A4F 7308                <1> 	jnc .root_dir_finished
   893 00000A51 E8E707              <1> 	call disk_reset_floppy		; Reset controller and try again
   894 00000A54 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
   895                              <1> 
   896 00000A56 61                  <1> 	popa
   897 00000A57 EB04                <1> 	jmp .read_failure		; Fatal double error
   898                              <1> 
   899                              <1> 
   900                              <1> .root_dir_finished:
   901 00000A59 61                  <1> 	popa				; Restore registers from main loop
   902                              <1> 
   903 00000A5A 61                  <1> 	popa				; And restore from start of this system call
   904                              <1> 
   905 00000A5B F8                  <1> 	clc				; Clear carry (for success)
   906 00000A5C C3                  <1> 	ret
   907                              <1> 
   908                              <1> .read_failure:
   909 00000A5D 61                  <1> 	popa
   910                              <1> 
   911 00000A5E F9                  <1> 	stc				; Set carry flag (for failure)
   912 00000A5F C3                  <1> 	ret
   913                              <1> 
   914                              <1> ; ------------------------------------------------------------------
   915                              <1> ; os_get_file_list -- Generate comma-separated string of files on floppy
   916                              <1> ; IN/OUT: AX = location to store zero-terminated filename string,
   917                              <1> ;         If [0087h] = 1, then BX = location of file extension list
   918                              <1> 
   919                              <1> os_get_file_list:
   920 00000A60 60                  <1> 	pusha
   921                              <1> 
   922 00000A61 C606[450B]00        <1> 	mov byte [.num_entries], 0
   923 00000A66 891E[460B]          <1> 	mov [.extension_list], bx
   924                              <1> 	
   925 00000A6A BE[4A0B]            <1> 	mov si, .msg_load
   926 00000A6D E81219              <1> 	call os_print_footer
   927                              <1> 	
   928 00000A70 A3[480B]            <1> 	mov word [.file_list_tmp], ax
   929                              <1> 
   930 00000A73 66B800000000        <1> 	mov eax, 0			; Needed for some older BIOSes
   931                              <1> 
   932 00000A79 E8BF07              <1> 	call disk_reset_floppy		; Just in case disk was changed
   933                              <1> 
   934 00000A7C B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
   935 00000A7F E8C807              <1> 	call disk_convert_l2hts
   936                              <1> 
   937 00000A82 BE00E0              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
   938 00000A85 89F3                <1> 	mov bx, si
   939                              <1> 
   940 00000A87 B80E02              <1> 	mov ax, 2 * 256 + 14	; Params for int 13h: read floppy sectors
   941                              <1> 
   942 00000A8A 60                  <1> 	pusha				; Prepare to enter loop
   943                              <1> 
   944                              <1> 
   945                              <1> .read_root_dir:
   946 00000A8B 61                  <1> 	popa
   947 00000A8C 60                  <1> 	pusha
   948                              <1> 
   949 00000A8D F9                  <1> 	stc
   950 00000A8E CD13                <1> 	int 13h				; Read sectors
   951 00000A90 E8A807              <1> 	call disk_reset_floppy		; Check we've read them OK
   952 00000A93 730B                <1> 	jnc .show_dir_init		; No errors, continue
   953                              <1> 
   954 00000A95 E8A307              <1> 	call disk_reset_floppy		; Error = reset controller and try again
   955 00000A98 73F1                <1> 	jnc .read_root_dir
   956                              <1> 
   957 00000A9A B8[690B]            <1> 	mov ax, .error
   958 00000A9D E8000B              <1> 	call os_fatal_error
   959                              <1> 	
   960                              <1> .show_dir_init:
   961 00000AA0 61                  <1> 	popa
   962                              <1> 
   963 00000AA1 B80000              <1> 	mov ax, 0
   964 00000AA4 BE00E0              <1> 	mov si, disk_buffer		; Data reader from start of filenames
   965                              <1> 
   966 00000AA7 8B3E[480B]          <1> 	mov word di, [.file_list_tmp]	; Name destination buffer
   967                              <1> 
   968                              <1> 
   969                              <1> .start_entry:
   970 00000AAB 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
   971 00000AAE 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
   972 00000AB0 7478                <1> 	je .skip
   973                              <1> 
   974 00000AB2 A808                <1> 	test al, 08h			; Is this a directory entry or volume label?
   975 00000AB4 7574                <1> 	jnz .skip			; Yes, ignore it
   976                              <1> 
   977 00000AB6 8A04                <1> 	mov al, [si]
   978 00000AB8 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
   979 00000ABA 746E                <1> 	je .skip
   980                              <1> 
   981 00000ABC 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
   982 00000ABE 7470                <1> 	je .done
   983                              <1> 	
   984 00000AC0 B90100              <1> 	mov cx, 1			; Set char counter
   985 00000AC3 89F2                <1> 	mov dx, si			; Beginning of possible entry
   986                              <1> 
   987                              <1> .testdirentry:
   988 00000AC5 46                  <1> 	inc si
   989 00000AC6 8A04                <1> 	mov al, [si]			; Test for most unusable characters
   990 00000AC8 3C20                <1> 	cmp al, ' '			; Windows sometimes puts 0 (UTF-8) or 0FFh
   991 00000ACA 7C5C                <1> 	jl .nxtdirentry
   992 00000ACC 3C7E                <1> 	cmp al, '~'
   993 00000ACE 7758                <1> 	ja .nxtdirentry
   994                              <1> 
   995 00000AD0 41                  <1> 	inc cx
   996 00000AD1 83F90B              <1> 	cmp cx, 11			; Done 11 char filename?
   997 00000AD4 7402                <1> 	je .gotfilename
   998 00000AD6 EBED                <1> 	jmp .testdirentry
   999                              <1> 
  1000                              <1> 
  1001                              <1> .gotfilename:				; Got a filename that passes testing
  1002 00000AD8 89D6                <1> 	mov si, dx			; DX = where getting string
  1003                              <1> 
  1004 00000ADA 803E870001          <1> 	cmp byte [0087h], 1
  1005 00000ADF 7522                <1> 	jne .no_extension_check
  1006                              <1> 	
  1007 00000AE1 8B1E[460B]          <1> 	mov bx, [.extension_list]
  1008 00000AE5 0FB60F              <1> 	movzx cx, byte [bx]
  1009                              <1> 
  1010                              <1> .extension_loop:
  1011 00000AE8 60                  <1> 	pusha
  1012 00000AE9 83C608              <1> 	add si, 8
  1013                              <1> 	
  1014 00000AEC 49                  <1> 	dec cx
  1015 00000AED 89CF                <1> 	mov di, cx
  1016 00000AEF C1E702              <1> 	shl di, 2	; Each entry is 4 bytes long
  1017 00000AF2 47                  <1> 	inc di		; The entry list starts with a 1-byte header
  1018 00000AF3 033E[460B]          <1> 	add di, [.extension_list]	
  1019                              <1> 	
  1020 00000AF7 B90300              <1> 	mov cx, 3
  1021 00000AFA F3A6                <1> 	rep cmpsb
  1022 00000AFC 61                  <1> 	popa
  1023 00000AFD 7404                <1> 	je .no_extension_check
  1024                              <1> 	
  1025 00000AFF E2E7                <1> 	loop .extension_loop
  1026                              <1> 	
  1027 00000B01 EB25                <1> 	jmp .nxtdirentry
  1028                              <1> 	
  1029                              <1> .no_extension_check:
  1030 00000B03 31C9                <1> 	xor cx, cx
  1031                              <1> 	
  1032                              <1> .loopy:
  1033 00000B05 AC                  <1> 	lodsb
  1034 00000B06 3C20                <1> 	cmp al, ' '
  1035 00000B08 7401                <1> 	je .ignore_space
  1036 00000B0A AA                  <1> 	stosb
  1037                              <1> 	
  1038                              <1> .ignore_space:
  1039 00000B0B 41                  <1> 	inc cx
  1040 00000B0C 83F908              <1> 	cmp cx, 8
  1041 00000B0F 7407                <1> 	je .add_dot
  1042 00000B11 83F90B              <1> 	cmp cx, 11
  1043 00000B14 7409                <1> 	je .done_copy
  1044 00000B16 EBED                <1> 	jmp .loopy
  1045                              <1> 
  1046                              <1> .add_dot:
  1047 00000B18 26C6052E            <1> 	mov byte [es:di], '.'
  1048 00000B1C 47                  <1> 	inc di
  1049 00000B1D EBE6                <1> 	jmp .loopy
  1050                              <1> 
  1051                              <1> .done_copy:
  1052 00000B1F 26C6052C            <1> 	mov byte [es:di], ','		; Use comma to separate filenames
  1053 00000B23 47                  <1> 	inc di
  1054 00000B24 FE06[450B]          <1> 	inc byte [.num_entries]
  1055                              <1> 	
  1056                              <1> .nxtdirentry:
  1057 00000B28 89D6                <1> 	mov si, dx			; Start of entry, pretend to skip to next
  1058                              <1> 
  1059                              <1> .skip:
  1060 00000B2A 83C620              <1> 	add si, 32			; Shift to next 32 bytes (next filename)
  1061 00000B2D E97BFF              <1> 	jmp .start_entry
  1062                              <1> 
  1063                              <1> 
  1064                              <1> .done:
  1065 00000B30 803E[450B]00        <1> 	cmp byte [.num_entries], 0
  1066 00000B35 7401                <1> 	je .no_dec
  1067                              <1> 	
  1068 00000B37 4F                  <1> 	dec di
  1069                              <1> 
  1070                              <1> .no_dec:
  1071 00000B38 26C60500            <1> 	mov byte [es:di], 0		; Zero-terminate string (gets rid of final comma)
  1072                              <1> 
  1073 00000B3C 60                  <1> 	pusha
  1074 00000B3D 31F6                <1> 	xor si, si
  1075 00000B3F E84018              <1> 	call os_print_footer
  1076 00000B42 61                  <1> 	popa
  1077                              <1> 
  1078 00000B43 61                  <1> 	popa
  1079                              <1> 
  1080 00000B44 C3                  <1> 	ret
  1081                              <1> 
  1082 00000B45 00                  <1> 	.num_entries		db 0
  1083 00000B46 0000                <1> 	.extension_list		dw 0
  1084 00000B48 0000                <1> 	.file_list_tmp		dw 0
  1085 00000B4A 2052656164696E6720- <1> 	.msg_load			db ' Reading directory contents...', 0
  1085 00000B53 6469726563746F7279- <1>
  1085 00000B5C 20636F6E74656E7473- <1>
  1085 00000B65 2E2E2E00            <1>
  1086 00000B69 6F735F6765745F6669- <1> 	.error				db 'os_get_file_list: Floppy reset fail', 0
  1086 00000B72 6C655F6C6973743A20- <1>
  1086 00000B7B 466C6F707079207265- <1>
  1086 00000B84 736574206661696C00  <1>
  1087                              <1> 	
  1088                              <1> ; ------------------------------------------------------------------
  1089                              <1> ; os_load_file -- Load a file into RAM
  1090                              <1> ; IN: AX = location of filename, ES:CX = location in RAM to load file
  1091                              <1> ; OUT: BX = file size (in bytes), carry set if file not found
  1092                              <1> 
  1093                              <1> os_load_file:
  1094 00000B8D 06                  <1> 	push es
  1095 00000B8E 8C06[E30C]          <1> 	mov [.old_segment], es
  1096                              <1> 
  1097 00000B92 0E                  <1> 	push cs
  1098 00000B93 07                  <1> 	pop es
  1099                              <1> 	
  1100 00000B94 E8751E              <1> 	call os_string_uppercase
  1101                              <1> 
  1102 00000B97 60                  <1> 	pusha							; Message display routine
  1103 00000B98 89C3                <1> 	mov bx, ax
  1104 00000B9A B8[E50C]            <1> 	mov ax, .msg_load
  1105 00000B9D B95200              <1> 	mov cx, 82
  1106 00000BA0 E8AC1E              <1> 	call os_string_join
  1107 00000BA3 BE5200              <1> 	mov si, 82
  1108 00000BA6 E8D917              <1> 	call os_print_footer
  1109 00000BA9 61                  <1> 	popa
  1110                              <1> 	
  1111 00000BAA E83D05              <1> 	call int_filename_convert
  1112                              <1> 
  1113 00000BAD A3[BB0C]            <1> 	mov [.filename_loc], ax		; Store filename location
  1114 00000BB0 890E[BD0C]          <1> 	mov [.load_position], cx	; And where to load the file!
  1115                              <1> 
  1116 00000BB4 6631C0              <1> 	xor eax, eax			; Needed for some older BIOSes
  1117                              <1> 
  1118 00000BB7 E88106              <1> 	call disk_reset_floppy		; In case floppy has been changed
  1119 00000BBA 7306                <1> 	jnc .floppy_ok			; Did the floppy reset OK?
  1120                              <1> 
  1121 00000BBC B8[C30C]            <1> 	mov ax, .err_msg_floppy_reset	; If not, bail out
  1122 00000BBF E9DE09              <1> 	jmp os_fatal_error
  1123                              <1> 
  1124                              <1> 
  1125                              <1> .floppy_ok:				; Ready to read first block of data
  1126 00000BC2 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  1127 00000BC5 E88206              <1> 	call disk_convert_l2hts
  1128                              <1> 
  1129 00000BC8 BE00E0              <1> 	mov si, disk_buffer		; ES:BX should point to our buffer
  1130 00000BCB 89F3                <1> 	mov bx, si
  1131                              <1> 
  1132 00000BCD B80E02              <1> 	mov ax, 2 * 256 + 14	; Params for int 13h: read floppy sectors
  1133                              <1> 
  1134 00000BD0 60                  <1> 	pusha				; Prepare to enter loop
  1135                              <1> 
  1136                              <1> 
  1137                              <1> .read_root_dir:
  1138 00000BD1 61                  <1> 	popa
  1139 00000BD2 60                  <1> 	pusha
  1140                              <1> 
  1141 00000BD3 F9                  <1> 	stc				; A few BIOSes clear, but don't set properly
  1142                              <1> 	
  1143 00000BD4 CD13                <1> 	int 13h				; Read sectors
  1144 00000BD6 7308                <1> 	jnc .search_root_dir		; No errors = continue
  1145                              <1> 
  1146 00000BD8 E86006              <1> 	call disk_reset_floppy		; Problem = reset controller and try again
  1147 00000BDB 73F4                <1> 	jnc .read_root_dir
  1148                              <1> 
  1149 00000BDD 61                  <1> 	popa
  1150 00000BDE EB38                <1> 	jmp .root_problem		; Double error = exit
  1151                              <1> 
  1152                              <1> .search_root_dir:
  1153 00000BE0 61                  <1> 	popa
  1154                              <1> 
  1155 00000BE1 B9E000              <1> 	mov cx, 224		; Search all entries in root dir
  1156 00000BE4 BBE0FF              <1> 	mov bx, -32			; Begin searching at offset 0 in root dir
  1157                              <1> 
  1158                              <1> .next_root_entry:
  1159 00000BE7 83C320              <1> 	add bx, 32			; Bump searched entries by 1 (offset + 32 bytes)
  1160 00000BEA BF00E0              <1> 	mov di, disk_buffer		; Point root dir at next entry
  1161 00000BED 01DF                <1> 	add di, bx
  1162                              <1> 
  1163 00000BEF 8A05                <1> 	mov al, [di]			; First character of name
  1164                              <1> 
  1165 00000BF1 3C00                <1> 	cmp al, 0			; Last file name already checked?
  1166 00000BF3 7423                <1> 	je .root_problem
  1167                              <1> 
  1168 00000BF5 3CE5                <1> 	cmp al, 229			; Was this file deleted?
  1169 00000BF7 74EE                <1> 	je .next_root_entry		; If yes, skip it
  1170                              <1> 
  1171 00000BF9 8A450B              <1> 	mov al, [di+11]			; Get the attribute byte
  1172                              <1> 
  1173 00000BFC 3C0F                <1> 	cmp al, 0Fh			; Is this a special Windows entry?
  1174 00000BFE 74E7                <1> 	je .next_root_entry
  1175                              <1> 
  1176 00000C00 A818                <1> 	test al, 18h			; Is this a directory entry or volume label?
  1177 00000C02 75E3                <1> 	jnz .next_root_entry
  1178                              <1> 
  1179 00000C04 C6450B00            <1> 	mov byte [di+11], 0		; Add a terminator to directory name entry
  1180                              <1> 
  1181 00000C08 89F8                <1> 	mov ax, di			; Convert root buffer name to upper case
  1182 00000C0A E8FF1D              <1> 	call os_string_uppercase
  1183                              <1> 
  1184 00000C0D 8B36[BB0C]          <1> 	mov si, [.filename_loc]		; DS:SI = location of filename to load
  1185                              <1> 
  1186 00000C11 E8911E              <1> 	call os_string_compare		; Current entry same as requested?
  1187 00000C14 7208                <1> 	jc .found_file_to_load
  1188                              <1> 
  1189 00000C16 E2CF                <1> 	loop .next_root_entry
  1190                              <1> 
  1191                              <1> .root_problem:
  1192 00000C18 BB0000              <1> 	mov bx, 0			; If file not found or major disk error,
  1193 00000C1B 07                  <1> 	pop es
  1194                              <1> 
  1195 00000C1C F9                  <1> 	stc				; return with size = 0 and carry set
  1196 00000C1D C3                  <1> 	ret
  1197                              <1> 
  1198                              <1> 
  1199                              <1> .found_file_to_load:			; Now fetch cluster and load FAT into RAM
  1200 00000C1E 668B451C            <1> 	mov eax, [di+28]			; Store file size to return to calling routine
  1201 00000C22 66A3[BF0C]          <1> 	mov [.file_size], eax
  1202                              <1> 
  1203 00000C26 6683F800            <1> 	cmp eax, 0			; If the file size is zero, don't bother trying
  1204 00000C2A 747B                <1> 	je .end				; to read more clusters
  1205                              <1> 
  1206 00000C2C 8B451A              <1> 	mov ax, [di+26]			; Now fetch cluster and load FAT into RAM
  1207 00000C2F A3[B70C]            <1> 	mov word [.cluster], ax
  1208                              <1> 
  1209 00000C32 B80100              <1> 	mov ax, 1			; Sector 1 = first sector of first FAT
  1210 00000C35 E81206              <1> 	call disk_convert_l2hts
  1211                              <1> 
  1212 00000C38 BB00E0              <1> 	mov bx, disk_buffer		; ES:BX points to our buffer
  1213                              <1> 
  1214 00000C3B B402                <1> 	mov ah, 2			; int 13h params: read sectors
  1215 00000C3D B009                <1> 	mov al, 9			; And read 9 of them
  1216                              <1> 
  1217 00000C3F 60                  <1> 	pusha
  1218                              <1> 
  1219                              <1> .read_fat:
  1220 00000C40 61                  <1> 	popa				; In case registers altered by int 13h
  1221 00000C41 60                  <1> 	pusha
  1222                              <1> 
  1223 00000C42 F9                  <1> 	stc
  1224 00000C43 CD13                <1> 	int 13h
  1225 00000C45 7308                <1> 	jnc .read_fat_ok
  1226                              <1> 
  1227 00000C47 E8F105              <1> 	call disk_reset_floppy
  1228 00000C4A 73F4                <1> 	jnc .read_fat
  1229                              <1> 
  1230 00000C4C 61                  <1> 	popa
  1231 00000C4D EBC9                <1> 	jmp .root_problem
  1232                              <1> 
  1233                              <1> 
  1234                              <1> .read_fat_ok:
  1235 00000C4F 61                  <1> 	popa
  1236                              <1> 
  1237                              <1> 
  1238                              <1> .load_file_sector:
  1239 00000C50 A1[B70C]            <1> 	mov ax, word [.cluster]		; Convert sector to logical
  1240 00000C53 83C01F              <1> 	add ax, 31
  1241                              <1> 
  1242 00000C56 E8F105              <1> 	call disk_convert_l2hts		; Make appropriate params for int 13h
  1243                              <1> 
  1244 00000C59 8B1E[BD0C]          <1> 	mov bx, [.load_position]
  1245 00000C5D 8E06[E30C]          <1> 	mov es, [.old_segment]
  1246                              <1> 
  1247 00000C61 B80102              <1> 	mov ax, 0201h			; AH = read sectors, AL = just read 1
  1248                              <1> 
  1249 00000C64 F9                  <1> 	stc
  1250 00000C65 CD13                <1> 	int 13h
  1251                              <1> 
  1252 00000C67 0E                  <1> 	push cs
  1253 00000C68 07                  <1> 	pop es
  1254                              <1> 	
  1255 00000C69 730B                <1> 	jnc .calculate_next_cluster	; If there's no error...
  1256                              <1> 
  1257 00000C6B E8CD05              <1> 	call disk_reset_floppy		; Otherwise, reset floppy and retry
  1258 00000C6E 73E0                <1> 	jnc .load_file_sector
  1259                              <1> 
  1260 00000C70 B8[C30C]            <1> 	mov ax, .err_msg_floppy_reset	; Reset failed, bail out
  1261 00000C73 E92A09              <1> 	jmp os_fatal_error
  1262                              <1> 
  1263                              <1> 
  1264                              <1> .calculate_next_cluster:
  1265 00000C76 A1[B70C]            <1> 	mov ax, [.cluster]
  1266 00000C79 BB0300              <1> 	mov bx, 3
  1267 00000C7C F7E3                <1> 	mul bx
  1268 00000C7E BB0200              <1> 	mov bx, 2
  1269 00000C81 F7F3                <1> 	div bx				; DX = [CLUSTER] mod 2
  1270 00000C83 BE00E0              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
  1271 00000C86 01C6                <1> 	add si, ax
  1272 00000C88 3E8B04              <1> 	mov ax, word [ds:si]
  1273                              <1> 
  1274 00000C8B 83FA00              <1> 	cmp dx, 0			; If DX = 0 [CLUSTER] = even, if DX = 1 then odd
  1275 00000C8E 7405                <1> 	je .even			; If [CLUSTER] = even, drop last 4 bits of word
  1276                              <1> 					; with next cluster; if odd, drop first 4 bits
  1277                              <1> 
  1278                              <1> .odd:
  1279 00000C90 C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (belong to another entry)
  1280 00000C93 EB03                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
  1281                              <1> 
  1282                              <1> .even:
  1283 00000C95 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits
  1284                              <1> 
  1285                              <1> .calculate_cluster_cont:
  1286 00000C98 A3[B70C]            <1> 	mov word [.cluster], ax		; Store cluster
  1287                              <1> 
  1288 00000C9B 3DF80F              <1> 	cmp ax, 0FF8h
  1289 00000C9E 7D07                <1> 	jge .end
  1290                              <1> 
  1291 00000CA0 8306[E30C]20        <1> 	add word [.old_segment], 512 / 16
  1292 00000CA5 EBA9                <1> 	jmp .load_file_sector		; Onto next sector!
  1293                              <1> 
  1294                              <1> 
  1295                              <1> .end:
  1296 00000CA7 668B1E[BF0C]        <1> 	mov ebx, [.file_size]		; Get file size to pass back in BX
  1297 00000CAC 60                  <1> 	pusha
  1298 00000CAD 31F6                <1> 	xor si, si
  1299 00000CAF E8D016              <1> 	call os_print_footer
  1300 00000CB2 61                  <1> 	popa
  1301 00000CB3 07                  <1> 	pop es
  1302                              <1> 
  1303 00000CB4 F8                  <1> 	clc				; Carry clear = good load
  1304 00000CB5 C3                  <1> 	ret
  1305                              <1> 
  1306                              <1> 
  1307 00000CB6 00                  <1> 	.bootd					db 0 		; Boot device number
  1308 00000CB7 0000                <1> 	.cluster				dw 0 		; Cluster of the file we want to load
  1309 00000CB9 0000                <1> 	.pointer				dw 0 		; Pointer into disk_buffer, for loading 'file2load'
  1310                              <1> 
  1311 00000CBB 0000                <1> 	.filename_loc			dw 0		; Temporary store of filename location
  1312 00000CBD 0000                <1> 	.load_position			dw 0		; Where we'll load the file
  1313 00000CBF 00000000            <1> 	.file_size				dd 0		; Size of the file
  1314                              <1> 
  1315 00000CC3 6F735F6C6F61645F66- <1> 	.err_msg_floppy_reset	db 'os_load_file: Floppy reset fail', 0
  1315 00000CCC 696C653A20466C6F70- <1>
  1315 00000CD5 707920726573657420- <1>
  1315 00000CDE 6661696C00          <1>
  1316                              <1> 
  1317 00000CE3 0000                <1> 	.old_segment			dw 0
  1318                              <1> 	
  1319 00000CE5 204C6F6164696E6720- <1> 	.msg_load				db ' Loading ', 0
  1319 00000CEE 00                  <1>
  1320                              <1> 	
  1321                              <1> ; --------------------------------------------------------------------------
  1322                              <1> ; os_write_file -- Save (max 64K) file to disk
  1323                              <1> ; IN: AX = filename, ES:BX = data location, CX = bytes to write
  1324                              <1> ; OUT: Carry clear if OK, set if failure
  1325                              <1> 
  1326                              <1> os_write_file:
  1327 00000CEF 60                  <1> 	pusha
  1328                              <1> 	
  1329 00000CF0 8C06[C60E]          <1> 	mov [.old_segment], es
  1330                              <1> 	
  1331 00000CF4 0E                  <1> 	push cs
  1332 00000CF5 07                  <1> 	pop es
  1333                              <1> 		
  1334 00000CF6 60                  <1> 	pusha							; Message display routine
  1335 00000CF7 89C3                <1> 	mov bx, ax
  1336 00000CF9 B8[C80E]            <1> 	mov ax, .msg_save
  1337 00000CFC B95200              <1> 	mov cx, 82
  1338 00000CFF E84D1D              <1> 	call os_string_join
  1339 00000D02 BE5200              <1> 	mov si, 82
  1340 00000D05 E87A16              <1> 	call os_print_footer
  1341 00000D08 61                  <1> 	popa
  1342                              <1> 
  1343 00000D09 89C6                <1> 	mov si, ax
  1344 00000D0B E8A51C              <1> 	call os_string_length
  1345 00000D0E 83F800              <1> 	cmp ax, 0
  1346 00000D11 0F849601            <1> 	je near .failure
  1347 00000D15 89F0                <1> 	mov ax, si
  1348                              <1> 
  1349 00000D17 E8F21C              <1> 	call os_string_uppercase
  1350                              <1> 
  1351 00000D1A E8CD03              <1> 	call int_filename_convert	; Make filename FAT12-style
  1352 00000D1D 0F828A01            <1> 	jc near .failure
  1353                              <1> 
  1354 00000D21 890E[BA0E]          <1> 	mov word [.filesize], cx
  1355 00000D25 891E[C00E]          <1> 	mov word [.location], bx
  1356 00000D29 A3[C40E]            <1> 	mov word [.filename], ax
  1357                              <1> 
  1358 00000D2C E8A201              <1> 	call os_file_exists		; Don't overwrite a file if it exists!
  1359 00000D2F 0F837801            <1> 	jnc near .failure
  1360                              <1> 
  1361                              <1> 
  1362                              <1> 	; First, zero out the .free_clusters list from any previous execution
  1363 00000D33 60                  <1> 	pusha
  1364                              <1> 
  1365 00000D34 BF00FF              <1> 	mov di, .free_clusters
  1366 00000D37 B98000              <1> 	mov cx, 128
  1367                              <1> .clean_free_loop:
  1368 00000D3A C7050000            <1> 	mov word [di], 0
  1369 00000D3E 47                  <1> 	inc di
  1370 00000D3F 47                  <1> 	inc di
  1371 00000D40 E2F8                <1> 	loop .clean_free_loop
  1372                              <1> 
  1373 00000D42 61                  <1> 	popa
  1374                              <1> 
  1375                              <1> 
  1376                              <1> 	; Next, we need to calculate now many 512 byte clusters are required
  1377                              <1> 
  1378 00000D43 89C8                <1> 	mov ax, cx
  1379 00000D45 31D2                <1> 	xor dx, dx
  1380 00000D47 BB0002              <1> 	mov bx, 512			; Divide file size by 512 to get clusters needed
  1381 00000D4A F7F3                <1> 	div bx
  1382 00000D4C 83FA00              <1> 	cmp dx, 0
  1383 00000D4F 7F02                <1> 	jg .add_a_bit			; If there's a remainder, we need another cluster
  1384 00000D51 EB03                <1> 	jmp .carry_on
  1385                              <1> 
  1386                              <1> .add_a_bit:
  1387 00000D53 83C001              <1> 	add ax, 1
  1388                              <1> .carry_on:
  1389                              <1> 
  1390 00000D56 A3[C20E]            <1> 	mov word [.clusters_needed], ax
  1391                              <1> 
  1392 00000D59 A1[C40E]            <1> 	mov word ax, [.filename]	; Get filename back
  1393                              <1> 
  1394 00000D5C E89301              <1> 	call os_create_file		; Create empty root dir entry for this file
  1395 00000D5F 0F824801            <1> 	jc near .failure		; If we can't write to the media, jump out
  1396                              <1> 
  1397 00000D63 8B1E[BA0E]          <1> 	mov word bx, [.filesize]
  1398 00000D67 83FB00              <1> 	cmp bx, 0
  1399 00000D6A 0F842F01            <1> 	je near .finished
  1400                              <1> 
  1401 00000D6E E83604              <1> 	call disk_read_fat		; Get FAT copy into RAM
  1402 00000D71 BE03E0              <1> 	mov si, disk_buffer + 3		; And point SI at it (skipping first two clusters)
  1403                              <1> 
  1404 00000D74 BB0200              <1> 	mov bx, 2			; Current cluster counter
  1405 00000D77 8B0E[C20E]          <1> 	mov word cx, [.clusters_needed]
  1406 00000D7B 31D2                <1> 	xor dx, dx			; Offset in .free_clusters list
  1407                              <1> 
  1408                              <1> .find_free_cluster:
  1409 00000D7D AD                  <1> 	lodsw				; Get a word
  1410 00000D7E 25FF0F              <1> 	and ax, 0FFFh			; Mask out for even
  1411 00000D81 740D                <1> 	jz .found_free_even		; Free entry?
  1412                              <1> 
  1413                              <1> .more_odd:
  1414 00000D83 43                  <1> 	inc bx				; If not, bump our counter
  1415 00000D84 4E                  <1> 	dec si				; 'lodsw' moved on two chars; we only want to move on one
  1416                              <1> 
  1417 00000D85 AD                  <1> 	lodsw				; Get word
  1418 00000D86 C1E804              <1> 	shr ax, 4			; Shift for odd
  1419 00000D89 09C0                <1> 	or ax, ax			; Free entry?
  1420 00000D8B 7413                <1> 	jz .found_free_odd
  1421                              <1> 
  1422                              <1> .more_even:
  1423 00000D8D 43                  <1> 	inc bx				; If not, keep going
  1424 00000D8E EBED                <1> 	jmp .find_free_cluster
  1425                              <1> 
  1426                              <1> 
  1427                              <1> .found_free_even:
  1428 00000D90 56                  <1> 	push si
  1429 00000D91 BE00FF              <1> 	mov si, .free_clusters		; Store cluster
  1430 00000D94 01D6                <1> 	add si, dx
  1431 00000D96 891C                <1> 	mov word [si], bx
  1432 00000D98 5E                  <1> 	pop si
  1433                              <1> 
  1434 00000D99 49                  <1> 	dec cx				; Got all the clusters we need?
  1435 00000D9A E314                <1> 	jcxz .finished_list
  1436                              <1> 
  1437 00000D9C 42                  <1> 	inc dx				; Next word in our list
  1438 00000D9D 42                  <1> 	inc dx
  1439 00000D9E EBE3                <1> 	jmp .more_odd
  1440                              <1> 
  1441                              <1> .found_free_odd:
  1442 00000DA0 56                  <1> 	push si
  1443 00000DA1 BE00FF              <1> 	mov si, .free_clusters		; Store cluster
  1444 00000DA4 01D6                <1> 	add si, dx
  1445 00000DA6 891C                <1> 	mov word [si], bx
  1446 00000DA8 5E                  <1> 	pop si
  1447                              <1> 
  1448 00000DA9 49                  <1> 	dec cx
  1449 00000DAA E304                <1> 	jcxz .finished_list
  1450                              <1> 
  1451 00000DAC 42                  <1> 	inc dx				; Next word in our list
  1452 00000DAD 42                  <1> 	inc dx
  1453 00000DAE EBDD                <1> 	jmp .more_even
  1454                              <1> 
  1455                              <1> 
  1456                              <1> 
  1457                              <1> .finished_list:
  1458                              <1> 
  1459                              <1> 	; Now the .free_clusters table contains a series of numbers (words)
  1460                              <1> 	; that correspond to free clusters on the disk; the next job is to
  1461                              <1> 	; create a cluster chain in the FAT for our file
  1462                              <1> 
  1463 00000DB0 31C9                <1> 	xor cx, cx			; .free_clusters offset counter
  1464 00000DB2 C706[BE0E]0100      <1> 	mov word [.count], 1		; General cluster counter
  1465                              <1> 
  1466                              <1> .chain_loop:
  1467 00000DB8 A1[BE0E]            <1> 	mov word ax, [.count]		; Is this the last cluster?
  1468 00000DBB 3B06[C20E]          <1> 	cmp word ax, [.clusters_needed]
  1469 00000DBF 7454                <1> 	je .last_cluster
  1470                              <1> 
  1471 00000DC1 BF00FF              <1> 	mov di, .free_clusters
  1472                              <1> 
  1473 00000DC4 01CF                <1> 	add di, cx
  1474 00000DC6 8B1D                <1> 	mov word bx, [di]		; Get cluster
  1475                              <1> 
  1476 00000DC8 89D8                <1> 	mov ax, bx			; Find out if it's an odd or even cluster
  1477 00000DCA 31D2                <1> 	xor dx, dx
  1478 00000DCC BB0300              <1> 	mov bx, 3
  1479 00000DCF F7E3                <1> 	mul bx
  1480 00000DD1 BB0200              <1> 	mov bx, 2
  1481 00000DD4 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
  1482 00000DD6 BE00E0              <1> 	mov si, disk_buffer
  1483 00000DD9 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
  1484 00000DDB 3E8B04              <1> 	mov ax, word [ds:si]
  1485                              <1> 
  1486 00000DDE 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
  1487 00000DE0 741B                <1> 	jz .even
  1488                              <1> 
  1489                              <1> .odd:
  1490 00000DE2 83E00F              <1> 	and ax, 000Fh			; Zero out bits we want to use
  1491 00000DE5 BF00FF              <1> 	mov di, .free_clusters
  1492 00000DE8 01CF                <1> 	add di, cx			; Get offset in .free_clusters
  1493 00000DEA 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT cluster
  1494 00000DED C1E304              <1> 	shl bx, 4			; And convert it into right format for FAT
  1495 00000DF0 01D8                <1> 	add ax, bx
  1496                              <1> 
  1497 00000DF2 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
  1498                              <1> 
  1499 00000DF5 FF06[BE0E]          <1> 	inc word [.count]
  1500 00000DF9 41                  <1> 	inc cx				; Move on a word in .free_clusters
  1501 00000DFA 41                  <1> 	inc cx
  1502                              <1> 
  1503 00000DFB EBBB                <1> 	jmp .chain_loop
  1504                              <1> 
  1505                              <1> .even:
  1506 00000DFD 2500F0              <1> 	and ax, 0F000h			; Zero out bits we want to use
  1507 00000E00 BF00FF              <1> 	mov di, .free_clusters
  1508 00000E03 01CF                <1> 	add di, cx			; Get offset in .free_clusters
  1509 00000E05 8B5D02              <1> 	mov word bx, [di+2]		; Get number of NEXT free cluster
  1510                              <1> 
  1511 00000E08 01D8                <1> 	add ax, bx
  1512                              <1> 
  1513 00000E0A 3E8904              <1> 	mov word [ds:si], ax		; Store cluster data back in FAT copy in RAM
  1514                              <1> 
  1515 00000E0D FF06[BE0E]          <1> 	inc word [.count]
  1516 00000E11 41                  <1> 	inc cx				; Move on a word in .free_clusters
  1517 00000E12 41                  <1> 	inc cx
  1518                              <1> 
  1519 00000E13 EBA3                <1> 	jmp .chain_loop
  1520                              <1> 
  1521                              <1> 
  1522                              <1> 
  1523                              <1> .last_cluster:
  1524 00000E15 BF00FF              <1> 	mov di, .free_clusters
  1525 00000E18 01CF                <1> 	add di, cx
  1526 00000E1A 8B1D                <1> 	mov word bx, [di]		; Get cluster
  1527                              <1> 
  1528 00000E1C 89D8                <1> 	mov ax, bx
  1529                              <1> 
  1530 00000E1E 31D2                <1> 	xor dx, dx
  1531 00000E20 BB0300              <1> 	mov bx, 3
  1532 00000E23 F7E3                <1> 	mul bx
  1533 00000E25 BB0200              <1> 	mov bx, 2
  1534 00000E28 F7F3                <1> 	div bx				; DX = [.cluster] mod 2
  1535 00000E2A BE00E0              <1> 	mov si, disk_buffer
  1536 00000E2D 01C6                <1> 	add si, ax			; AX = word in FAT for the 12 bit entry
  1537 00000E2F 3E8B04              <1> 	mov ax, word [ds:si]
  1538                              <1> 
  1539 00000E32 09D2                <1> 	or dx, dx			; If DX = 0, [.cluster] = even; if DX = 1 then odd
  1540 00000E34 7408                <1> 	jz .even_last
  1541                              <1> 
  1542                              <1> .odd_last:
  1543 00000E36 83E00F              <1> 	and ax, 000Fh			; Set relevant parts to FF8h (last cluster in file)
  1544 00000E39 83C080              <1> 	add ax, 0FF80h
  1545 00000E3C EB06                <1> 	jmp .finito
  1546                              <1> 
  1547                              <1> .even_last:
  1548 00000E3E 2500F0              <1> 	and ax, 0F000h			; Same as above, but for an even cluster
  1549 00000E41 05F80F              <1> 	add ax, 0FF8h
  1550                              <1> 
  1551                              <1> 
  1552                              <1> .finito:
  1553 00000E44 3E8904              <1> 	mov word [ds:si], ax
  1554                              <1> 
  1555 00000E47 E88803              <1> 	call disk_write_fat		; Save our FAT back to disk
  1556                              <1> 
  1557                              <1> 
  1558                              <1> 	; Now it's time to save the sectors to disk!
  1559                              <1> 
  1560 00000E4A 31C9                <1> 	xor cx, cx
  1561                              <1> 
  1562                              <1> .save_loop:
  1563 00000E4C BF00FF              <1> 	mov di, .free_clusters
  1564 00000E4F 01CF                <1> 	add di, cx
  1565 00000E51 8B05                <1> 	mov word ax, [di]
  1566                              <1> 
  1567 00000E53 83F800              <1> 	cmp ax, 0
  1568 00000E56 0F842200            <1> 	je near .write_root_entry
  1569                              <1> 
  1570 00000E5A 60                  <1> 	pusha
  1571                              <1> 
  1572 00000E5B 83C01F              <1> 	add ax, 31
  1573                              <1> 
  1574 00000E5E E8E903              <1> 	call disk_convert_l2hts
  1575                              <1> 
  1576 00000E61 8B1E[C00E]          <1> 	mov word bx, [.location]
  1577 00000E65 8E06[C60E]          <1> 	mov es, [.old_segment]
  1578                              <1> 	
  1579 00000E69 B80103              <1> 	mov ax, 0301h
  1580 00000E6C F9                  <1> 	stc
  1581 00000E6D CD13                <1> 	int 13h
  1582                              <1> 
  1583 00000E6F 0E                  <1> 	push cs
  1584 00000E70 07                  <1> 	pop es
  1585                              <1> 		
  1586 00000E71 61                  <1> 	popa
  1587                              <1> 
  1588 00000E72 8106[C00E]0002      <1> 	add word [.location], 512
  1589 00000E78 41                  <1> 	inc cx
  1590 00000E79 41                  <1> 	inc cx
  1591 00000E7A EBD0                <1> 	jmp .save_loop
  1592                              <1> 
  1593                              <1> 
  1594                              <1> .write_root_entry:
  1595                              <1> 
  1596                              <1> 	; Now it's time to head back to the root directory, find our
  1597                              <1> 	; entry and update it with the cluster in use and file size
  1598                              <1> 
  1599 00000E7C E87203              <1> 	call disk_read_root_dir
  1600                              <1> 
  1601 00000E7F A1[C40E]            <1> 	mov word ax, [.filename]
  1602 00000E82 E8EA02              <1> 	call disk_get_root_entry
  1603                              <1> 
  1604 00000E85 A100FF              <1> 	mov word ax, [.free_clusters]	; Get first free cluster
  1605                              <1> 
  1606 00000E88 89451A              <1> 	mov word [di+26], ax		; Save cluster location into root dir entry
  1607                              <1> 
  1608 00000E8B 8B0E[BA0E]          <1> 	mov word cx, [.filesize]
  1609 00000E8F 894D1C              <1> 	mov word [di+28], cx
  1610                              <1> 
  1611 00000E92 C6451E00            <1> 	mov byte [di+30], 0		; File size
  1612 00000E96 C6451F00            <1> 	mov byte [di+31], 0
  1613                              <1> 
  1614 00000E9A E87F03              <1> 	call disk_write_root_dir
  1615                              <1> 
  1616                              <1> .finished:
  1617 00000E9D 61                  <1> 	popa
  1618 00000E9E 60                  <1> 	pusha
  1619 00000E9F 31F6                <1> 	xor si, si
  1620 00000EA1 E8DE14              <1> 	call os_print_footer
  1621 00000EA4 61                  <1> 	popa
  1622 00000EA5 8E06[C60E]          <1> 	mov es, [.old_segment]
  1623                              <1> 
  1624 00000EA9 F8                  <1> 	clc
  1625 00000EAA C3                  <1> 	ret
  1626                              <1> 
  1627                              <1> .failure:
  1628 00000EAB 61                  <1> 	popa
  1629 00000EAC 60                  <1> 	pusha
  1630 00000EAD BE0000              <1> 	mov si, 0
  1631 00000EB0 E8CF14              <1> 	call os_print_footer
  1632 00000EB3 61                  <1> 	popa
  1633 00000EB4 8E06[C60E]          <1> 	mov es, [.old_segment]
  1634                              <1> 
  1635 00000EB8 F9                  <1> 	stc				; Couldn't write!
  1636 00000EB9 C3                  <1> 	ret
  1637                              <1> 
  1638                              <1> 
  1639 00000EBA 0000                <1> 	.filesize				dw 0
  1640 00000EBC 0000                <1> 	.cluster				dw 0
  1641 00000EBE 0000                <1> 	.count					dw 0
  1642 00000EC0 0000                <1> 	.location				dw 0
  1643                              <1> 
  1644 00000EC2 0000                <1> 	.clusters_needed		dw 0
  1645                              <1> 
  1646 00000EC4 0000                <1> 	.filename				dw 0
  1647                              <1> 
  1648                              <1> 	.free_clusters			equ 65280
  1649                              <1> 
  1650 00000EC6 0000                <1> 	.old_segment			dw 0
  1651                              <1> 
  1652 00000EC8 20536176696E672000  <1> 	.msg_save				db ' Saving ', 0
  1653                              <1> 	
  1654                              <1> ; --------------------------------------------------------------------------
  1655                              <1> ; os_file_exists -- Check for presence of file on the floppy
  1656                              <1> ; IN: AX = filename location; OUT: carry clear if found, set if not
  1657                              <1> 
  1658                              <1> os_file_exists:
  1659 00000ED1 E8381B              <1> 	call os_string_uppercase
  1660 00000ED4 E81302              <1> 	call int_filename_convert	; Make FAT12-style filename
  1661                              <1> 
  1662 00000ED7 50                  <1> 	push ax
  1663 00000ED8 E8D81A              <1> 	call os_string_length
  1664 00000EDB 83F800              <1> 	cmp ax, 0
  1665 00000EDE 740F                <1> 	je .failure
  1666 00000EE0 58                  <1> 	pop ax
  1667                              <1> 
  1668 00000EE1 50                  <1> 	push ax
  1669 00000EE2 E80C03              <1> 	call disk_read_root_dir
  1670                              <1> 
  1671 00000EE5 58                  <1> 	pop ax				; Restore filename
  1672                              <1> 
  1673 00000EE6 BF00E0              <1> 	mov di, disk_buffer
  1674                              <1> 
  1675 00000EE9 E88302              <1> 	call disk_get_root_entry	; Set or clear carry flag
  1676                              <1> 
  1677 00000EEC 9C                  <1> 	pushf
  1678                              <1> 
  1679 00000EED 9D                  <1> 	popf
  1680 00000EEE C3                  <1> 	ret
  1681                              <1> 
  1682                              <1> .failure:
  1683 00000EEF 58                  <1> 	pop ax
  1684                              <1> 
  1685 00000EF0 F9                  <1> 	stc
  1686 00000EF1 C3                  <1> 	ret
  1687                              <1> 
  1688                              <1> 
  1689                              <1> ; --------------------------------------------------------------------------
  1690                              <1> ; os_create_file -- Creates a new 0-byte file on the floppy disk
  1691                              <1> ; IN: AX = location of filename; OUT: Nothing
  1692                              <1> 
  1693                              <1> os_create_file:
  1694 00000EF2 F8                  <1> 	clc
  1695                              <1> 
  1696 00000EF3 E8161B              <1> 	call os_string_uppercase
  1697 00000EF6 E8F101              <1> 	call int_filename_convert	; Make FAT12-style filename
  1698 00000EF9 60                  <1> 	pusha
  1699                              <1> 
  1700 00000EFA 50                  <1> 	push ax				; Save filename for now
  1701                              <1> 
  1702 00000EFB E8D3FF              <1> 	call os_file_exists		; Does the file already exist?
  1703 00000EFE 731B                <1> 	jnc .exists_error
  1704                              <1> 
  1705                              <1> 
  1706                              <1> 	; Root dir already read into disk_buffer by os_file_exists
  1707                              <1> 
  1708 00000F00 BF00E0              <1> 	mov di, disk_buffer		; So point DI at it!
  1709                              <1> 
  1710 00000F03 B9E000              <1> 	mov cx, 224			; Cycle through root dir entries
  1711                              <1> .next_entry:
  1712 00000F06 8A05                <1> 	mov byte al, [di]
  1713 00000F08 3C00                <1> 	cmp al, 0			; Is this a free entry?
  1714 00000F0A 7412                <1> 	je .found_free_entry
  1715 00000F0C 3CE5                <1> 	cmp al, 0E5h			; Is this a free entry?
  1716 00000F0E 740E                <1> 	je .found_free_entry
  1717 00000F10 83C720              <1> 	add di, 32			; If not, go onto next entry
  1718 00000F13 E2F1                <1> 	loop .next_entry
  1719                              <1> 	
  1720 00000F15 B8[B20F]            <1> 	mov ax, .err_msg		; Is the root directory full?
  1721 00000F18 E88506              <1> 	call os_fatal_error
  1722                              <1> 
  1723                              <1> .exists_error:				; We also get here if above loop finds nothing
  1724 00000F1B 58                  <1> 	pop ax				; Get filename back
  1725                              <1> 
  1726 00000F1C EB7C                <1> 	jmp .failure
  1727                              <1> 
  1728                              <1> .found_free_entry:
  1729 00000F1E 5E                  <1> 	pop si				; Get filename back
  1730 00000F1F B90B00              <1> 	mov cx, 11
  1731 00000F22 F3A4                <1> 	rep movsb			; And copy it into RAM copy of root dir (in DI)
  1732                              <1> 
  1733                              <1> 	; Get the time information
  1734                              <1> 	
  1735 00000F24 60                  <1> 	pusha
  1736 00000F25 B402                <1> 	mov ah, 2
  1737 00000F27 E88F07              <1> 	call os_int_1Ah
  1738                              <1> 
  1739 00000F2A 88E8                <1> 	mov al, ch			; Hours
  1740 00000F2C E8D404              <1> 	call os_bcd_to_int
  1741 00000F2F 89C3                <1> 	mov bx, ax
  1742 00000F31 C1E306              <1> 	shl bx, 6
  1743                              <1> 	
  1744 00000F34 88C8                <1> 	mov al, cl			; Minutes
  1745 00000F36 E8CA04              <1> 	call os_bcd_to_int
  1746 00000F39 09C3                <1> 	or bx, ax
  1747 00000F3B C1E305              <1> 	shl bx, 5
  1748                              <1> 	
  1749 00000F3E D0EE                <1> 	shr dh, 1			; Seconds (they're stored as "doubleseconds")
  1750 00000F40 88F0                <1> 	mov al, dh
  1751 00000F42 E8BE04              <1> 	call os_bcd_to_int
  1752 00000F45 09C3                <1> 	or bx, ax
  1753                              <1> 	
  1754 00000F47 891E[A00F]          <1> 	mov [.creation_time], bx
  1755 00000F4B 891E[A80F]          <1> 	mov [.write_time], bx
  1756                              <1> 
  1757                              <1> 	; Get date information
  1758                              <1> 	
  1759 00000F4F B404                <1> 	mov ah, 4
  1760 00000F51 E86507              <1> 	call os_int_1Ah
  1761                              <1> 
  1762 00000F54 52                  <1> 	push dx
  1763 00000F55 88E8                <1> 	mov al, ch			; Century
  1764 00000F57 E8A904              <1> 	call os_bcd_to_int
  1765 00000F5A BB6400              <1> 	mov bx, 100
  1766 00000F5D F7E3                <1> 	mul bx
  1767 00000F5F 89C3                <1> 	mov bx, ax
  1768                              <1> 	
  1769 00000F61 88C8                <1> 	mov al, cl			; Years
  1770 00000F63 E89D04              <1> 	call os_bcd_to_int
  1771 00000F66 01C3                <1> 	add bx, ax
  1772                              <1> 	
  1773 00000F68 81EBBC07            <1> 	sub bx, 1980		; Years are stored as "years past 1980"
  1774                              <1> 	
  1775 00000F6C C1E304              <1> 	shl bx, 4
  1776 00000F6F 5A                  <1> 	pop dx
  1777                              <1> 	
  1778 00000F70 88F0                <1> 	mov al, dh			; Months
  1779 00000F72 E88E04              <1> 	call os_bcd_to_int
  1780 00000F75 09C3                <1> 	or bx, ax
  1781 00000F77 C1E305              <1> 	shl bx, 5
  1782                              <1> 	
  1783 00000F7A 88D0                <1> 	mov al, dl			; Days
  1784 00000F7C E88404              <1> 	call os_bcd_to_int
  1785 00000F7F 09C3                <1> 	or bx, ax
  1786                              <1> 	
  1787 00000F81 891E[A20F]          <1> 	mov [.creation_date], bx
  1788 00000F85 891E[AA0F]          <1> 	mov [.write_date], bx
  1789 00000F89 61                  <1> 	popa
  1790                              <1> 	
  1791 00000F8A BE[9D0F]            <1> 	mov si, .table		; Copy over all the attributes
  1792 00000F8D B91500              <1> 	mov cx, 21
  1793 00000F90 F3A4                <1> 	rep movsb
  1794                              <1> 	
  1795 00000F92 E88702              <1> 	call disk_write_root_dir
  1796 00000F95 7203                <1> 	jc .failure
  1797                              <1> 
  1798 00000F97 61                  <1> 	popa
  1799                              <1> 
  1800 00000F98 F8                  <1> 	clc				; Clear carry for success
  1801 00000F99 C3                  <1> 	ret
  1802                              <1> 
  1803                              <1> .failure:
  1804 00000F9A 61                  <1> 	popa
  1805                              <1> 
  1806 00000F9B F9                  <1> 	stc
  1807 00000F9C C3                  <1> 	ret
  1808                              <1> 
  1809                              <1> ;	.table			db 0, 0, 0, 0C6h, 07Eh, 0, 0, 0, 0, 0, 0, 0C6h, 07Eh, 0, 0, 0, 0, 0, 0, 0, 0 
  1810                              <1> 	.table:
  1811 00000F9D 00                  <1> 		.atttribute		db 0
  1812 00000F9E 00<rep 2h>          <1> 		.reserved		times 2 db 0
  1813 00000FA0 0000                <1> 		.creation_time	dw 0
  1814 00000FA2 0000                <1> 		.creation_date	dw 0
  1815 00000FA4 00<rep 4h>          <1> 		.reserved2		times 4 db 0
  1816 00000FA8 0000                <1> 		.write_time		dw 0
  1817 00000FAA 0000                <1> 		.write_date		dw 0
  1818 00000FAC 00<rep 6h>          <1> 		.reserved3		times 6 db 0
  1819 00000FB2 4E6F7420656E6F7567- <1> 	.err_msg		db 'Not enough space in directory', 0
  1819 00000FBB 682073706163652069- <1>
  1819 00000FC4 6E206469726563746F- <1>
  1819 00000FCD 727900              <1>
  1820                              <1> 
  1821                              <1> ; --------------------------------------------------------------------------
  1822                              <1> ; os_remove_file -- Deletes the specified file from the filesystem
  1823                              <1> ; IN: AX = location of filename to remove
  1824                              <1> 
  1825                              <1> os_remove_file:
  1826 00000FD0 60                  <1> 	pusha
  1827 00000FD1 E8381A              <1> 	call os_string_uppercase
  1828 00000FD4 E81301              <1> 	call int_filename_convert	; Make filename FAT12-style
  1829 00000FD7 50                  <1> 	push ax				; Save filename
  1830                              <1> 
  1831 00000FD8 F8                  <1> 	clc
  1832                              <1> 
  1833 00000FD9 E81502              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1834                              <1> 
  1835 00000FDC BF00E0              <1> 	mov di, disk_buffer		; Point DI to root dir
  1836                              <1> 
  1837 00000FDF 58                  <1> 	pop ax				; Get chosen filename back
  1838                              <1> 
  1839 00000FE0 E88C01              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1840 00000FE3 7268                <1> 	jc .failure			; If entry can't be found
  1841                              <1> 
  1842                              <1> 
  1843 00000FE5 268B451A            <1> 	mov ax, word [es:di+26]		; Get first cluster number from the dir entry
  1844 00000FE9 A3[5010]            <1> 	mov word [.cluster], ax		; And save it
  1845                              <1> 
  1846 00000FEC C605E5              <1> 	mov byte [di], 0E5h		; Mark directory entry (first byte of filename) as empty
  1847                              <1> 
  1848 00000FEF 47                  <1> 	inc di
  1849                              <1> 
  1850 00000FF0 31C9                <1> 	xor cx, cx			; Set rest of data in root dir entry to zeros
  1851                              <1> .clean_loop:
  1852 00000FF2 C60500              <1> 	mov byte [di], 0
  1853 00000FF5 47                  <1> 	inc di
  1854 00000FF6 41                  <1> 	inc cx
  1855 00000FF7 83F91F              <1> 	cmp cx, 31			; 32-byte entries, minus E5h byte we marked before
  1856 00000FFA 7CF6                <1> 	jl .clean_loop
  1857                              <1> 
  1858 00000FFC E81D02              <1> 	call disk_write_root_dir	; Save back the root directory from RAM
  1859                              <1> 
  1860                              <1> 
  1861 00000FFF E8A501              <1> 	call disk_read_fat		; Now FAT is in disk_buffer
  1862 00001002 BF00E0              <1> 	mov di, disk_buffer		; And DI points to it
  1863                              <1> 
  1864                              <1> 
  1865                              <1> .more_clusters:
  1866 00001005 A1[5010]            <1> 	mov word ax, [.cluster]		; Get cluster contents
  1867                              <1> 
  1868 00001008 83F800              <1> 	cmp ax, 0			; If it's zero, this was an empty file
  1869 0000100B 743D                <1> 	je .nothing_to_do
  1870                              <1> 
  1871 0000100D BB0300              <1> 	mov bx, 3			; Determine if cluster is odd or even number
  1872 00001010 F7E3                <1> 	mul bx
  1873 00001012 BB0200              <1> 	mov bx, 2
  1874 00001015 F7F3                <1> 	div bx				; DX = [first_cluster] mod 2
  1875 00001017 BE00E0              <1> 	mov si, disk_buffer		; AX = word in FAT for the 12 bits
  1876 0000101A 01C6                <1> 	add si, ax
  1877 0000101C 3E8B04              <1> 	mov ax, word [ds:si]
  1878                              <1> 
  1879 0000101F 09D2                <1> 	or dx, dx			; If DX = 0 [.cluster] = even, if DX = 1 then odd
  1880                              <1> 
  1881 00001021 740D                <1> 	jz .even			; If [.cluster] = even, drop last 4 bits of word
  1882                              <1> 					; with next cluster; if odd, drop first 4 bits
  1883                              <1> .odd:
  1884 00001023 50                  <1> 	push ax
  1885 00001024 83E00F              <1> 	and ax, 000Fh			; Set cluster data to zero in FAT in RAM
  1886 00001027 3E8904              <1> 	mov word [ds:si], ax
  1887 0000102A 58                  <1> 	pop ax
  1888                              <1> 
  1889 0000102B C1E804              <1> 	shr ax, 4			; Shift out first 4 bits (they belong to another entry)
  1890 0000102E EB0B                <1> 	jmp .calculate_cluster_cont	; Onto next sector!
  1891                              <1> 
  1892                              <1> .even:
  1893 00001030 50                  <1> 	push ax
  1894 00001031 2500F0              <1> 	and ax, 0F000h			; Set cluster data to zero in FAT in RAM
  1895 00001034 3E8904              <1> 	mov word [ds:si], ax
  1896 00001037 58                  <1> 	pop ax
  1897                              <1> 
  1898 00001038 25FF0F              <1> 	and ax, 0FFFh			; Mask out top (last) 4 bits (they belong to another entry)
  1899                              <1> 
  1900                              <1> .calculate_cluster_cont:
  1901 0000103B A3[5010]            <1> 	mov word [.cluster], ax		; Store cluster
  1902                              <1> 
  1903 0000103E 3DF80F              <1> 	cmp ax, 0FF8h			; Final cluster marker?
  1904 00001041 7302                <1> 	jae .end
  1905                              <1> 
  1906 00001043 EBC0                <1> 	jmp .more_clusters		; If not, grab more
  1907                              <1> 
  1908                              <1> .end:
  1909 00001045 E88A01              <1> 	call disk_write_fat
  1910 00001048 7203                <1> 	jc .failure
  1911                              <1> 
  1912                              <1> .nothing_to_do:
  1913 0000104A 61                  <1> 	popa
  1914                              <1> 
  1915 0000104B F8                  <1> 	clc
  1916 0000104C C3                  <1> 	ret
  1917                              <1> 
  1918                              <1> .failure:
  1919 0000104D 61                  <1> 	popa
  1920                              <1> 
  1921 0000104E F9                  <1> 	stc
  1922 0000104F C3                  <1> 	ret
  1923                              <1> 
  1924                              <1> 
  1925 00001050 0000                <1> 	.cluster dw 0
  1926                              <1> 
  1927                              <1> 
  1928                              <1> ; --------------------------------------------------------------------------
  1929                              <1> ; os_rename_file -- Change the name of a file on the disk
  1930                              <1> ; IN: AX = filename to change, BX = new filename (zero-terminated strings)
  1931                              <1> ; OUT: carry set on error
  1932                              <1> 
  1933                              <1> os_rename_file:
  1934 00001052 53                  <1> 	push bx
  1935 00001053 50                  <1> 	push ax
  1936                              <1> 
  1937 00001054 F8                  <1> 	clc
  1938                              <1> 
  1939 00001055 E89901              <1> 	call disk_read_root_dir		; Get root dir into disk_buffer
  1940                              <1> 
  1941 00001058 BF00E0              <1> 	mov di, disk_buffer		; Point DI to root dir
  1942                              <1> 
  1943 0000105B 58                  <1> 	pop ax				; Get chosen filename back
  1944                              <1> 
  1945 0000105C E8AD19              <1> 	call os_string_uppercase
  1946 0000105F E88800              <1> 	call int_filename_convert
  1947 00001062 721E                <1> 	jc .fail_read
  1948                              <1> 	
  1949 00001064 E80801              <1> 	call disk_get_root_entry	; Entry will be returned in DI
  1950 00001067 7219                <1> 	jc .fail_read			; Quit out if file not found
  1951                              <1> 
  1952 00001069 5B                  <1> 	pop bx				; Get new filename string (originally passed in BX)
  1953                              <1> 
  1954 0000106A 89D8                <1> 	mov ax, bx
  1955                              <1> 
  1956 0000106C E89D19              <1> 	call os_string_uppercase
  1957 0000106F E87800              <1> 	call int_filename_convert
  1958 00001072 7211                <1> 	jc .fail_write
  1959                              <1> 	
  1960 00001074 89C6                <1> 	mov si, ax
  1961                              <1> 
  1962 00001076 B90B00              <1> 	mov cx, 11			; Copy new filename string into root dir entry in disk_buffer
  1963 00001079 F3A4                <1> 	rep movsb
  1964                              <1> 
  1965 0000107B E89E01              <1> 	call disk_write_root_dir	; Save root dir to disk
  1966 0000107E 7205                <1> 	jc .fail_write
  1967                              <1> 
  1968                              <1> 
  1969 00001080 F8                  <1> 	clc
  1970 00001081 C3                  <1> 	ret
  1971                              <1> 
  1972                              <1> .fail_read:
  1973 00001082 58                  <1> 	pop ax
  1974                              <1> 
  1975 00001083 F9                  <1> 	stc
  1976 00001084 C3                  <1> 	ret
  1977                              <1> 
  1978                              <1> .fail_write:
  1979                              <1> 
  1980 00001085 F9                  <1> 	stc
  1981 00001086 C3                  <1> 	ret
  1982                              <1> 
  1983                              <1> 
  1984                              <1> ; --------------------------------------------------------------------------
  1985                              <1> ; os_get_file_size -- Get file size information for specified file
  1986                              <1> ; IN: AX = filename; OUT: EBX = file size in bytes (up to 4GB)
  1987                              <1> ; or carry set if file not found
  1988                              <1> 
  1989                              <1> os_get_file_size:
  1990 00001087 60                  <1> 	pusha
  1991                              <1> 
  1992 00001088 E88119              <1> 	call os_string_uppercase
  1993 0000108B E85C00              <1> 	call int_filename_convert
  1994                              <1> 
  1995 0000108E F8                  <1> 	clc
  1996                              <1> 
  1997 0000108F 50                  <1> 	push ax
  1998                              <1> 
  1999 00001090 E85E01              <1> 	call disk_read_root_dir
  2000 00001093 7219                <1> 	jc .failure
  2001                              <1> 
  2002 00001095 58                  <1> 	pop ax
  2003                              <1> 
  2004 00001096 BF00E0              <1> 	mov di, disk_buffer
  2005                              <1> 
  2006 00001099 E8D300              <1> 	call disk_get_root_entry
  2007 0000109C 7210                <1> 	jc .failure
  2008                              <1> 
  2009 0000109E 668B5D1C            <1> 	mov ebx, [di+28]
  2010                              <1> 
  2011 000010A2 66891E[B110]        <1> 	mov [.tmp], ebx
  2012                              <1> 
  2013 000010A7 61                  <1> 	popa
  2014                              <1> 
  2015 000010A8 668B1E[B110]        <1> 	mov ebx, [.tmp]
  2016                              <1> 
  2017                              <1> 
  2018 000010AD C3                  <1> 	ret
  2019                              <1> 
  2020                              <1> .failure:
  2021 000010AE 61                  <1> 	popa
  2022 000010AF F9                  <1> 	stc
  2023                              <1> 
  2024 000010B0 C3                  <1> 	ret
  2025                              <1> 
  2026                              <1> 
  2027 000010B1 00000000            <1> 	.tmp	dd 0
  2028                              <1> 
  2029                              <1> ; --------------------------------------------------------------------------
  2030                              <1> ; os_get_file_datetime -- Get file write time/date information for specified file
  2031                              <1> ; IN: AX = filename; OUT: BX = time of creation (HHHHHMMMMMMSSSSS), CX = date of creation (YYYYYYYMMMMDDDDD)
  2032                              <1> ; or carry set if file not found
  2033                              <1> 
  2034                              <1> os_get_file_datetime:
  2035 000010B5 60                  <1> 	pusha
  2036                              <1> 
  2037 000010B6 E85319              <1> 	call os_string_uppercase
  2038 000010B9 E82E00              <1> 	call int_filename_convert
  2039                              <1> 
  2040 000010BC F8                  <1> 	clc
  2041                              <1> 
  2042 000010BD 50                  <1> 	push ax
  2043                              <1> 
  2044 000010BE E83001              <1> 	call disk_read_root_dir
  2045 000010C1 7220                <1> 	jc .failure
  2046                              <1> 
  2047 000010C3 58                  <1> 	pop ax
  2048                              <1> 
  2049 000010C4 BF00E0              <1> 	mov di, disk_buffer
  2050                              <1> 
  2051 000010C7 E8A500              <1> 	call disk_get_root_entry
  2052 000010CA 7217                <1> 	jc .failure
  2053                              <1> 
  2054 000010CC 8B4516              <1> 	mov ax, [di+22]
  2055 000010CF 8B5D18              <1> 	mov bx, [di+24]
  2056                              <1> 
  2057 000010D2 A3[E610]            <1> 	mov [.tmp], ax
  2058 000010D5 891E[E810]          <1> 	mov [.tmp + 2], bx
  2059                              <1> 
  2060 000010D9 61                  <1> 	popa
  2061                              <1> 
  2062 000010DA 8B1E[E610]          <1> 	mov bx, [.tmp]
  2063 000010DE 8B0E[E810]          <1> 	mov cx, [.tmp + 2]
  2064                              <1> 
  2065                              <1> 
  2066 000010E2 C3                  <1> 	ret
  2067                              <1> 
  2068                              <1> .failure:
  2069 000010E3 61                  <1> 	popa
  2070 000010E4 F9                  <1> 	stc
  2071                              <1> 
  2072 000010E5 C3                  <1> 	ret
  2073                              <1> 
  2074                              <1> 
  2075 000010E6 00000000            <1> 	.tmp	dd 0
  2076                              <1> 
  2077                              <1> 
  2078                              <1> ; ==================================================================
  2079                              <1> ; INTERNAL OS ROUTINES -- Not accessible to user programs
  2080                              <1> 
  2081                              <1> ; ------------------------------------------------------------------
  2082                              <1> ; int_filename_convert -- Change 'TEST.BIN' into 'TEST    BIN' as per FAT12
  2083                              <1> ; IN: AX = filename string
  2084                              <1> ; OUT: AX = location of converted string (carry set if invalid)
  2085                              <1> 
  2086                              <1> 
  2087                              <1> int_filename_convert:
  2088 000010EA 60                  <1> 	pusha
  2089                              <1> 
  2090 000010EB 89C6                <1> 	mov si, ax
  2091                              <1> 
  2092 000010ED E8C318              <1> 	call os_string_length
  2093 000010F0 83F80C              <1> 	cmp ax, 12			; Filename too long?
  2094 000010F3 7F49                <1> 	jg .failure0			; Fail if so
  2095                              <1> 
  2096 000010F5 83F800              <1> 	cmp ax, 0
  2097 000010F8 744B                <1> 	je .failure1			; Similarly, fail if zero-char string
  2098                              <1> 
  2099 000010FA 89C2                <1> 	mov dx, ax			; Store string length for now
  2100                              <1> 
  2101 000010FC BF[6211]            <1> 	mov di, .dest_string
  2102                              <1> 
  2103 000010FF B90000              <1> 	mov cx, 0
  2104                              <1> .copy_loop:
  2105 00001102 AC                  <1> 	lodsb
  2106 00001103 3C2E                <1> 	cmp al, '.'
  2107 00001105 7408                <1> 	je .extension_found
  2108 00001107 AA                  <1> 	stosb
  2109 00001108 41                  <1> 	inc cx
  2110 00001109 39D1                <1> 	cmp cx, dx
  2111 0000110B 7F3F                <1> 	jg .failure2			; No extension found = wrong
  2112 0000110D EBF3                <1> 	jmp .copy_loop
  2113                              <1> 
  2114                              <1> .extension_found:
  2115 0000110F 83F900              <1> 	cmp cx, 0
  2116 00001112 743F                <1> 	je .failure3			; Fail if extension dot is first char
  2117                              <1> 
  2118 00001114 83F908              <1> 	cmp cx, 8
  2119 00001117 740A                <1> 	je .do_extension		; Skip spaces if first bit is 8 chars
  2120                              <1> 
  2121                              <1> 	; Now it's time to pad out the rest of the first part of the filename
  2122                              <1> 	; with spaces, if necessary
  2123                              <1> 
  2124                              <1> .add_spaces:
  2125 00001119 C60520              <1> 	mov byte [di], ' '
  2126 0000111C 47                  <1> 	inc di
  2127 0000111D 41                  <1> 	inc cx
  2128 0000111E 83F908              <1> 	cmp cx, 8
  2129 00001121 7CF6                <1> 	jl .add_spaces
  2130                              <1> 
  2131                              <1> 	; Finally, copy over the extension
  2132                              <1> .do_extension:
  2133 00001123 AC                  <1> 	lodsb				; 3 characters
  2134 00001124 3C00                <1> 	cmp al, 0
  2135 00001126 7432                <1> 	je .failure4
  2136 00001128 AA                  <1> 	stosb
  2137 00001129 AC                  <1> 	lodsb
  2138 0000112A 3C00                <1> 	cmp al, 0
  2139 0000112C 742C                <1> 	je .failure4
  2140 0000112E AA                  <1> 	stosb
  2141 0000112F AC                  <1> 	lodsb
  2142 00001130 3C00                <1> 	cmp al, 0
  2143 00001132 7426                <1> 	je .failure4
  2144 00001134 AA                  <1> 	stosb
  2145                              <1> 
  2146 00001135 C60500              <1> 	mov byte [di], 0		; Zero-terminate filename
  2147                              <1> 
  2148 00001138 61                  <1> 	popa
  2149 00001139 B8[6211]            <1> 	mov ax, .dest_string
  2150 0000113C F8                  <1> 	clc				; Clear carry for success
  2151 0000113D C3                  <1> 	ret
  2152                              <1> 
  2153                              <1> 
  2154                              <1> .failure0:
  2155 0000113E C606860000          <1> 	mov byte [0086h], 0
  2156 00001143 EB1A                <1> 	jmp .failure
  2157                              <1> 	
  2158                              <1> .failure1:
  2159 00001145 C606860001          <1> 	mov byte [0086h], 1
  2160 0000114A EB13                <1> 	jmp .failure
  2161                              <1> 	
  2162                              <1> .failure2:
  2163 0000114C C606860002          <1> 	mov byte [0086h], 2
  2164 00001151 EB0C                <1> 	jmp .failure
  2165                              <1> 	
  2166                              <1> .failure3:
  2167 00001153 C606860003          <1> 	mov byte [0086h], 3
  2168 00001158 EB05                <1> 	jmp .failure
  2169                              <1> 	
  2170                              <1> .failure4:
  2171 0000115A C606860004          <1> 	mov byte [0086h], 4
  2172                              <1> 
  2173                              <1> .failure:	
  2174 0000115F 61                  <1> 	popa
  2175 00001160 F9                  <1> 	stc				; Set carry for failure
  2176 00001161 C3                  <1> 	ret
  2177                              <1> 
  2178 00001162 00<rep Dh>          <1> 	.dest_string	times 13 db 0
  2179                              <1> 
  2180                              <1> 
  2181                              <1> ; --------------------------------------------------------------------------
  2182                              <1> ; disk_get_root_entry -- Search RAM copy of root dir for file entry
  2183                              <1> ; IN: AX = filename; OUT: DI = location in disk_buffer of root dir entry,
  2184                              <1> ; or carry set if file not found
  2185                              <1> 
  2186                              <1> disk_get_root_entry:
  2187 0000116F 60                  <1> 	pusha
  2188                              <1> 
  2189 00001170 A3[A311]            <1> 	mov word [.filename], ax
  2190                              <1> 
  2191 00001173 B9E000              <1> 	mov cx, 224			; Search all (224) entries
  2192 00001176 B80000              <1> 	mov ax, 0			; Searching at offset 0
  2193                              <1> 
  2194                              <1> .to_next_root_entry:
  2195 00001179 87CA                <1> 	xchg cx, dx			; We use CX in the inner loop...
  2196                              <1> 
  2197 0000117B 8B36[A311]          <1> 	mov word si, [.filename]	; Start searching for filename
  2198 0000117F B90B00              <1> 	mov cx, 11
  2199 00001182 F3A6                <1> 	rep cmpsb
  2200 00001184 740F                <1> 	je .found_file			; Pointer DI will be at offset 11, if file found
  2201                              <1> 
  2202 00001186 83C020              <1> 	add ax, 32			; Bump searched entries by 1 (32 bytes/entry)
  2203                              <1> 
  2204 00001189 BF00E0              <1> 	mov di, disk_buffer		; Point to next root dir entry
  2205 0000118C 01C7                <1> 	add di, ax
  2206                              <1> 
  2207 0000118E 87D1                <1> 	xchg dx, cx			; Get the original CX back
  2208 00001190 E2E7                <1> 	loop .to_next_root_entry
  2209                              <1> 
  2210 00001192 61                  <1> 	popa
  2211                              <1> 
  2212 00001193 F9                  <1> 	stc				; Set carry if entry not found
  2213 00001194 C3                  <1> 	ret
  2214                              <1> 
  2215                              <1> 
  2216                              <1> .found_file:
  2217 00001195 83EF0B              <1> 	sub di, 11			; Move back to start of this root dir entry
  2218                              <1> 
  2219 00001198 893E[A511]          <1> 	mov word [.tmp], di		; Restore all registers except for DI
  2220                              <1> 
  2221 0000119C 61                  <1> 	popa
  2222                              <1> 
  2223 0000119D 8B3E[A511]          <1> 	mov word di, [.tmp]
  2224                              <1> 
  2225 000011A1 F8                  <1> 	clc
  2226 000011A2 C3                  <1> 	ret
  2227                              <1> 
  2228                              <1> 
  2229 000011A3 0000                <1> 	.filename	dw 0
  2230 000011A5 0000                <1> 	.tmp		dw 0
  2231                              <1> 
  2232                              <1> 
  2233                              <1> ; --------------------------------------------------------------------------
  2234                              <1> ; disk_read_fat -- Read FAT entry from floppy into disk_buffer
  2235                              <1> ; IN: Nothing; OUT: carry set if failure
  2236                              <1> 
  2237                              <1> disk_read_fat:
  2238 000011A7 60                  <1> 	pusha
  2239                              <1> 
  2240 000011A8 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  2241 000011AB E89C00              <1> 	call disk_convert_l2hts
  2242                              <1> 
  2243 000011AE BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  2244 000011B1 8CCB                <1> 	mov bx, cs
  2245 000011B3 8EC3                <1> 	mov es, bx
  2246 000011B5 89F3                <1> 	mov bx, si
  2247                              <1> 
  2248 000011B7 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  2249 000011B9 B009                <1> 	mov al, 9			; And read 9 of them for first FAT
  2250                              <1> 
  2251 000011BB 60                  <1> 	pusha				; Prepare to enter loop
  2252                              <1> 
  2253                              <1> 
  2254                              <1> .read_fat_loop:
  2255 000011BC 61                  <1> 	popa
  2256 000011BD 60                  <1> 	pusha
  2257                              <1> 
  2258 000011BE F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2259 000011BF CD13                <1> 	int 13h				; Read sectors
  2260                              <1> 
  2261 000011C1 7308                <1> 	jnc .fat_done
  2262 000011C3 E87500              <1> 	call disk_reset_floppy		; Reset controller and try again
  2263 000011C6 73F4                <1> 	jnc .read_fat_loop		; Floppy reset OK?
  2264                              <1> 
  2265 000011C8 61                  <1> 	popa
  2266 000011C9 EB04                <1> 	jmp .read_failure		; Fatal double error
  2267                              <1> 
  2268                              <1> .fat_done:
  2269 000011CB 61                  <1> 	popa				; Restore registers from main loop
  2270                              <1> 
  2271 000011CC 61                  <1> 	popa				; And restore registers from start of system call
  2272 000011CD F8                  <1> 	clc
  2273 000011CE C3                  <1> 	ret
  2274                              <1> 
  2275                              <1> .read_failure:
  2276 000011CF 61                  <1> 	popa
  2277 000011D0 F9                  <1> 	stc				; Set carry flag (for failure)
  2278 000011D1 C3                  <1> 	ret
  2279                              <1> 
  2280                              <1> 
  2281                              <1> ; --------------------------------------------------------------------------
  2282                              <1> ; disk_write_fat -- Save FAT contents from disk_buffer in RAM to disk
  2283                              <1> ; IN: FAT in disk_buffer; OUT: carry set if failure
  2284                              <1> 
  2285                              <1> disk_write_fat:
  2286 000011D2 60                  <1> 	pusha
  2287                              <1> 
  2288 000011D3 B80100              <1> 	mov ax, 1			; FAT starts at logical sector 1 (after boot sector)
  2289 000011D6 E87100              <1> 	call disk_convert_l2hts
  2290                              <1> 
  2291 000011D9 BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to 8K OS buffer
  2292 000011DC 8CDB                <1> 	mov bx, ds
  2293 000011DE 8EC3                <1> 	mov es, bx
  2294 000011E0 89F3                <1> 	mov bx, si
  2295                              <1> 
  2296 000011E2 B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  2297 000011E4 B009                <1> 	mov al, 9			; And write 9 of them for first FAT
  2298                              <1> 
  2299 000011E6 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2300 000011E7 CD13                <1> 	int 13h				; Write sectors
  2301                              <1> 
  2302 000011E9 7203                <1> 	jc .write_failure		; Fatal double error
  2303                              <1> 
  2304 000011EB 61                  <1> 	popa				; And restore from start of system call
  2305 000011EC F8                  <1> 	clc
  2306 000011ED C3                  <1> 	ret
  2307                              <1> 
  2308                              <1> .write_failure:
  2309 000011EE 61                  <1> 	popa
  2310 000011EF F9                  <1> 	stc				; Set carry flag (for failure)
  2311 000011F0 C3                  <1> 	ret
  2312                              <1> 
  2313                              <1> 
  2314                              <1> ; --------------------------------------------------------------------------
  2315                              <1> ; disk_read_root_dir -- Get the root directory contents
  2316                              <1> ; IN: Nothing; OUT: root directory contents in disk_buffer, carry set if error
  2317                              <1> 
  2318                              <1> disk_read_root_dir:
  2319 000011F1 60                  <1> 	pusha
  2320                              <1> 
  2321 000011F2 B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  2322 000011F5 E85200              <1> 	call disk_convert_l2hts
  2323                              <1> 
  2324 000011F8 BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  2325 000011FB 8CDB                <1> 	mov bx, ds
  2326 000011FD 8EC3                <1> 	mov es, bx
  2327 000011FF 89F3                <1> 	mov bx, si
  2328                              <1> 
  2329 00001201 B402                <1> 	mov ah, 2			; Params for int 13h: read floppy sectors
  2330 00001203 B00E                <1> 	mov al, 14			; And read 14 of them (from 19 onwards)
  2331                              <1> 
  2332 00001205 60                  <1> 	pusha				; Prepare to enter loop
  2333                              <1> 
  2334                              <1> 
  2335                              <1> .read_root_dir_loop:
  2336 00001206 61                  <1> 	popa
  2337 00001207 60                  <1> 	pusha
  2338                              <1> 
  2339 00001208 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2340 00001209 CD13                <1> 	int 13h				; Read sectors
  2341                              <1> 
  2342 0000120B 7308                <1> 	jnc .root_dir_finished
  2343 0000120D E82B00              <1> 	call disk_reset_floppy		; Reset controller and try again
  2344 00001210 73F4                <1> 	jnc .read_root_dir_loop		; Floppy reset OK?
  2345                              <1> 
  2346 00001212 61                  <1> 	popa
  2347 00001213 EB04                <1> 	jmp .read_failure		; Fatal double error
  2348                              <1> 
  2349                              <1> 
  2350                              <1> .root_dir_finished:
  2351 00001215 61                  <1> 	popa				; Restore registers from main loop
  2352                              <1> 
  2353 00001216 61                  <1> 	popa				; And restore from start of this system call
  2354 00001217 F8                  <1> 	clc				; Clear carry (for success)
  2355 00001218 C3                  <1> 	ret
  2356                              <1> 
  2357                              <1> .read_failure:
  2358 00001219 61                  <1> 	popa
  2359 0000121A F9                  <1> 	stc				; Set carry flag (for failure)
  2360 0000121B C3                  <1> 	ret
  2361                              <1> 
  2362                              <1> ; --------------------------------------------------------------------------
  2363                              <1> ; disk_write_root_dir -- Write root directory contents from disk_buffer to disk
  2364                              <1> ; IN: root dir copy in disk_buffer; OUT: carry set if error
  2365                              <1> 
  2366                              <1> disk_write_root_dir:
  2367 0000121C 60                  <1> 	pusha
  2368                              <1> 
  2369 0000121D B81300              <1> 	mov ax, 19			; Root dir starts at logical sector 19
  2370 00001220 E82700              <1> 	call disk_convert_l2hts
  2371                              <1> 
  2372 00001223 BE00E0              <1> 	mov si, disk_buffer		; Set ES:BX to point to OS buffer
  2373 00001226 8CDB                <1> 	mov bx, ds
  2374 00001228 8EC3                <1> 	mov es, bx
  2375 0000122A 89F3                <1> 	mov bx, si
  2376                              <1> 
  2377 0000122C B403                <1> 	mov ah, 3			; Params for int 13h: write floppy sectors
  2378 0000122E B00E                <1> 	mov al, 14			; And write 14 of them (from 19 onwards)
  2379                              <1> 
  2380 00001230 F9                  <1> 	stc				; A few BIOSes do not set properly on error
  2381 00001231 CD13                <1> 	int 13h				; Write sectors
  2382 00001233 7203                <1> 	jc .write_failure
  2383                              <1> 
  2384 00001235 61                  <1> 	popa				; And restore from start of this system call
  2385 00001236 F8                  <1> 	clc
  2386 00001237 C3                  <1> 	ret
  2387                              <1> 
  2388                              <1> .write_failure:
  2389 00001238 61                  <1> 	popa
  2390 00001239 F9                  <1> 	stc				; Set carry flag (for failure)
  2391 0000123A C3                  <1> 	ret
  2392                              <1> 
  2393                              <1> 
  2394                              <1> ; --------------------------------------------------------------------------
  2395                              <1> ; Reset floppy disk
  2396                              <1> 
  2397                              <1> disk_reset_floppy:
  2398 0000123B 50                  <1> 	push ax
  2399 0000123C 52                  <1> 	push dx
  2400 0000123D B80000              <1> 	mov ax, 0
  2401                              <1> ; ******************************************************************
  2402 00001240 8A16[7912]          <1> 	mov dl, [bootdev]
  2403                              <1> ; ******************************************************************
  2404 00001244 F9                  <1> 	stc
  2405 00001245 CD13                <1> 	int 13h
  2406 00001247 5A                  <1> 	pop dx
  2407 00001248 58                  <1> 	pop ax
  2408 00001249 C3                  <1> 	ret
  2409                              <1> 
  2410                              <1> 
  2411                              <1> ; --------------------------------------------------------------------------
  2412                              <1> ; disk_convert_l2hts -- Calculate head, track and sector for int 13h
  2413                              <1> ; IN: logical sector in AX; OUT: correct registers for int 13h
  2414                              <1> 
  2415                              <1> disk_convert_l2hts:
  2416 0000124A 53                  <1> 	push bx
  2417 0000124B 50                  <1> 	push ax
  2418                              <1> 
  2419 0000124C 89C3                <1> 	mov bx, ax			; Save logical sector
  2420                              <1> 
  2421 0000124E BA0000              <1> 	mov dx, 0			; First the sector
  2422 00001251 F736[7712]          <1> 	div word [SecsPerTrack]		; Sectors per track
  2423 00001255 80C201              <1> 	add dl, 01h			; Physical sectors start at 1
  2424 00001258 88D1                <1> 	mov cl, dl			; Sectors belong in CL for int 13h
  2425 0000125A 89D8                <1> 	mov ax, bx
  2426                              <1> 
  2427 0000125C BA0000              <1> 	mov dx, 0			; Now calculate the head
  2428 0000125F F736[7712]          <1> 	div word [SecsPerTrack]		; Sectors per track
  2429 00001263 BA0000              <1> 	mov dx, 0
  2430 00001266 F736[7512]          <1> 	div word [Sides]		; Floppy sides
  2431 0000126A 88D6                <1> 	mov dh, dl			; Head/side
  2432 0000126C 88C5                <1> 	mov ch, al			; Track
  2433                              <1> 	
  2434 0000126E 58                  <1> 	pop ax
  2435 0000126F 5B                  <1> 	pop bx
  2436                              <1> 
  2437 00001270 8A16[7912]          <1> 	mov dl, [bootdev]		; Set correct device
  2438                              <1> 
  2439 00001274 C3                  <1> 	ret
  2440                              <1> 
  2441                              <1> 
  2442                              <1> 
  2443 00001275 0200                <1> 	Sides dw 2
  2444 00001277 1200                <1> 	SecsPerTrack dw 18
  2445                              <1> 	
  2446 00001279 00                  <1> 	bootdev db 0			; Boot device number
  2447                              <1> 
  2448                              <1> 
  2449                              <1> ; ==================================================================
  2450                              <1> 
  2451                              <1> 
   811                                  	%INCLUDE "drivers/keyboard.asm"
   812                              <1> ; ==================================================================
   813                              <1> ; KEYBOARD HANDLING ROUTINES
   814                              <1> ; ==================================================================
   815                              <1> 
   816                              <1> ; ------------------------------------------------------------------
   817                              <1> ; os_wait_for_key -- Waits for keypress and returns key
   818                              <1> ; Also handles the screensaver. TODO: move the screensaver code to "int.asm"
   819                              <1> ; IN: Nothing; OUT: AX = key pressed, other regs preserved
   820                              <1> 
   821                              <1> os_wait_for_key:
   822 0000127A 60                  <1> 	pusha
   823                              <1> 	
   824                              <1> .try_again:
   825 0000127B B700                <1> 	mov bh, 0
   826 0000127D E88200              <1> 	call .screen_power
   827                              <1> 
   828                              <1> 	; Reset the screensaver tick
   829 00001280 0FB606F2DE          <1> 	movzx ax, byte [57074]
   830 00001285 BB4404              <1> 	mov bx, 1092		; 18.2 Hz * 60 seconds
   831 00001288 F7E3                <1> 	mul bx
   832 0000128A A3[B548]            <1> 	mov [screensaver_timer], ax		; See "int.asm"
   833                              <1> 	
   834 0000128D C606[1B13]00        <1> 	mov byte [.scrn_active], 0	; Reset all the screensaver variables
   835                              <1> 
   836 00001292 A08200              <1> 	mov al, [0082h]				; Save the current screen state, for later
   837 00001295 A2[1813]            <1> 	mov [.gfx_state], al
   838 00001298 B403                <1> 	mov ah, 03h
   839 0000129A B700                <1> 	mov bh, 0
   840 0000129C CD10                <1> 	int 10h
   841 0000129E 890E[1913]          <1> 	mov [.orig_crsr], cx		; Get the shape of the cursor
   842                              <1> 	
   843                              <1> .loop:
   844 000012A2 F4                  <1> 	hlt							; Halt the CPU for 1/18.2 seconds, to save the CPU usage
   845 000012A3 E82C00              <1> 	call .screensaver
   846 000012A6 E87400              <1> 	call os_check_for_key
   847                              <1> 	
   848 000012A9 83F800              <1> 	cmp ax, 0
   849 000012AC 74F4                <1> 	je .loop
   850                              <1> 
   851 000012AE 60                  <1> 	pusha
   852 000012AF B80005              <1> 	mov ax, 0500h
   853 000012B2 CD10                <1> 	int 10h
   854                              <1> 	
   855 000012B4 A0[1813]            <1> 	mov al, [.gfx_state]
   856 000012B7 A28200              <1> 	mov [0082h], al
   857 000012BA 8B0E[1913]          <1> 	mov cx, [.orig_crsr]
   858 000012BE B401                <1> 	mov ah, 01h
   859 000012C0 CD10                <1> 	int 10h
   860 000012C2 61                  <1> 	popa
   861                              <1> 	
   862 000012C3 803E[1B13]01        <1> 	cmp byte [.scrn_active], 1
   863 000012C8 74B1                <1> 	je .try_again
   864                              <1> 	
   865 000012CA A3[1613]            <1> 	mov [.tmp_buf], ax
   866                              <1> 
   867 000012CD 61                  <1> 	popa
   868 000012CE A1[1613]            <1> 	mov ax, [.tmp_buf]
   869 000012D1 C3                  <1> 	ret
   870                              <1> 	
   871                              <1> .screensaver:
   872 000012D2 833E[B548]00        <1> 	cmp word [screensaver_timer], 0
   873 000012D7 7528                <1> 	jne .good
   874                              <1> 	
   875 000012D9 803EF2DE00          <1> 	cmp byte [57074], 0
   876 000012DE 7421                <1> 	je .good
   877                              <1> 	
   878 000012E0 B40F                <1> 	mov ah, 0Fh
   879 000012E2 CD10                <1> 	int 10h
   880                              <1> 	
   881 000012E4 3C03                <1> 	cmp al, 3
   882 000012E6 7519                <1> 	jne .good
   883                              <1> 	
   884 000012E8 60                  <1> 	pusha
   885 000012E9 C606820001          <1> 	mov byte [0082h], 1
   886 000012EE B80105              <1> 	mov ax, 0501h
   887 000012F1 CD10                <1> 	int 10h
   888 000012F3 E8B005              <1> 	call os_hide_cursor
   889 000012F6 C606[1B13]01        <1> 	mov byte [.scrn_active], 1
   890                              <1> 
   891 000012FB B704                <1> 	mov bh, 4
   892 000012FD E80200              <1> 	call .screen_power
   893 00001300 61                  <1> 	popa
   894                              <1> 
   895                              <1> .good:
   896 00001301 C3                  <1> 	ret
   897                              <1> 	
   898                              <1> .screen_power:
   899 00001302 3A3E[1C13]          <1> 	cmp bh, [.scrn_power]
   900 00001306 74F9                <1> 	je .good
   901                              <1> 
   902 00001308 60                  <1> 	pusha
   903 00001309 B8104F              <1> 	mov ax, 4F10h
   904 0000130C B301                <1> 	mov bl, 1
   905 0000130E 883E[1C13]          <1> 	mov [.scrn_power], bh
   906 00001312 CD10                <1> 	int 10h
   907 00001314 61                  <1> 	popa
   908 00001315 C3                  <1> 	ret
   909                              <1> 	
   910 00001316 0000                <1> 	.tmp_buf		dw 0
   911 00001318 00                  <1> 	.gfx_state		db 0
   912 00001319 0000                <1> 	.orig_crsr		dw 0
   913 0000131B 00                  <1> 	.scrn_active	db 0
   914 0000131C 00                  <1> 	.scrn_power		db 0
   915                              <1> 	
   916                              <1> ; ------------------------------------------------------------------
   917                              <1> ; os_check_for_key -- Scans keyboard buffer for input, but doesn't wait
   918                              <1> ; Also handles special keyboard shortcuts.
   919                              <1> ; IN: Nothing; OUT: AX = 0 if no key pressed, otherwise scan code
   920                              <1> 
   921                              <1> os_check_for_key:
   922 0000131D 60                  <1> 	pusha
   923                              <1> 
   924 0000131E B411                <1> 	mov ah, 11h			; BIOS call to check for key
   925                              <1> 	
   926 00001320 CD16                <1> 	int 16h
   927                              <1> 		
   928 00001322 740F                <1> 	jz .nokey			; If no key, skip to end
   929                              <1> 
   930 00001324 B410                <1> 	mov ah, 10h			; Otherwise get it from buffer
   931 00001326 CD16                <1> 	int 16h
   932                              <1> 
   933 00001328 E80E00              <1> 	call special_keys
   934                              <1> 
   935 0000132B A3[3713]            <1> 	mov [.tmp_buf], ax		; Store resulting keypress
   936                              <1> 
   937 0000132E 61                  <1> 	popa				; But restore all other regs
   938 0000132F A1[3713]            <1> 	mov ax, [.tmp_buf]
   939 00001332 C3                  <1> 	ret
   940                              <1> 
   941                              <1> .nokey:
   942 00001333 61                  <1> 	popa
   943                              <1> 	clr ax			; Zero result if no key pressed
    11 00001334 31C0                <2>  xor %1, %1
   944 00001336 C3                  <1> 	ret
   945                              <1> 
   946                              <1> 
   947 00001337 0000                <1> 	.tmp_buf	dw 0
   948                              <1> 
   949                              <1> 
   950                              <1> ; ==================================================================
   951                              <1> 
   952                              <1> ; Checks for special keys and performs their action.
   953                              <1> ; IN: AX = key
   954                              <1> ; OUT: nothing
   955                              <1> special_keys:
   956 00001339 60                  <1> 	pusha
   957 0000133A 80FC69              <1> 	cmp ah, 105
   958 0000133D 0F844E00            <1> 	je near .disable_sound
   959 00001341 80FC6A              <1> 	cmp ah, 106
   960 00001344 0F844000            <1> 	je near .enable_sound
   961 00001348 80FC6B              <1> 	cmp ah, 107
   962 0000134B 0F842500            <1> 	je near .exit_app
   963 0000134F 80FC8B              <1> 	cmp ah, 139
   964 00001352 0F840200            <1> 	je near .intended_system_crash
   965 00001356 61                  <1> 	popa
   966 00001357 C3                  <1> 	ret
   967                              <1> 	
   968                              <1> .intended_system_crash:
   969 00001358 B8[5E13]            <1> 	mov ax, .crash_msg
   970 0000135B E84202              <1> 	call os_fatal_error
   971                              <1> 	
   972 0000135E 496E74656E64656420- <1> 	.crash_msg		db 'Intended system crash', 0
   972 00001367 73797374656D206372- <1>
   972 00001370 61736800            <1>
   973                              <1> 	
   974                              <1> .exit_app:
   975 00001374 803E[B408]00        <1> 	cmp byte [app_running], 0
   976 00001379 0F840900            <1> 	je near .no_exit
   977                              <1> 	
   978 0000137D 61                  <1> 	popa
   979                              <1> 	
   980 0000137E 8B26[B208]          <1> 	mov sp, [origstack]
   981 00001382 83EC02              <1> 	sub sp, 2
   982                              <1> 	
   983 00001385 C3                  <1> 	ret
   984                              <1> 	
   985                              <1> .no_exit:
   986 00001386 61                  <1> 	popa
   987 00001387 C3                  <1> 	ret
   988                              <1> 		
   989                              <1> .enable_sound:
   990 00001388 C606830001          <1> 	mov byte [0083h], 1
   991 0000138D EB08                <1> 	jmp .display_speaker
   992                              <1> 	
   993                              <1> .disable_sound:
   994 0000138F C606830000          <1> 	mov byte [0083h], 0
   995 00001394 E8D312              <1> 	call os_speaker_off
   996                              <1> 
   997                              <1> .display_speaker:
   998 00001397 803E820001          <1> 	cmp byte [0082h], 1
   999 0000139C 741E                <1> 	je .no_display_spkr
  1000                              <1> 
  1001 0000139E E8CE04              <1> 	call os_get_cursor_pos
  1002 000013A1 52                  <1> 	push dx
  1003 000013A2 BA4F00              <1> 	mov dx, 79			; Print the little speaker icon
  1004 000013A5 E8BE04              <1> 	call os_move_cursor
  1005                              <1> 	
  1006 000013A8 B8170E              <1> 	mov ax, 0E17h
  1007 000013AB B700                <1> 	mov bh, 0
  1008 000013AD 803E830000          <1> 	cmp byte [0083h], 0
  1009 000013B2 7402                <1> 	je .no_crossed_spkr
  1010                              <1> 	
  1011 000013B4 FEC8                <1> 	dec al
  1012                              <1> 	
  1013                              <1> .no_crossed_spkr:
  1014 000013B6 CD10                <1> 	int 10h
  1015 000013B8 5A                  <1> 	pop dx
  1016 000013B9 E8AA04              <1> 	call os_move_cursor
  1017                              <1> 	
  1018                              <1> .no_display_spkr:
  1019 000013BC 61                  <1> 	popa
  1020 000013BD C3                  <1> 	ret
  1021                              <1> 	
  1022                              <1> ; ==================================================================
  1023                              <1> 
   812                                  	%INCLUDE "drivers/math.asm"
   813                              <1> ; ==================================================================
   814                              <1> ; MATH ROUTINES
   815                              <1> ; ==================================================================
   816                              <1> 
   817                              <1> ; ------------------------------------------------------------------
   818                              <1> ; os_seed_random -- Seed the random number generator based on the current state of registers and time
   819                              <1> ; IN: every register; OUT: Nothing (registers preserved)
   820                              <1> 
   821                              <1> os_seed_random:
   822 000013BE 60                  <1> 	pusha
   823                              <1> 
   824 000013BF B402                <1> 	mov ah, 02h
   825 000013C1 CD1A                <1> 	int 1Ah
   826                              <1> 	
   827 000013C3 31D8                <1> 	xor ax, bx
   828 000013C5 01C8                <1> 	add ax, cx
   829 000013C7 31D0                <1> 	xor ax, dx
   830 000013C9 01F0                <1> 	add ax, si
   831 000013CB 31F8                <1> 	xor ax, di
   832 000013CD 01E0                <1> 	add ax, sp
   833 000013CF 31E8                <1> 	xor ax, bp
   834 000013D1 05ADDE              <1> 	add ax, 0xDEAD
   835 000013D4 35EFBE              <1> 	xor ax, 0xBEEF
   836                              <1> 	
   837 000013D7 A3[DC13]            <1> 	mov [os_random_seed], ax	; Store the data
   838 000013DA 61                  <1> 	popa
   839 000013DB C3                  <1> 	ret
   840                              <1> 
   841                              <1> 
   842 000013DC 0000                <1> 	os_random_seed	dw 0
   843                              <1> 
   844                              <1> 
   845                              <1> ; ------------------------------------------------------------------
   846                              <1> ; os_get_random -- Return a random integer between low and high (inclusive)
   847                              <1> ; IN: AX = low integer, BX = high integer
   848                              <1> ; OUT: CX = random integer
   849                              <1> 
   850                              <1> os_get_random:
   851 000013DE 52                  <1> 	push dx
   852 000013DF 53                  <1> 	push bx
   853 000013E0 50                  <1> 	push ax
   854                              <1> 
   855 000013E1 29C3                <1> 	sub bx, ax			; We want a number between 0 and (high-low)
   856 000013E3 E80D00              <1> 	call .generate_random
   857 000013E6 89DA                <1> 	mov dx, bx
   858 000013E8 42                  <1> 	inc dx
   859 000013E9 F7E2                <1> 	mul dx
   860 000013EB 89D1                <1> 	mov cx, dx
   861                              <1> 
   862 000013ED 58                  <1> 	pop ax
   863 000013EE 5B                  <1> 	pop bx
   864 000013EF 5A                  <1> 	pop dx
   865 000013F0 01C1                <1> 	add cx, ax			; Add the low offset back
   866 000013F2 C3                  <1> 	ret
   867                              <1> 
   868                              <1> 
   869                              <1> .generate_random:
   870 000013F3 52                  <1> 	push dx
   871 000013F4 53                  <1> 	push bx
   872                              <1> 
   873 000013F5 A1[DC13]            <1> 	mov ax, [os_random_seed]
   874 000013F8 BA8373              <1> 	mov dx, 0x7383			; The magic number (random.org)
   875 000013FB F7E2                <1> 	mul dx				; DX:AX = AX * DX
   876 000013FD A3[DC13]            <1> 	mov [os_random_seed], ax
   877                              <1> 
   878 00001400 5B                  <1> 	pop bx
   879 00001401 5A                  <1>  	pop dx
   880 00001402 C3                  <1> 	ret
   881                              <1> 
   882                              <1> 
   883                              <1> ; ------------------------------------------------------------------
   884                              <1> ; os_bcd_to_int -- Converts a binary coded decimal number to an integer
   885                              <1> ; IN: AL = BCD number; OUT: AX = integer value
   886                              <1> 
   887                              <1> os_bcd_to_int:
   888 00001403 60                  <1> 	pusha
   889                              <1> 
   890 00001404 88C3                <1> 	mov bl, al			; Store entire number for now
   891                              <1> 
   892 00001406 83E00F              <1> 	and ax, 0Fh			; Zero-out high bits
   893 00001409 89C1                <1> 	mov cx, ax			; CH/CL = lower BCD number, zero extended
   894                              <1> 
   895 0000140B C0EB04              <1> 	shr bl, 4			; Move higher BCD number into lower bits, zero fill msb
   896 0000140E B00A                <1> 	mov al, 10
   897 00001410 F6E3                <1> 	mul bl				; AX = 10 * BL
   898                              <1> 
   899 00001412 01C8                <1> 	add ax, cx			; Add lower BCD to 10*higher
   900 00001414 A3[1C14]            <1> 	mov [.tmp], ax
   901                              <1> 
   902 00001417 61                  <1> 	popa
   903 00001418 A1[1C14]            <1> 	mov ax, [.tmp]			; And return it in AX!
   904 0000141B C3                  <1> 	ret
   905                              <1> 
   906                              <1> 
   907 0000141C 0000                <1> 	.tmp	dw 0
   908                              <1> 
   909                              <1> 	
   910                              <1> ; ------------------------------------------------------------------
   911                              <1> ; os_int_to_bcd -- Converts an integer to a binary coded decimal number
   912                              <1> ; IN: AL = integer value; OUT: AL = BCD number
   913                              <1> 
   914                              <1> os_int_to_bcd:
   915 0000141E 60                  <1> 	pusha
   916 0000141F 0FB6C0              <1> 	movzx ax, al
   917 00001422 31D2                <1> 	xor dx, dx
   918                              <1> 	
   919 00001424 BB0A00              <1> 	mov bx, 10
   920 00001427 F7F3                <1> 	div bx
   921                              <1> 	
   922 00001429 C0E004              <1> 	shl al, 4
   923 0000142C 00C2                <1> 	add dl, al
   924                              <1> 	
   925 0000142E 8816[3714]          <1> 	mov [.tmp], dl
   926 00001432 61                  <1> 	popa
   927 00001433 A0[3714]            <1> 	mov al, [.tmp]
   928 00001436 C3                  <1> 	ret
   929                              <1> 
   930 00001437 00                  <1> 	.tmp	db 0
   931                              <1> 
   932                              <1> 
   933                              <1> ; Calculates EAX^EBX.
   934                              <1> ; IN: EAX^EBX = input
   935                              <1> ; OUT: EAX = result
   936                              <1> 
   937                              <1> os_math_power:
   938 00001438 6660                <1> 	pushad
   939 0000143A 6683FB01            <1> 	cmp ebx, 1
   940 0000143E 0F841900            <1> 	je near .power_end
   941 00001442 6683FB00            <1> 	cmp ebx, 0
   942 00001446 0F841F00            <1> 	je near .zero
   943 0000144A 6689D9              <1> 	mov ecx, ebx				; Prepare the data
   944 0000144D 6689C3              <1> 	mov ebx, eax
   945                              <1> .power_loop:
   946 00001450 66F7E3              <1> 	mul ebx
   947 00001453 6649                <1> 	dec ecx
   948 00001455 6683F901            <1> 	cmp ecx, 1
   949 00001459 7FF5                <1> 	jnle .power_loop
   950                              <1> .power_end:
   951 0000145B 66A3[7514]          <1> 	mov [.tmp_dword], eax
   952 0000145F 6661                <1> 	popad
   953 00001461 66A1[7514]          <1> 	mov eax, [.tmp_dword]
   954 00001465 6631D2              <1> 	xor edx, edx
   955 00001468 C3                  <1> 	ret
   956                              <1> .zero:
   957 00001469 6661                <1> 	popad
   958 0000146B 66B801000000        <1> 	mov eax, 1
   959 00001471 6631D2              <1> 	xor edx, edx
   960 00001474 C3                  <1> 	ret
   961                              <1> 	
   962 00001475 00000000            <1> 	.tmp_dword		dd 0
   963 00001479 00000000            <1> 	.tmp_dword2		dd 0
   964                              <1> 	
   965                              <1> ; Calculates the EBX root of EAX.
   966                              <1> ; IN: EAX = input, EBX = root
   967                              <1> ; OUT: EAX(EDX = 0) = result; EAX to EDX = range
   968                              <1> 
   969                              <1> os_math_root:
   970 0000147D 6660                <1> 	pushad
   971 0000147F 6689C1              <1> 	mov ecx, eax				; Prepare the data
   972 00001482 66BE02000000        <1> 	mov esi, 2
   973                              <1> .root_loop:
   974 00001488 6689F0              <1> 	mov eax, esi
   975 0000148B E8AAFF              <1> 	call os_math_power
   976 0000148E 6639C8              <1> 	cmp eax, ecx
   977 00001491 0F840800            <1> 	je near .root_exact
   978 00001495 0F8F1300            <1> 	jg near .root_range
   979 00001499 6646                <1> 	inc esi
   980 0000149B EBEB                <1> 	jmp .root_loop
   981                              <1> .root_exact:
   982 0000149D 668936[C414]        <1> 	mov [.tmp_dword], esi
   983 000014A2 6661                <1> 	popad
   984 000014A4 66A1[C414]          <1> 	mov eax, [.tmp_dword]
   985 000014A8 6631D2              <1> 	xor edx, edx
   986 000014AB C3                  <1> 	ret
   987                              <1> .root_range:
   988 000014AC 668936[C814]        <1> 	mov [.tmp_dword2], esi
   989 000014B1 664E                <1> 	dec esi
   990 000014B3 668936[C414]        <1> 	mov [.tmp_dword], esi
   991 000014B8 6661                <1> 	popad
   992 000014BA 66A1[C414]          <1> 	mov eax, [.tmp_dword]
   993 000014BE 668B16[C814]        <1> 	mov edx, [.tmp_dword2]
   994 000014C3 C3                  <1> 	ret
   995                              <1> 	
   996 000014C4 00000000            <1> 	.tmp_dword		dd 0
   997 000014C8 00000000            <1> 	.tmp_dword2		dd 0
   998                              <1> 
   999                              <1> ; ==================================================================
   813                                  	%INCLUDE "drivers/misc.asm"
   814                              <1> ; ==================================================================
   815                              <1> ; MISCELLANEOUS ROUTINES
   816                              <1> ; ==================================================================
   817                              <1> 
   818                              <1> ; ------------------------------------------------------------------
   819                              <1> ; os_pause -- Delay execution for specified 110ms chunks
   820                              <1> ; IN: AX = amount of ticks to wait
   821                              <1> 
   822                              <1> os_pause:
   823 000014CC 60                  <1> 	pusha
   824 000014CD 83F800              <1> 	cmp ax, 0
   825 000014D0 741F                <1> 	je .time_up			; If delay = 0 then bail out
   826                              <1> 
   827 000014D2 C706[0815]0000      <1> 	mov word [.counter_var], 0		; Zero the counter variable
   828                              <1> 
   829 000014D8 A3[0615]            <1> 	mov [.orig_req_delay], ax	; Save it
   830                              <1> 
   831 000014DB B400                <1> 	mov ah, 0
   832 000014DD E8D901              <1> 	call os_int_1Ah				; Get tick count	
   833                              <1> 
   834 000014E0 8916[0A15]          <1> 	mov [.prev_tick_count], dx	; Save it for later comparison
   835                              <1> 
   836                              <1> .checkloop:
   837 000014E4 B400                <1> 	mov ah,0
   838 000014E6 E8D001              <1> 	call os_int_1Ah				; Get tick count again
   839                              <1> 
   840 000014E9 3916[0A15]          <1> 	cmp [.prev_tick_count], dx	; Compare with previous tick count
   841                              <1> 
   842 000014ED 7504                <1> 	jne .up_date			; If it's changed check it
   843 000014EF EBF3                <1> 	jmp .checkloop			; Otherwise wait some more
   844                              <1> 
   845                              <1> .time_up:
   846 000014F1 61                  <1> 	popa
   847 000014F2 C3                  <1> 	ret
   848                              <1> 
   849                              <1> .up_date:
   850 000014F3 FF06[0815]          <1> 	inc word [.counter_var]		; Inc counter_var
   851 000014F7 A1[0815]            <1> 	mov ax, [.counter_var]
   852                              <1> 	
   853 000014FA 3B06[0615]          <1> 	cmp ax, [.orig_req_delay]	; Is counter_var = required delay?
   854 000014FE 7DF1                <1> 	jge .time_up			; Yes, so bail out
   855                              <1> 
   856 00001500 8916[0A15]          <1> 	mov [.prev_tick_count], dx	; No, so update .prev_tick_count 
   857                              <1> 
   858 00001504 EBDE                <1> 	jmp .checkloop			; And go wait some more
   859                              <1> 
   860                              <1> 
   861 00001506 0000                <1> 	.orig_req_delay		dw	0
   862 00001508 0000                <1> 	.counter_var		dw	0
   863 0000150A 0000                <1> 	.prev_tick_count	dw	0
   864                              <1> 
   865                              <1> ; ------------------------------------------------------------------
   866                              <1> ; os_clear_registers -- Clear all registers
   867                              <1> ; IN: Nothing; OUT: Clear registers
   868                              <1> 
   869                              <1> os_clear_registers:
   870 0000150C 6631C0              <1> 	xor eax, eax
   871 0000150F 6631DB              <1> 	xor ebx, ebx
   872 00001512 6631C9              <1> 	xor ecx, ecx
   873 00001515 6631D2              <1> 	xor edx, edx
   874 00001518 6631F6              <1> 	xor esi, esi
   875 0000151B 6631FF              <1> 	xor edi, edi
   876 0000151E C3                  <1> 	ret
   877                              <1> 
   878                              <1> os_illegal_call:
   879 0000151F B8[2415]            <1> 	mov ax, .msg
   880 00001522 EB7C                <1> 	jmp os_fatal_error
   881                              <1> 	
   882 00001524 43616C6C6564206120- <1> 	.msg db 'Called a non-existent system function', 0
   882 0000152D 6E6F6E2D6578697374- <1>
   882 00001536 656E74207379737465- <1>
   882 0000153F 6D2066756E6374696F- <1>
   882 00001548 6E00                <1>
   883                              <1> 	
   884                              <1> os_update_clock:
   885 0000154A 60                  <1> 	pusha
   886 0000154B 803E820001          <1> 	cmp byte [0082h], 1
   887 00001550 0F843B00            <1> 	je near .update_time_end
   888                              <1> 	
   889 00001554 B402                <1> 	mov ah, 02h			; Get the time
   890 00001556 E86001              <1> 	call os_int_1Ah
   891 00001559 3B0E[9D15]          <1> 	cmp cx, [.tmp_time]
   892 0000155D 0F842E00            <1> 	je near .update_time_end
   893 00001561 890E[9D15]          <1> 	mov [.tmp_time], cx
   894                              <1> 	
   895 00001565 E80703              <1> 	call os_get_cursor_pos
   896 00001568 52                  <1> 	push dx
   897                              <1> 	
   898 00001569 BB[9115]            <1> 	mov bx, .tmp_buffer
   899 0000156C E88416              <1> 	call os_get_date_string
   900                              <1> 	
   901 0000156F BA4500              <1> 	mov dx, 69			; Display date
   902 00001572 E8F102              <1> 	call os_move_cursor
   903                              <1> 
   904 00001575 89DE                <1> 	mov si, bx
   905 00001577 E87B02              <1> 	call os_print_string
   906                              <1> 	
   907 0000157A BB[9115]            <1> 	mov bx, .tmp_buffer
   908 0000157D E82C16              <1> 	call os_get_time_string
   909                              <1> 
   910 00001580 BA3F00              <1> 	mov dx, 63			; Display time
   911 00001583 E8E002              <1> 	call os_move_cursor
   912 00001586 89DE                <1> 	mov si, bx
   913 00001588 E86A02              <1> 	call os_print_string
   914                              <1> 	
   915 0000158B 5A                  <1> 	pop dx
   916 0000158C E8D702              <1> 	call os_move_cursor
   917                              <1> 	
   918                              <1> .update_time_end:
   919 0000158F 61                  <1> 	popa
   920 00001590 C3                  <1> 	ret
   921                              <1> 	
   922 00001591 00<rep Ch>          <1> 	.tmp_buffer		times 12 db 0
   923 0000159D 0000                <1> 	.tmp_time		dw 0
   924 0000159F 00                  <1> 	.tmp_hours		db 0
   925                              <1> 
   926                              <1> ; ------------------------------------------------------------------
   927                              <1> ; os_fatal_error -- Display error message and halt execution
   928                              <1> ; IN: AX = error message string location
   929                              <1> 
   930                              <1> os_fatal_error:
   931 000015A0 A3[9816]            <1> 	mov [.ax], ax			; Store string location for now, ...
   932 000015A3 E8AA02              <1> 	call os_clear_screen
   933                              <1> 	
   934                              <1> .main_screen:
   935 000015A6 8CC8                <1> 	mov ax, cs
   936 000015A8 8ED8                <1> 	mov ds, ax
   937 000015AA 8EC0                <1> 	mov es, ax
   938                              <1> 
   939 000015AC B80300              <1> 	mov ax, 3
   940 000015AF CD10                <1> 	int 10h
   941                              <1> 	
   942 000015B1 B80310              <1> 	mov ax, 1003h				; Set text output with certain attributes
   943 000015B4 31DB                <1> 	xor bx, bx					; to be bright, and not blinking
   944 000015B6 CD10                <1> 	int 10h	
   945                              <1> 
   946 000015B8 B8[5416]            <1> 	mov ax, .title_msg
   947 000015BB BB[6816]            <1> 	mov bx, .footer_msg
   948 000015BE B94F00              <1> 	mov cx, 01001111b
   949 000015C1 E8AD08              <1> 	call os_draw_background
   950 000015C4 E8200E              <1> 	call os_reset_font
   951                              <1> 	
   952 000015C7 BA0002              <1> 	mov dx, 2 * 256
   953 000015CA E89902              <1> 	call os_move_cursor
   954 000015CD BE[B508]            <1> 	mov si, bomblogo
   955 000015D0 E8520E              <1> 	call os_draw_icon
   956                              <1> 	
   957 000015D3 BA2302              <1> 	mov dx, 2 * 256 + 35
   958 000015D6 E88D02              <1> 	call os_move_cursor
   959                              <1> 	
   960 000015D9 BE[6916]            <1> 	mov si, .msg0
   961 000015DC E81602              <1> 	call os_print_string
   962                              <1> 	
   963 000015DF BA2303              <1> 	mov dx, 3 * 256 + 35
   964 000015E2 E88102              <1> 	call os_move_cursor
   965                              <1> 	
   966 000015E5 B82A0A              <1> 	mov ax, 0A2Ah					; Write a 43-character long asterisk-type line
   967 000015E8 B700                <1> 	mov bh, 0
   968 000015EA B92B00              <1> 	mov cx, 43
   969 000015ED CD10                <1> 	int 10h
   970                              <1> 	
   971 000015EF BA2305              <1> 	mov dx, 5 * 256 + 35
   972 000015F2 E87102              <1> 	call os_move_cursor
   973 000015F5 BE[9016]            <1> 	mov si, .msg3
   974 000015F8 E8FA01              <1> 	call os_print_string
   975                              <1> 
   976 000015FB 8B36[9816]          <1> 	mov si, [.ax]
   977 000015FF E8F301              <1> 	call os_print_string
   978                              <1> 
   979 00001602 E8A102              <1> 	call os_hide_cursor
   980                              <1> 	
   981 00001605 5B                  <1> 	pop bx
   982 00001606 58                  <1> 	pop ax
   983                              <1> 	
   984                              <1> 	mov16 dx, 35, 7
    15 00001607 BA2307              <2>  mov %1, (%2 + %3 * 256)
   985 0000160A E85902              <1> 	call os_move_cursor
   986                              <1> 	
   987 0000160D BE[3316]            <1> 	mov si, .msg
   988 00001610 E8E201              <1> 	call os_print_string
   989                              <1> 	
   990 00001613 E88A0B              <1> 	call os_print_4hex
   991                              <1> 	
   992 00001616 B03A                <1> 	mov al, ':'
   993 00001618 E8C601              <1> 	call os_putchar
   994                              <1> 	
   995 0000161B 89D8                <1> 	mov ax, bx
   996 0000161D E8800B              <1> 	call os_print_4hex
   997                              <1> 	
   998                              <1> 	mov16 dx, 35, 8
    15 00001620 BA2308              <2>  mov %1, (%2 + %3 * 256)
   999 00001623 E84002              <1> 	call os_move_cursor
  1000                              <1> 	
  1001 00001626 BE[4416]            <1> 	mov si, .msg1
  1002 00001629 E8C901              <1> 	call os_print_string
  1003                              <1> 	
  1004 0000162C 89E0                <1> 	mov ax, sp
  1005 0000162E E86F0B              <1> 	call os_print_4hex
  1006                              <1> 	
  1007 00001631 FA                  <1> 	cli
  1008 00001632 F4                  <1> 	hlt
  1009                              <1> 	
  1010 00001633 4372617368206C6F63- <1> 	.msg 			db 'Crash location: ', 0
  1010 0000163C 6174696F6E3A2000    <1>
  1011 00001644 537461636B20706F69- <1> 	.msg1			db 'Stack pointer: ', 0
  1011 0000164D 6E7465723A2000      <1>
  1012                              <1> 	
  1013 00001654 43726570654F532053- <1> 	.title_msg		db 'CrepeOS System Error'
  1013 0000165D 797374656D20457272- <1>
  1013 00001666 6F72                <1>
  1014 00001668 00                  <1> 	.footer_msg		db 0
  1015                              <1> 	
  1016 00001669 43726570654F532068- <1> 	.msg0			db 'CrepeOS has encountered a fatal error.', 0
  1016 00001672 617320656E636F756E- <1>
  1016 0000167B 746572656420612066- <1>
  1016 00001684 6174616C206572726F- <1>
  1016 0000168D 722E00              <1>
  1017 00001690 4572726F723A2000    <1> 	.msg3			db 'Error: ', 0
  1018                              <1> 
  1019 00001698 0000                <1> 	.ax				dw 0
  1020                              <1> 
  1021                              <1> ; Gets the amount of system RAM.
  1022                              <1> ; IN: nothing
  1023                              <1> ; OUT: AX = conventional memory(kB), EBX = high memory(kB)
  1024                              <1> os_get_memory:
  1025 0000169A 60                  <1> 	pusha
  1026 0000169B 31C9                <1> 	xor cx, cx
  1027 0000169D CD12                <1> 	int 12h					; Get the conventional memory size...
  1028 0000169F A3[B216]            <1> 	mov [.conv_mem], ax		; ...and store it
  1029                              <1> 	
  1030 000016A2 B488                <1> 	mov ah, 88h				; Also get the high memory (>1MB)...
  1031 000016A4 CD15                <1> 	int 15h
  1032 000016A6 A3[B416]            <1> 	mov [.high_mem], ax		; ...and store it too
  1033 000016A9 61                  <1> 	popa
  1034 000016AA A1[B216]            <1> 	mov ax, [.conv_mem]
  1035 000016AD 8B1E[B416]          <1> 	mov bx, [.high_mem]
  1036 000016B1 C3                  <1> 	ret
  1037                              <1> 
  1038 000016B2 0000                <1> 	.conv_mem	dw 0
  1039 000016B4 0000                <1> 	.high_mem	dw 0
  1040                              <1> 
  1041                              <1> ; Calls a system function from a far location.
  1042                              <1> ; IN: BP = System function number (8000h, 8003h...)
  1043                              <1> ; OUT: nothing
  1044                              <1> os_far_call:
  1045 000016B6 FFD5                <1> 	call bp
  1046 000016B8 CB                  <1> 	retf
  1047                              <1> 	
  1048                              <1> ; Serves as a middle-man between the INT 1Ah call and the kernel/apps (used for timezones).
  1049                              <1> ; IN/OUT: same as int 1Ah
  1050                              <1> os_int_1Ah:
  1051 000016B9 60                  <1> 	pusha
  1052                              <1> 
  1053 000016BA 80FC02              <1> 	cmp ah, 2		; Read system time
  1054 000016BD 7416                <1> 	je .read_time
  1055                              <1> 	
  1056 000016BF 80FC04              <1> 	cmp ah, 4		; Read system date
  1057 000016C2 7404                <1> 	je .read_date
  1058                              <1> 	
  1059 000016C4 61                  <1> 	popa
  1060 000016C5 CD1A                <1> 	int 1Ah
  1061 000016C7 C3                  <1> 	ret
  1062                              <1> 	
  1063                              <1> .read_date:
  1064 000016C8 E81700              <1> 	call .update_time
  1065 000016CB 61                  <1> 	popa
  1066 000016CC 8B16[A617]          <1> 	mov dx, [.days]
  1067 000016D0 8B0E[A817]          <1> 	mov cx, [.years]
  1068 000016D4 C3                  <1> 	ret
  1069                              <1> 	
  1070                              <1> .read_time:
  1071 000016D5 E80A00              <1> 	call .update_time
  1072                              <1> 	
  1073 000016D8 61                  <1> 	popa
  1074 000016D9 8A36[A317]          <1> 	mov dh, [.seconds]
  1075 000016DD 8B0E[A417]          <1> 	mov cx, [.minutes]
  1076                              <1> 	
  1077 000016E1 C3                  <1> 	ret
  1078                              <1> 
  1079                              <1> .update_time:
  1080 000016E2 B404                <1> 	mov ah, 4
  1081 000016E4 CD1A                <1> 	int 1Ah
  1082 000016E6 8916[A617]          <1> 	mov [.days], dx
  1083 000016EA 890E[A817]          <1> 	mov [.years], cx
  1084                              <1> 	
  1085 000016EE B402                <1> 	mov ah, 2
  1086 000016F0 CD1A                <1> 	int 1Ah
  1087                              <1> 
  1088 000016F2 8836[A317]          <1> 	mov [.seconds], dh
  1089 000016F6 890E[A417]          <1> 	mov [.minutes], cx
  1090                              <1> 	
  1091                              <1> 	; Convert all of these values from BCD to integers
  1092                              <1> 	
  1093 000016FA B90700              <1> 	mov cx, 7
  1094 000016FD BE[A317]            <1> 	mov si, .seconds
  1095 00001700 89F7                <1> 	mov di, si
  1096                              <1> 	
  1097                              <1> .loop:
  1098 00001702 AC                  <1> 	lodsb
  1099 00001703 E8FDFC              <1> 	call os_bcd_to_int
  1100 00001706 AA                  <1> 	stosb
  1101                              <1> 	
  1102 00001707 E2F9                <1> 	loop .loop
  1103                              <1> 	
  1104                              <1> 	; Calculate the time with the time offset
  1105                              <1> 	
  1106 00001709 A1F9DE              <1> 	mov ax, [57081]
  1107 0000170C A90080              <1> 	test ax, 8000h
  1108 0000170F 7541                <1> 	jnz .subtract
  1109                              <1> 	
  1110 00001711 31D2                <1> 	xor dx, dx
  1111 00001713 BB3C00              <1> 	mov bx, 60
  1112 00001716 F7F3                <1> 	div bx
  1113                              <1> 	
  1114                              <1> 	; DX = value to add to minutes
  1115                              <1> 	; AX = value to add to hours
  1116                              <1> 	
  1117 00001718 0016[A417]          <1> 	add [.minutes], dl
  1118 0000171C 803E[A417]3C        <1> 	cmp byte [.minutes], 60
  1119 00001721 7C19                <1> 	jl .add_minutes_ok
  1120                              <1> 	
  1121 00001723 802E[A417]3C        <1> 	sub byte [.minutes], 60
  1122 00001728 FE06[A517]          <1> 	inc byte [.hours]
  1123 0000172C 803E[A517]18        <1> 	cmp byte [.hours], 24
  1124 00001731 7C09                <1> 	jl .add_minutes_ok
  1125                              <1> 	
  1126 00001733 802E[A517]18        <1> 	sub byte [.hours], 24
  1127 00001738 FE06[A617]          <1> 	inc byte [.days]
  1128                              <1> 	
  1129                              <1> 	; At this point I don't care
  1130                              <1> 	
  1131                              <1> .add_minutes_ok:
  1132 0000173C 0006[A517]          <1> 	add [.hours], al
  1133 00001740 803E[A517]18        <1> 	cmp byte [.hours], 24
  1134 00001745 7C4C                <1> 	jl .encodeandexit
  1135                              <1> 	
  1136 00001747 802E[A517]18        <1> 	sub byte [.hours], 24
  1137 0000174C FE06[A617]          <1> 	inc byte [.days]
  1138                              <1> 	
  1139 00001750 EB41                <1> 	jmp .encodeandexit
  1140                              <1> 	
  1141                              <1> .subtract:
  1142 00001752 F7D8                <1> 	neg ax
  1143                              <1> 	
  1144 00001754 31D2                <1> 	xor dx, dx
  1145 00001756 BB3C00              <1> 	mov bx, 60
  1146 00001759 F7F3                <1> 	div bx
  1147                              <1> 	
  1148                              <1> 	; DX = value to subtract from minutes
  1149                              <1> 	; AX = value to subtract from hours
  1150                              <1> 
  1151 0000175B 2816[A417]          <1> 	sub [.minutes], dl
  1152 0000175F 803E[A417]00        <1> 	cmp byte [.minutes], 0
  1153 00001764 7D19                <1> 	jge .sub_minutes_ok
  1154                              <1> 	
  1155                              <1> 	
  1156 00001766 8006[A417]3C        <1> 	add byte [.minutes], 60
  1157 0000176B FE0E[A517]          <1> 	dec byte [.hours]
  1158 0000176F 803E[A517]00        <1> 	cmp byte [.hours], 0
  1159 00001774 7D09                <1> 	jge .sub_minutes_ok
  1160                              <1> 	
  1161 00001776 8006[A517]18        <1> 	add byte [.hours], 24
  1162 0000177B FE0E[A617]          <1> 	dec byte [.days]
  1163                              <1> 	
  1164                              <1> 	; At this point I don't care
  1165                              <1> 	
  1166                              <1> .sub_minutes_ok:
  1167 0000177F 2806[A517]          <1> 	sub [.hours], al
  1168 00001783 803E[A517]00        <1> 	cmp byte [.hours], 0
  1169 00001788 7D09                <1> 	jge .encodeandexit
  1170                              <1> 	
  1171 0000178A 8006[A517]18        <1> 	add byte [.hours], 24
  1172 0000178F FE0E[A617]          <1> 	dec byte [.days]
  1173                              <1> 	
  1174                              <1> .encodeandexit:
  1175 00001793 B90700              <1> 	mov cx, 7
  1176 00001796 BE[A317]            <1> 	mov si, .seconds
  1177 00001799 89F7                <1> 	mov di, si
  1178                              <1> 	
  1179                              <1> .encode_loop:
  1180 0000179B AC                  <1> 	lodsb
  1181 0000179C E87FFC              <1> 	call os_int_to_bcd
  1182 0000179F AA                  <1> 	stosb
  1183 000017A0 E2F9                <1> 	loop .encode_loop
  1184                              <1> 
  1185 000017A2 C3                  <1> 	ret
  1186                              <1> 	
  1187                              <1> 	
  1188 000017A3 00                  <1> 	.seconds	db 0
  1189 000017A4 00                  <1> 	.minutes	db 0
  1190 000017A5 00                  <1> 	.hours		db 0
  1191 000017A6 00                  <1> 	.days		db 0
  1192 000017A7 00                  <1> 	.months		db 0
  1193 000017A8 00                  <1> 	.years		db 0
  1194 000017A9 00                  <1> 	.centuries	db 0
  1195                              <1> 	
  1196                              <1> ; ==================================================================
  1197                              <1> 
   814                                  	%INCLUDE "drivers/ports.asm"
   815                              <1> ; ==================================================================
   816                              <1> ; PORT INPUT AND OUTPUT ROUTINES
   817                              <1> ; ==================================================================
   818                              <1> 
   819                              <1> ; ------------------------------------------------------------------
   820                              <1> ; os_serial_port_enable -- Set up the serial port for transmitting data
   821                              <1> ; IN: AX = 0 for normal mode (9600 baud), or 1 for slow mode (1200 baud)
   822                              <1> 
   823                              <1> os_serial_port_enable:
   824 000017AA 60                  <1> 	pusha
   825                              <1> 
   826                              <1> 	clr dx			; Configure serial port 1
    11 000017AB 31D2                <2>  xor %1, %1
   827 000017AD 83F801              <1> 	cmp ax, 1
   828 000017B0 7405                <1> 	je .slow_mode
   829                              <1> 
   830 000017B2 B8E300              <1> 	mov ax, 11100011b		; 9600 baud, no parity, 8 data bits, 1 stop bit
   831 000017B5 EB03                <1> 	jmp .finish
   832                              <1> 
   833                              <1> .slow_mode:
   834 000017B7 B88300              <1> 	mov ax, 10000011b		; 1200 baud, no parity, 8 data bits, 1 stop bit	
   835                              <1> 
   836                              <1> .finish:
   837 000017BA CD14                <1> 	int 14h
   838                              <1> 
   839 000017BC 61                  <1> 	popa
   840 000017BD C3                  <1> 	ret
   841                              <1> 
   842                              <1> 
   843                              <1> ; ------------------------------------------------------------------
   844                              <1> ; os_send_via_serial -- Send a byte via the serial port
   845                              <1> ; IN: AL = byte to send via serial; OUT: AH = Bit 7 clear on success
   846                              <1> 
   847                              <1> os_send_via_serial:
   848 000017BE 60                  <1> 	pusha
   849                              <1> 
   850 000017BF B401                <1> 	mov ah, 01h
   851                              <1> 	clr dx			; COM1
    11 000017C1 31D2                <2>  xor %1, %1
   852                              <1> 
   853 000017C3 CD14                <1> 	int 14h
   854                              <1> 
   855 000017C5 8826[CF17]          <1> 	mov [.tmp], ah
   856                              <1> 
   857 000017C9 61                  <1> 	popa
   858                              <1> 
   859 000017CA 8A26[CF17]          <1> 	mov ah, [.tmp]
   860                              <1> 
   861 000017CE C3                  <1> 	ret
   862                              <1> 
   863 000017CF 00                  <1> 	.tmp db 0
   864                              <1> 
   865                              <1> 
   866                              <1> ; ------------------------------------------------------------------
   867                              <1> ; os_get_via_serial -- Get a byte from the serial port
   868                              <1> ; IN: nothing; OUT: AL = byte that was received, AH = Bit 7 clear on success
   869                              <1> 
   870                              <1> os_get_via_serial:
   871 000017D0 60                  <1> 	pusha
   872                              <1> 
   873 000017D1 B402                <1> 	mov ah, 02h
   874                              <1> 	clr dx			; COM1
    11 000017D3 31D2                <2>  xor %1, %1
   875                              <1> 
   876 000017D5 CD14                <1> 	int 14h
   877                              <1> 
   878 000017D7 A3[DF17]            <1> 	mov [.tmp], ax
   879                              <1> 
   880 000017DA 61                  <1> 	popa
   881                              <1> 
   882 000017DB A1[DF17]            <1> 	mov ax, [.tmp]
   883                              <1> 
   884 000017DE C3                  <1> 	ret
   885                              <1> 
   886                              <1> 
   887 000017DF 0000                <1> 	.tmp dw 0
   888                              <1> 
   889                              <1> ; ==================================================================
   890                              <1> 
   815                                  	%INCLUDE "drivers/screen.asm"
   816                              <1> ; ==================================================================
   817                              <1> ; SCREEN HANDLING SYSTEM CALLS
   818                              <1> ; ==================================================================
   819                              <1> 
   820                              <1> ; ------------------------------------------------------------------
   821                              <1> ; os_putchar -- Puts a character on the screen
   822                              <1> ; IN: AL = character
   823                              <1> ; OUT: Nothing (registers preserved)
   824                              <1> 
   825                              <1> os_putchar:
   826 000017E1 60                  <1> 	pusha
   827 000017E2 B40E                <1> 	mov ah, 0Eh
   828 000017E4 CD10                <1> 	int 10h
   829 000017E6 61                  <1> 	popa
   830 000017E7 C3                  <1> 	ret
   831                              <1> 
   832                              <1> ; ------------------------------------------------------------------
   833                              <1> ; os_put_chars -- Puts up to a set amount of characters on the screen
   834                              <1> ; IN: BL = terminator, SI = location, CX = character count
   835                              <1> ; OUT: Nothing (registers preserved)
   836                              <1> 
   837                              <1> os_put_chars:
   838 000017E8 60                  <1> 	pusha
   839                              <1> 	
   840                              <1> .loop:
   841 000017E9 AC                  <1> 	lodsb
   842 000017EA 38D8                <1> 	cmp al, bl
   843 000017EC 7405                <1> 	je .done
   844                              <1> 	
   845 000017EE E8F0FF              <1> 	call os_putchar
   846                              <1> 	
   847 000017F1 E2F6                <1> 	loop .loop
   848                              <1> 	
   849                              <1> .done:
   850 000017F3 61                  <1> 	popa
   851 000017F4 C3                  <1> 	ret
   852                              <1> 
   853                              <1> ; ------------------------------------------------------------------
   854                              <1> ; os_print_string -- Displays text
   855                              <1> ; IN: SI = message location (zero-terminated string)
   856                              <1> ; OUT: Nothing (registers preserved)
   857                              <1> 
   858                              <1> os_print_string:
   859 000017F5 60                  <1> 	pusha
   860                              <1> 
   861                              <1> .repeat:
   862 000017F6 AC                  <1> 	lodsb				; Get char from string
   863 000017F7 3C00                <1> 	cmp al, 0
   864 000017F9 7405                <1> 	je .done			; If char is zero, end of string
   865                              <1> 
   866 000017FB E8E3FF              <1> 	call os_putchar
   867 000017FE EBF6                <1> 	jmp .repeat			; And move on to next char
   868                              <1> 
   869                              <1> .done:
   870 00001800 61                  <1> 	popa
   871 00001801 C3                  <1> 	ret
   872                              <1> 
   873                              <1> ; ------------------------------------------------------------------
   874                              <1> ; os_print_string_box -- Displays text inside a text-box.
   875                              <1> ; IN: SI = message location (zero-terminated string), DL = left alignment
   876                              <1> ; OUT: Nothing (registers preserved)
   877                              <1> 
   878                              <1> os_print_string_box:
   879 00001802 60                  <1> 	pusha
   880 00001803 88D1                <1> 	mov cl, dl
   881                              <1> 
   882                              <1> .repeat:
   883 00001805 AC                  <1> 	lodsb				; Get char from string
   884 00001806 3C00                <1> 	cmp al, 0
   885 00001808 7409                <1> 	je .done			; If char is zero, end of string
   886                              <1> 
   887 0000180A 3C0D                <1> 	cmp al, 13
   888 0000180C 7407                <1> 	je .cr
   889                              <1> 	
   890 0000180E E8D0FF              <1> 	call os_putchar
   891 00001811 EBF2                <1> 	jmp .repeat			; And move on to next char
   892                              <1> 
   893                              <1> .done:
   894 00001813 61                  <1> 	popa
   895 00001814 C3                  <1> 	ret
   896                              <1> 	
   897                              <1> .cr:
   898 00001815 E85700              <1> 	call os_get_cursor_pos
   899 00001818 88CA                <1> 	mov dl, cl
   900 0000181A E84900              <1> 	call os_move_cursor
   901 0000181D EBE6                <1> 	jmp .repeat
   902                              <1> 
   903                              <1> ; ------------------------------------------------------------------
   904                              <1> ; os_format_string -- Displays colored text
   905                              <1> ; IN: BL/SI = text color/message location (zero-terminated string)
   906                              <1> ; OUT: Nothing (registers preserved)
   907                              <1> 
   908                              <1> os_format_string:
   909 0000181F 60                  <1> 	pusha
   910                              <1> 
   911 00001820 B409                <1> 	mov ah, 09h			; int 09h
   912 00001822 B700                <1> 	mov bh, 0
   913 00001824 B90100              <1> 	mov cx, 1
   914 00001827 E84500              <1> 	call os_get_cursor_pos
   915                              <1> 	
   916                              <1> .repeat:
   917 0000182A AC                  <1> 	lodsb				; Get char from string
   918 0000182B 3C0D                <1> 	cmp al, 13
   919 0000182D 7411                <1> 	je .cr
   920 0000182F 3C0A                <1> 	cmp al, 10
   921 00001831 7414                <1> 	je .lf
   922 00001833 3C00                <1> 	cmp al, 0
   923 00001835 7417                <1> 	je .done			; If char is zero, end of string
   924                              <1> 
   925 00001837 CD10                <1> 	int 10h				; Otherwise, print it
   926                              <1> 
   927 00001839 FEC2                <1> 	inc dl
   928 0000183B E82800              <1> 	call os_move_cursor
   929                              <1> 	
   930 0000183E EBEA                <1> 	jmp .repeat			; And move on to next char
   931                              <1> 	
   932                              <1> .cr:
   933 00001840 B200                <1> 	mov dl, 0
   934 00001842 E82100              <1> 	call os_move_cursor
   935 00001845 EBE3                <1> 	jmp .repeat
   936                              <1> 
   937                              <1> .lf:
   938 00001847 FEC6                <1> 	inc dh
   939 00001849 E81A00              <1> 	call os_move_cursor
   940 0000184C EBDC                <1> 	jmp .repeat
   941                              <1> 	
   942                              <1> .done:
   943 0000184E 61                  <1> 	popa
   944 0000184F C3                  <1> 	ret
   945                              <1> 
   946                              <1> 
   947                              <1> ; ------------------------------------------------------------------
   948                              <1> ; os_clear_screen -- Clears the screen to background
   949                              <1> ; IN/OUT: Nothing (registers preserved)
   950                              <1> 
   951                              <1> os_clear_screen:
   952 00001850 60                  <1> 	pusha
   953                              <1> 
   954 00001851 BA0000              <1> 	mov dx, 0			; Position cursor at top-left
   955 00001854 E80F00              <1> 	call os_move_cursor
   956                              <1> 
   957                              <1> 	mov16 ax, 0, 6		; Scroll full-screen
    15 00001857 B80006              <2>  mov %1, (%2 + %3 * 256)
   958 0000185A B707                <1> 	mov bh, 7
   959                              <1> 	mov16 cx, 0, 0		; Top-left
    15 0000185C B90000              <2>  mov %1, (%2 + %3 * 256)
   960                              <1> 	mov16 dx, 79, 24	; Bottom-right
    15 0000185F BA4F18              <2>  mov %1, (%2 + %3 * 256)
   961 00001862 CD10                <1> 	int 10h
   962                              <1> 
   963 00001864 61                  <1> 	popa
   964 00001865 C3                  <1> 	ret
   965                              <1> 
   966                              <1> 
   967                              <1> ; ------------------------------------------------------------------
   968                              <1> ; os_move_cursor -- Moves cursor in text mode
   969                              <1> ; IN: DH, DL = row, column; OUT: Nothing (registers preserved)
   970                              <1> 
   971                              <1> os_move_cursor:
   972 00001866 60                  <1> 	pusha
   973                              <1> 
   974 00001867 B700                <1> 	mov bh, 0
   975 00001869 B402                <1> 	mov ah, 2
   976 0000186B CD10                <1> 	int 10h				; BIOS interrupt to move cursor
   977                              <1> 
   978 0000186D 61                  <1> 	popa
   979 0000186E C3                  <1> 	ret
   980                              <1> 
   981                              <1> 
   982                              <1> ; ------------------------------------------------------------------
   983                              <1> ; os_get_cursor_pos -- Return position of text cursor
   984                              <1> ; OUT: DH, DL = row, column
   985                              <1> 
   986                              <1> os_get_cursor_pos:
   987 0000186F 60                  <1> 	pusha
   988                              <1> 
   989 00001870 B700                <1> 	mov bh, 0
   990 00001872 B403                <1> 	mov ah, 3
   991 00001874 CD10                <1> 	int 10h				; BIOS interrupt to get cursor position
   992                              <1> 
   993 00001876 8916[8018]          <1> 	mov [.tmp], dx
   994 0000187A 61                  <1> 	popa
   995 0000187B 8B16[8018]          <1> 	mov dx, [.tmp]
   996 0000187F C3                  <1> 	ret
   997                              <1> 
   998                              <1> 
   999 00001880 0000                <1> 	.tmp dw 0
  1000                              <1> 
  1001                              <1> 
  1002                              <1> ; ------------------------------------------------------------------
  1003                              <1> ; os_print_horiz_line -- Draw a horizontal line on the screen
  1004                              <1> ; IN: AX = line type (1 for double (-), otherwise single (=))
  1005                              <1> ; OUT: Nothing (registers preserved)
  1006                              <1> 
  1007                              <1> os_print_horiz_line:
  1008 00001882 60                  <1> 	pusha
  1009                              <1> 
  1010 00001883 89C1                <1> 	mov cx, ax			; Store line type param
  1011 00001885 B0C4                <1> 	mov al, 196			; Default is single-line code
  1012                              <1> 
  1013 00001887 83F901              <1> 	cmp cx, 1			; Was double-line specified in AX?
  1014 0000188A 7502                <1> 	jne .ready
  1015 0000188C B0CD                <1> 	mov al, 205			; If so, here's the code
  1016                              <1> 
  1017                              <1> .ready:
  1018 0000188E B95000              <1> 	mov cx, 80			; Counter
  1019 00001891 B40E                <1> 	mov ah, 0Eh			; BIOS output char routine
  1020 00001893 B700                <1> 	mov bh, 0
  1021                              <1> 	
  1022                              <1> .loop:
  1023 00001895 CD10                <1> 	int 10h
  1024 00001897 E2FC                <1> 	loop .loop
  1025                              <1> 	
  1026 00001899 61                  <1> 	popa
  1027 0000189A C3                  <1> 	ret
  1028                              <1> 
  1029                              <1> 
  1030                              <1> ; ------------------------------------------------------------------
  1031                              <1> ; os_show_cursor -- Turns on cursor in text mode
  1032                              <1> ; IN/OUT: Nothing
  1033                              <1> 
  1034                              <1> os_show_cursor:
  1035 0000189B 60                  <1> 	pusha
  1036                              <1> 
  1037                              <1> 	mov16 cx, 7, 6
    15 0000189C B90706              <2>  mov %1, (%2 + %3 * 256)
  1038                              <1> 	mov16 ax, 3, 1
    15 0000189F B80301              <2>  mov %1, (%2 + %3 * 256)
  1039 000018A2 CD10                <1> 	int 10h
  1040                              <1> 
  1041 000018A4 61                  <1> 	popa
  1042 000018A5 C3                  <1> 	ret
  1043                              <1> 
  1044                              <1> 
  1045                              <1> ; ------------------------------------------------------------------
  1046                              <1> ; os_hide_cursor -- Turns off cursor in text mode
  1047                              <1> ; IN/OUT: Nothing
  1048                              <1> 
  1049                              <1> os_hide_cursor:
  1050 000018A6 60                  <1> 	pusha
  1051                              <1> 
  1052 000018A7 B520                <1> 	mov ch, 32
  1053                              <1> 	mov16 ax, 3, 1	; AL must be video mode for buggy BIOSes!
    15 000018A9 B80301              <2>  mov %1, (%2 + %3 * 256)
  1054 000018AC CD10                <1> 	int 10h
  1055                              <1> 
  1056 000018AE 61                  <1> 	popa
  1057 000018AF C3                  <1> 	ret
  1058                              <1> 
  1059                              <1> 
  1060                              <1> ; ------------------------------------------------------------------
  1061                              <1> ; os_draw_block -- Render block of specified colour
  1062                              <1> ; IN: BL/DL/DH/SI/DI = colour/start X pos/start Y pos/width/finish Y pos
  1063                              <1> 
  1064                              <1> os_draw_block:
  1065 000018B0 60                  <1> 	pusha
  1066                              <1> 
  1067                              <1> .more:
  1068 000018B1 E8B2FF              <1> 	call os_move_cursor		; Move to block starting position
  1069                              <1> 
  1070                              <1> 	mov16 ax, ' ', 09h			; Draw colour section
    15 000018B4 B82009              <2>  mov %1, (%2 + %3 * 256)
  1071 000018B7 B700                <1> 	mov bh, 0
  1072 000018B9 89F1                <1> 	mov cx, si
  1073 000018BB CD10                <1> 	int 10h
  1074                              <1> 
  1075 000018BD FEC6                <1> 	inc dh				; Get ready for next line
  1076                              <1> 
  1077 000018BF 0FB6C6              <1> 	movzx ax, dh		; Get current Y position into DL
  1078 000018C2 39F8                <1> 	cmp ax, di			; Reached finishing point (DI)?
  1079 000018C4 75EB                <1> 	jne .more			; If not, keep drawing
  1080                              <1> 
  1081 000018C6 61                  <1> 	popa
  1082 000018C7 C3                  <1> 	ret
  1083                              <1> 
  1084                              <1> 
  1085                              <1> ; ------------------------------------------------------------------
  1086                              <1> ; os_file_selector -- Show a file selection dialog
  1087                              <1> ; IN: If [0087h] = 1, then BX = location of file extension list
  1088                              <1> ; OUT: AX = location of filename string (or carry set if Esc pressed)
  1089                              <1> 
  1090                              <1> os_file_selector:
  1091                              <1> 	; Get volume name
  1092                              <1> 	
  1093 000018C8 60                  <1> 	pusha
  1094 000018C9 B90100              <1> 	mov cx, 1					; Load first disk sector into RAM
  1095 000018CC 0FB6168400          <1> 	movzx dx, byte [0084h]
  1096 000018D1 BB00E0              <1> 	mov bx, disk_buffer
  1097                              <1> 
  1098                              <1> 	mov16 ax, 1, 2
    15 000018D4 B80102              <2>  mov %1, (%2 + %3 * 256)
  1099 000018D7 F9                  <1> 	stc
  1100 000018D8 CD13                <1> 	int 13h						; BIOS load sector call
  1101                              <1> 
  1102 000018DA BE2BE0              <1> 	mov si, disk_buffer + 2Bh	; Disk label starts here
  1103                              <1> 
  1104 000018DD BF[631B]            <1> 	mov di, .volname
  1105 000018E0 B90B00              <1> 	mov cx, 11					; Copy 11 chars of it
  1106 000018E3 F3A4                <1> 	rep movsb
  1107 000018E5 61                  <1> 	popa
  1108                              <1> 	
  1109 000018E6 60                  <1> 	pusha
  1110 000018E7 C706[481B]0000      <1> 	mov word [.filename], 0		; Terminate string in case user leaves without choosing
  1111                              <1> 
  1112 000018ED E8F9F0              <1> 	call os_report_free_space
  1113 000018F0 D1E8                <1> 	shr ax, 1					; Sectors -> kB
  1114 000018F2 A3[6F1B]            <1> 	mov [.freespace], ax
  1115                              <1> 	
  1116                              <1> 	; Add the filters, if desired
  1117                              <1> 
  1118 000018F5 BF5100              <1> 	mov di, 0051h
  1119 000018F8 C60500              <1> 	mov byte [di], 0
  1120                              <1> 	
  1121 000018FB 803E870001          <1> 	cmp byte [0087h], 1
  1122 00001900 752F                <1> 	jne .no_filter
  1123                              <1> 	
  1124 00001902 891E[711B]          <1> 	mov [.extension_list], bx
  1125                              <1> 
  1126 00001906 BE[121B]            <1> 	mov si, .filter_msg
  1127 00001909 BF5100              <1> 	mov di, 0051h
  1128 0000190C E83711              <1> 	call os_string_copy
  1129                              <1> 
  1130 0000190F 60                  <1> 	pusha
  1131 00001910 BF5A00              <1> 	mov di, 0051h + 9
  1132 00001913 89DE                <1> 	mov si, bx
  1133 00001915 8A1C                <1> 	mov bl, [si]
  1134 00001917 46                  <1> 	inc si
  1135 00001918 B100                <1> 	mov cl, 0
  1136                              <1> 	
  1137                              <1> .filter_loop:
  1138 0000191A E82911              <1> 	call os_string_copy
  1139 0000191D C6450320            <1> 	mov byte [di + 3], ' '
  1140 00001921 83C704              <1> 	add di, 4
  1141 00001924 83C604              <1> 	add si, 4
  1142 00001927 FEC1                <1> 	inc cl
  1143 00001929 38D9                <1> 	cmp cl, bl
  1144 0000192B 75ED                <1> 	jne .filter_loop
  1145                              <1> 	
  1146 0000192D C60500              <1> 	mov byte [di], 0
  1147 00001930 61                  <1> 	popa
  1148                              <1> 	
  1149                              <1> .no_filter:
  1150                              <1> 	; Create the filename index list
  1151                              <1> 
  1152 00001931 E8BDF8              <1> 	call disk_read_root_dir		; Get the files into the buffer
  1153                              <1> 
  1154 00001934 BE00E0              <1> 	mov si, disk_buffer			; Raw directory buffer
  1155 00001937 BF00FC              <1> 	mov di, 64512				; Buffer for indexes
  1156 0000193A B90000              <1> 	mov cx, 0					; Number of found files
  1157                              <1> 
  1158                              <1> .index_loop:
  1159 0000193D 81FE00FC            <1> 	cmp si, 64512			; Are we done looping through the directory?
  1160 00001941 744E                <1> 	je .done
  1161                              <1> 
  1162 00001943 8A440B              <1> 	mov al, [si+11]			; File attributes for entry
  1163 00001946 3C0F                <1> 	cmp al, 0Fh			; Windows marker, skip it
  1164 00001948 7442                <1> 	je .skip
  1165                              <1> 
  1166 0000194A A808                <1> 	test al, 08h			; Is this a directory entry or volume label?
  1167 0000194C 753E                <1> 	jnz .skip			; Yes, ignore it
  1168                              <1> 
  1169 0000194E 8A04                <1> 	mov al, [si]
  1170 00001950 3CE5                <1> 	cmp al, 229			; If we read 229 = deleted filename
  1171 00001952 7438                <1> 	je .skip
  1172                              <1> 
  1173 00001954 3C00                <1> 	cmp al, 0			; 1st byte = entry never used
  1174 00001956 7439                <1> 	je .done
  1175                              <1> 
  1176 00001958 60                  <1> 	pusha
  1177                              <1> 
  1178 00001959 803E870001          <1> 	cmp byte [0087h], 1	; Check if we are supposed to filter the filenames
  1179 0000195E 7523                <1> 	jne .no_extension_check
  1180                              <1> 	
  1181 00001960 8B1E[711B]          <1> 	mov bx, [.extension_list]
  1182 00001964 0FB60F              <1> 	movzx cx, byte [bx]
  1183                              <1> 
  1184                              <1> .extension_loop:
  1185 00001967 60                  <1> 	pusha
  1186 00001968 83C608              <1> 	add si, 8
  1187                              <1> 	
  1188 0000196B 49                  <1> 	dec cx
  1189 0000196C 89CF                <1> 	mov di, cx
  1190 0000196E C1E702              <1> 	shl di, 2	; Each entry is 4 bytes long
  1191 00001971 47                  <1> 	inc di		; The entry list starts with a 1-byte header
  1192 00001972 033E[711B]          <1> 	add di, [.extension_list]
  1193                              <1> 	
  1194 00001976 B90300              <1> 	mov cx, 3
  1195 00001979 F3A6                <1> 	rep cmpsb
  1196 0000197B 61                  <1> 	popa
  1197 0000197C 7405                <1> 	je .no_extension_check
  1198                              <1> 	
  1199 0000197E E2E7                <1> 	loop .extension_loop
  1200                              <1> 	
  1201 00001980 61                  <1> 	popa
  1202 00001981 EB09                <1> 	jmp .skip
  1203                              <1> 
  1204                              <1> .no_extension_check:
  1205 00001983 61                  <1> 	popa
  1206                              <1> 
  1207 00001984 41                  <1> 	inc cx				; Increment the number of discovered files
  1208 00001985 89F0                <1> 	mov ax, si			; Store the filename pointer into the buffer
  1209 00001987 AB                  <1> 	stosw
  1210                              <1> 
  1211 00001988 C6440B00            <1> 	mov byte [si+11], 0	; Zero-terminate the string
  1212                              <1> 
  1213                              <1> .skip:
  1214 0000198C 83C620              <1> 	add si, byte 32		; Skip to the next file
  1215 0000198F EBAC                <1> 	jmp .index_loop
  1216                              <1> 
  1217                              <1> .done:
  1218                              <1> 	; Let the user select a file
  1219                              <1> 
  1220 00001991 89C8                <1> 	mov ax, cx			; Pass the number of files
  1221 00001993 BB[341B]            <1> 	mov bx, .root
  1222 00001996 B95100              <1> 	mov cx, 0051h
  1223 00001999 BE[E519]            <1> 	mov si, .callback
  1224                              <1> 
  1225 0000199C C606[731B]01        <1> 	mov byte [.file_selector_calling], 1
  1226 000019A1 E8D301              <1> 	call os_list_dialog_tooltip
  1227 000019A4 C606[731B]00        <1> 	mov byte [.file_selector_calling], 0
  1228                              <1> 
  1229 000019A9 7209                <1> 	jc .esc_pressed
  1230                              <1> 
  1231 000019AB E80900              <1> 	call .get_filename
  1232                              <1> 	
  1233 000019AE 61                  <1> 	popa
  1234 000019AF B8[481B]            <1> 	mov ax, .filename
  1235 000019B2 F8                  <1> 	clc
  1236 000019B3 C3                  <1> 	ret
  1237                              <1> 
  1238                              <1> .esc_pressed:				; Set carry flag if Escape was pressed
  1239 000019B4 61                  <1> 	popa
  1240 000019B5 F9                  <1> 	stc
  1241 000019B6 C3                  <1> 	ret
  1242                              <1> 
  1243                              <1> .get_filename:
  1244 000019B7 48                  <1> 	dec ax				; Result from os_list_dialog starts from 1, but
  1245                              <1> 						; for our file list offset we want to start from 0
  1246                              <1> 	
  1247 000019B8 89C6                <1> 	mov si, ax			; Get the pointer to the string in the index
  1248 000019BA D1E6                <1> 	shl si, 1
  1249 000019BC 81C600FC            <1> 	add si, 64512
  1250                              <1> 
  1251 000019C0 AD                  <1> 	lodsw
  1252 000019C1 89C6                <1> 	mov si, ax			; Our resulting pointer
  1253                              <1> 	clr cx
    11 000019C3 31C9                <2>  xor %1, %1
  1254 000019C5 BF[481B]            <1> 	mov di, .filename
  1255                              <1> 	
  1256                              <1> .loopy:
  1257 000019C8 AC                  <1> 	lodsb
  1258 000019C9 3C20                <1> 	cmp al, ' '
  1259 000019CB 7401                <1> 	je .ignore_space
  1260 000019CD AA                  <1> 	stosb
  1261                              <1> 	
  1262                              <1> .ignore_space:
  1263 000019CE 41                  <1> 	inc cx
  1264 000019CF 83F908              <1> 	cmp cx, 8
  1265 000019D2 7407                <1> 	je .add_dot
  1266 000019D4 83F90B              <1> 	cmp cx, 11
  1267 000019D7 7408                <1> 	je .done_copy
  1268 000019D9 EBED                <1> 	jmp .loopy
  1269                              <1> 
  1270                              <1> .add_dot:
  1271 000019DB C6052E              <1> 	mov byte [di], '.'
  1272 000019DE 47                  <1> 	inc di
  1273 000019DF EBE7                <1> 	jmp .loopy
  1274                              <1> 
  1275                              <1> .done_copy:
  1276 000019E1 C60500              <1> 	mov byte [di], 0
  1277                              <1> 
  1278 000019E4 C3                  <1> 	ret
  1279                              <1> 	
  1280                              <1> .callback:
  1281                              <1> 	; Draw the box on the right
  1282 000019E5 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  1283                              <1> 	mov16 dx, 41, 2		; Start X/Y position
    15 000019E9 BA2902              <2>  mov %1, (%2 + %3 * 256)
  1284 000019EC BE2500              <1> 	mov si, 37			; Width
  1285 000019EF BF1700              <1> 	mov di, 23			; Finish Y position
  1286 000019F2 E8BBFE              <1> 	call os_draw_block	; Draw option selector window
  1287                              <1> 
  1288                              <1> 	; Draw the icon's background
  1289 000019F5 B3F0                <1> 	mov bl, 0F0h
  1290                              <1> 	mov16 dx, 50, 3
    15 000019F7 BA3203              <2>  mov %1, (%2 + %3 * 256)
  1291 000019FA BE1300              <1> 	mov si, 19			; Width
  1292 000019FD BF0D00              <1> 	mov di, 13			; Finish Y position
  1293 00001A00 E8ADFE              <1> 	call os_draw_block	; Draw option selector window	
  1294                              <1> 
  1295                              <1> 	; Draw the icon
  1296                              <1> 	
  1297                              <1> 	mov16 dx, 52, 4
    15 00001A03 BA3404              <2>  mov %1, (%2 + %3 * 256)
  1298 00001A06 E85DFE              <1> 	call os_move_cursor
  1299                              <1> 	
  1300 00001A09 BE[4709]            <1> 	mov si, filelogo
  1301 00001A0C E8160A              <1> 	call os_draw_icon
  1302                              <1> 
  1303                              <1> 	; Display the filename
  1304                              <1> 
  1305                              <1> 	mov16 dx, 42, 14
    15 00001A0F BA2A0E              <2>  mov %1, (%2 + %3 * 256)
  1306 00001A12 E851FE              <1> 	call os_move_cursor
  1307                              <1> 
  1308 00001A15 50                  <1> 	push ax
  1309 00001A16 E89EFF              <1> 	call .get_filename
  1310                              <1> 	
  1311 00001A19 BE[481B]            <1> 	mov si, .filename
  1312 00001A1C E8D6FD              <1> 	call os_print_string
  1313                              <1> 	
  1314                              <1> 	; Find the correct directory entry for this file
  1315                              <1> 
  1316 00001A1F 58                  <1> 	pop ax
  1317                              <1> 
  1318 00001A20 48                  <1> 	dec ax
  1319 00001A21 89C6                <1> 	mov si, ax
  1320 00001A23 D1E6                <1> 	shl si, 1
  1321 00001A25 81C600FC            <1> 	add si, 64512
  1322 00001A29 8B34                <1> 	mov si, [si]			; Get the pointer to the entry in the index list
  1323                              <1> 
  1324 00001A2B 56                  <1> 	push si
  1325                              <1> 	
  1326                              <1> 	; Display the file size
  1327                              <1> 	
  1328 00001A2C 668B441C            <1> 	mov eax, [si + 28]
  1329 00001A30 E81D12              <1> 	call os_32int_to_string
  1330                              <1> 	
  1331 00001A33 89C6                <1> 	mov si, ax
  1332 00001A35 BF[481B]            <1> 	mov di, .filename
  1333 00001A38 E80B10              <1> 	call os_string_copy
  1334                              <1> 	
  1335 00001A3B B8[481B]            <1> 	mov ax, .filename
  1336 00001A3E BB[1C1B]            <1> 	mov bx, .byte_msg
  1337 00001A41 E8600F              <1> 	call os_string_add
  1338                              <1> 	
  1339 00001A44 E86C0F              <1> 	call os_string_length
  1340                              <1> 
  1341 00001A47 B24D                <1> 	mov dl, 77
  1342 00001A49 28C2                <1> 	sub dl, al
  1343 00001A4B E818FE              <1> 	call os_move_cursor
  1344                              <1> 	
  1345 00001A4E BE[481B]            <1> 	mov si, .filename
  1346 00001A51 E8A1FD              <1> 	call os_print_string
  1347                              <1> 	
  1348                              <1> 	; Display the file write date/time
  1349                              <1> 	
  1350 00001A54 C606[481B]00        <1> 	mov byte [.filename], 0
  1351                              <1> 	
  1352 00001A59 5E                  <1> 	pop si
  1353 00001A5A 8B5C0E              <1> 	mov bx, [si + 14]
  1354 00001A5D 8B4C10              <1> 	mov cx, [si + 16]
  1355                              <1> 	
  1356 00001A60 53                  <1> 	push bx
  1357 00001A61 89C8                <1> 	mov ax, cx		; Days
  1358 00001A63 83E01F              <1> 	and ax, 11111b
  1359                              <1> 	
  1360 00001A66 BA[2E1B]            <1> 	mov dx, .dateseparator
  1361 00001A69 E88400              <1> 	call .cb_add_num
  1362                              <1> 	
  1363 00001A6C 89C8                <1> 	mov ax, cx		; Months
  1364 00001A6E C1E805              <1> 	shr ax, 5
  1365 00001A71 83E00F              <1> 	and ax, 1111b
  1366                              <1> 	
  1367 00001A74 E87900              <1> 	call .cb_add_num
  1368                              <1> 	
  1369 00001A77 89C8                <1> 	mov ax, cx		; Years
  1370 00001A79 C1E809              <1> 	shr ax, 9
  1371 00001A7C 05BC07              <1> 	add ax, 1980
  1372                              <1> 	
  1373 00001A7F BA[301B]            <1> 	mov dx, .whiteseparator
  1374 00001A82 E86B00              <1> 	call .cb_add_num
  1375                              <1> 	
  1376 00001A85 59                  <1> 	pop cx
  1377                              <1> 	
  1378 00001A86 89C8                <1> 	mov ax, cx		; Hours
  1379 00001A88 C1E80B              <1> 	shr ax, 11
  1380                              <1> 
  1381 00001A8B BA[2C1B]            <1> 	mov dx, .timeseparator
  1382 00001A8E E85F00              <1> 	call .cb_add_num
  1383                              <1> 	
  1384 00001A91 89C8                <1> 	mov ax, cx		; Minutes
  1385 00001A93 C1E805              <1> 	shr ax, 5
  1386 00001A96 83E03F              <1> 	and ax, 111111b
  1387                              <1> 	
  1388 00001A99 E85400              <1> 	call .cb_add_num
  1389                              <1> 
  1390 00001A9C 89C8                <1> 	mov ax, cx		; Seconds
  1391 00001A9E 83E01F              <1> 	and ax, 11111b
  1392 00001AA1 D1E0                <1> 	shl ax, 1
  1393                              <1> 
  1394 00001AA3 BA[111B]            <1> 	mov dx, .help_msg2
  1395 00001AA6 E84700              <1> 	call .cb_add_num
  1396                              <1> 	
  1397                              <1> 	mov16 dx, 42, 16
    15 00001AA9 BA2A10              <2>  mov %1, (%2 + %3 * 256)
  1398 00001AAC E8B7FD              <1> 	call os_move_cursor
  1399                              <1> 
  1400 00001AAF BE[381B]            <1> 	mov si, .time_msg
  1401 00001AB2 E840FD              <1> 	call os_print_string
  1402                              <1> 	
  1403                              <1> 	; Display volume information
  1404                              <1> 	
  1405                              <1> 	mov16 dx, 42, 20
    15 00001AB5 BA2A14              <2>  mov %1, (%2 + %3 * 256)
  1406 00001AB8 E8ABFD              <1> 	call os_move_cursor
  1407                              <1> 
  1408 00001ABB B8C409              <1> 	mov ax, 09C4h
  1409 00001ABE 0FB61EA9DE          <1> 	movzx bx, byte [57001]
  1410 00001AC3 B92300              <1> 	mov cx, 35
  1411 00001AC6 CD10                <1> 	int 10h
  1412                              <1> 	
  1413 00001AC8 FEC6                <1> 	inc dh
  1414 00001ACA E899FD              <1> 	call os_move_cursor
  1415                              <1> 
  1416 00001ACD BE[5C1B]            <1> 	mov si, .vol_msg
  1417 00001AD0 E822FD              <1> 	call os_print_string
  1418                              <1> 	
  1419 00001AD3 A1[6F1B]            <1> 	mov ax, [.freespace]
  1420 00001AD6 E86B10              <1> 	call os_int_to_string
  1421 00001AD9 89C6                <1> 	mov si, ax
  1422 00001ADB E8D50E              <1> 	call os_string_length
  1423                              <1> 	
  1424 00001ADE 80C21B              <1> 	add dl, 27
  1425 00001AE1 28C2                <1> 	sub dl, al
  1426 00001AE3 E880FD              <1> 	call os_move_cursor
  1427                              <1> 		
  1428 00001AE6 E80CFD              <1> 	call os_print_string
  1429                              <1> 		
  1430 00001AE9 BE[231B]            <1> 	mov si, .free_msg
  1431 00001AEC E806FD              <1> 	call os_print_string
  1432 00001AEF C3                  <1> 	ret
  1433                              <1> 	
  1434                              <1> .cb_add_num:
  1435 00001AF0 83F80A              <1> 	cmp ax, 10
  1436 00001AF3 7D0B                <1> 	jge .no_zero
  1437                              <1> 	
  1438 00001AF5 50                  <1> 	push ax
  1439 00001AF6 BB[321B]            <1> 	mov bx, .zerofill
  1440 00001AF9 B8[481B]            <1> 	mov ax, .filename
  1441 00001AFC E8A50E              <1> 	call os_string_add
  1442 00001AFF 58                  <1> 	pop ax
  1443                              <1> 	
  1444                              <1> .no_zero:
  1445 00001B00 E84110              <1> 	call os_int_to_string
  1446 00001B03 89C3                <1> 	mov bx, ax
  1447 00001B05 B8[481B]            <1> 	mov ax, .filename
  1448 00001B08 E8990E              <1> 	call os_string_add
  1449                              <1> 	
  1450 00001B0B 89D3                <1> 	mov bx, dx
  1451 00001B0D E8940E              <1> 	call os_string_add
  1452                              <1> 
  1453 00001B10 C3                  <1> 	ret
  1454                              <1> 	
  1455 00001B11 00                  <1> 	.help_msg2		db 0
  1456 00001B12 46696C746572733A20- <1> 	.filter_msg		db 'Filters: ', 0
  1456 00001B1B 00                  <1>
  1457 00001B1C 20627974657300      <1> 	.byte_msg		db ' bytes', 0
  1458 00001B23 206B42206672656500  <1> 	.free_msg		db ' kB free', 0
  1459 00001B2C 3A00                <1> 	.timeseparator	db ':', 0
  1460 00001B2E 2F00                <1> 	.dateseparator	db '/', 0
  1461 00001B30 2000                <1> 	.whiteseparator	db ' ', 0
  1462 00001B32 3000                <1> 	.zerofill		db '0', 0
  1463 00001B34 413A2F00            <1> 	.root			db 'A:/', 0
  1464                              <1> 
  1465 00001B38 5772697474656E2074- <1> 	.time_msg		db 'Written to on:  '
  1465 00001B41 6F206F6E3A2020      <1>
  1466 00001B48 00<rep 14h>         <1> 	.filename		times 20 db 0
  1467                              <1> 	
  1468 00001B5C 566F6C756D6520      <1> 	.vol_msg		db 'Volume '
  1469 00001B63 00<rep Ch>          <1> 	.volname		times 12 db 0
  1470 00001B6F 0000                <1> 	.freespace		dw 0
  1471 00001B71 0000                <1> 	.extension_list	dw 0
  1472                              <1> 
  1473 00001B73 00                  <1> 	.file_selector_calling			db 0
  1474 00001B74 00                  <1> 	.file_selector_cursorpos		db 0
  1475 00001B75 00                  <1> 	.file_selector_skipnum			db 0
  1476 00001B76 00                  <1> 	.file_selector_numofentries		db 0
  1477                              <1> 
  1478                              <1> 
  1479                              <1> ; ------------------------------------------------------------------
  1480                              <1> ; os_list_dialog_tooltip -- Show a dialog with a list of options and a tooltip.
  1481                              <1> ; That means, when the user changes the selection, the application will be called back
  1482                              <1> ; to change the tooltip's contents.
  1483                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1484                              <1> ;     BX = first help string, CX = second help string
  1485                              <1> ;     SI = callback pointer
  1486                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1487                              <1> 
  1488                              <1> os_list_dialog_tooltip:
  1489 00001B77 C70689002500        <1> 	mov word [0089h], 37
  1490                              <1> 	
  1491 00001B7D 8936[B21B]          <1> 	mov [.callbackaddr], si
  1492                              <1> 	
  1493 00001B81 C706[6F1E][971B]    <1> 	mov word [os_list_dialog.callback], .callback
  1494 00001B87 E82A00              <1> 	call os_list_dialog
  1495 00001B8A C706[6F1E]0000      <1> 	mov word [os_list_dialog.callback], 0
  1496 00001B90 C70689004C00        <1> 	mov word [0089h], 76
  1497 00001B96 C3                  <1> 	ret
  1498                              <1> 	
  1499                              <1> .callback:
  1500                              <1> 	; Draw the box on the right
  1501 00001B97 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  1502                              <1> 	mov16 dx, 41, 2		; Start X/Y position
    15 00001B9B BA2902              <2>  mov %1, (%2 + %3 * 256)
  1503 00001B9E BE2500              <1> 	mov si, 37			; Width
  1504 00001BA1 BF1700              <1> 	mov di, 23			; Finish Y position
  1505 00001BA4 E809FD              <1> 	call os_draw_block	; Draw option selector window	
  1506                              <1> 
  1507                              <1> 	mov16 dx, 42, 3
    15 00001BA7 BA2A03              <2>  mov %1, (%2 + %3 * 256)
  1508 00001BAA E8B9FC              <1> 	call os_move_cursor
  1509                              <1> 
  1510 00001BAD FF16[B21B]          <1> 	call [.callbackaddr]
  1511 00001BB1 C3                  <1> 	ret
  1512                              <1> 	
  1513 00001BB2 0000                <1> 	.callbackaddr	dw 0
  1514                              <1> 	
  1515                              <1> ; ------------------------------------------------------------------
  1516                              <1> ; os_list_dialog -- Show a dialog with a list of options
  1517                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated),
  1518                              <1> ;     BX = first help string, CX = second help string
  1519                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc pressed
  1520                              <1> 
  1521                              <1> os_list_dialog:
  1522 00001BB4 60                  <1> 	pusha
  1523                              <1> 
  1524 00001BB5 50                  <1> 	push ax				; Store string list for now
  1525                              <1> 
  1526 00001BB6 51                  <1> 	push cx				; And help strings
  1527 00001BB7 53                  <1> 	push bx
  1528                              <1> 
  1529 00001BB8 E8EBFC              <1> 	call os_hide_cursor
  1530                              <1> 
  1531                              <1> 	; Are we calling from the file selector?
  1532                              <1> 
  1533 00001BBB 803E[731B]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1534 00001BC0 7509                <1> 	jne .normal_count
  1535                              <1> 
  1536 00001BC2 83F800              <1> 	cmp ax, 0
  1537 00001BC5 740B                <1> 	je .empty_list
  1538                              <1> 
  1539 00001BC7 89C1                <1> 	mov cx, ax
  1540                              <1> 
  1541 00001BC9 EB4B                <1> 	jmp .done_count_f
  1542                              <1> 
  1543                              <1> .normal_count:
  1544 00001BCB 89C6                <1> 	mov si, ax
  1545 00001BCD 803C00              <1> 	cmp byte [si], 0
  1546 00001BD0 7530                <1> 	jne .count_entries
  1547                              <1> 
  1548                              <1> .empty_list:
  1549 00001BD2 83C406              <1> 	add sp, 6
  1550 00001BD5 61                  <1> 	popa
  1551                              <1> 
  1552 00001BD6 B8[E41B]            <1> 	mov ax, .nofilesmsg
  1553                              <1> 	clr bx
    11 00001BD9 31DB                <2>  xor %1, %1
  1554                              <1> 	clr cx
    11 00001BDB 31C9                <2>  xor %1, %1
  1555                              <1> 	clr dx
    11 00001BDD 31D2                <2>  xor %1, %1
  1556 00001BDF E85604              <1> 	call os_dialog_box
  1557                              <1> 
  1558 00001BE2 F9                  <1> 	stc
  1559 00001BE3 C3                  <1> 	ret
  1560                              <1> 
  1561 00001BE4 546865726520617265- <1> 	.nofilesmsg	db "There are no items to select.", 0
  1561 00001BED 206E6F206974656D73- <1>
  1561 00001BF6 20746F2073656C6563- <1>
  1561 00001BFF 742E00              <1>
  1562                              <1> 	
  1563                              <1> .count_entries:	
  1564 00001C02 B100                <1> 	mov cl, 0			; Count the number of entries in the list
  1565                              <1> 	
  1566                              <1> .count_loop:
  1567 00001C04 268A04              <1> 	mov al, [es:si]
  1568 00001C07 46                  <1> 	inc si
  1569 00001C08 3C00                <1> 	cmp al, 0
  1570 00001C0A 7408                <1> 	je .done_count
  1571 00001C0C 3C2C                <1> 	cmp al, ','
  1572 00001C0E 75F4                <1> 	jne .count_loop
  1573 00001C10 FEC1                <1> 	inc cl
  1574 00001C12 EBF0                <1> 	jmp .count_loop
  1575                              <1> 
  1576                              <1> .done_count:
  1577 00001C14 FEC1                <1> 	inc cl
  1578                              <1> 
  1579                              <1> .done_count_f:
  1580 00001C16 880E[631E]          <1> 	mov byte [.num_of_entries], cl
  1581                              <1> 
  1582                              <1> 
  1583 00001C1A 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  1584                              <1> 	mov16 dx, 2, 2		; Start X/Y position
    15 00001C1E BA0202              <2>  mov %1, (%2 + %3 * 256)
  1585 00001C21 8B368900            <1> 	mov si, [0089h]		; Width
  1586 00001C25 BF1700              <1> 	mov di, 23			; Finish Y position
  1587 00001C28 E885FC              <1> 	call os_draw_block	; Draw option selector window
  1588                              <1> 
  1589                              <1> 	mov16 dx, 3, 3		; Show first line of help text...
    15 00001C2B BA0303              <2>  mov %1, (%2 + %3 * 256)
  1590 00001C2E E835FC              <1> 	call os_move_cursor
  1591                              <1> 
  1592 00001C31 5E                  <1> 	pop si				; Get back first string
  1593 00001C32 E8C0FB              <1> 	call os_print_string
  1594                              <1> 
  1595 00001C35 FEC6                <1> 	inc dh
  1596 00001C37 E82CFC              <1> 	call os_move_cursor
  1597                              <1> 
  1598 00001C3A 5E                  <1> 	pop si				; ...and the second
  1599 00001C3B E8B7FB              <1> 	call os_print_string
  1600                              <1> 
  1601                              <1> 
  1602 00001C3E 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  1603 00001C3F 8936[651E]          <1> 	mov word [.list_string], si
  1604                              <1> 
  1605                              <1> 
  1606                              <1> 	; Now that we've drawn the list, highlight the currently selected
  1607                              <1> 	; entry and let the user move up and down using the cursor keys
  1608                              <1> 
  1609 00001C43 C606[641E]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  1610                              <1> 
  1611                              <1> 	mov16 dx, 25, 6			; Set up starting position for selector
    15 00001C48 BA1906              <2>  mov %1, (%2 + %3 * 256)
  1612                              <1> 
  1613 00001C4B 803E[731B]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1614 00001C50 7510                <1> 	jne .no_load_position
  1615                              <1> 	
  1616 00001C52 3A0E[761B]          <1> 	cmp cl, [os_file_selector.file_selector_numofentries]
  1617 00001C56 750A                <1> 	jne .no_load_position
  1618                              <1> 	
  1619 00001C58 8A36[741B]          <1> 	mov dh, [os_file_selector.file_selector_cursorpos]
  1620 00001C5C A0[751B]            <1> 	mov al, [os_file_selector.file_selector_skipnum]
  1621 00001C5F A2[641E]            <1> 	mov [.skip_num], al
  1622                              <1> 	
  1623                              <1> .no_load_position:
  1624 00001C62 E801FC              <1> 	call os_move_cursor
  1625                              <1> 
  1626                              <1> .more_select:
  1627 00001C65 60                  <1> 	pusha
  1628 00001C66 B3F0                <1> 	mov bl, 11110000b		; Black on white for option list box
  1629                              <1> 	mov16 dx, 3, 5
    15 00001C68 BA0305              <2>  mov %1, (%2 + %3 * 256)
  1630 00001C6B 8B368900            <1> 	mov si, [0089h]
  1631 00001C6F 83EE02              <1> 	sub si, byte 2
  1632 00001C72 BF1600              <1> 	mov di, 22
  1633 00001C75 E838FC              <1> 	call os_draw_block
  1634 00001C78 61                  <1> 	popa
  1635                              <1> 
  1636 00001C79 E8B701              <1> 	call .draw_black_bar
  1637                              <1> 
  1638 00001C7C 8B36[651E]          <1> 	mov word si, [.list_string]
  1639 00001C80 E8FA00              <1>  	call .draw_list
  1640                              <1> 
  1641                              <1> .another_key:
  1642 00001C83 E8F4F5              <1> 	call os_wait_for_key		; Move / select option
  1643 00001C86 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  1644 00001C89 7420                <1> 	je .go_up
  1645 00001C8B 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  1646 00001C8E 742C                <1> 	je .go_down
  1647 00001C90 3C0D                <1> 	cmp al, 13			; Enter pressed?
  1648 00001C92 0F849B00            <1> 	je .option_selected
  1649 00001C96 3C1B                <1> 	cmp al, 27			; Esc pressed?
  1650 00001C98 0F84C400            <1> 	je .esc_pressed
  1651 00001C9C 3C09                <1> 	cmp al, 9			; Tab pressed?
  1652 00001C9E 7402                <1> 	je .tab_pressed
  1653 00001CA0 EBC3                <1> 	jmp .more_select	; If not, wait for another key
  1654                              <1> 
  1655                              <1> .tab_pressed:
  1656 00001CA2 B606                <1> 	mov dh, 6
  1657 00001CA4 C606[641E]00        <1> 	mov byte [.skip_num], 0
  1658 00001CA9 EBBA                <1> 	jmp .more_select
  1659                              <1> 	
  1660                              <1> .go_up:
  1661 00001CAB 80FE06              <1> 	cmp dh, 6			; Already at top?
  1662 00001CAE 7E2F                <1> 	jle .hit_top
  1663                              <1> 
  1664 00001CB0 E89701              <1> 	call .draw_white_bar
  1665                              <1> 
  1666 00001CB3 B219                <1> 	mov dl, 25
  1667 00001CB5 E8AEFB              <1> 	call os_move_cursor
  1668                              <1> 
  1669 00001CB8 FECE                <1> 	dec dh				; Row to select (increasing down)
  1670 00001CBA EBA9                <1> 	jmp .more_select
  1671                              <1> 
  1672                              <1> 
  1673                              <1> .go_down:				; Already at bottom of list?
  1674 00001CBC 80FE14              <1> 	cmp dh, 20
  1675 00001CBF 742E                <1> 	je .hit_bottom
  1676                              <1> 
  1677                              <1> 	clr cx
    11 00001CC1 31C9                <2>  xor %1, %1
  1678 00001CC3 88F1                <1> 	mov byte cl, dh
  1679                              <1> 
  1680 00001CC5 80E905              <1> 	sub cl, 5
  1681 00001CC8 020E[641E]          <1> 	add byte cl, [.skip_num]
  1682                              <1> 
  1683 00001CCC A0[631E]            <1> 	mov byte al, [.num_of_entries]
  1684 00001CCF 38C1                <1> 	cmp cl, al
  1685 00001CD1 741C                <1> 	je .hit_bottom
  1686                              <1> 
  1687 00001CD3 E87401              <1> 	call .draw_white_bar
  1688                              <1> 
  1689 00001CD6 B219                <1> 	mov dl, 25
  1690 00001CD8 E88BFB              <1> 	call os_move_cursor
  1691                              <1> 
  1692 00001CDB FEC6                <1> 	inc dh
  1693 00001CDD EB86                <1> 	jmp .more_select
  1694                              <1> 
  1695                              <1> 
  1696                              <1> .hit_top:
  1697 00001CDF 8A0E[641E]          <1> 	mov byte cl, [.skip_num]	; Any lines to scroll up?
  1698 00001CE3 80F900              <1> 	cmp cl, 0
  1699 00001CE6 742C                <1> 	je .skip_to_bottom			; If not, wait for another key
  1700                              <1> 
  1701 00001CE8 FE0E[641E]          <1> 	dec byte [.skip_num]		; If so, decrement lines to skip
  1702 00001CEC E976FF              <1> 	jmp .more_select
  1703                              <1> 
  1704                              <1> 
  1705                              <1> .hit_bottom:				; See if there's more to scroll
  1706                              <1> 	clr cx
    11 00001CEF 31C9                <2>  xor %1, %1
  1707 00001CF1 88F1                <1> 	mov byte cl, dh
  1708                              <1> 
  1709 00001CF3 80E906              <1> 	sub cl, 6
  1710 00001CF6 FEC1                <1> 	inc cl
  1711 00001CF8 020E[641E]          <1> 	add byte cl, [.skip_num]
  1712                              <1> 
  1713 00001CFC A0[631E]            <1> 	mov byte al, [.num_of_entries]
  1714 00001CFF 38C1                <1> 	cmp cl, al
  1715 00001D01 7407                <1> 	je .skip_to_top
  1716                              <1> 
  1717 00001D03 FE06[641E]          <1> 	inc byte [.skip_num]		; If so, increment lines to skip
  1718 00001D07 E95BFF              <1> 	jmp .more_select
  1719                              <1> 
  1720                              <1> .skip_to_top:
  1721 00001D0A C606[641E]00        <1> 	mov byte [.skip_num], 0
  1722 00001D0F B606                <1> 	mov dh, 6
  1723 00001D11 E951FF              <1> 	jmp .more_select
  1724                              <1> 
  1725                              <1> .skip_to_bottom:
  1726 00001D14 A0[631E]            <1> 	mov al, [.num_of_entries]
  1727 00001D17 3C0F                <1> 	cmp al, 15
  1728 00001D19 7E0A                <1> 	jle .basic_skip
  1729                              <1> 	
  1730                              <1> .no_basic_skip:
  1731 00001D1B B614                <1> 	mov dh, 20
  1732 00001D1D 2C0F                <1> 	sub al, 15
  1733 00001D1F A2[641E]            <1> 	mov [.skip_num], al
  1734                              <1> 
  1735 00001D22 E940FF              <1> 	jmp .more_select
  1736                              <1> 	
  1737                              <1> .basic_skip:
  1738 00001D25 3C00                <1> 	cmp al, 0
  1739 00001D27 7CF2                <1> 	jl .no_basic_skip
  1740 00001D29 88C6                <1> 	mov dh, al
  1741 00001D2B 80C605              <1> 	add dh, 5
  1742 00001D2E E934FF              <1> 	jmp .more_select
  1743                              <1> 	
  1744                              <1> .option_selected:
  1745 00001D31 E867FB              <1> 	call os_show_cursor
  1746                              <1> 
  1747 00001D34 803E[731B]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1748 00001D39 7510                <1> 	jne .no_store_position
  1749                              <1> 	
  1750 00001D3B 8836[741B]          <1> 	mov [os_file_selector.file_selector_cursorpos], dh
  1751 00001D3F A0[641E]            <1> 	mov al, [.skip_num]
  1752 00001D42 A2[751B]            <1> 	mov [os_file_selector.file_selector_skipnum], al
  1753 00001D45 A0[631E]            <1> 	mov al, [.num_of_entries]
  1754 00001D48 A2[761B]            <1> 	mov [os_file_selector.file_selector_numofentries], al
  1755                              <1> 	
  1756                              <1> .no_store_position:
  1757 00001D4B 80EE06              <1> 	sub dh, 6
  1758                              <1> 
  1759 00001D4E 0FB6C6              <1> 	movzx ax, dh
  1760                              <1> 
  1761 00001D51 FEC0                <1> 	inc al				; Options start from 1
  1762 00001D53 0206[641E]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  1763                              <1> 
  1764 00001D57 A3[611E]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  1765                              <1> 
  1766 00001D5A 61                  <1> 	popa
  1767                              <1> 
  1768 00001D5B A1[611E]            <1> 	mov word ax, [.tmp]
  1769 00001D5E F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  1770 00001D5F C3                  <1> 	ret
  1771                              <1> 
  1772                              <1> 
  1773                              <1> 
  1774                              <1> .esc_pressed:
  1775 00001D60 E838FB              <1> 	call os_show_cursor
  1776                              <1> 
  1777 00001D63 803E[731B]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1778 00001D68 7510                <1> 	jne .no_store_position_on_exit
  1779                              <1> 	
  1780 00001D6A 8836[741B]          <1> 	mov [os_file_selector.file_selector_cursorpos], dh
  1781 00001D6E A0[641E]            <1> 	mov al, [.skip_num]
  1782 00001D71 A2[751B]            <1> 	mov [os_file_selector.file_selector_skipnum], al
  1783 00001D74 A0[631E]            <1> 	mov al, [.num_of_entries]
  1784 00001D77 A2[761B]            <1> 	mov [os_file_selector.file_selector_numofentries], al
  1785                              <1> 	
  1786                              <1> .no_store_position_on_exit:
  1787 00001D7A 61                  <1> 	popa
  1788 00001D7B F9                  <1> 	stc				; Set carry for Esc
  1789 00001D7C C3                  <1> 	ret
  1790                              <1> 
  1791                              <1> 
  1792                              <1> 
  1793                              <1> .draw_list:
  1794 00001D7D 60                  <1> 	pusha
  1795                              <1> 
  1796                              <1> 	mov16 dx, 5, 6		; Get into position for option list text
    15 00001D7E BA0506              <2>  mov %1, (%2 + %3 * 256)
  1797 00001D81 E8E2FA              <1> 	call os_move_cursor
  1798                              <1> 
  1799                              <1> 	clr cx				; Skip lines scrolled off the top of the dialog
    11 00001D84 31C9                <2>  xor %1, %1
  1800 00001D86 8A0E[641E]          <1> 	mov byte cl, [.skip_num]
  1801                              <1> 
  1802 00001D8A 803E[731B]01        <1> 	cmp byte [os_file_selector.file_selector_calling], 1
  1803 00001D8F 747C                <1> 	je .file_draw_list
  1804                              <1> 
  1805                              <1> .skip_loop:
  1806 00001D91 83F900              <1> 	cmp cx, 0
  1807 00001D94 740B                <1> 	je .skip_loop_finished
  1808                              <1> .more_lodsb:
  1809 00001D96 268A04              <1> 	mov al, [es:si]
  1810 00001D99 46                  <1> 	inc si
  1811 00001D9A 3C2C                <1> 	cmp al, ','
  1812 00001D9C 75F8                <1> 	jne .more_lodsb
  1813 00001D9E 49                  <1> 	dec cx
  1814 00001D9F EBF0                <1> 	jmp .skip_loop
  1815                              <1> 
  1816                              <1> 
  1817                              <1> .skip_loop_finished:
  1818                              <1> 	clr bx				; Counter for total number of options
    11 00001DA1 31DB                <2>  xor %1, %1
  1819                              <1> 
  1820                              <1> 
  1821                              <1> .more:
  1822 00001DA3 268A04              <1> 	mov al, [es:si]		; Get next character in file name, increment pointer
  1823 00001DA6 46                  <1> 	inc si
  1824                              <1> 	
  1825 00001DA7 3C00                <1> 	cmp al, 0			; End of string?
  1826 00001DA9 7417                <1> 	je .done_list
  1827                              <1> 
  1828 00001DAB 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  1829 00001DAD 7406                <1> 	je .newline
  1830                              <1> 
  1831 00001DAF B40E                <1> 	mov ah, 0Eh
  1832 00001DB1 CD10                <1> 	int 10h
  1833 00001DB3 EBEE                <1> 	jmp .more
  1834                              <1> 
  1835                              <1> .newline:
  1836 00001DB5 B205                <1> 	mov dl, 5			; Go back to starting X position
  1837 00001DB7 FEC6                <1> 	inc dh				; But jump down a line
  1838 00001DB9 E8AAFA              <1> 	call os_move_cursor
  1839                              <1> 
  1840 00001DBC 43                  <1> 	inc bx				; Update the number-of-options counter
  1841 00001DBD 83FB0F              <1> 	cmp bx, 15			; Limit to one screen of options
  1842 00001DC0 7CE1                <1> 	jl .more
  1843                              <1> 
  1844                              <1> .done_list:
  1845 00001DC2 61                  <1> 	popa
  1846                              <1> 
  1847 00001DC3 60                  <1> 	pusha
  1848 00001DC4 52                  <1> 	push dx
  1849                              <1> 	mov16 dx, 5, 22
    15 00001DC5 BA0516              <2>  mov %1, (%2 + %3 * 256)
  1850 00001DC8 E89BFA              <1> 	call os_move_cursor
  1851                              <1> 	
  1852 00001DCB BE[671E]            <1> 	mov si, .string1
  1853 00001DCE E824FA              <1> 	call os_print_string
  1854                              <1> 	
  1855 00001DD1 5A                  <1> 	pop dx
  1856 00001DD2 A0[641E]            <1> 	mov al, [.skip_num]
  1857 00001DD5 00F0                <1> 	add al, dh
  1858 00001DD7 2C05                <1> 	sub al, 5
  1859 00001DD9 0FB6C0              <1> 	movzx ax, al
  1860 00001DDC E8650D              <1> 	call os_int_to_string
  1861 00001DDF 89C6                <1> 	mov si, ax
  1862 00001DE1 E811FA              <1> 	call os_print_string
  1863                              <1> 	
  1864 00001DE4 BE[691E]            <1> 	mov si, .string2
  1865 00001DE7 E80BFA              <1> 	call os_print_string
  1866                              <1> 	
  1867 00001DEA 0FB606[631E]        <1> 	movzx ax, byte [.num_of_entries]
  1868 00001DEF E8520D              <1> 	call os_int_to_string
  1869 00001DF2 89C6                <1> 	mov si, ax
  1870 00001DF4 E8FEF9              <1> 	call os_print_string
  1871                              <1> 	
  1872 00001DF7 BE[6B1E]            <1> 	mov si, .string3
  1873 00001DFA E8F8F9              <1> 	call os_print_string
  1874                              <1> 	
  1875                              <1> 	
  1876 00001DFD A0[641E]            <1> 	mov al, [.skip_num]
  1877 00001E00 00F0                <1> 	add al, dh
  1878 00001E02 2C05                <1> 	sub al, 5
  1879 00001E04 0FB6C0              <1> 	movzx ax, al
  1880 00001E07 FF16[6F1E]          <1> 	call [.callback]
  1881                              <1> 	
  1882 00001E0B 61                  <1> 	popa
  1883 00001E0C C3                  <1> 	ret
  1884                              <1> 
  1885                              <1> .file_draw_list:
  1886                              <1> 	clr bx
    11 00001E0D 31DB                <2>  xor %1, %1
  1887                              <1> 
  1888                              <1> .f_more:
  1889 00001E0F 51                  <1> 	push cx
  1890 00001E10 89C8                <1> 	mov ax, cx
  1891 00001E12 40                  <1> 	inc ax
  1892 00001E13 E8A1FB              <1> 	call os_file_selector.get_filename
  1893 00001E16 BE[481B]            <1> 	mov si, os_file_selector.filename
  1894 00001E19 E8D9F9              <1> 	call os_print_string
  1895 00001E1C 59                  <1> 	pop cx
  1896                              <1> 
  1897 00001E1D B205                <1> 	mov dl, 5			; Go back to starting X position
  1898 00001E1F FEC6                <1> 	inc dh				; But jump down a line
  1899 00001E21 E842FA              <1> 	call os_move_cursor
  1900                              <1> 
  1901 00001E24 41                  <1> 	inc cx
  1902 00001E25 3A0E[631E]          <1> 	cmp cl, [.num_of_entries]
  1903 00001E29 7497                <1> 	je .done_list
  1904                              <1> 
  1905 00001E2B 43                  <1> 	inc bx				; Update the number-of-options counter
  1906 00001E2C 83FB0F              <1> 	cmp bx, 15			; Limit to one screen of options
  1907 00001E2F 7CDE                <1> 	jl .f_more
  1908 00001E31 EB8F                <1> 	jmp .done_list
  1909                              <1> 
  1910                              <1> .draw_black_bar:
  1911 00001E33 60                  <1> 	pusha
  1912                              <1> 
  1913 00001E34 B204                <1> 	mov dl, 4
  1914 00001E36 E82DFA              <1> 	call os_move_cursor
  1915                              <1> 
  1916                              <1> 	mov16 ax, ' ', 09h			; Draw white bar at top
    15 00001E39 B82009              <2>  mov %1, (%2 + %3 * 256)
  1917                              <1> 	mov16 bx, 00001111b, 0	; White text on black background
    15 00001E3C BB0F00              <2>  mov %1, (%2 + %3 * 256)
  1918 00001E3F 8B0E8900            <1> 	mov cx, [0089h]
  1919 00001E43 83E904              <1> 	sub cx, byte 4
  1920 00001E46 CD10                <1> 	int 10h
  1921                              <1> 
  1922 00001E48 61                  <1> 	popa
  1923 00001E49 C3                  <1> 	ret
  1924                              <1> 
  1925                              <1> 
  1926                              <1> 
  1927                              <1> .draw_white_bar:
  1928 00001E4A 60                  <1> 	pusha
  1929                              <1> 
  1930 00001E4B B204                <1> 	mov dl, 4
  1931 00001E4D E816FA              <1> 	call os_move_cursor
  1932                              <1> 
  1933                              <1> 	mov16 ax, ' ', 09h			; Draw white bar at top
    15 00001E50 B82009              <2>  mov %1, (%2 + %3 * 256)
  1934                              <1> 	mov16 bx, 11110000b, 0	; White text on black background
    15 00001E53 BBF000              <2>  mov %1, (%2 + %3 * 256)
  1935 00001E56 8B0E8900            <1> 	mov cx, [0089h]
  1936 00001E5A 83E904              <1> 	sub cx, byte 4
  1937 00001E5D CD10                <1> 	int 10h
  1938                              <1> 
  1939 00001E5F 61                  <1> 	popa
  1940 00001E60 C3                  <1> 	ret
  1941                              <1> 
  1942                              <1> 
  1943 00001E61 0000                <1> 	.tmp			dw 0
  1944 00001E63 00                  <1> 	.num_of_entries	db 0
  1945 00001E64 00                  <1> 	.skip_num		db 0
  1946 00001E65 0000                <1> 	.list_string	dw 0
  1947 00001E67 2800                <1> 	.string1		db '(', 0
  1948 00001E69 2F00                <1> 	.string2		db '/', 0
  1949 00001E6B 29202000            <1> 	.string3		db ')  ', 0
  1950 00001E6F 0000                <1> 	.callback		dw 0
  1951                              <1> 	
  1952                              <1> ; ------------------------------------------------------------------
  1953                              <1> ; os_draw_background -- Clear screen with white top and bottom bars
  1954                              <1> ; containing text, and a coloured middle section.
  1955                              <1> ; IN: AX/BX = top/bottom string locations, CX = colour (256 if the app wants to display the default background)
  1956                              <1> 
  1957                              <1> os_draw_background:
  1958 00001E71 60                  <1> 	pusha
  1959                              <1> 	
  1960 00001E72 50                  <1> 	push ax				; Store params to pop out later
  1961 00001E73 53                  <1> 	push bx
  1962 00001E74 51                  <1> 	push cx
  1963                              <1> 
  1964 00001E75 BA0000              <1> 	mov dx, 0
  1965 00001E78 E8EBF9              <1> 	call os_move_cursor
  1966                              <1> 
  1967 00001E7B B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  1968 00001E7E B95000              <1> 	mov cx, 80
  1969 00001E81 BB7000              <1> 	mov bx, 01110000b
  1970 00001E84 CD10                <1> 	int 10h
  1971                              <1> 
  1972 00001E86 BA0001              <1> 	mov dx, 256
  1973 00001E89 E8DAF9              <1> 	call os_move_cursor
  1974                              <1> 	
  1975 00001E8C 5B                  <1> 	pop bx				; Get colour param (originally in CX)
  1976 00001E8D 81FB0001            <1> 	cmp bx, 256
  1977 00001E91 7469                <1> 	je .draw_default_background
  1978                              <1> 	
  1979 00001E93 B82009              <1> 	mov ax, 0920h			; Draw colour section
  1980 00001E96 B93007              <1> 	mov cx, 1840
  1981 00001E99 B700                <1> 	mov bh, 0
  1982 00001E9B CD10                <1> 	int 10h
  1983                              <1> 
  1984                              <1> .bg_drawn:
  1985                              <1> 	mov16 dx, 0, 24
    15 00001E9D BA0018              <2>  mov %1, (%2 + %3 * 256)
  1986 00001EA0 E8C3F9              <1> 	call os_move_cursor
  1987                              <1> 
  1988 00001EA3 B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  1989 00001EA6 B95000              <1> 	mov cx, 80
  1990 00001EA9 BB7000              <1> 	mov bx, 01110000b
  1991 00001EAC CD10                <1> 	int 10h
  1992                              <1> 
  1993                              <1> 	mov16 dx, 1, 24
    15 00001EAE BA0118              <2>  mov %1, (%2 + %3 * 256)
  1994 00001EB1 E8B2F9              <1> 	call os_move_cursor
  1995 00001EB4 5E                  <1> 	pop si				; Get bottom string param
  1996 00001EB5 E83DF9              <1> 	call os_print_string
  1997                              <1> 
  1998 00001EB8 BA0100              <1> 	mov dx, 1
  1999 00001EBB E8A8F9              <1> 	call os_move_cursor
  2000 00001EBE 5E                  <1> 	pop si				; Get top string param
  2001 00001EBF E833F9              <1> 	call os_print_string
  2002                              <1> 
  2003 00001EC2 BB[2F1F]            <1> 	mov bx, tmp_string
  2004 00001EC5 E82B0D              <1> 	call os_get_date_string
  2005                              <1> 	
  2006 00001EC8 BA4500              <1> 	mov dx, 69			; Display date
  2007 00001ECB E898F9              <1> 	call os_move_cursor
  2008 00001ECE 89DE                <1> 	mov si, bx
  2009 00001ED0 E822F9              <1> 	call os_print_string
  2010                              <1> 	
  2011 00001ED3 BB[2F1F]            <1> 	mov bx, tmp_string
  2012 00001ED6 E8D30C              <1> 	call os_get_time_string
  2013                              <1> 
  2014 00001ED9 BA3F00              <1> 	mov dx, 63			; Display time
  2015 00001EDC E887F9              <1> 	call os_move_cursor
  2016 00001EDF 89DE                <1> 	mov si, bx
  2017 00001EE1 E811F9              <1> 	call os_print_string
  2018                              <1> 	
  2019 00001EE4 B24F                <1> 	mov dl, 79			; Print the little speaker icon
  2020 00001EE6 E87DF9              <1> 	call os_move_cursor
  2021                              <1> 	
  2022 00001EE9 B8170E              <1> 	mov ax, 0E17h
  2023 00001EEC 2A068300            <1> 	sub al, [0083h]
  2024 00001EF0 B700                <1> 	mov bh, 0
  2025 00001EF2 CD10                <1> 	int 10h
  2026                              <1> 	
  2027                              <1> 	mov16 dx, 0, 1		; Ready for app text
    15 00001EF4 BA0001              <2>  mov %1, (%2 + %3 * 256)
  2028 00001EF7 E86CF9              <1> 	call os_move_cursor
  2029                              <1> 
  2030 00001EFA 61                  <1> 	popa
  2031 00001EFB C3                  <1> 	ret
  2032                              <1> 
  2033                              <1> .draw_default_background:
  2034 00001EFC 64803E000600        <1> 	cmp byte [fs:DESKTOP_BACKGROUND], 0
  2035 00001F02 741B                <1> 	je .fill_color
  2036                              <1> 	
  2037 00001F04 1E                  <1> 	push ds
  2038 00001F05 06                  <1> 	push es
  2039                              <1> 	
  2040 00001F06 8E1E[F205]          <1> 	mov ds, [driversgmt]
  2041 00001F0A BE0006              <1> 	mov si, DESKTOP_BACKGROUND
  2042                              <1> 
  2043 00001F0D B800B8              <1> 	mov ax, 0B800h
  2044 00001F10 8EC0                <1> 	mov es, ax
  2045 00001F12 BFA000              <1> 	mov di, 160
  2046                              <1> 	
  2047 00001F15 B9600E              <1> 	mov cx, 80 * 23 * 2
  2048                              <1> 	
  2049 00001F18 F3A4                <1> 	rep movsb
  2050                              <1> 	
  2051 00001F1A 07                  <1> 	pop es
  2052 00001F1B 1F                  <1> 	pop ds
  2053 00001F1C E97EFF              <1> 	jmp .bg_drawn
  2054                              <1> 	
  2055                              <1> .fill_color:
  2056 00001F1F 0FB61EA8DE          <1> 	movzx bx, byte [57000]
  2057 00001F24 B82009              <1> 	mov ax, 0920h
  2058 00001F27 B93007              <1> 	mov cx, 1840
  2059                              <1> 
  2060 00001F2A CD10                <1> 	int 10h
  2061 00001F2C E96EFF              <1> 	jmp .bg_drawn
  2062                              <1> 
  2063 00001F2F 00<rep Fh>          <1> 	tmp_string			times 15 db 0
  2064                              <1> 
  2065                              <1> 
  2066                              <1> ; ------------------------------------------------------------------
  2067                              <1> ; os_print_newline -- Reset cursor to start of next line
  2068                              <1> ; IN/OUT: Nothing (registers preserved)
  2069                              <1> 
  2070                              <1> os_print_newline:
  2071 00001F3E 60                  <1> 	pusha
  2072                              <1> 
  2073 00001F3F B40E                <1> 	mov ah, 0Eh			; BIOS output char code
  2074                              <1> 
  2075 00001F41 B00D                <1> 	mov al, 13
  2076 00001F43 CD10                <1> 	int 10h
  2077 00001F45 B00A                <1> 	mov al, 10
  2078 00001F47 CD10                <1> 	int 10h
  2079                              <1> 
  2080 00001F49 61                  <1> 	popa
  2081 00001F4A C3                  <1> 	ret
  2082                              <1> 
  2083                              <1> 
  2084                              <1> ; ------------------------------------------------------------------
  2085                              <1> ; os_dump_registers -- Displays register contents in hex on the screen
  2086                              <1> ; IN/OUT: EAX/EBX/ECX/EDX/ESI/EDI = registers to show
  2087                              <1> 
  2088                              <1> os_dump_registers:
  2089 00001F4B 6660                <1> 	pushad
  2090                              <1> 
  2091 00001F4D 6657                <1> 	push edi
  2092 00001F4F 68[9C1F]            <1> 	push .di_string
  2093 00001F52 6656                <1> 	push esi
  2094 00001F54 68[961F]            <1> 	push .si_string
  2095 00001F57 6652                <1> 	push edx
  2096 00001F59 68[901F]            <1> 	push .dx_string
  2097 00001F5C 6651                <1> 	push ecx
  2098 00001F5E 68[8A1F]            <1> 	push .cx_string
  2099 00001F61 6653                <1> 	push ebx
  2100 00001F63 68[841F]            <1> 	push .bx_string
  2101 00001F66 6650                <1> 	push eax
  2102 00001F68 68[7F1F]            <1> 	push .ax_string
  2103                              <1> 	
  2104 00001F6B B90600              <1> 	mov cx, 6
  2105                              <1> 	
  2106                              <1> .loop:
  2107 00001F6E 5E                  <1> 	pop si
  2108 00001F6F E883F8              <1> 	call os_print_string
  2109 00001F72 6658                <1> 	pop eax
  2110 00001F74 E8B903              <1> 	call os_print_8hex
  2111 00001F77 E2F5                <1> 	loop .loop
  2112                              <1> 	
  2113 00001F79 E8C2FF              <1> 	call os_print_newline
  2114                              <1> 
  2115 00001F7C 6661                <1> 	popad
  2116 00001F7E C3                  <1> 	ret
  2117                              <1> 
  2118                              <1> 
  2119 00001F7F 4541583A00          <1> 	.ax_string		db 'EAX:', 0
  2120 00001F84 204542583A00        <1> 	.bx_string		db ' EBX:', 0
  2121 00001F8A 204543583A00        <1> 	.cx_string		db ' ECX:', 0
  2122 00001F90 204544583A00        <1> 	.dx_string		db ' EDX:', 0
  2123 00001F96 204553493A00        <1> 	.si_string		db ' ESI:', 0
  2124 00001F9C 204544493A00        <1> 	.di_string		db ' EDI:', 0
  2125                              <1> 
  2126                              <1> 
  2127                              <1> ; ------------------------------------------------------------------
  2128                              <1> ; os_input_dialog -- Get text string from user via a dialog box
  2129                              <1> ; IN: AX = string location, BX = message to show; OUT: AX = string location
  2130                              <1> 
  2131                              <1> os_input_dialog:
  2132 00001FA2 60                  <1> 	pusha
  2133                              <1> 
  2134 00001FA3 50                  <1> 	push ax				; Save string location
  2135 00001FA4 53                  <1> 	push bx				; Save message to show
  2136                              <1> 
  2137                              <1> 
  2138                              <1> 	mov16 dx, 12, 10			; First, draw red background box
    15 00001FA5 BA0C0A              <2>  mov %1, (%2 + %3 * 256)
  2139                              <1> 
  2140                              <1> .redbox:				; Loop to draw all lines of box
  2141 00001FA8 E8BBF8              <1> 	call os_move_cursor
  2142                              <1> 
  2143 00001FAB 60                  <1> 	pusha
  2144                              <1> 	mov16 ax, ' ', 09h
    15 00001FAC B82009              <2>  mov %1, (%2 + %3 * 256)
  2145 00001FAF B93700              <1> 	mov cx, 55
  2146 00001FB2 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  2147 00001FB7 CD10                <1> 	int 10h
  2148 00001FB9 61                  <1> 	popa
  2149                              <1> 
  2150 00001FBA FEC6                <1> 	inc dh
  2151 00001FBC 80FE10              <1> 	cmp dh, 16
  2152 00001FBF 7402                <1> 	je .boxdone
  2153 00001FC1 EBE5                <1> 	jmp .redbox
  2154                              <1> 
  2155                              <1> 
  2156                              <1> .boxdone:
  2157                              <1> 	mov16 dx, 14, 14
    15 00001FC3 BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2158 00001FC6 E89DF8              <1> 	call os_move_cursor
  2159                              <1> 
  2160                              <1> 	mov16 ax, ' ', 09h
    15 00001FC9 B82009              <2>  mov %1, (%2 + %3 * 256)
  2161 00001FCC BBF000              <1> 	mov bx, 240
  2162 00001FCF B93300              <1> 	mov cx, 51
  2163 00001FD2 CD10                <1> 	int 10h
  2164                              <1> 	
  2165                              <1> 	mov16 dx, 14, 11
    15 00001FD4 BA0E0B              <2>  mov %1, (%2 + %3 * 256)
  2166 00001FD7 E88CF8              <1> 	call os_move_cursor
  2167                              <1> 	
  2168                              <1> 
  2169 00001FDA 5B                  <1> 	pop bx				; Get message back and display it
  2170 00001FDB 89DE                <1> 	mov si, bx
  2171 00001FDD E815F8              <1> 	call os_print_string
  2172                              <1> 
  2173                              <1> 	mov16 dx, 14, 14
    15 00001FE0 BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2174 00001FE3 E880F8              <1> 	call os_move_cursor
  2175                              <1> 
  2176                              <1> 
  2177 00001FE6 58                  <1> 	pop ax				; Get input string back
  2178 00001FE7 E8C301              <1> 	call os_input_string
  2179                              <1> 
  2180 00001FEA 61                  <1> 	popa
  2181 00001FEB C3                  <1> 	ret
  2182                              <1> 
  2183                              <1> ; ------------------------------------------------------------------
  2184                              <1> ; os_password_dialog -- Get a password from user via a dialog box
  2185                              <1> ; IN: AX = string location, BX = message to show; OUT: AX = string location
  2186                              <1> 
  2187                              <1> os_password_dialog:
  2188 00001FEC 60                  <1> 	pusha
  2189                              <1> 
  2190 00001FED 50                  <1> 	push ax				; Save string location
  2191 00001FEE 53                  <1> 	push bx				; Save message to show
  2192                              <1> 
  2193                              <1> 
  2194                              <1> 	mov16 dx, 12, 10			; First, draw red background box
    15 00001FEF BA0C0A              <2>  mov %1, (%2 + %3 * 256)
  2195                              <1> 
  2196                              <1> .redbox:				; Loop to draw all lines of box
  2197 00001FF2 E871F8              <1> 	call os_move_cursor
  2198                              <1> 
  2199 00001FF5 60                  <1> 	pusha
  2200                              <1> 	mov16 ax, ' ', 09h
    15 00001FF6 B82009              <2>  mov %1, (%2 + %3 * 256)
  2201 00001FF9 B93700              <1> 	mov cx, 55
  2202 00001FFC 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  2203 00002001 CD10                <1> 	int 10h
  2204 00002003 61                  <1> 	popa
  2205                              <1> 
  2206 00002004 FEC6                <1> 	inc dh
  2207 00002006 80FE10              <1> 	cmp dh, 16
  2208 00002009 7402                <1> 	je .boxdone
  2209 0000200B EBE5                <1> 	jmp .redbox
  2210                              <1> 
  2211                              <1> 
  2212                              <1> .boxdone:
  2213                              <1> 	mov16 dx, 14, 14
    15 0000200D BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2214 00002010 E853F8              <1> 	call os_move_cursor
  2215                              <1> 
  2216                              <1> 	mov16 ax, ' ', 09h
    15 00002013 B82009              <2>  mov %1, (%2 + %3 * 256)
  2217 00002016 BBF000              <1> 	mov bx, 240
  2218 00002019 B93300              <1> 	mov cx, 51
  2219 0000201C CD10                <1> 	int 10h
  2220                              <1> 	
  2221                              <1> 	mov16 dx, 14, 11
    15 0000201E BA0E0B              <2>  mov %1, (%2 + %3 * 256)
  2222 00002021 E842F8              <1> 	call os_move_cursor
  2223                              <1> 	
  2224                              <1> 
  2225 00002024 5B                  <1> 	pop bx				; Get message back and display it
  2226 00002025 89DE                <1> 	mov si, bx
  2227 00002027 E8CBF7              <1> 	call os_print_string
  2228                              <1> 
  2229                              <1> 	mov16 dx, 14, 14
    15 0000202A BA0E0E              <2>  mov %1, (%2 + %3 * 256)
  2230 0000202D E836F8              <1> 	call os_move_cursor
  2231                              <1> 
  2232                              <1> 
  2233 00002030 58                  <1> 	pop ax				; Get input string back
  2234 00002031 B3F0                <1> 	mov bl, 240
  2235 00002033 E8E101              <1> 	call os_input_password
  2236                              <1> 
  2237 00002036 61                  <1> 	popa
  2238 00002037 C3                  <1> 	ret
  2239                              <1> 
  2240                              <1> 
  2241                              <1> ; ------------------------------------------------------------------
  2242                              <1> ; os_dialog_box -- Print dialog box in middle of screen, with button(s)
  2243                              <1> ; IN: AX, BX, CX = string locations (set registers to 0 for no display),
  2244                              <1> ; IN: DX = 0 for single 'OK' dialog, 1 for two-button 'OK' and 'Cancel'
  2245                              <1> ; IN: [0085h] = Default button for 2-button dialog (0 or 1)
  2246                              <1> ; OUT: If two-button mode, AX = 0 for OK and 1 for cancel
  2247                              <1> ; NOTE: Each string is limited to 40 characters
  2248                              <1> 
  2249                              <1> os_dialog_box:
  2250 00002038 60                  <1> 	pusha
  2251                              <1> 
  2252 00002039 52                  <1> 	push dx
  2253                              <1> 
  2254 0000203A 51                  <1> 	push cx
  2255 0000203B 53                  <1> 	push bx
  2256 0000203C 50                  <1> 	push ax
  2257                              <1> 	
  2258 0000203D E866F8              <1> 	call os_hide_cursor
  2259                              <1> 
  2260 00002040 60                  <1> 	pusha
  2261 00002041 8A1EA9DE            <1> 	mov bl, [57001]		; Color from RAM
  2262                              <1> 	mov16 dx, 19, 9			; First, draw red background box
    15 00002045 BA1309              <2>  mov %1, (%2 + %3 * 256)
  2263 00002048 BE2A00              <1> 	mov si, 42
  2264 0000204B BF1000              <1> 	mov di, 16
  2265 0000204E E85FF8              <1> 	call os_draw_block
  2266 00002051 61                  <1> 	popa
  2267                              <1> 	
  2268                              <1> 	mov16 dx, 20, 9
    15 00002052 BA1409              <2>  mov %1, (%2 + %3 * 256)
  2269 00002055 B90300              <1> 	mov cx, 3
  2270                              <1> 	
  2271                              <1> .loop:
  2272 00002058 FEC6                <1> 	inc dh
  2273 0000205A E809F8              <1> 	call os_move_cursor
  2274                              <1> 	
  2275 0000205D 5E                  <1> 	pop si
  2276 0000205E 83FE00              <1> 	cmp si, 0
  2277 00002061 7403                <1> 	je .no_string
  2278                              <1> 	
  2279 00002063 E88FF7              <1> 	call os_print_string
  2280                              <1> 	
  2281                              <1> .no_string:
  2282 00002066 E2F0                <1> 	loop .loop
  2283                              <1> 	
  2284 00002068 5A                  <1> 	pop dx
  2285 00002069 83FA01              <1> 	cmp dx, 1
  2286 0000206C 7426                <1> 	je .two_button
  2287                              <1> 
  2288                              <1> 	
  2289                              <1> .one_button:
  2290 0000206E B3F0                <1> 	mov bl, 11110000b		; Black on white
  2291                              <1> 	mov16 dx, 35, 14
    15 00002070 BA230E              <2>  mov %1, (%2 + %3 * 256)
  2292 00002073 BE0800              <1> 	mov si, 8
  2293 00002076 BF0F00              <1> 	mov di, 15
  2294 00002079 E834F8              <1> 	call os_draw_block
  2295                              <1> 
  2296                              <1> 	mov16 dx, 38, 14		; OK button, centred at bottom of box
    15 0000207C BA260E              <2>  mov %1, (%2 + %3 * 256)
  2297 0000207F E8E4F7              <1> 	call os_move_cursor
  2298 00002082 BE[6321]            <1> 	mov si, .ok_button_string
  2299 00002085 E86DF7              <1> 	call os_print_string
  2300                              <1> 
  2301                              <1> .one_button_wait:
  2302 00002088 E8EFF1              <1> 	call os_wait_for_key
  2303 0000208B 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
  2304 0000208D 75F9                <1> 	jne .one_button_wait
  2305                              <1> 
  2306 0000208F E809F8              <1> 	call os_show_cursor
  2307                              <1> 
  2308 00002092 61                  <1> 	popa
  2309 00002093 C3                  <1> 	ret
  2310                              <1> 
  2311                              <1> .two_button:
  2312 00002094 B3F0                <1> 	mov bl, 11110000b		; Black on white
  2313                              <1> 	mov16 dx, 27, 14
    15 00002096 BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  2314 00002099 BE0800              <1> 	mov si, 8
  2315 0000209C BF0F00              <1> 	mov di, 15
  2316 0000209F E80EF8              <1> 	call os_draw_block
  2317                              <1> 
  2318                              <1> 	mov16 dx, 30, 14			; OK button
    15 000020A2 BA1E0E              <2>  mov %1, (%2 + %3 * 256)
  2319 000020A5 E8BEF7              <1> 	call os_move_cursor
  2320 000020A8 BE[6321]            <1> 	mov si, .ok_button_string
  2321 000020AB E847F7              <1> 	call os_print_string
  2322                              <1> 
  2323                              <1> 	mov16 dx, 44, 14			; Cancel button
    15 000020AE BA2C0E              <2>  mov %1, (%2 + %3 * 256)
  2324 000020B1 E8B2F7              <1> 	call os_move_cursor
  2325 000020B4 BE[6621]            <1> 	mov si, .cancel_button_string
  2326 000020B7 E83BF7              <1> 	call os_print_string
  2327                              <1> 
  2328 000020BA 803E850001          <1> 	cmp byte [0085h], 1
  2329 000020BF 7466                <1> 	je .draw_right
  2330 000020C1 7529                <1> 	jne .draw_left
  2331                              <1> 	
  2332                              <1> .two_button_wait:
  2333 000020C3 E8B4F1              <1> 	call os_wait_for_key
  2334                              <1> 
  2335 000020C6 80FC4B              <1> 	cmp ah, 75			; Left cursor key pressed?
  2336 000020C9 7421                <1> 	je .draw_left
  2337 000020CB 80FC4D              <1> 	cmp ah, 77			; Right cursor key pressed?
  2338 000020CE 7457                <1> 	je .draw_right
  2339                              <1> 	
  2340 000020D0 3C1B                <1> 	cmp al, 27			; Escape, automatically select "Cancel"
  2341 000020D2 7410                <1> 	je .cancel
  2342 000020D4 3C0D                <1> 	cmp al, 13			; Wait for enter key (13) to be pressed
  2343 000020D6 75EB                <1> 	jne .two_button_wait
  2344                              <1> 	
  2345 000020D8 E8C0F7              <1> 	call os_show_cursor
  2346                              <1> 
  2347 000020DB 890E[6D21]          <1> 	mov [.tmp], cx			; Keep result after restoring all regs
  2348 000020DF 61                  <1> 	popa
  2349 000020E0 A1[6D21]            <1> 	mov ax, [.tmp]
  2350                              <1> 
  2351 000020E3 C3                  <1> 	ret
  2352                              <1> 
  2353                              <1> .cancel:
  2354 000020E4 E8B4F7              <1> 	call os_show_cursor
  2355 000020E7 61                  <1> 	popa
  2356 000020E8 B80100              <1> 	mov ax, 1
  2357 000020EB C3                  <1> 	ret
  2358                              <1> 
  2359                              <1> .draw_left:
  2360 000020EC B3F0                <1> 	mov bl, 11110000b		; Black on white
  2361                              <1> 	mov16 dx, 27, 14
    15 000020EE BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  2362 000020F1 BE0800              <1> 	mov si, 8
  2363 000020F4 BF0F00              <1> 	mov di, 15
  2364 000020F7 E8B6F7              <1> 	call os_draw_block
  2365                              <1> 
  2366                              <1> 	mov16 dx, 30, 14		; OK button
    15 000020FA BA1E0E              <2>  mov %1, (%2 + %3 * 256)
  2367 000020FD E866F7              <1> 	call os_move_cursor
  2368 00002100 BE[6321]            <1> 	mov si, .ok_button_string
  2369 00002103 E8EFF6              <1> 	call os_print_string
  2370                              <1> 
  2371 00002106 8A1EA9DE            <1> 	mov bl, [57001]
  2372                              <1> 	mov16 dx, 42, 14
    15 0000210A BA2A0E              <2>  mov %1, (%2 + %3 * 256)
  2373 0000210D BE0900              <1> 	mov si, 9
  2374 00002110 BF0F00              <1> 	mov di, 15
  2375 00002113 E89AF7              <1> 	call os_draw_block
  2376                              <1> 
  2377                              <1> 	mov16 dx, 44, 14		; Cancel button
    15 00002116 BA2C0E              <2>  mov %1, (%2 + %3 * 256)
  2378 00002119 E84AF7              <1> 	call os_move_cursor
  2379 0000211C BE[6621]            <1> 	mov si, .cancel_button_string
  2380 0000211F E8D3F6              <1> 	call os_print_string
  2381                              <1> 
  2382 00002122 B90000              <1> 	mov cx, 0			; And update result we'll return
  2383 00002125 EB9C                <1> 	jmp .two_button_wait
  2384                              <1> 
  2385                              <1> .draw_right:
  2386 00002127 8A1EA9DE            <1> 	mov bl, [57001]
  2387                              <1> 	mov16 dx, 27, 14
    15 0000212B BA1B0E              <2>  mov %1, (%2 + %3 * 256)
  2388 0000212E BE0800              <1> 	mov si, 8
  2389 00002131 BF0F00              <1> 	mov di, 15
  2390 00002134 E879F7              <1> 	call os_draw_block
  2391                              <1> 
  2392                              <1> 	mov16 dx, 30, 14			; OK button
    15 00002137 BA1E0E              <2>  mov %1, (%2 + %3 * 256)
  2393 0000213A E829F7              <1> 	call os_move_cursor
  2394 0000213D BE[6321]            <1> 	mov si, .ok_button_string
  2395 00002140 E8B2F6              <1> 	call os_print_string
  2396                              <1> 
  2397 00002143 B3F0                <1> 	mov bl, 11110000b
  2398                              <1> 	mov16 dx, 43, 14
    15 00002145 BA2B0E              <2>  mov %1, (%2 + %3 * 256)
  2399 00002148 BE0800              <1> 	mov si, 8
  2400 0000214B BF0F00              <1> 	mov di, 15
  2401 0000214E E85FF7              <1> 	call os_draw_block
  2402                              <1> 
  2403                              <1> 	mov16 dx, 44, 14			; Cancel button
    15 00002151 BA2C0E              <2>  mov %1, (%2 + %3 * 256)
  2404 00002154 E80FF7              <1> 	call os_move_cursor
  2405 00002157 BE[6621]            <1> 	mov si, .cancel_button_string
  2406 0000215A E898F6              <1> 	call os_print_string
  2407                              <1> 
  2408 0000215D B90100              <1> 	mov cx, 1			; And update result we'll return
  2409 00002160 E960FF              <1> 	jmp .two_button_wait
  2410                              <1> 
  2411                              <1> 
  2412                              <1> 
  2413 00002163 4F4B00              <1> 	.ok_button_string	db 'OK', 0
  2414 00002166 43616E63656C00      <1> 	.cancel_button_string	db 'Cancel', 0
  2415                              <1> 
  2416 0000216D 0000                <1> 	.tmp dw 0
  2417                              <1> 
  2418                              <1> ; ------------------------------------------------------------------
  2419                              <1> ; os_print_space -- Print a space to the screen
  2420                              <1> ; IN/OUT: Nothing
  2421                              <1> 
  2422                              <1> os_print_space:
  2423 0000216F 60                  <1> 	pusha
  2424                              <1> 
  2425 00002170 B8200E              <1> 	mov ax, 0E20h			; BIOS teletype function
  2426 00002173 CD10                <1> 	int 10h
  2427                              <1> 
  2428 00002175 61                  <1> 	popa
  2429 00002176 C3                  <1> 	ret
  2430                              <1> 
  2431                              <1> 
  2432                              <1> ; ------------------------------------------------------------------
  2433                              <1> ; os_print_digit -- Displays contents of AX as a single digit
  2434                              <1> ; Works up to base 37, ie digits 0-Z
  2435                              <1> ; IN: AX = "digit" to format and print
  2436                              <1> 
  2437                              <1> os_print_digit:
  2438 00002177 60                  <1> 	pusha
  2439                              <1> 
  2440 00002178 83F809              <1> 	cmp ax, 9			; There is a break in ASCII table between 9 and A
  2441 0000217B 7E03                <1> 	jle .digit_format
  2442                              <1> 
  2443 0000217D 83C007              <1> 	add ax, 'A'-'9'-1		; Correct for the skipped punctuation
  2444                              <1> 
  2445                              <1> .digit_format:
  2446 00002180 83C030              <1> 	add ax, '0'			; 0 will display as '0', etc.	
  2447                              <1> 
  2448 00002183 B40E                <1> 	mov ah, 0Eh			; May modify other registers
  2449 00002185 CD10                <1> 	int 10h
  2450                              <1> 
  2451 00002187 61                  <1> 	popa
  2452 00002188 C3                  <1> 	ret
  2453                              <1> 
  2454                              <1> 
  2455                              <1> ; ------------------------------------------------------------------
  2456                              <1> ; os_print_1hex -- Displays low nibble of AL in hex format
  2457                              <1> ; IN: AL = number to format and print
  2458                              <1> 
  2459                              <1> os_print_1hex:
  2460 00002189 60                  <1> 	pusha
  2461                              <1> 
  2462 0000218A 83E00F              <1> 	and ax, 0Fh			; Mask off data to display
  2463 0000218D E8E7FF              <1> 	call os_print_digit
  2464                              <1> 
  2465 00002190 61                  <1> 	popa
  2466 00002191 C3                  <1> 	ret
  2467                              <1> 
  2468                              <1> 
  2469                              <1> ; ------------------------------------------------------------------
  2470                              <1> ; os_print_2hex -- Displays AL in hex format
  2471                              <1> ; IN: AL = number to format and print
  2472                              <1> 
  2473                              <1> os_print_2hex:
  2474 00002192 60                  <1> 	pusha
  2475                              <1> 
  2476 00002193 50                  <1> 	push ax				; Output high nibble
  2477 00002194 C1E804              <1> 	shr ax, 4
  2478 00002197 E8EFFF              <1> 	call os_print_1hex
  2479                              <1> 
  2480 0000219A 58                  <1> 	pop ax				; Output low nibble
  2481 0000219B E8EBFF              <1> 	call os_print_1hex
  2482                              <1> 
  2483 0000219E 61                  <1> 	popa
  2484 0000219F C3                  <1> 	ret
  2485                              <1> 
  2486                              <1> 
  2487                              <1> ; ------------------------------------------------------------------
  2488                              <1> ; os_print_4hex -- Displays AX in hex format
  2489                              <1> ; IN: AX = number to format and print
  2490                              <1> 
  2491                              <1> os_print_4hex:
  2492 000021A0 60                  <1> 	pusha
  2493                              <1> 
  2494 000021A1 50                  <1> 	push ax				; Output high byte
  2495 000021A2 88E0                <1> 	mov al, ah
  2496 000021A4 E8EBFF              <1> 	call os_print_2hex
  2497                              <1> 
  2498 000021A7 58                  <1> 	pop ax				; Output low byte
  2499 000021A8 E8E7FF              <1> 	call os_print_2hex
  2500                              <1> 
  2501 000021AB 61                  <1> 	popa
  2502 000021AC C3                  <1> 	ret
  2503                              <1> 
  2504                              <1> 
  2505                              <1> ; ------------------------------------------------------------------
  2506                              <1> ; os_input_string -- Take string from keyboard entry
  2507                              <1> ; IN/OUT: AX = location of string, other regs preserved
  2508                              <1> ; (Location will contain up to [0088h] characters, zero-terminated)
  2509                              <1> 
  2510                              <1> os_input_string:
  2511 000021AD 60                  <1> 	pusha
  2512                              <1> 
  2513 000021AE E8EAF6              <1> 	call os_show_cursor
  2514                              <1> 	
  2515 000021B1 89C7                <1> 	mov di, ax			; DI is where we'll store input (buffer)
  2516 000021B3 B90000              <1> 	mov cx, 0			; Character received counter for backspace
  2517                              <1> 
  2518                              <1> 
  2519                              <1> .more:					; Now onto string getting
  2520 000021B6 E8C1F0              <1> 	call os_wait_for_key
  2521                              <1> 
  2522 000021B9 3C0D                <1> 	cmp al, 13			; If Enter key pressed, finish
  2523 000021BB 7455                <1> 	je .done
  2524                              <1> 
  2525 000021BD 3C08                <1> 	cmp al, 8			; Backspace pressed?
  2526 000021BF 7406                <1> 	je .backspace			; If not, skip following checks
  2527                              <1> 
  2528 000021C1 3C20                <1> 	cmp al, ' '			; In ASCII range (32 - 127)?
  2529 000021C3 7CF1                <1> 	jl .more			; Ignore most non-printing characters
  2530                              <1> 
  2531 000021C5 EB35                <1> 	jmp .nobackspace
  2532                              <1> 
  2533                              <1> 
  2534                              <1> .backspace:
  2535 000021C7 83F900              <1> 	cmp cx, 0			; Backspace at start of string?
  2536 000021CA 74EA                <1> 	je .more			; Ignore it if so
  2537                              <1> 
  2538 000021CC E8A0F6              <1> 	call os_get_cursor_pos		; Backspace at start of screen line?
  2539 000021CF 80FA00              <1> 	cmp dl, 0
  2540 000021D2 7413                <1> 	je .backspace_linestart
  2541                              <1> 
  2542 000021D4 60                  <1> 	pusha
  2543 000021D5 B8080E              <1> 	mov ax, 0E08h		; If not, write space and move cursor back
  2544 000021D8 CD10                <1> 	int 10h				; Backspace twice, to clear space
  2545 000021DA B020                <1> 	mov al, 32
  2546 000021DC CD10                <1> 	int 10h
  2547 000021DE B008                <1> 	mov al, 8
  2548 000021E0 CD10                <1> 	int 10h
  2549 000021E2 61                  <1> 	popa
  2550                              <1> 
  2551 000021E3 4F                  <1> 	dec di				; Character position will be overwritten by new
  2552                              <1> 						; character or terminator at end
  2553                              <1> 
  2554 000021E4 49                  <1> 	dec cx				; Step back counter
  2555                              <1> 
  2556 000021E5 EBCF                <1> 	jmp .more
  2557                              <1> 
  2558                              <1> 
  2559                              <1> .backspace_linestart:
  2560 000021E7 FECE                <1> 	dec dh				; Jump back to end of previous line
  2561 000021E9 B24F                <1> 	mov dl, 79
  2562 000021EB E878F6              <1> 	call os_move_cursor
  2563                              <1> 
  2564 000021EE B8200E              <1> 	mov ax, 0E20h		; Print space there
  2565 000021F1 CD10                <1> 	int 10h
  2566                              <1> 
  2567 000021F3 B24F                <1> 	mov dl, 79			; And jump back before the space
  2568 000021F5 E86EF6              <1> 	call os_move_cursor
  2569                              <1> 
  2570 000021F8 4F                  <1> 	dec di				; Step back position in string
  2571 000021F9 49                  <1> 	dec cx				; Step back counter
  2572                              <1> 
  2573 000021FA EBBA                <1> 	jmp .more
  2574                              <1> 
  2575                              <1> 
  2576                              <1> .nobackspace:
  2577 000021FC 0FB61E8800          <1> 	movzx bx, byte [0088h]
  2578 00002201 39D9                <1> 	cmp cx, bx			; Make sure we don't exhaust buffer
  2579 00002203 0F8DAFFF            <1> 	jge near .more
  2580                              <1> 
  2581 00002207 60                  <1> 	pusha
  2582 00002208 B40E                <1> 	mov ah, 0Eh			; Output entered, printable character
  2583 0000220A CD10                <1> 	int 10h
  2584 0000220C 61                  <1> 	popa
  2585                              <1> 
  2586 0000220D AA                  <1> 	stosb				; Store character in designated buffer
  2587 0000220E 41                  <1> 	inc cx				; Characters processed += 1
  2588                              <1> 	
  2589 0000220F E9A4FF              <1> 	jmp near .more			; Still room for more
  2590                              <1> 
  2591                              <1> .done:
  2592 00002212 B000                <1> 	mov al, 0
  2593 00002214 AA                  <1> 	stosb
  2594                              <1> 
  2595 00002215 61                  <1> 	popa
  2596 00002216 C3                  <1> 	ret
  2597                              <1> 
  2598                              <1> ; Input password(displays it as *s)
  2599                              <1> ; IN: AX = location of string, other regs preserved, BL = color
  2600                              <1> ; OUT: nothing
  2601                              <1> ; (Location will contain up to [0088h] characters, zero-terminated)
  2602                              <1> 
  2603                              <1> os_input_password:
  2604 00002217 60                  <1> 	pusha
  2605                              <1> 
  2606 00002218 E854F6              <1> 	call os_get_cursor_pos	; Store the cursor position
  2607 0000221B 8916[8822]          <1> 	mov [.cursor], dx
  2608                              <1> 	
  2609 0000221F 89C7                <1> 	mov di, ax			; DI is where we'll store input (buffer)
  2610 00002221 B90000              <1> 	mov cx, 0			; Character received counter for backspace
  2611                              <1> 
  2612                              <1> .more:					; Now onto string getting
  2613 00002224 E853F0              <1> 	call os_wait_for_key
  2614                              <1> 
  2615 00002227 3C0D                <1> 	cmp al, 13			; If Enter key pressed, finish
  2616 00002229 742E                <1> 	je .done
  2617                              <1> 
  2618 0000222B 3C08                <1> 	cmp al, 8			; Backspace pressed?
  2619 0000222D 740A                <1> 	je .backspace			; If not, skip following checks
  2620                              <1> 
  2621 0000222F 3C20                <1> 	cmp al, ' '			; In ASCII range (32 - 126)?
  2622 00002231 7D13                <1> 	jge .nobackspace	; Ignore most non-printing characters
  2623                              <1> 	
  2624 00002233 3C00                <1> 	cmp al, 0
  2625 00002235 7C0F                <1> 	jl .nobackspace
  2626                              <1> 	
  2627 00002237 EBEB                <1> 	jmp .more
  2628                              <1> 
  2629                              <1> 
  2630                              <1> .backspace:
  2631 00002239 83F900              <1> 	cmp cx, 0			; Backspace at start of string?
  2632 0000223C 74E6                <1> 	je .more			; Ignore it if so
  2633                              <1> 
  2634 0000223E 4F                  <1> 	dec di				; Character position will be overwritten by new
  2635                              <1> 						; character or terminator at end
  2636                              <1> 
  2637 0000223F 49                  <1> 	dec cx				; Step back counter
  2638                              <1> 
  2639 00002240 E81C00              <1> 	call .update
  2640                              <1> 	
  2641 00002243 E9DEFF              <1> 	jmp near .more
  2642                              <1> 
  2643                              <1> 
  2644                              <1> .nobackspace:
  2645 00002246 0FB6168800          <1> 	movzx dx, byte [0088h]
  2646 0000224B 39D1                <1> 	cmp cx, dx			; Make sure we don't exhaust buffer
  2647 0000224D 0F8DD3FF            <1> 	jge near .more
  2648                              <1> 
  2649 00002251 AA                  <1> 	stosb				; Store character in designated buffer
  2650 00002252 41                  <1> 	inc cx				; Characters processed += 1
  2651                              <1> 
  2652 00002253 E80900              <1> 	call .update
  2653                              <1> 	
  2654 00002256 E9CBFF              <1> 	jmp near .more		; Still room for more
  2655                              <1> 
  2656                              <1> .done:
  2657 00002259 B000                <1> 	mov al, 0
  2658 0000225B AA                  <1> 	stosb
  2659                              <1> 
  2660 0000225C 61                  <1> 	popa
  2661 0000225D F8                  <1> 	clc
  2662 0000225E C3                  <1> 	ret
  2663                              <1> 
  2664                              <1> .update:
  2665 0000225F 60                  <1> 	pusha
  2666 00002260 8B16[8822]          <1> 	mov dx, [.cursor]
  2667 00002264 E8FFF5              <1> 	call os_move_cursor
  2668 00002267 B82009              <1> 	mov ax, 0920h		; Clear the line
  2669 0000226A B700                <1> 	mov bh, 0
  2670 0000226C B92000              <1> 	mov cx, 32
  2671 0000226F CD10                <1> 	int 10h
  2672 00002271 61                  <1> 	popa
  2673                              <1> 
  2674 00002272 60                  <1> 	pusha
  2675 00002273 8B16[8822]          <1> 	mov dx, [.cursor]
  2676 00002277 E8ECF5              <1> 	call os_move_cursor
  2677 0000227A B82A09              <1> 	mov ax, 092Ah		; Print *s(amount in CX)
  2678 0000227D B700                <1> 	mov bh, 0
  2679 0000227F CD10                <1> 	int 10h
  2680 00002281 00CA                <1> 	add dl, cl
  2681 00002283 E8E0F5              <1> 	call os_move_cursor
  2682 00002286 61                  <1> 	popa
  2683 00002287 C3                  <1> 	ret
  2684                              <1> 	
  2685 00002288 0000                <1> 	.cursor			dw 0
  2686                              <1> 	
  2687                              <1> ; Opens up os_list_dialog with color.
  2688                              <1> ; IN: nothing
  2689                              <1> ; OUT: color number(0-15)
  2690                              <1> 
  2691                              <1> os_color_selector:
  2692 0000228A 60                  <1> 	pusha
  2693 0000228B B8[A022]            <1> 	mov ax, .colorlist			; Call os_list_dialog with colors
  2694 0000228E BB[1B23]            <1> 	mov bx, .colormsg0
  2695 00002291 B9[2D23]            <1> 	mov cx, .colormsg1
  2696 00002294 E81DF9              <1> 	call os_list_dialog
  2697                              <1> 	
  2698 00002297 48                  <1> 	dec ax						; Output from os_list_dialog starts with 1, so decrement it
  2699 00002298 A3[2E23]            <1> 	mov [.tmp_word], ax
  2700 0000229B 61                  <1> 	popa
  2701 0000229C A0[2E23]            <1> 	mov al, [.tmp_word]
  2702 0000229F C3                  <1> 	ret
  2703                              <1> 	
  2704 000022A0 426C61636B2C426C75- <1> 	.colorlist	db 'Black,Blue,Green,Cyan,Red,Magenta,Brown,Light Gray,Dark Gray,Light Blue,Light Green,Light Cyan,Light Red,Pink,Yellow,White', 0
  2704 000022A9 652C477265656E2C43- <1>
  2704 000022B2 79616E2C5265642C4D- <1>
  2704 000022BB 6167656E74612C4272- <1>
  2704 000022C4 6F776E2C4C69676874- <1>
  2704 000022CD 20477261792C446172- <1>
  2704 000022D6 6B20477261792C4C69- <1>
  2704 000022DF 67687420426C75652C- <1>
  2704 000022E8 4C6967687420477265- <1>
  2704 000022F1 656E2C4C6967687420- <1>
  2704 000022FA 4379616E2C4C696768- <1>
  2704 00002303 74205265642C50696E- <1>
  2704 0000230C 6B2C59656C6C6F772C- <1>
  2704 00002315 576869746500        <1>
  2705 0000231B 43686F6F7365206120- <1> 	.colormsg0	db 'Choose a color...', 0
  2705 00002324 636F6C6F722E2E2E00  <1>
  2706 0000232D 00                  <1> 	.colormsg1	db 0
  2707 0000232E 0000                <1> 	.tmp_word	dw 0
  2708                              <1> 	
  2709                              <1> ; Displays EAX in hex format
  2710                              <1> ; IN: EAX = unsigned integer
  2711                              <1> ; OUT: nothing
  2712                              <1> os_print_8hex:
  2713 00002330 6660                <1> 	pushad
  2714 00002332 6660                <1> 	pushad
  2715 00002334 66C1E810            <1> 	shr eax, 16
  2716 00002338 E865FE              <1> 	call os_print_4hex
  2717 0000233B 6661                <1> 	popad
  2718 0000233D E860FE              <1> 	call os_print_4hex
  2719 00002340 6661                <1> 	popad
  2720 00002342 C3                  <1> 	ret
  2721                              <1> 	
  2722                              <1> ; Displays a dialog similar to os_dialog_box, but without the buttons.
  2723                              <1> ; IN: SI/AX/BX/CX/DX = string locations (or 0 for no display)
  2724                              <1> ; OUT: nothing
  2725                              <1> os_temp_box:
  2726 00002343 60                  <1> 	pusha
  2727                              <1> 
  2728 00002344 52                  <1> 	push dx
  2729 00002345 51                  <1> 	push cx
  2730 00002346 53                  <1> 	push bx
  2731 00002347 50                  <1> 	push ax
  2732 00002348 56                  <1> 	push si
  2733                              <1> 	
  2734 00002349 E85AF5              <1> 	call os_hide_cursor
  2735                              <1> 
  2736                              <1> 	mov16 dx, 19, 9			; First, draw red background box
    15 0000234C BA1309              <2>  mov %1, (%2 + %3 * 256)
  2737                              <1> 
  2738                              <1> .redbox:				; Loop to draw all lines of box
  2739 0000234F E814F5              <1> 	call os_move_cursor
  2740                              <1> 
  2741 00002352 60                  <1> 	pusha
  2742 00002353 B82009              <1> 	mov ax, 0920h
  2743 00002356 0FB61EA9DE          <1> 	movzx bx, byte [57001]		; Color from RAM
  2744 0000235B B92A00              <1> 	mov cx, 42
  2745 0000235E CD10                <1> 	int 10h
  2746 00002360 61                  <1> 	popa
  2747                              <1> 
  2748 00002361 FEC6                <1> 	inc dh
  2749 00002363 80FE10              <1> 	cmp dh, 16
  2750 00002366 7402                <1> 	je .boxdone
  2751 00002368 EBE5                <1> 	jmp .redbox
  2752                              <1> 
  2753                              <1> 
  2754                              <1> .boxdone:
  2755                              <1> 	mov16 dx, 20, 9
    15 0000236A BA1409              <2>  mov %1, (%2 + %3 * 256)
  2756 0000236D B90500              <1> 	mov cx, 5
  2757                              <1> 
  2758                              <1> .loop:
  2759 00002370 FEC6                <1> 	inc dh
  2760 00002372 E8F1F4              <1> 	call os_move_cursor
  2761                              <1> 
  2762 00002375 5E                  <1> 	pop si
  2763 00002376 83FE00              <1> 	cmp si, 0			; Skip string params if zero
  2764 00002379 7403                <1> 	je .no_string
  2765                              <1> 
  2766 0000237B E877F4              <1> 	call os_print_string
  2767                              <1> 
  2768                              <1> .no_string:
  2769 0000237E E2F0                <1> 	loop .loop
  2770 00002380 61                  <1> 	popa
  2771 00002381 C3                  <1> 	ret
  2772                              <1> 
  2773                              <1> ; Prints a message on the footer.
  2774                              <1> ; IN: SI = Message location(if 0, then it restores the previous message)
  2775                              <1> ; OUT: nothing
  2776                              <1> os_print_footer:
  2777 00002382 60                  <1> 	pusha
  2778 00002383 A08200              <1> 	mov al, [0082h]
  2779 00002386 3C01                <1> 	cmp al, 1
  2780 00002388 0F844700            <1> 	je near .exit
  2781                              <1> 	
  2782 0000238C E8E0F4              <1> 	call os_get_cursor_pos
  2783 0000238F 52                  <1> 	push dx
  2784                              <1> 	
  2785 00002390 BF0100              <1> 	mov di, 1
  2786 00002393 83FE00              <1> 	cmp si, 0
  2787 00002396 0F843B00            <1> 	je near .restore
  2788                              <1> 	
  2789                              <1> 	mov16 dx, 0, 24
    15 0000239A BA0018              <2>  mov %1, (%2 + %3 * 256)
  2790                              <1> 	
  2791                              <1> .loop:
  2792 0000239D E8C6F4              <1> 	call os_move_cursor
  2793                              <1> 	
  2794 000023A0 B408                <1> 	mov ah, 08h
  2795 000023A2 B700                <1> 	mov bh, 0
  2796 000023A4 CD10                <1> 	int 10h
  2797                              <1> 	
  2798 000023A6 AA                  <1> 	stosb
  2799                              <1> 	
  2800 000023A7 FEC2                <1> 	inc dl
  2801 000023A9 83FF51              <1> 	cmp di, 81
  2802 000023AC 0F8CEDFF            <1> 	jnge near .loop
  2803                              <1> 	
  2804 000023B0 C606500000          <1> 	mov byte [80], 0
  2805                              <1> 	
  2806                              <1> 	mov16 dx, 0, 24
    15 000023B5 BA0018              <2>  mov %1, (%2 + %3 * 256)
  2807 000023B8 E8ABF4              <1> 	call os_move_cursor
  2808                              <1> 	
  2809 000023BB B82009              <1> 	mov ax, 0920h
  2810 000023BE BB7000              <1> 	mov bx, 70h
  2811 000023C1 B95000              <1> 	mov cx, 80
  2812 000023C4 CD10                <1> 	int 10h
  2813                              <1> 	
  2814                              <1> 	mov16 dx, 0, 24
    15 000023C6 BA0018              <2>  mov %1, (%2 + %3 * 256)
  2815 000023C9 E89AF4              <1> 	call os_move_cursor
  2816                              <1> 	
  2817 000023CC E826F4              <1> 	call os_print_string
  2818                              <1> 	
  2819 000023CF 5A                  <1> 	pop dx
  2820 000023D0 E893F4              <1> 	call os_move_cursor
  2821                              <1> 
  2822                              <1> .exit:	
  2823 000023D3 61                  <1> 	popa
  2824 000023D4 C3                  <1> 	ret
  2825                              <1> 	
  2826                              <1> .restore:
  2827                              <1> 	mov16 dx, 0, 24
    15 000023D5 BA0018              <2>  mov %1, (%2 + %3 * 256)
  2828 000023D8 E88BF4              <1> 	call os_move_cursor
  2829 000023DB BE0100              <1> 	mov si, 1
  2830 000023DE E814F4              <1> 	call os_print_string
  2831                              <1> 	
  2832 000023E1 5A                  <1> 	pop dx
  2833 000023E2 E881F4              <1> 	call os_move_cursor
  2834                              <1> 	
  2835 000023E5 61                  <1> 	popa
  2836 000023E6 C3                  <1> 	ret
  2837                              <1> 	
  2838                              <1> ; Resets the font to the selected default.
  2839                              <1> ; IN = nothing
  2840                              <1> ; OUT = nothing
  2841                              <1> os_reset_font:
  2842 000023E7 60                  <1> 	pusha
  2843                              <1> 	
  2844 000023E8 803EF1DE01          <1> 	cmp byte [57073], 1
  2845 000023ED 0F841800            <1> 	je near .bios
  2846                              <1> 	
  2847 000023F1 06                  <1> 	push es
  2848 000023F2 B80011              <1> 	mov ax, 1100h
  2849 000023F5 BB0010              <1> 	mov bx, 1000h
  2850 000023F8 B90001              <1> 	mov cx, 0100h
  2851                              <1> 	clr dx
    11 000023FB 31D2                <2>  xor %1, %1
  2852 000023FD 8E06[F205]          <1> 	mov es, [driversgmt]
  2853 00002401 BD0016              <1> 	mov bp, SYSTEM_FONT
  2854 00002404 CD10                <1> 	int 10h
  2855 00002406 07                  <1> 	pop es
  2856 00002407 61                  <1> 	popa
  2857 00002408 C3                  <1> 	ret
  2858                              <1> 	
  2859                              <1> .bios:
  2860 00002409 61                  <1> 	popa
  2861 0000240A C3                  <1> 	ret
  2862                              <1> 
  2863                              <1> ; Draws the crepeOS logo.
  2864                              <1> ; IN: nothing
  2865                              <1> ; OUT: a very beautiful logo :-)
  2866                              <1> os_draw_logo:
  2867 0000240B 60                  <1> 	pusha
  2868                              <1> 	
  2869                              <1> 	mov16 dx, 0, 2
    15 0000240C BA0002              <2>  mov %1, (%2 + %3 * 256)
  2870 0000240F E854F4              <1> 	call os_move_cursor
  2871                              <1> 
  2872 00002412 B82009              <1> 	mov ax, 0920h
  2873 00002415 BB0400              <1> 	mov bx, 00000100b
  2874 00002418 B93002              <1> 	mov cx, 560
  2875 0000241B CD10                <1> 	int 10h
  2876                              <1> 
  2877 0000241D BE[6909]            <1> 	mov si, logo
  2878 00002420 E80200              <1> 	call os_draw_icon
  2879 00002423 61                  <1> 	popa
  2880 00002424 C3                  <1> 	ret
  2881                              <1> 
  2882                              <1> ; Draws an icon (in the crepeOS format).
  2883                              <1> ; IN: SI = address of the icon
  2884                              <1> ; OUT: nothing
  2885                              <1> os_draw_icon:
  2886 00002425 60                  <1> 	pusha
  2887                              <1> 	
  2888 00002426 E846F4              <1> 	call os_get_cursor_pos
  2889 00002429 8916[9224]          <1> 	mov [.cursor], dx
  2890                              <1> 	
  2891 0000242D AD                  <1> 	lodsw
  2892 0000242E A3[9824]            <1> 	mov [.size], ax
  2893                              <1> 	
  2894                              <1> 	clr cx
    11 00002431 31C9                <2>  xor %1, %1
  2895                              <1> 	
  2896                              <1> .loop:
  2897 00002433 AC                  <1> 	lodsb
  2898                              <1> 	
  2899 00002434 B40E                <1> 	mov ah, 0Eh
  2900                              <1> 	
  2901 00002436 51                  <1> 	push cx
  2902 00002437 88C1                <1> 	mov cl, al
  2903 00002439 0FB6D9              <1> 	movzx bx, cl
  2904 0000243C 80E3C0              <1> 	and bl, 11000000b
  2905 0000243F C0EB06              <1> 	shr bl, 6
  2906 00002442 8A87[9424]          <1> 	mov al, [.chars + bx]
  2907 00002446 CD10                <1> 	int 10h
  2908                              <1> 	
  2909 00002448 0FB6D9              <1> 	movzx bx, cl
  2910 0000244B 80E330              <1> 	and bl, 110000b
  2911 0000244E C0EB04              <1> 	shr bl, 4
  2912 00002451 8A87[9424]          <1> 	mov al, [.chars + bx]
  2913 00002455 CD10                <1> 	int 10h
  2914                              <1> 	
  2915 00002457 0FB6D9              <1> 	movzx bx, cl
  2916 0000245A 80E30C              <1> 	and bl, 1100b
  2917 0000245D C0EB02              <1> 	shr bl, 2
  2918 00002460 8A87[9424]          <1> 	mov al, [.chars + bx]
  2919 00002464 CD10                <1> 	int 10h
  2920                              <1> 	
  2921 00002466 0FB6D9              <1> 	movzx bx, cl
  2922 00002469 80E303              <1> 	and bl, 11b
  2923 0000246C 8A87[9424]          <1> 	mov al, [.chars + bx]
  2924 00002470 CD10                <1> 	int 10h
  2925 00002472 59                  <1> 	pop cx
  2926                              <1> 	
  2927 00002473 FEC1                <1> 	inc cl
  2928 00002475 3A0E[9824]          <1> 	cmp cl, [.size]
  2929 00002479 75B8                <1> 	jne .loop
  2930                              <1> 
  2931 0000247B FE06[9324]          <1> 	inc byte [.cursor + 1]
  2932 0000247F 8B16[9224]          <1> 	mov dx, [.cursor]
  2933 00002483 E8E0F3              <1> 	call os_move_cursor
  2934                              <1> 	
  2935 00002486 B100                <1> 	mov cl, 0
  2936 00002488 FEC5                <1> 	inc ch
  2937 0000248A 3A2E[9924]          <1> 	cmp ch, [.size + 1]
  2938 0000248E 75A3                <1> 	jne .loop
  2939                              <1> 	
  2940 00002490 61                  <1> 	popa
  2941 00002491 C3                  <1> 	ret
  2942                              <1> 
  2943 00002492 0000                <1> 	.cursor		dw 0
  2944 00002494 20DCDFDB            <1> 	.chars		db 32, 220, 223, 219
  2945 00002498 0000                <1> 	.size		dw 0
  2946                              <1> 	
  2947                              <1> ; ------------------------------------------------------------------
  2948                              <1> ; os_option_menu -- Show a menu with a list of options
  2949                              <1> ; IN: AX = comma-separated list of strings to show (zero-terminated), BX = menu width
  2950                              <1> ; OUT: AX = number (starts from 1) of entry selected; carry set if Esc, left or right pressed
  2951                              <1> 
  2952                              <1> os_option_menu:
  2953 0000249A 60                  <1> 	pusha
  2954                              <1> 
  2955 0000249B 803EEFDE00          <1> 	cmp byte [57071], 0
  2956 000024A0 741C                <1> 	je .skip
  2957                              <1> 	
  2958                              <1> 	mov16 dx, 0, 1
    15 000024A2 BA0001              <2>  mov %1, (%2 + %3 * 256)
  2959                              <1> 
  2960 000024A5 E8BEF3              <1> 	call os_move_cursor
  2961                              <1> 	
  2962 000024A8 B408                <1> 	mov ah, 08h
  2963 000024AA B700                <1> 	mov bh, 0
  2964 000024AC CD10                <1> 	int 10h				; Get the character's attribute (X = 0, Y = 1)
  2965                              <1> 	
  2966 000024AE 80E4F0              <1> 	and ah, 0F0h		; Keep only the background, set foreground to 0
  2967                              <1> 	
  2968 000024B1 0FB6DC              <1> 	movzx bx, ah
  2969 000024B4 B8B109              <1> 	mov ax, 09B1h
  2970 000024B7 B93007              <1> 	mov cx, 1840
  2971 000024BA CD10                <1> 	int 10h
  2972                              <1> 	
  2973 000024BC 61                  <1> 	popa
  2974 000024BD 60                  <1> 	pusha
  2975                              <1> 
  2976                              <1> .skip:
  2977 000024BE 891E[2826]          <1> 	mov [.width], bx
  2978                              <1> 
  2979 000024C2 50                  <1> 	push ax				; Store string list for now
  2980                              <1> 
  2981 000024C3 E8E0F3              <1> 	call os_hide_cursor
  2982                              <1> 
  2983 000024C6 B100                <1> 	mov cl, 0			; Count the number of entries in the list
  2984 000024C8 89C6                <1> 	mov si, ax
  2985                              <1> 	
  2986                              <1> .count_loop:
  2987 000024CA AC                  <1> 	lodsb
  2988 000024CB 3C00                <1> 	cmp al, 0
  2989 000024CD 7408                <1> 	je .done_count
  2990 000024CF 3C2C                <1> 	cmp al, ','
  2991 000024D1 75F7                <1> 	jne .count_loop
  2992 000024D3 FEC1                <1> 	inc cl
  2993 000024D5 EBF3                <1> 	jmp .count_loop
  2994                              <1> 
  2995                              <1> .done_count:
  2996 000024D7 FEC1                <1> 	inc cl
  2997 000024D9 880E[2426]          <1> 	mov byte [.num_of_entries], cl
  2998                              <1> 
  2999                              <1> 
  3000 000024DD 5E                  <1> 	pop si				; SI = location of option list string (pushed earlier)
  3001 000024DE 8936[2626]          <1> 	mov word [.list_string], si
  3002                              <1> 
  3003                              <1> 
  3004                              <1> 	; Now that we've drawn the list, highlight the currently selected
  3005                              <1> 	; entry and let the user move up and down using the cursor keys
  3006                              <1> 
  3007 000024E2 C606[2526]00        <1> 	mov byte [.skip_num], 0		; Not skipping any lines at first showing
  3008                              <1> 
  3009                              <1> 	mov16 dx, 25, 2			; Set up starting position for selector
    15 000024E7 BA1902              <2>  mov %1, (%2 + %3 * 256)
  3010                              <1> 
  3011 000024EA E879F3              <1> 	call os_move_cursor
  3012                              <1> 
  3013                              <1> .more_select:
  3014 000024ED 60                  <1> 	pusha
  3015 000024EE 8A1EF0DE            <1> 	mov bl, [57072]		; Black on white for option list box
  3016                              <1> 	mov16 dx, 1, 1
    15 000024F2 BA0101              <2>  mov %1, (%2 + %3 * 256)
  3017                              <1> 
  3018 000024F5 8B36[2826]          <1> 	mov si, [.width]
  3019 000024F9 0FB63E[2426]        <1> 	movzx di, [.num_of_entries]
  3020 000024FE 83C703              <1> 	add di, 3
  3021 00002501 E8ACF3              <1> 	call os_draw_block
  3022 00002504 61                  <1> 	popa
  3023                              <1> 
  3024 00002505 E8EA00              <1> 	call .draw_black_bar
  3025                              <1> 
  3026 00002508 8B36[2626]          <1> 	mov word si, [.list_string]
  3027 0000250C E8A000              <1> 	call .draw_list
  3028                              <1> 
  3029                              <1> .another_key:
  3030 0000250F E868ED              <1> 	call os_wait_for_key		; Move / select option
  3031 00002512 80FC48              <1> 	cmp ah, 48h			; Up pressed?
  3032 00002515 7419                <1> 	je .go_up
  3033 00002517 80FC50              <1> 	cmp ah, 50h			; Down pressed?
  3034 0000251A 7425                <1> 	je .go_down
  3035 0000251C 3C0D                <1> 	cmp al, 13			; Enter pressed?
  3036 0000251E 745A                <1> 	je .option_selected
  3037 00002520 3C1B                <1> 	cmp al, 27			; Esc pressed?
  3038 00002522 7470                <1> 	je .esc_pressed
  3039 00002524 80FC4B              <1> 	cmp ah, 75			; Left pressed?
  3040 00002527 7474                <1> 	je .left_pressed
  3041 00002529 80FC4D              <1> 	cmp ah, 77			; Right pressed?
  3042 0000252C 7478                <1> 	je .right_pressed
  3043 0000252E EBDF                <1> 	jmp .another_key		; If not, wait for another key
  3044                              <1> 
  3045                              <1> 
  3046                              <1> .go_up:
  3047 00002530 80FE02              <1> 	cmp dh, 2			; Already at top?
  3048 00002533 7E37                <1> 	jle .hit_top
  3049                              <1> 
  3050 00002535 E8D100              <1> 	call .draw_white_bar
  3051                              <1> 
  3052 00002538 B219                <1> 	mov dl, 25
  3053 0000253A E829F3              <1> 	call os_move_cursor
  3054                              <1> 
  3055 0000253D FECE                <1> 	dec dh				; Row to select (increasing down)
  3056 0000253F EBAC                <1> 	jmp .more_select
  3057                              <1> 
  3058                              <1> 
  3059                              <1> .go_down:				; Already at bottom of list?
  3060 00002541 8A1E[2426]          <1> 	mov bl, [.num_of_entries]
  3061 00002545 FEC3                <1> 	inc bl
  3062 00002547 38DE                <1> 	cmp dh, bl
  3063 00002549 742A                <1> 	je .hit_bottom
  3064                              <1> 
  3065 0000254B B90000              <1> 	mov cx, 0
  3066 0000254E 88F1                <1> 	mov byte cl, dh
  3067                              <1> 
  3068 00002550 80E906              <1> 	sub cl, 6
  3069 00002553 FEC1                <1> 	inc cl
  3070 00002555 020E[2526]          <1> 	add byte cl, [.skip_num]
  3071                              <1> 
  3072 00002559 A0[2426]            <1> 	mov byte al, [.num_of_entries]
  3073 0000255C 38C1                <1> 	cmp cl, al
  3074 0000255E 74AF                <1> 	je .another_key
  3075                              <1> 
  3076 00002560 E8A600              <1> 	call .draw_white_bar
  3077                              <1> 
  3078 00002563 B219                <1> 	mov dl, 25
  3079 00002565 E8FEF2              <1> 	call os_move_cursor
  3080                              <1> 
  3081 00002568 FEC6                <1> 	inc dh
  3082 0000256A EB81                <1> 	jmp .more_select
  3083                              <1> 
  3084                              <1> 
  3085                              <1> .hit_top:
  3086 0000256C B601                <1> 	mov dh, 1
  3087 0000256E 0236[2426]          <1> 	add dh, [.num_of_entries]
  3088 00002572 E978FF              <1> 	jmp .more_select
  3089                              <1> 
  3090                              <1> 
  3091                              <1> .hit_bottom:
  3092 00002575 B602                <1> 	mov dh, 2
  3093 00002577 E973FF              <1> 	jmp .more_select
  3094                              <1> 
  3095                              <1> 
  3096                              <1> 
  3097                              <1> .option_selected:
  3098 0000257A E81EF3              <1> 	call os_show_cursor
  3099                              <1> 
  3100 0000257D 80EE02              <1> 	sub dh, 2
  3101                              <1> 
  3102 00002580 B80000              <1> 	mov ax, 0
  3103 00002583 88F0                <1> 	mov al, dh
  3104                              <1> 
  3105 00002585 FEC0                <1> 	inc al				; Options start from 1
  3106 00002587 0206[2526]          <1> 	add byte al, [.skip_num]	; Add any lines skipped from scrolling
  3107                              <1> 
  3108 0000258B A3[2226]            <1> 	mov word [.tmp], ax		; Store option number before restoring all other regs
  3109                              <1> 
  3110 0000258E 61                  <1> 	popa
  3111                              <1> 
  3112 0000258F A1[2226]            <1> 	mov word ax, [.tmp]
  3113 00002592 F8                  <1> 	clc				; Clear carry as Esc wasn't pressed
  3114 00002593 C3                  <1> 	ret
  3115                              <1> 
  3116                              <1> 
  3117                              <1> 
  3118                              <1> .esc_pressed:
  3119 00002594 E804F3              <1> 	call os_show_cursor
  3120 00002597 61                  <1> 	popa
  3121 00002598 B80000              <1> 	mov ax, 0
  3122 0000259B F9                  <1> 	stc
  3123 0000259C C3                  <1> 	ret
  3124                              <1> 
  3125                              <1> .left_pressed:
  3126 0000259D E8FBF2              <1> 	call os_show_cursor
  3127 000025A0 61                  <1> 	popa
  3128 000025A1 B80100              <1> 	mov ax, 1
  3129 000025A4 F9                  <1> 	stc
  3130 000025A5 C3                  <1> 	ret
  3131                              <1> 
  3132                              <1> .right_pressed:
  3133 000025A6 E8F2F2              <1> 	call os_show_cursor
  3134 000025A9 61                  <1> 	popa
  3135 000025AA B80200              <1> 	mov ax, 2
  3136 000025AD F9                  <1> 	stc
  3137 000025AE C3                  <1> 	ret
  3138                              <1> 
  3139                              <1> .draw_list:
  3140 000025AF 60                  <1> 	pusha
  3141                              <1> 
  3142                              <1> 	mov16 dx, 3, 2			; Get into position for option list text
    15 000025B0 BA0302              <2>  mov %1, (%2 + %3 * 256)
  3143 000025B3 E8B0F2              <1> 	call os_move_cursor
  3144                              <1> 
  3145                              <1> 
  3146 000025B6 B90000              <1> 	mov cx, 0			; Skip lines scrolled off the top of the dialog
  3147 000025B9 8A0E[2526]          <1> 	mov byte cl, [.skip_num]
  3148                              <1> 
  3149                              <1> .skip_loop:
  3150 000025BD 83F900              <1> 	cmp cx, 0
  3151 000025C0 7408                <1> 	je .skip_loop_finished
  3152                              <1> 	
  3153                              <1> .more_lodsb:
  3154 000025C2 AC                  <1> 	lodsb
  3155 000025C3 3C2C                <1> 	cmp al, ','
  3156 000025C5 75FB                <1> 	jne .more_lodsb
  3157 000025C7 49                  <1> 	dec cx
  3158 000025C8 EBF3                <1> 	jmp .skip_loop
  3159                              <1> 
  3160                              <1> 
  3161                              <1> .skip_loop_finished:
  3162 000025CA BB0000              <1> 	mov bx, 0			; Counter for total number of options
  3163                              <1> 
  3164                              <1> 
  3165                              <1> .more:
  3166 000025CD AC                  <1> 	lodsb				; Get next character in file name, increment pointer
  3167                              <1> 
  3168 000025CE 3C00                <1> 	cmp al, 0			; End of string?
  3169 000025D0 741B                <1> 	je .done_list
  3170                              <1> 
  3171 000025D2 3C2C                <1> 	cmp al, ','			; Next option? (String is comma-separated)
  3172 000025D4 7406                <1> 	je .newline
  3173                              <1> 
  3174 000025D6 B40E                <1> 	mov ah, 0Eh
  3175 000025D8 CD10                <1> 	int 10h
  3176 000025DA EBF1                <1> 	jmp .more
  3177                              <1> 
  3178                              <1> .newline:
  3179 000025DC B203                <1> 	mov dl, 3			; Go back to starting X position
  3180 000025DE FEC6                <1> 	inc dh				; But jump down a line
  3181 000025E0 E883F2              <1> 	call os_move_cursor
  3182                              <1> 
  3183 000025E3 43                  <1> 	inc bx				; Update the number-of-options counter
  3184 000025E4 0FB63E[2426]        <1> 	movzx di, [.num_of_entries]	; Low 8 bits of DI = [.items], high 8 bits = 0
  3185 000025E9 39FB                <1> 	cmp bx, di			; Limit to one screen of options
  3186 000025EB 7CE0                <1> 	jl .more
  3187                              <1> 
  3188                              <1> .done_list:
  3189 000025ED 61                  <1> 	popa
  3190 000025EE E875F2              <1> 	call os_move_cursor
  3191                              <1> 
  3192 000025F1 C3                  <1> 	ret
  3193                              <1> 
  3194                              <1> 
  3195                              <1> 
  3196                              <1> .draw_black_bar:
  3197 000025F2 60                  <1> 	pusha
  3198                              <1> 
  3199 000025F3 B202                <1> 	mov dl, 2
  3200 000025F5 E86EF2              <1> 	call os_move_cursor
  3201                              <1> 
  3202 000025F8 B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  3203 000025FB 8B0E[2826]          <1> 	mov cx, [.width]
  3204 000025FF 83E902              <1> 	sub cx, 2
  3205 00002602 BB0F00              <1> 	mov bx, 00001111b		; White text on black background
  3206 00002605 CD10                <1> 	int 10h
  3207                              <1> 
  3208 00002607 61                  <1> 	popa
  3209 00002608 C3                  <1> 	ret
  3210                              <1> 
  3211                              <1> .draw_white_bar:
  3212 00002609 60                  <1> 	pusha
  3213                              <1> 
  3214 0000260A B202                <1> 	mov dl, 2
  3215 0000260C E857F2              <1> 	call os_move_cursor
  3216                              <1> 
  3217 0000260F B82009              <1> 	mov ax, 0920h			; Draw white bar at top
  3218 00002612 8B0E[2826]          <1> 	mov cx, [.width]
  3219 00002616 83E902              <1> 	sub cx, 2
  3220 00002619 0FB61EF0DE          <1> 	movzx bx, byte [57072]	; Black text on white background
  3221 0000261E CD10                <1> 	int 10h
  3222                              <1> 
  3223 00002620 61                  <1> 	popa
  3224 00002621 C3                  <1> 	ret
  3225                              <1> 
  3226 00002622 0000                <1> 	.tmp					dw 0
  3227 00002624 00                  <1> 	.num_of_entries			db 0
  3228 00002625 00                  <1> 	.skip_num				db 0
  3229 00002626 0000                <1> 	.list_string			dw 0
  3230 00002628 0000                <1> 	.width					dw 0
  3231                              <1> 	
  3232                              <1> ; ==================================================================
   816                                  	%INCLUDE "drivers/sound.asm"
   817                              <1> ; ==================================================================
   818                              <1> ; PC SPEAKER/ADLIB SOUND ROUTINES
   819                              <1> ; ==================================================================
   820                              <1> 
   821                              <1> ; ------------------------------------------------------------------
   822                              <1> ; os_speaker_tone -- Generate PC speaker tone (call os_speaker_off to turn off)
   823                              <1> ; IN: AX = note frequency; OUT: Nothing (registers preserved)
   824                              <1> 
   825                              <1> os_speaker_tone:
   826 0000262A 60                  <1> 	pusha
   827 0000262B 803E830000          <1> 	cmp byte [0083h], 0
   828 00002630 0F842600            <1> 	je near .exit
   829 00002634 61                  <1> 	popa
   830                              <1> 	
   831 00002635 60                  <1> 	pusha
   832 00002636 83F800              <1> 	cmp ax, 0
   833 00002639 0F841D00            <1> 	je near .exit
   834                              <1> 	
   835 0000263D E82A00              <1> 	call os_speaker_off
   836 00002640 89C1                <1> 	mov cx, ax			; Store note value for now
   837                              <1> 
   838 00002642 B0B6                <1> 	mov al, 10110110b
   839 00002644 E643                <1> 	out 43h, al
   840 00002646 BA1200              <1> 	mov dx, 12h			; Set up frequency
   841 00002649 B8DC34              <1> 	mov ax, 34DCh
   842 0000264C F7F1                <1> 	div cx
   843 0000264E E642                <1> 	out 42h, al
   844 00002650 88E0                <1> 	mov al, ah
   845 00002652 E642                <1> 	out 42h, al
   846                              <1> 
   847 00002654 E461                <1> 	in al, 61h			; Switch PC speaker on
   848 00002656 0C03                <1> 	or al, 03h
   849 00002658 E661                <1> 	out 61h, al
   850                              <1> 
   851                              <1> .exit:
   852 0000265A 61                  <1> 	popa
   853 0000265B C3                  <1> 	ret
   854                              <1> 
   855                              <1> ; ------------------------------------------------------------------
   856                              <1> ; os_speaker_note_length -- Generate PC speaker tone for a set amount of time and then stop
   857                              <1> ; IN: AX = note frequency, CX = length (in ticks)
   858                              <1> 
   859                              <1> os_speaker_note_length:
   860 0000265C 60                  <1> 	pusha
   861 0000265D E8CAFF              <1> 	call os_speaker_tone
   862                              <1> 	
   863 00002660 89C8                <1> 	mov ax, cx
   864 00002662 E867EE              <1> 	call os_pause
   865                              <1> 	
   866 00002665 E80200              <1> 	call os_speaker_off
   867 00002668 61                  <1> 	popa
   868 00002669 C3                  <1> 	ret
   869                              <1> 
   870                              <1> ; ------------------------------------------------------------------
   871                              <1> ; os_speaker_off -- Turn off PC speaker
   872                              <1> ; IN/OUT: Nothing (registers preserved)
   873                              <1> 
   874                              <1> os_speaker_off:
   875 0000266A 60                  <1> 	pusha
   876                              <1> 
   877 0000266B E461                <1> 	in al, 61h
   878 0000266D 24FC                <1> 	and al, 0FCh
   879 0000266F E661                <1> 	out 61h, al
   880                              <1> 
   881 00002671 61                  <1> 	popa
   882 00002672 C3                  <1> 	ret
   883                              <1> 
   884                              <1> ; ------------------------------------------------------------------
   885                              <1> ; os_start_adlib -- Starts the selected Adlib driver
   886                              <1> ; IN: SI = interrupt handler, CX = prescaler, BL = number of channels
   887                              <1> ; The interrupt will fire at 33144 Hz (the closest possible to 32768 Hz) divided by CX.
   888                              <1> ; Common prescaler values:
   889                              <1> ;		33 = ~1 kHz (1004.362 Hz)
   890                              <1> ;		663 = ~50 Hz (49.991 Hz)
   891                              <1> ;		1820 = ~18.2 Hz (18.211 Hz)
   892                              <1> 
   893                              <1> os_start_adlib:
   894 00002673 60                  <1> 	pusha
   895 00002674 C606[4928]01        <1> 	mov byte [adlib_running], 1
   896                              <1> 
   897 00002679 803EEEDE01          <1> 	cmp byte [57070], 1
   898 0000267E 7D16                <1> 	jge .pcspk
   899                              <1> 	
   900 00002680 B80000              <1> 	mov ax, 0
   901                              <1> 	
   902                              <1> .loop:
   903 00002683 E8C700              <1> 	call int_adlib_regwrite
   904 00002686 FEC4                <1> 	inc ah
   905 00002688 75F9                <1> 	jnz .loop
   906                              <1> 	
   907 0000268A B82400              <1> 	mov ax, 36
   908 0000268D F7E1                <1> 	mul cx
   909                              <1> 	
   910 0000268F 89C1                <1> 	mov cx, ax
   911 00002691 E81421              <1> 	call os_attach_app_timer
   912                              <1> 	
   913 00002694 61                  <1> 	popa
   914 00002695 C3                  <1> 	ret
   915                              <1> 	
   916                              <1> .pcspk:
   917 00002696 B82400              <1> 	mov ax, 36
   918 00002699 F6F3                <1> 	div bl
   919                              <1> 	
   920 0000269B A2[E428]            <1> 	mov [pwm_channel_amplitude], al
   921                              <1> 
   922 0000269E 8936[DD28]          <1> 	mov [pwm_callback], si
   923 000026A2 890E[DF28]          <1> 	mov [pwm_callback_ctr], cx
   924 000026A6 890E[E128]          <1> 	mov [pwm_callback_ctr_def], cx
   925                              <1> 
   926                              <1> 	; Set up the PC speaker
   927 000026AA E461                <1> 	in al, 0x61
   928 000026AC 0C03                <1> 	or al, 3
   929 000026AE E661                <1> 	out 0x61, al
   930                              <1> 
   931                              <1> 	; Enable the callback
   932 000026B0 BE[4A28]            <1> 	mov si, pwm_handler
   933 000026B3 8CCF                <1> 	mov di, cs
   934 000026B5 B11C                <1> 	mov cl, 01Ch
   935 000026B7 E8A820              <1> 	call os_modify_int_handler
   936                              <1> 
   937 000026BA B92400              <1> 	mov cx, 36
   938 000026BD E80F21              <1> 	call os_set_timer_speed
   939                              <1> 	
   940 000026C0 61                  <1> 	popa
   941 000026C1 C3                  <1> 	ret
   942                              <1> 	
   943                              <1> ; ------------------------------------------------------------------
   944                              <1> ; os_stop_adlib -- Stops the Adlib driver
   945                              <1> 
   946                              <1> os_stop_adlib:
   947 000026C2 60                  <1> 	pusha
   948 000026C3 803EEEDE01          <1> 	cmp byte [57070], 1
   949 000026C8 7D1D                <1> 	jge .pcspk
   950                              <1> 	
   951 000026CA E8EA20              <1> 	call os_return_app_timer
   952                              <1> 
   953 000026CD B400                <1> 	mov ah, 0
   954                              <1> 	
   955                              <1> .loop:
   956 000026CF 0FB6DC              <1> 	movzx bx, ah
   957 000026D2 C1EB05              <1> 	shr bx, 5
   958 000026D5 8A87[0A27]          <1> 	mov al, [adlib_clear_regs + bx]
   959                              <1> 
   960 000026D9 E87100              <1> 	call int_adlib_regwrite
   961                              <1> 	
   962 000026DC FEC4                <1> 	inc ah
   963 000026DE 75EF                <1> 	jnz .loop
   964                              <1> 	
   965 000026E0 C606[4928]00        <1> 	mov byte [adlib_running], 0
   966 000026E5 61                  <1> 	popa
   967 000026E6 C3                  <1> 	ret
   968                              <1> 	
   969                              <1> .pcspk:
   970                              <1> 	; Turn off the PC speaker
   971 000026E7 E461                <1> 	in al, 0x61
   972 000026E9 24FC                <1> 	and al, 0xfc
   973 000026EB E661                <1> 	out 0x61, al
   974                              <1> 
   975 000026ED B90000              <1> 	mov cx, 0
   976 000026F0 E8DC20              <1> 	call os_set_timer_speed
   977                              <1> 	
   978                              <1> 	; Reset the RTC handler
   979 000026F3 B11C                <1> 	mov cl, 1Ch
   980 000026F5 BE[7848]            <1> 	mov si, os_compat_int1C
   981 000026F8 8CCF                <1> 	mov di, cs
   982 000026FA E86520              <1> 	call os_modify_int_handler
   983                              <1> 	
   984                              <1> 	; Turn off all of the channels
   985 000026FD B91200              <1> 	mov cx, 18		; Not only nuke pwm_freq, but also pwm_cntr!
   986 00002700 BF[B828]            <1> 	mov di, pwm_freq
   987 00002703 B80000              <1> 	mov ax, 0
   988 00002706 F3AB                <1> 	rep stosw
   989                              <1> 	
   990 00002708 61                  <1> 	popa
   991 00002709 C3                  <1> 	ret
   992                              <1> 	
   993                              <1> 	; Registers:    	   0x00  0x20  0x40  0x60  0x80  0xA0  0xC0  0xE0
   994 0000270A 00003FFFFF000000    <1> 	adlib_clear_regs	db 0x00, 0x00, 0x3F, 0xFF, 0xFF, 0x00, 0x00, 0x00
   995                              <1> 	
   996                              <1> ; ------------------------------------------------------------------
   997                              <1> ; os_check_adlib -- Checks if YM3812 is present in the system
   998                              <1> ; OUT: CF clear if YM3812 is present
   999                              <1> 
  1000                              <1> os_check_adlib:
  1001 00002712 60                  <1> 	pusha
  1002 00002713 803EEEDE01          <1> 	cmp byte [57070], 1
  1003 00002718 7D14                <1> 	jge .ok
  1004                              <1> 
  1005 0000271A B86004              <1> 	mov ax, 0460h
  1006 0000271D E82D00              <1> 	call int_adlib_regwrite
  1007                              <1> 	
  1008 00002720 B88004              <1> 	mov ax, 0480h
  1009 00002723 E82700              <1> 	call int_adlib_regwrite
  1010                              <1> 	
  1011 00002726 BA8803              <1> 	mov dx, 388h
  1012 00002729 EC                  <1> 	in al, dx
  1013 0000272A 3C00                <1> 	cmp al, 0
  1014 0000272C 7503                <1> 	jne .error
  1015                              <1> 	
  1016                              <1> .ok:
  1017 0000272E 61                  <1> 	popa
  1018 0000272F F8                  <1> 	clc
  1019 00002730 C3                  <1> 	ret
  1020                              <1> 	
  1021                              <1> .error:
  1022 00002731 61                  <1> 	popa
  1023 00002732 F9                  <1> 	stc
  1024 00002733 C3                  <1> 	ret
  1025                              <1> 	
  1026                              <1> ; ------------------------------------------------------------------
  1027                              <1> ; os_adlib_regwrite -- Write to a YM3812 register
  1028                              <1> ; IN: AH/AL - register address/value to write
  1029                              <1> 
  1030                              <1> os_adlib_regwrite:
  1031 00002734 60                  <1> 	pusha
  1032                              <1> 	
  1033 00002735 0FB6DC              <1> 	movzx bx, ah		; Store the value in the buffer first
  1034 00002738 6488870005          <1> 	mov [fs:ADLIB_BUFFER + bx], al
  1035                              <1> 	
  1036 0000273D E80D00              <1> 	call int_adlib_regwrite
  1037                              <1> 	
  1038 00002740 61                  <1> 	popa
  1039 00002741 C3                  <1> 	ret
  1040                              <1> 	
  1041                              <1> ; ------------------------------------------------------------------
  1042                              <1> ; os_adlib_regread -- Read from a YM3812 register
  1043                              <1> ; IN: AH - register address; OUT: AL - value
  1044                              <1> 
  1045                              <1> os_adlib_regread:
  1046 00002742 53                  <1> 	push bx
  1047                              <1> 	
  1048 00002743 0FB6DC              <1> 	movzx bx, ah		; Store the value in the buffer first
  1049 00002746 648A870005          <1> 	mov al, [fs:ADLIB_BUFFER + bx]
  1050                              <1> 	
  1051 0000274B 5B                  <1> 	pop bx
  1052 0000274C C3                  <1> 	ret
  1053                              <1> 	
  1054                              <1> ; ------------------------------------------------------------------
  1055                              <1> ; int_adlib_regwrite -- Internal kernel function - not available to user programs
  1056                              <1> ; IN: AH/AL - register address/value to write
  1057                              <1> 	
  1058                              <1> int_adlib_regwrite:
  1059 0000274D 60                  <1> 	pusha
  1060                              <1> 
  1061 0000274E 803EEEDE01          <1> 	cmp byte [57070], 1
  1062 00002753 7D21                <1> 	jge .pcspk
  1063                              <1> 
  1064 00002755 803E[4928]00        <1> 	cmp byte [adlib_running], 0
  1065 0000275A 7418                <1> 	je .no_write
  1066                              <1> 
  1067 0000275C BA8803              <1> 	mov dx, 388h
  1068 0000275F 50                  <1> 	push ax
  1069 00002760 88E0                <1> 	mov al, ah
  1070 00002762 EE                  <1> 	out dx, al
  1071                              <1> 
  1072 00002763 EC                  <1> 	in al, dx
  1073 00002764 EC                  <1> 	in al, dx
  1074 00002765 EC                  <1> 	in al, dx
  1075 00002766 EC                  <1> 	in al, dx
  1076 00002767 EC                  <1> 	in al, dx
  1077 00002768 EC                  <1> 	in al, dx
  1078                              <1> 	
  1079 00002769 58                  <1> 	pop ax
  1080 0000276A 42                  <1> 	inc dx
  1081 0000276B EE                  <1> 	out dx, al
  1082                              <1> 
  1083 0000276C 4A                  <1> 	dec	dx
  1084 0000276D B422                <1> 	mov	ah, 22h
  1085                              <1> 
  1086                              <1> .wait:
  1087 0000276F EC                  <1> 	in al,dx
  1088 00002770 FECC                <1> 	dec ah
  1089 00002772 75FB                <1> 	jnz .wait
  1090                              <1> 	
  1091                              <1> .no_write:
  1092 00002774 61                  <1> 	popa
  1093 00002775 C3                  <1> 	ret
  1094                              <1> 
  1095                              <1> .pcspk:
  1096 00002776 80FCA0              <1> 	cmp ah, 0A0h
  1097 00002779 7CF9                <1> 	jl .no_write
  1098                              <1> 
  1099 0000277B 80FCB8              <1> 	cmp ah, 0B8h
  1100 0000277E 7FF4                <1> 	jg .no_write
  1101                              <1> 
  1102 00002780 80E40F              <1> 	and ah, 0Fh
  1103 00002783 0FB6DC              <1> 	movzx bx, ah
  1104                              <1> 	
  1105 00002786 648A87A005          <1> 	mov al, [fs:ADLIB_BUFFER + 0A0h + bx]
  1106 0000278B 648AA7B005          <1> 	mov ah, [fs:ADLIB_BUFFER + 0B0h + bx]
  1107                              <1> 	
  1108 00002790 F6C420              <1> 	test ah, 20h
  1109 00002793 7439                <1> 	jz .pcspk_clear
  1110                              <1> 	
  1111 00002795 88E2                <1> 	mov dl, ah		; Get the block number
  1112 00002797 C0EA02              <1> 	shr dl, 2
  1113 0000279A 80E207              <1> 	and dl, 7
  1114                              <1> 	
  1115 0000279D 25FF03              <1> 	and ax, 3FFh	; Get the FNum
  1116                              <1> 	
  1117                              <1> 	; WARNING! Due to the 16-bit integer limit (for speed), the maximum is block = 7, FNum = 511.
  1118                              <1> 	; Quick and dirty formula: freq = (fnum << block) / 21
  1119                              <1> 
  1120 000027A0 8816[A627]          <1> 	mov [.shift + 2], dl
  1121                              <1> 	
  1122 000027A4 C1E000              <1> 	.shift: db 0C1h, 0E0h, 0	; Shift AX left by the block number
  1123                              <1> 
  1124 000027A7 53                  <1> 	push bx
  1125                              <1> 	
  1126 000027A8 31D2                <1> 	xor dx, dx
  1127 000027AA BB1500              <1> 	mov bx, 21
  1128 000027AD F7F3                <1> 	div bx						; Calculate the frequency
  1129                              <1> 
  1130 000027AF 5B                  <1> 	pop bx
  1131                              <1> 
  1132 000027B0 53                  <1> 	push bx						; Apply the frequency multiplier
  1133 000027B1 B700                <1> 	mov bh, 0
  1134 000027B3 8A9F[E827]          <1> 	mov bl, [adlib_fmul_registers + bx]
  1135 000027B7 648A9F0005          <1> 	mov bl, [fs:ADLIB_BUFFER + bx]
  1136 000027BC 80E30F              <1> 	and bl, 0Fh
  1137 000027BF 8A9F[D827]          <1> 	mov bl, [adlib_fmul_values + bx]
  1138                              <1> 	
  1139 000027C3 F7E3                <1> 	mul bx
  1140 000027C5 5B                  <1> 	pop bx
  1141                              <1> 	
  1142 000027C6 D1E3                <1> 	shl bx, 1		; Words
  1143 000027C8 8987[B828]          <1> 	mov word [pwm_freq + bx], ax
  1144                              <1> 
  1145 000027CC 61                  <1> 	popa
  1146 000027CD C3                  <1> 	ret
  1147                              <1> 	
  1148                              <1> .pcspk_clear:
  1149 000027CE D1E3                <1> 	shl bx, 1		; Words
  1150 000027D0 C787[B828]0000      <1> 	mov word [pwm_freq + bx], 0
  1151                              <1> 	
  1152 000027D6 61                  <1> 	popa
  1153 000027D7 C3                  <1> 	ret
  1154                              <1> 	
  1155 000027D8 01020406080A0C0E10- <1> 	adlib_fmul_values		db 1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 20, 24, 24, 30, 30
  1155 000027E1 12141418181E1E      <1>
  1156 000027E8 2324252B2C2D333435  <1> 	adlib_fmul_registers	db 23h, 24h, 25h, 2Bh, 2Ch, 2Dh, 33h, 34h, 35h
  1157                              <1> 	
  1158                              <1> ; ------------------------------------------------------------------
  1159                              <1> ; os_adlib_mute -- Mute the YM3812's current state
  1160                              <1> ; IN: nothing
  1161                              <1> 
  1162                              <1> os_adlib_mute:
  1163 000027F1 60                  <1> 	pusha
  1164                              <1> 	
  1165 000027F2 803EEEDE01          <1> 	cmp byte [57070], 1
  1166 000027F7 7D15                <1> 	jge .pcspk
  1167                              <1> 	
  1168 000027F9 BE[3728]            <1> 	mov si, adlib_volume_registers
  1169 000027FC B91200              <1> 	mov cx, 18
  1170                              <1> 	
  1171                              <1> .loop:
  1172 000027FF AC                  <1> 	lodsb
  1173 00002800 88C4                <1> 	mov ah, al
  1174                              <1> 	
  1175 00002802 E83DFF              <1> 	call os_adlib_regread
  1176 00002805 0C3F                <1> 	or al, 3Fh
  1177 00002807 E843FF              <1> 	call int_adlib_regwrite
  1178                              <1> 	
  1179 0000280A E2F3                <1> 	loop .loop
  1180 0000280C 61                  <1> 	popa
  1181 0000280D C3                  <1> 	ret
  1182                              <1> 
  1183                              <1> .pcspk:
  1184 0000280E C606[DC28]01        <1> 	mov byte [pwm_muted], 1
  1185 00002813 61                  <1> 	popa
  1186 00002814 C3                  <1> 	ret
  1187                              <1> 	
  1188                              <1> ; ------------------------------------------------------------------
  1189                              <1> ; os_adlib_unmute -- Unmute the YM3812's current state
  1190                              <1> ; IN: nothing
  1191                              <1> 
  1192                              <1> os_adlib_unmute:
  1193 00002815 60                  <1> 	pusha
  1194                              <1> 
  1195 00002816 803EEEDE01          <1> 	cmp byte [57070], 1
  1196 0000281B 7D13                <1> 	jge .pcspk
  1197                              <1> 	
  1198 0000281D BE[3728]            <1> 	mov si, adlib_volume_registers
  1199 00002820 B91200              <1> 	mov cx, 18
  1200                              <1> 	
  1201                              <1> .loop:
  1202 00002823 AC                  <1> 	lodsb
  1203 00002824 88C4                <1> 	mov ah, al
  1204                              <1> 	
  1205 00002826 E819FF              <1> 	call os_adlib_regread
  1206 00002829 E821FF              <1> 	call int_adlib_regwrite
  1207                              <1> 	
  1208 0000282C E2F5                <1> 	loop .loop
  1209 0000282E 61                  <1> 	popa
  1210 0000282F C3                  <1> 	ret
  1211                              <1> 	
  1212                              <1> .pcspk:
  1213 00002830 C606[DC28]00        <1> 	mov byte [pwm_muted], 0
  1214 00002835 61                  <1> 	popa
  1215 00002836 C3                  <1> 	ret
  1216                              <1> 
  1217 00002837 40414243444548494A- <1> 	adlib_volume_registers	db 40h, 41h, 42h, 43h, 44h, 45h, 48h, 49h, 4Ah, 4Bh, 4Ch, 4Dh, 50h, 51h, 52h, 53h, 54h, 55h
  1217 00002840 4B4C4D505152535455  <1>
  1218 00002849 00                  <1> 	adlib_running			db 0
  1219                              <1> 
  1220                              <1> ; ------------------------------------------------------------------
  1221                              <1> ; PWM DRIVER
  1222                              <1> ; What is emulated: FNum, block number, carrier frequency multiplier
  1223                              <1> ; What is NOT emulated: literally everything else - amplitude, ADSR, waveforms, modulator
  1224                              <1> 
  1225                              <1> pwm_handler:
  1226 0000284A FA                  <1> 	cli
  1227 0000284B 60                  <1> 	pusha
  1228 0000284C 1E                  <1> 	push ds
  1229                              <1> 	
  1230 0000284D 8CC8                <1> 	mov ax, cs
  1231 0000284F 8ED8                <1> 	mov ds, ax
  1232                              <1> 	
  1233 00002851 803E[DC28]01        <1> 	cmp byte [pwm_muted], 1
  1234 00002856 744D                <1> 	je .no_spk
  1235                              <1> 
  1236                              <1> 	; Send the PWM value to the PC speaker
  1237 00002858 B0B0                <1> 	mov al, 10110000b
  1238 0000285A E643                <1> 	out 0x43, al
  1239 0000285C A0[E328]            <1> 	mov al, [pwm_val]
  1240 0000285F E642                <1> 	out 0x42, al
  1241 00002861 B000                <1> 	mov al, 0
  1242 00002863 E642                <1> 	out 0x42, al
  1243                              <1> 
  1244                              <1> 	; Calculate the next value
  1245 00002865 B90900              <1> 	mov cx, 9
  1246 00002868 BE[B828]            <1> 	mov si, pwm_freq
  1247 0000286B BF[C828]            <1> 	mov di, pwm_cntr - 2
  1248 0000286E B300                <1> 	mov bl, 0
  1249                              <1> 	
  1250 00002870 8A16[E428]          <1> 	mov dl, [pwm_channel_amplitude]
  1251                              <1> 	
  1252 00002874 803EEEDE02          <1> 	cmp byte [57070], 2
  1253 00002879 7513                <1> 	jne .handler_loop
  1254                              <1> 	
  1255                              <1> 	; Max volume mode, count the number of active channels
  1256 0000287B 56                  <1> 	push si
  1257 0000287C 51                  <1> 	push cx
  1258                              <1> 	
  1259                              <1> 	clr bx
    11 0000287D 31DB                <2>  xor %1, %1
  1260                              <1> 	
  1261                              <1> .channel_count_loop:
  1262 0000287F AD                  <1> 	lodsw
  1263                              <1> 	
  1264 00002880 83F800              <1> 	cmp ax, 0
  1265 00002883 7401                <1> 	je .channel_count_loop_no_inc
  1266                              <1> 	
  1267 00002885 43                  <1> 	inc bx
  1268                              <1> 	
  1269                              <1> .channel_count_loop_no_inc:
  1270 00002886 E2F7                <1> 	loop .channel_count_loop
  1271                              <1> 	
  1272 00002888 59                  <1> 	pop cx
  1273 00002889 5E                  <1> 	pop si
  1274                              <1> 	
  1275 0000288A 8A97[E528]          <1> 	mov dl, [pwm_fixed_amplitudes + bx]
  1276                              <1> 
  1277                              <1> 	; Add all of the channels together
  1278                              <1> .handler_loop:
  1279 0000288E AD                  <1> 	lodsw
  1280                              <1> 	
  1281 0000288F 83F800              <1> 	cmp ax, 0
  1282 00002892 7409                <1> 	je .handler_loop_no_inc
  1283                              <1> 	
  1284 00002894 83C702              <1> 	add di, 2
  1285 00002897 0105                <1> 	add [di], ax
  1286                              <1> 	
  1287 00002899 7902                <1> 	jns .handler_loop_no_inc
  1288                              <1> 	
  1289 0000289B 00D3                <1> 	add	bl, dl
  1290                              <1> 
  1291                              <1> .handler_loop_no_inc:
  1292 0000289D E2EF                <1> 	loop .handler_loop
  1293                              <1> 	
  1294 0000289F FEC3                <1> 	inc bl
  1295 000028A1 881E[E328]          <1> 	mov [pwm_val], bl
  1296                              <1> 	
  1297                              <1> .no_spk:
  1298                              <1> 	; Have we reached the callback value?	
  1299 000028A5 FF0E[DF28]          <1> 	dec word [pwm_callback_ctr]
  1300 000028A9 750A                <1> 	jnz .exit
  1301                              <1> 
  1302                              <1> 	; Yes, reset it
  1303 000028AB A1[E128]            <1> 	mov ax, [pwm_callback_ctr_def]
  1304 000028AE A3[DF28]            <1> 	mov [pwm_callback_ctr], ax
  1305                              <1> 	
  1306                              <1> 	; Call the callback
  1307 000028B1 FF16[DD28]          <1> 	call [pwm_callback]
  1308                              <1> 	
  1309                              <1> .exit:
  1310 000028B5 1F                  <1> 	pop ds
  1311 000028B6 61                  <1> 	popa
  1312 000028B7 CF                  <1> 	iret
  1313                              <1> 
  1314 000028B8 0000<rep 9h>        <1> 	pwm_freq				times 9 dw 0
  1315 000028CA 0000<rep 9h>        <1> 	pwm_cntr				times 9 dw 0
  1316 000028DC 00                  <1> 	pwm_muted				db 0
  1317 000028DD 0000                <1> 	pwm_callback			dw 0
  1318 000028DF 0000                <1> 	pwm_callback_ctr		dw 0
  1319 000028E1 0000                <1> 	pwm_callback_ctr_def	dw 0
  1320 000028E3 00                  <1> 	pwm_val					db 0
  1321 000028E4 00                  <1> 	pwm_channel_amplitude	db 0
  1322 000028E5 0024120C0907060504- <1> 	pwm_fixed_amplitudes	db 0, 36, 18, 12, 9, 7, 6, 5, 4, 4
  1322 000028EE 04                  <1>
  1323                              <1> 	
  1324                              <1> ; ------------------------------------------------------------------
  1325                              <1> ; os_adlib_calcfreq -- Play a frequency
  1326                              <1> ; IN: AX - frequency, CL = channel; OUT: nothing
  1327                              <1> 
  1328                              <1> os_adlib_calcfreq:
  1329 000028EF 6660                <1> 	pushad
  1330                              <1> 
  1331 000028F1 803EEEDE01          <1> 	cmp byte [57070], 1
  1332 000028F6 7D54                <1> 	jge .pcspk
  1333                              <1> 
  1334 000028F8 880E[5A29]          <1> 	mov [.channel], cl
  1335                              <1> 	
  1336 000028FC 660FB7C0            <1> 	movzx eax, ax
  1337 00002900 B100                <1> 	mov cl, 0		; Block number
  1338                              <1> 	
  1339 00002902 6650                <1> 	push eax
  1340                              <1> 
  1341                              <1> .block_loop:		; f-num = freq * 2^(20 - block) / 49716
  1342 00002904 6658                <1> 	pop eax
  1343 00002906 6650                <1> 	push eax
  1344                              <1> 	
  1345 00002908 B314                <1> 	mov bl, 20
  1346 0000290A 28CB                <1> 	sub bl, cl
  1347                              <1> 	
  1348 0000290C 881E[1329]          <1> 	mov [.shift + 3], bl
  1349 00002910 66C1E000            <1> .shift: db 0x66, 0xc1, 0xe0, 0		; shl eax, XX
  1350                              <1> 
  1351                              <1> 	clr edx
    11 00002914 6631D2              <2>  xor %1, %1
  1352 00002917 66BB34C20000        <1> 	mov ebx, 49716	; Divide by the sample rate
  1353 0000291D 66F7F3              <1> 	div ebx
  1354                              <1> 
  1355 00002920 FEC1                <1> 	inc cl
  1356                              <1> 	
  1357 00002922 3D0004              <1> 	cmp ax, 1024	; Is the result too large?
  1358 00002925 7DDD                <1> 	jge .block_loop
  1359                              <1> 	
  1360 00002927 FEC9                <1> 	dec cl
  1361                              <1> 	
  1362 00002929 C0E102              <1> 	shl cl, 2		; Write the block number
  1363 0000292C 00CC                <1> 	add ah, cl
  1364                              <1> 
  1365 0000292E 80CC20              <1> 	or ah, 20h		; Note on
  1366                              <1> 	
  1367 00002931 50                  <1> 	push ax
  1368 00002932 B4A0                <1> 	mov ah, 0A0h
  1369 00002934 0226[5A29]          <1> 	add ah, [.channel]
  1370 00002938 E8F9FD              <1> 	call os_adlib_regwrite
  1371 0000293B 58                  <1> 	pop ax
  1372                              <1> 	
  1373 0000293C 88E0                <1> 	mov al, ah
  1374 0000293E B4B0                <1> 	mov ah, 0B0h
  1375 00002940 0226[5A29]          <1> 	add ah, [.channel]
  1376 00002944 E8EDFD              <1> 	call os_adlib_regwrite
  1377                              <1> 	
  1378 00002947 6658                <1> 	pop eax
  1379 00002949 6661                <1> 	popad
  1380 0000294B C3                  <1> 	ret
  1381                              <1> 	
  1382                              <1> .pcspk:
  1383 0000294C 0FB6D9              <1> 	movzx bx, cl
  1384 0000294F D1E3                <1> 	shl bx, 1
  1385 00002951 D1E0                <1> 	shl ax, 1
  1386 00002953 8987[B828]          <1> 	mov [pwm_freq + bx], ax
  1387 00002957 6661                <1> 	popad
  1388 00002959 C3                  <1> 	ret
  1389                              <1> 	
  1390 0000295A 00                  <1> 	.channel	db 0
  1391                              <1> 	
  1392                              <1> ; ------------------------------------------------------------------
  1393                              <1> ; os_adlib_noteoff -- Turns off a note
  1394                              <1> ; IN: CL = channel; OUT: nothing
  1395                              <1> 
  1396                              <1> os_adlib_noteoff:
  1397 0000295B 803EEEDE01          <1> 	cmp byte [57070], 1
  1398 00002960 7D0F                <1> 	jge .pcspk
  1399                              <1> 	
  1400 00002962 60                  <1> 	pusha
  1401                              <1> 
  1402 00002963 B4B0                <1> 	mov ah, 0B0h
  1403 00002965 00CC                <1> 	add ah, cl
  1404 00002967 E8D8FD              <1> 	call os_adlib_regread
  1405                              <1> 	
  1406 0000296A 24DF                <1> 	and al, 11011111b
  1407 0000296C E8C5FD              <1> 	call os_adlib_regwrite
  1408                              <1> 	
  1409 0000296F 61                  <1> 	popa
  1410 00002970 C3                  <1> 	ret
  1411                              <1> 	
  1412                              <1> .pcspk:
  1413 00002971 60                  <1> 	pusha
  1414 00002972 0FB6D9              <1> 	movzx bx, cl
  1415 00002975 D1E3                <1> 	shl bx, 1
  1416 00002977 C787[B828]0000      <1> 	mov word [pwm_freq + bx], 0
  1417 0000297D 61                  <1> 	popa
  1418 0000297E C3                  <1> 	ret	
  1419                              <1> 	
  1420                              <1> ; ==================================================================
  1421                              <1> 
   817                                  	%INCLUDE "drivers/string.asm"
   818                              <1> ; ==================================================================
   819                              <1> ; STRING MANIPULATION ROUTINES
   820                              <1> ; ==================================================================
   821                              <1> 
   822                              <1> ; os_string_encrypt -- Encrypts a string using a totally military-grade encryption algorithm
   823                              <1> ; IN: SI = Input string/Output string
   824                              <1> 
   825                              <1> os_string_encrypt:
   826 0000297F 60                  <1> 	pusha
   827 00002980 89F7                <1> 	mov di, si
   828                              <1> 
   829 00002982 89F0                <1> 	mov ax, si
   830 00002984 E82C00              <1> 	call os_string_length
   831 00002987 C0E002              <1> 	shl al, 2
   832 0000298A 347B                <1> 	xor al, 123
   833                              <1> 	
   834 0000298C B17B                <1> 	mov cl, 123
   835 0000298E 00C1                <1> 	add cl, al
   836 00002990 80F1DB              <1> 	xor cl, 219
   837                              <1> 	
   838                              <1> .loop:
   839 00002993 AC                  <1> 	lodsb
   840 00002994 3C00                <1> 	cmp al, 0
   841 00002996 740A                <1> 	je .exit
   842                              <1> 	
   843 00002998 00C8                <1> 	add al, cl
   844 0000299A 34AA                <1> 	xor al, 10101010b
   845 0000299C AA                  <1> 	stosb
   846                              <1> 	
   847 0000299D 80C14D              <1> 	add cl, 77
   848 000029A0 EBF1                <1> 	jmp .loop
   849                              <1> 	
   850                              <1> .exit:
   851 000029A2 61                  <1> 	popa
   852 000029A3 C3                  <1> 	ret
   853                              <1> 	
   854                              <1> ; os_string_add -- Add a string on top of another string
   855                              <1> ; IN: AX/BX = Main string/Added string
   856                              <1> 
   857                              <1> os_string_add:
   858 000029A4 60                  <1> 	pusha
   859 000029A5 50                  <1> 	push ax
   860 000029A6 E80A00              <1> 	call os_string_length		; Get the length of the main string
   861 000029A9 5F                  <1> 	pop di
   862 000029AA 01C7                <1> 	add di, ax					; Add it to the pointer
   863 000029AC 89DE                <1> 	mov si, bx
   864 000029AE E89500              <1>  	call os_string_copy			; Copy the string
   865 000029B1 61                  <1>  	popa
   866 000029B2 C3                  <1>  	ret
   867                              <1> 	
   868                              <1> ; ------------------------------------------------------------------
   869                              <1> ; os_string_length -- Return length of a string
   870                              <1> ; IN: AX = string location
   871                              <1> ; OUT AX = length (other regs preserved)
   872                              <1> 
   873                              <1> os_string_length:
   874 000029B3 60                  <1> 	pusha
   875                              <1> 
   876 000029B4 89C3                <1> 	mov bx, ax			; Move location of string to BX
   877                              <1> 
   878 000029B6 31C9                <1> 	xor cx, cx			; Counter
   879                              <1> 
   880                              <1> .more:
   881 000029B8 803F00              <1> 	cmp byte [bx], 0		; Zero (end of string) yet?
   882 000029BB 7404                <1> 	je .done
   883 000029BD 43                  <1> 	inc bx				; If not, keep adding
   884 000029BE 41                  <1> 	inc cx
   885 000029BF EBF7                <1> 	jmp .more
   886                              <1> 
   887                              <1> 
   888                              <1> .done:
   889 000029C1 890E[CA29]          <1> 	mov word [.tmp_counter], cx	; Store count before restoring other registers
   890 000029C5 61                  <1> 	popa
   891                              <1> 
   892 000029C6 A1[CA29]            <1> 	mov ax, [.tmp_counter]		; Put count back into AX before returning
   893 000029C9 C3                  <1> 	ret
   894                              <1> 
   895                              <1> 
   896 000029CA 0000                <1> 	.tmp_counter	dw 0
   897                              <1> 
   898                              <1> 
   899                              <1> ; ------------------------------------------------------------------
   900                              <1> ; os_string_reverse -- Reverse the characters in a string
   901                              <1> ; IN: SI = string location
   902                              <1> 
   903                              <1> os_string_reverse:
   904 000029CC 60                  <1> 	pusha
   905                              <1> 
   906 000029CD 803C00              <1> 	cmp byte [si], 0		; Don't attempt to reverse empty string
   907 000029D0 7418                <1> 	je .end
   908                              <1> 
   909 000029D2 89F0                <1> 	mov ax, si
   910 000029D4 E8DCFF              <1> 	call os_string_length
   911                              <1> 
   912 000029D7 89F7                <1> 	mov di, si
   913 000029D9 01C7                <1> 	add di, ax
   914 000029DB 4F                  <1> 	dec di				; DI now points to last char in string
   915                              <1> 
   916                              <1> .loop:
   917 000029DC 8A04                <1> 	mov byte al, [si]		; Swap bytes
   918 000029DE 8A1D                <1> 	mov byte bl, [di]
   919                              <1> 
   920 000029E0 881C                <1> 	mov byte [si], bl
   921 000029E2 8805                <1> 	mov byte [di], al
   922                              <1> 
   923 000029E4 46                  <1> 	inc si				; Move towards string centre
   924 000029E5 4F                  <1> 	dec di
   925                              <1> 
   926 000029E6 39F7                <1> 	cmp di, si			; Both reached the centre?
   927 000029E8 77F2                <1> 	ja .loop
   928                              <1> 
   929                              <1> .end:
   930 000029EA 61                  <1> 	popa
   931 000029EB C3                  <1> 	ret
   932                              <1> 
   933                              <1> 
   934                              <1> ; ------------------------------------------------------------------
   935                              <1> ; os_find_char_in_string -- Find location of character in a string
   936                              <1> ; IN: SI = string location, AL = character to find
   937                              <1> ; OUT: AX = location in string, or 0 if char not present
   938                              <1> 
   939                              <1> os_find_char_in_string:
   940 000029EC 60                  <1> 	pusha
   941                              <1> 
   942 000029ED B90100              <1> 	mov cx, 1			; Counter -- start at first char (we count
   943                              <1> 					; from 1 in chars here, so that we can
   944                              <1> 					; return 0 if the source char isn't found)
   945                              <1> 
   946                              <1> .more:
   947 000029F0 3804                <1> 	cmp byte [si], al
   948 000029F2 7409                <1> 	je .done
   949 000029F4 803C00              <1> 	cmp byte [si], 0
   950 000029F7 740D                <1> 	je .notfound
   951 000029F9 46                  <1> 	inc si
   952 000029FA 41                  <1> 	inc cx
   953 000029FB EBF3                <1> 	jmp .more
   954                              <1> 
   955                              <1> .done:
   956 000029FD 890E[0A2A]          <1> 	mov [.tmp], cx
   957 00002A01 61                  <1> 	popa
   958 00002A02 A1[0A2A]            <1> 	mov ax, [.tmp]
   959 00002A05 C3                  <1> 	ret
   960                              <1> 
   961                              <1> .notfound:
   962 00002A06 61                  <1> 	popa
   963 00002A07 31C0                <1> 	xor ax, ax
   964 00002A09 C3                  <1> 	ret
   965                              <1> 
   966                              <1> 
   967 00002A0A 0000                <1> 	.tmp	dw 0
   968                              <1> 
   969                              <1> 
   970                              <1> ; ------------------------------------------------------------------
   971                              <1> ; os_string_uppercase -- Convert zero-terminated string to upper case
   972                              <1> ; IN/OUT: AX = string location
   973                              <1> 
   974                              <1> os_string_uppercase:
   975 00002A0C 60                  <1> 	pusha
   976                              <1> 
   977 00002A0D 89C6                <1> 	mov si, ax			; Use SI to access string
   978                              <1> 
   979                              <1> .more:
   980 00002A0F 803C00              <1> 	cmp byte [si], 0		; Zero-termination of string?
   981 00002A12 7413                <1> 	je .done			; If so, quit
   982                              <1> 
   983 00002A14 803C61              <1> 	cmp byte [si], 'a'		; In the lower case A to Z range?
   984 00002A17 720B                <1> 	jb .noatoz
   985 00002A19 803C7A              <1> 	cmp byte [si], 'z'
   986 00002A1C 7706                <1> 	ja .noatoz
   987                              <1> 
   988 00002A1E 802C20              <1> 	sub byte [si], 20h		; If so, convert input char to upper case
   989                              <1> 
   990 00002A21 46                  <1> 	inc si
   991 00002A22 EBEB                <1> 	jmp .more
   992                              <1> 
   993                              <1> .noatoz:
   994 00002A24 46                  <1> 	inc si
   995 00002A25 EBE8                <1> 	jmp .more
   996                              <1> 
   997                              <1> .done:
   998 00002A27 61                  <1> 	popa
   999 00002A28 C3                  <1> 	ret
  1000                              <1> 
  1001                              <1> 
  1002                              <1> ; ------------------------------------------------------------------
  1003                              <1> ; os_string_lowercase -- Convert zero-terminated string to lower case
  1004                              <1> ; IN/OUT: AX = string location
  1005                              <1> 
  1006                              <1> os_string_lowercase:
  1007 00002A29 60                  <1> 	pusha
  1008                              <1> 
  1009 00002A2A 89C6                <1> 	mov si, ax			; Use SI to access string
  1010                              <1> 
  1011                              <1> .more:
  1012 00002A2C 803C00              <1> 	cmp byte [si], 0		; Zero-termination of string?
  1013 00002A2F 7413                <1> 	je .done			; If so, quit
  1014                              <1> 
  1015 00002A31 803C41              <1> 	cmp byte [si], 'A'		; In the upper case A to Z range?
  1016 00002A34 720B                <1> 	jb .noatoz
  1017 00002A36 803C5A              <1> 	cmp byte [si], 'Z'
  1018 00002A39 7706                <1> 	ja .noatoz
  1019                              <1> 
  1020 00002A3B 800420              <1> 	add byte [si], 20h		; If so, convert input char to lower case
  1021                              <1> 
  1022 00002A3E 46                  <1> 	inc si
  1023 00002A3F EBEB                <1> 	jmp .more
  1024                              <1> 
  1025                              <1> .noatoz:
  1026 00002A41 46                  <1> 	inc si
  1027 00002A42 EBE8                <1> 	jmp .more
  1028                              <1> 
  1029                              <1> .done:
  1030 00002A44 61                  <1> 	popa
  1031 00002A45 C3                  <1> 	ret
  1032                              <1> 
  1033                              <1> 
  1034                              <1> ; ------------------------------------------------------------------
  1035                              <1> ; os_string_copy -- Copy one string into another
  1036                              <1> ; IN/OUT: SI = source, DI = destination (programmer ensure sufficient room)
  1037                              <1> 
  1038                              <1> os_string_copy:
  1039 00002A46 60                  <1> 	pusha
  1040                              <1> 
  1041                              <1> .more:
  1042 00002A47 AC                  <1> 	lodsb
  1043 00002A48 AA                  <1> 	stosb
  1044 00002A49 3C00                <1> 	cmp byte al, 0			; If source string is empty, quit out
  1045 00002A4B 75FA                <1> 	jne .more
  1046 00002A4D 61                  <1> 	popa
  1047 00002A4E C3                  <1> 	ret
  1048                              <1> 
  1049                              <1> 
  1050                              <1> ; ------------------------------------------------------------------
  1051                              <1> ; os_string_join -- Join two strings into a third string
  1052                              <1> ; IN/OUT: AX = string one, BX = string two, CX = destination string
  1053                              <1> 
  1054                              <1> os_string_join:
  1055 00002A4F 60                  <1> 	pusha
  1056                              <1> 
  1057 00002A50 89C6                <1> 	mov si, ax
  1058 00002A52 89CF                <1> 	mov di, cx
  1059 00002A54 E8EFFF              <1> 	call os_string_copy
  1060                              <1> 
  1061 00002A57 E859FF              <1> 	call os_string_length		; Get length of first string
  1062                              <1> 
  1063 00002A5A 01C1                <1> 	add cx, ax			; Position at end of first string
  1064                              <1> 
  1065 00002A5C 89DE                <1> 	mov si, bx			; Add second string onto it
  1066 00002A5E 89CF                <1> 	mov di, cx
  1067 00002A60 E8E3FF              <1> 	call os_string_copy
  1068                              <1> 
  1069 00002A63 61                  <1> 	popa
  1070 00002A64 C3                  <1> 	ret
  1071                              <1> 
  1072                              <1> 
  1073                              <1> ; ------------------------------------------------------------------
  1074                              <1> ; os_string_chomp -- Strip leading and trailing spaces from a string
  1075                              <1> ; IN: AX = string location
  1076                              <1> 
  1077                              <1> os_string_chomp:
  1078 00002A65 60                  <1> 	pusha
  1079                              <1> 
  1080 00002A66 89C2                <1> 	mov dx, ax			; Save string location
  1081                              <1> 
  1082 00002A68 89C7                <1> 	mov di, ax			; Put location into DI
  1083 00002A6A 31C9                <1> 	xor cx, cx			; Space counter
  1084                              <1> 
  1085                              <1> .keepcounting:				; Get number of leading spaces into BX
  1086 00002A6C 803D20              <1> 	cmp byte [di], ' '
  1087 00002A6F 7504                <1> 	jne .counted
  1088 00002A71 41                  <1> 	inc cx
  1089 00002A72 47                  <1> 	inc di
  1090 00002A73 EBF7                <1> 	jmp .keepcounting
  1091                              <1> 
  1092                              <1> .counted:
  1093 00002A75 83F900              <1> 	cmp cx, 0			; No leading spaces?
  1094 00002A78 7410                <1> 	je .finished_copy
  1095                              <1> 
  1096 00002A7A 89FE                <1> 	mov si, di			; Address of first non-space character
  1097 00002A7C 89D7                <1> 	mov di, dx			; DI = original string start
  1098                              <1> 
  1099                              <1> .keep_copying:
  1100 00002A7E 8A04                <1> 	mov al, [si]			; Copy SI into DI
  1101 00002A80 8805                <1> 	mov [di], al			; Including terminator
  1102 00002A82 3C00                <1> 	cmp al, 0
  1103 00002A84 7404                <1> 	je .finished_copy
  1104 00002A86 46                  <1> 	inc si
  1105 00002A87 47                  <1> 	inc di
  1106 00002A88 EBF4                <1> 	jmp .keep_copying
  1107                              <1> 
  1108                              <1> .finished_copy:
  1109 00002A8A 89D0                <1> 	mov ax, dx			; AX = original string start
  1110                              <1> 
  1111 00002A8C E824FF              <1> 	call os_string_length
  1112 00002A8F 83F800              <1> 	cmp ax, 0			; If empty or all blank, done, return 'null'
  1113 00002A92 740F                <1> 	je .done
  1114                              <1> 
  1115 00002A94 89D6                <1> 	mov si, dx
  1116 00002A96 01C6                <1> 	add si, ax			; Move to end of string
  1117                              <1> 
  1118                              <1> .more:
  1119 00002A98 4E                  <1> 	dec si
  1120 00002A99 803C20              <1> 	cmp byte [si], ' '
  1121 00002A9C 7505                <1> 	jne .done
  1122 00002A9E C60400              <1> 	mov byte [si], 0		; Fill end spaces with 0s
  1123 00002AA1 EBF5                <1> 	jmp .more			; (First 0 will be the string terminator)
  1124                              <1> 
  1125                              <1> .done:
  1126 00002AA3 61                  <1> 	popa
  1127 00002AA4 C3                  <1> 	ret
  1128                              <1> 
  1129                              <1> 
  1130                              <1> ; ------------------------------------------------------------------
  1131                              <1> ; os_string_compare -- See if two strings match
  1132                              <1> ; IN: SI = string one, DI = string two
  1133                              <1> ; OUT: carry set if same, clear if different
  1134                              <1> 
  1135                              <1> os_string_compare:
  1136 00002AA5 60                  <1> 	pusha
  1137                              <1> 
  1138                              <1> .more:
  1139 00002AA6 8A04                <1> 	mov al, [si]			; Retrieve string contents
  1140 00002AA8 8A1D                <1> 	mov bl, [di]
  1141                              <1> 
  1142 00002AAA 38D8                <1> 	cmp al, bl			; Compare characters at current location
  1143 00002AAC 7508                <1> 	jne .not_same
  1144                              <1> 
  1145 00002AAE 3C00                <1> 	cmp al, 0			; End of first string? Must also be end of second
  1146 00002AB0 7407                <1> 	je .terminated
  1147                              <1> 
  1148 00002AB2 46                  <1> 	inc si
  1149 00002AB3 47                  <1> 	inc di
  1150 00002AB4 EBF0                <1> 	jmp .more
  1151                              <1> 
  1152                              <1> 
  1153                              <1> .not_same:				; If unequal lengths with same beginning, the byte
  1154 00002AB6 61                  <1> 	popa				; comparison fails at shortest string terminator
  1155 00002AB7 F8                  <1> 	clc				; Clear carry flag
  1156 00002AB8 C3                  <1> 	ret
  1157                              <1> 
  1158                              <1> 
  1159                              <1> .terminated:				; Both strings terminated at the same position
  1160 00002AB9 61                  <1> 	popa
  1161 00002ABA F9                  <1> 	stc				; Set carry flag
  1162 00002ABB C3                  <1> 	ret
  1163                              <1> 
  1164                              <1> 
  1165                              <1> ; ------------------------------------------------------------------
  1166                              <1> ; os_string_parse -- Take string (eg "run foo bar baz") and return
  1167                              <1> ; pointers to zero-terminated strings (eg AX = "run", BX = "foo" etc.)
  1168                              <1> ; IN: SI = string; OUT: AX, BX, CX, DX = individual strings
  1169                              <1> 
  1170                              <1> os_string_parse:
  1171 00002ABC 56                  <1> 	push si
  1172                              <1> 
  1173 00002ABD 89F0                <1> 	mov ax, si			; AX = start of first string
  1174                              <1> 
  1175 00002ABF 31DB                <1> 	xor bx, bx			; By default, other strings start empty
  1176 00002AC1 31C9                <1> 	xor cx, cx
  1177 00002AC3 31D2                <1> 	xor dx, dx
  1178                              <1> 
  1179 00002AC5 50                  <1> 	push ax				; Save to retrieve at end
  1180                              <1> 
  1181                              <1> .loop1:
  1182 00002AC6 AC                  <1> 	lodsb				; Get a byte
  1183 00002AC7 3C00                <1> 	cmp al, 0			; End of string?
  1184 00002AC9 742B                <1> 	je .finish
  1185 00002ACB 3C20                <1> 	cmp al, ' '			; A space?
  1186 00002ACD 75F7                <1> 	jne .loop1
  1187 00002ACF 4E                  <1> 	dec si
  1188 00002AD0 C60400              <1> 	mov byte [si], 0		; If so, zero-terminate this bit of the string
  1189                              <1> 
  1190 00002AD3 46                  <1> 	inc si				; Store start of next string in BX
  1191 00002AD4 89F3                <1> 	mov bx, si
  1192                              <1> 
  1193                              <1> .loop2:					; Repeat the above for CX and DX...
  1194 00002AD6 AC                  <1> 	lodsb
  1195 00002AD7 3C00                <1> 	cmp al, 0
  1196 00002AD9 741B                <1> 	je .finish
  1197 00002ADB 3C20                <1> 	cmp al, ' '
  1198 00002ADD 75F7                <1> 	jne .loop2
  1199 00002ADF 4E                  <1> 	dec si
  1200 00002AE0 C60400              <1> 	mov byte [si], 0
  1201                              <1> 
  1202 00002AE3 46                  <1> 	inc si
  1203 00002AE4 89F1                <1> 	mov cx, si
  1204                              <1> 
  1205                              <1> .loop3:
  1206 00002AE6 AC                  <1> 	lodsb
  1207 00002AE7 3C00                <1> 	cmp al, 0
  1208 00002AE9 740B                <1> 	je .finish
  1209 00002AEB 3C20                <1> 	cmp al, ' '
  1210 00002AED 75F7                <1> 	jne .loop3
  1211 00002AEF 4E                  <1> 	dec si
  1212 00002AF0 C60400              <1> 	mov byte [si], 0
  1213                              <1> 
  1214 00002AF3 46                  <1> 	inc si
  1215 00002AF4 89F2                <1> 	mov dx, si
  1216                              <1> 
  1217                              <1> .finish:
  1218 00002AF6 58                  <1> 	pop ax
  1219                              <1> 
  1220 00002AF7 5E                  <1> 	pop si
  1221 00002AF8 C3                  <1> 	ret
  1222                              <1> 
  1223                              <1> 
  1224                              <1> ; ------------------------------------------------------------------
  1225                              <1> ; os_string_to_int -- Convert decimal string to integer value
  1226                              <1> ; IN: SI = string location (max 5 chars, up to '65535')
  1227                              <1> ; OUT: AX = number
  1228                              <1> 
  1229                              <1> os_string_to_int:
  1230 00002AF9 E88E01              <1> 	call os_string_to_32int		; This function only exists for compatibility reasons
  1231 00002AFC C3                  <1> 	ret
  1232                              <1> 
  1233                              <1> ; ------------------------------------------------------------------
  1234                              <1> ; os_string_to_hex -- Convert hexadecimal string to integer value
  1235                              <1> ; IN: SI = string location (max 8 chars, up to 'FFFFFFFF')
  1236                              <1> ; OUT: EAX = number
  1237                              <1> 
  1238                              <1> os_string_to_hex:
  1239 00002AFD 6660                <1> 	pushad
  1240                              <1> 	
  1241 00002AFF 89F0                <1> 	mov ax, si			; First, uppercase the string
  1242 00002B01 E808FF              <1> 	call os_string_uppercase
  1243                              <1> 
  1244 00002B04 6631C0              <1> 	xor eax, eax				; Temporary 32-bit integer
  1245                              <1> 	
  1246                              <1> .loop:
  1247 00002B07 6650                <1> 	push eax
  1248 00002B09 AC                  <1> 	lodsb					; Load a byte from SI
  1249 00002B0A 88C1                <1> 	mov cl, al
  1250 00002B0C 6658                <1> 	pop eax
  1251 00002B0E 80F900              <1> 	cmp cl, 0				; Have we reached the end?
  1252 00002B11 0F842000            <1> 	je near .exit			; If we have, exit
  1253                              <1> 	
  1254 00002B15 80F939              <1> 	cmp cl, '9'
  1255 00002B18 7E03                <1> 	jle .no_change
  1256                              <1> 	
  1257 00002B1A 80E907              <1> 	sub cl, 7
  1258                              <1> 	
  1259                              <1> .no_change:
  1260 00002B1D 80E930              <1> 	sub cl, '0'				; Convert the value to decimal
  1261 00002B20 6681E1FF000000      <1> 	and ecx, 255			; Keep the low 8 bits only
  1262 00002B27 66BB10000000        <1> 	mov ebx, 16 
  1263 00002B2D 66F7E3              <1> 	mul ebx					; Multiply EAX by 16
  1264 00002B30 6601C8              <1> 	add eax, ecx			; Add the value to the integer
  1265 00002B33 EBD2                <1> 	jmp .loop				; Loop again
  1266                              <1> 	
  1267                              <1> .exit:
  1268 00002B35 66A3[402B]          <1> 	mov [.tmp_dword], eax
  1269 00002B39 6661                <1> 	popad
  1270 00002B3B 66A1[402B]          <1> 	mov eax, [.tmp_dword]
  1271 00002B3F C3                  <1> 	ret
  1272                              <1> 	
  1273 00002B40 00000000            <1> 	.tmp_dword	dd 0
  1274                              <1> 
  1275                              <1> ; ------------------------------------------------------------------
  1276                              <1> ; os_int_to_string -- Convert unsigned integer to string
  1277                              <1> ; IN: AX = unsigned int
  1278                              <1> ; OUT: AX = string location
  1279                              <1> 
  1280                              <1> os_int_to_string:
  1281 00002B44 60                  <1> 	pusha
  1282                              <1> 
  1283 00002B45 31C9                <1> 	xor cx, cx
  1284 00002B47 BB0A00              <1> 	mov bx, 10			; Set BX 10, for division and mod
  1285 00002B4A BF[6B2B]            <1> 	mov di, .t			; Get our pointer ready
  1286                              <1> 
  1287                              <1> .push:
  1288 00002B4D 31D2                <1> 	xor dx, dx
  1289 00002B4F F7F3                <1> 	div bx				; Remainder in DX, quotient in AX
  1290 00002B51 41                  <1> 	inc cx				; Increase pop loop counter
  1291 00002B52 52                  <1> 	push dx				; Push remainder, so as to reverse order when popping
  1292 00002B53 85C0                <1> 	test ax, ax			; Is quotient zero?
  1293 00002B55 75F6                <1> 	jnz .push			; If not, loop again
  1294                              <1> .pop:
  1295 00002B57 5A                  <1> 	pop dx				; Pop off values in reverse order, and add 48 to make them digits
  1296 00002B58 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
  1297 00002B5B 2E8815              <1> 	mov [cs:di], dl
  1298 00002B5E 47                  <1> 	inc di
  1299 00002B5F 49                  <1> 	dec cx
  1300 00002B60 75F5                <1> 	jnz .pop
  1301                              <1> 
  1302 00002B62 2EC60500            <1> 	mov byte [cs:di], 0		; Zero-terminate string
  1303                              <1> 
  1304 00002B66 61                  <1> 	popa
  1305 00002B67 B8[6B2B]            <1> 	mov ax, .t			; Return location of string
  1306 00002B6A C3                  <1> 	ret
  1307                              <1> 
  1308                              <1> 
  1309 00002B6B 00<rep 7h>          <1> 	.t times 7 db 0
  1310                              <1> 
  1311                              <1> 
  1312                              <1> ; ------------------------------------------------------------------
  1313                              <1> ; os_sint_to_string -- Convert signed integer to string
  1314                              <1> ; IN: AX = signed int
  1315                              <1> ; OUT: AX = string location
  1316                              <1> 
  1317                              <1> os_sint_to_string:
  1318 00002B72 60                  <1> 	pusha
  1319                              <1> 
  1320 00002B73 31C9                <1> 	xor cx, cx
  1321 00002B75 BB0A00              <1> 	mov bx, 10			; Set BX 10, for division and mod
  1322 00002B78 BF[A52B]            <1> 	mov di, .t			; Get our pointer ready
  1323                              <1> 
  1324 00002B7B 85C0                <1> 	test ax, ax			; Find out if X > 0 or not, force a sign
  1325 00002B7D 7802                <1> 	js .neg				; If negative...
  1326 00002B7F EB08                <1> 	jmp .push			; ...or if positive
  1327                              <1> .neg:
  1328 00002B81 F7D8                <1> 	neg ax				; Make AX positive
  1329 00002B83 C606[A52B]2D        <1> 	mov byte [.t], '-'		; Add a minus sign to our string
  1330 00002B88 47                  <1> 	inc di				; Update the index
  1331                              <1> .push:
  1332 00002B89 31D2                <1> 	xor dx, dx
  1333 00002B8B F7F3                <1> 	div bx				; Remainder in DX, quotient in AX
  1334 00002B8D 41                  <1> 	inc cx				; Increase pop loop counter
  1335 00002B8E 52                  <1> 	push dx				; Push remainder, so as to reverse order when popping
  1336 00002B8F 85C0                <1> 	test ax, ax			; Is quotient zero?
  1337 00002B91 75F6                <1> 	jnz .push			; If not, loop again
  1338                              <1> .pop:
  1339 00002B93 5A                  <1> 	pop dx				; Pop off values in reverse order, and add 48 to make them digits
  1340 00002B94 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
  1341 00002B97 8815                <1> 	mov [di], dl
  1342 00002B99 47                  <1> 	inc di
  1343 00002B9A 49                  <1> 	dec cx
  1344 00002B9B 75F6                <1> 	jnz .pop
  1345                              <1> 
  1346 00002B9D C60500              <1> 	mov byte [di], 0		; Zero-terminate string
  1347                              <1> 
  1348 00002BA0 61                  <1> 	popa
  1349 00002BA1 B8[A52B]            <1> 	mov ax, .t			; Return location of string
  1350 00002BA4 C3                  <1> 	ret
  1351                              <1> 
  1352                              <1> 
  1353 00002BA5 00<rep 7h>          <1> 	.t times 7 db 0
  1354                              <1> 
  1355                              <1> ; ------------------------------------------------------------------
  1356                              <1> ; os_get_time_string -- Get current time in a string (eg '10:25')
  1357                              <1> ; IN/OUT: BX = string location
  1358                              <1> 
  1359                              <1> os_get_time_string:
  1360 00002BAC 60                  <1> 	pusha
  1361                              <1> 	
  1362 00002BAD 89DF                <1> 	mov di, bx			; Location to place the string
  1363                              <1> 
  1364 00002BAF B402                <1> 	mov ah, 02h			; Get the current time
  1365 00002BB1 E805EB              <1> 	call os_int_1Ah
  1366                              <1> 	
  1367 00002BB4 723B                <1> 	jc .exit
  1368                              <1> 
  1369 00002BB6 51                  <1> 	push cx	
  1370                              <1> 
  1371 00002BB7 88E8                <1> 	mov al, ch
  1372 00002BB9 E847E8              <1> 	call os_bcd_to_int
  1373 00002BBC 83F80A              <1> 	cmp ax, 10
  1374 00002BBF 7D05                <1> 	jge .hour_10
  1375                              <1> 	
  1376 00002BC1 50                  <1> 	push ax
  1377 00002BC2 B030                <1> 	mov al, '0'
  1378 00002BC4 AA                  <1> 	stosb
  1379 00002BC5 58                  <1> 	pop ax
  1380                              <1> 	
  1381                              <1> .hour_10:
  1382 00002BC6 E87BFF              <1> 	call os_int_to_string
  1383 00002BC9 89C6                <1> 	mov si, ax
  1384                              <1> 	
  1385                              <1> .hour_loop:	
  1386 00002BCB AC                  <1> 	lodsb
  1387 00002BCC 3C00                <1> 	cmp al, 0
  1388 00002BCE 7403                <1> 	je .hour_loop_end
  1389 00002BD0 AA                  <1> 	stosb
  1390 00002BD1 EBF8                <1> 	jmp .hour_loop
  1391                              <1> 	
  1392                              <1> .hour_loop_end:
  1393 00002BD3 B03A                <1> 	mov al, ':'			; Insert the time separator (or whatever it's called)
  1394 00002BD5 AA                  <1> 	stosb
  1395                              <1> 		
  1396 00002BD6 59                  <1> 	pop cx
  1397 00002BD7 88C8                <1> 	mov al, cl
  1398 00002BD9 E827E8              <1> 	call os_bcd_to_int
  1399 00002BDC 83F80A              <1> 	cmp ax, 10
  1400 00002BDF 7D05                <1> 	jge .minute_10
  1401                              <1> 	
  1402 00002BE1 50                  <1> 	push ax
  1403 00002BE2 B030                <1> 	mov al, '0'
  1404 00002BE4 AA                  <1> 	stosb
  1405 00002BE5 58                  <1> 	pop ax
  1406                              <1> 	
  1407                              <1> .minute_10:
  1408 00002BE6 E85BFF              <1> 	call os_int_to_string
  1409 00002BE9 89C6                <1> 	mov si, ax
  1410                              <1> 		
  1411                              <1> .minute_loop:	
  1412 00002BEB AC                  <1> 	lodsb
  1413 00002BEC AA                  <1> 	stosb
  1414                              <1> 	
  1415 00002BED 3C00                <1> 	cmp al, 0
  1416 00002BEF 75FA                <1> 	jne .minute_loop
  1417                              <1> 
  1418                              <1> .exit:
  1419 00002BF1 61                  <1> 	popa
  1420 00002BF2 C3                  <1> 	ret
  1421                              <1> 
  1422                              <1> ; ------------------------------------------------------------------
  1423                              <1> ; os_get_date_string -- Get current date in a string (eg '12/31/2007')
  1424                              <1> ; IN/OUT: BX = string location
  1425                              <1> 
  1426                              <1> os_get_date_string:
  1427 00002BF3 60                  <1> 	pusha
  1428                              <1> 
  1429 00002BF4 89DF                <1> 	mov di, bx
  1430                              <1> 	
  1431 00002BF6 F8                  <1> 	clc				; For buggy BIOSes
  1432 00002BF7 B404                <1> 	mov ah, 4			; Get date data from BIOS in BCD format
  1433 00002BF9 E8BDEA              <1> 	call os_int_1Ah
  1434 00002BFC 7306                <1> 	jnc .fmt1_day
  1435                              <1> 
  1436 00002BFE F8                  <1> 	clc
  1437 00002BFF B404                <1> 	mov ah, 4			; BIOS was updating (~1 in 500 chance), so try again
  1438 00002C01 E8B5EA              <1> 	call os_int_1Ah
  1439                              <1> 
  1440                              <1> .fmt1_day:
  1441 00002C04 88D4                <1> 	mov ah, dl			; Day
  1442 00002C06 E81A00              <1> 	call .add_2digits
  1443                              <1> 
  1444 00002C09 B02F                <1> 	mov al, '/'
  1445 00002C0B AA                  <1> 	stosb				; Day-month separator
  1446                              <1> 
  1447                              <1> .fmt1_month:
  1448 00002C0C 88F4                <1> 	mov ah,	dh			; Month
  1449 00002C0E E81200              <1> 	call .add_2digits
  1450                              <1> 
  1451 00002C11 B02F                <1> 	mov al, '/'
  1452 00002C13 AA                  <1> 	stosb
  1453                              <1> 
  1454                              <1> .fmt1_century:
  1455 00002C14 88EC                <1> 	mov ah,	ch			; Century
  1456 00002C16 E80A00              <1> 	call .add_2digits
  1457                              <1> 
  1458                              <1> .fmt1_year:
  1459 00002C19 88CC                <1> 	mov ah, cl			; Year
  1460 00002C1B E80500              <1> 	call .add_2digits
  1461                              <1> 
  1462 00002C1E B000                <1> 	mov al, 0			; Terminate date string
  1463 00002C20 AA                  <1> 	stosb
  1464                              <1> 
  1465 00002C21 61                  <1> 	popa
  1466 00002C22 C3                  <1> 	ret
  1467                              <1> 
  1468                              <1> .add_2digits:
  1469 00002C23 88E0                <1> 	mov al, ah			; Convert AH to 2 ASCII digits
  1470 00002C25 C0E804              <1> 	shr al, 4
  1471 00002C28 E80800              <1> 	call .add_digit
  1472 00002C2B 88E0                <1> 	mov al, ah
  1473 00002C2D 240F                <1> 	and al, 0Fh
  1474 00002C2F E80100              <1> 	call .add_digit
  1475 00002C32 C3                  <1> 	ret
  1476                              <1> 
  1477                              <1> .add_digit:
  1478 00002C33 0430                <1> 	add al, '0'			; Convert AL to ASCII
  1479 00002C35 AA                  <1> 	stosb				; Put into string buffer
  1480 00002C36 C3                  <1> 	ret
  1481                              <1> 	
  1482                              <1> 	
  1483                              <1> ; ------------------------------------------------------------------
  1484                              <1> ; os_string_tokenize -- Reads tokens separated by specified char from
  1485                              <1> ; a string. Returns pointer to next token, or 0 if none left
  1486                              <1> ; IN: AL = separator char, SI = beginning; OUT: DI = next token or 0 if none
  1487                              <1> 
  1488                              <1> os_string_tokenize:
  1489 00002C37 56                  <1> 	push si
  1490                              <1> 
  1491                              <1> .next_char:
  1492 00002C38 3804                <1> 	cmp byte [si], al
  1493 00002C3A 7408                <1> 	je .return_token
  1494 00002C3C 803C00              <1> 	cmp byte [si], 0
  1495 00002C3F 740B                <1> 	jz .no_more
  1496 00002C41 46                  <1> 	inc si
  1497 00002C42 EBF4                <1> 	jmp .next_char
  1498                              <1> 
  1499                              <1> .return_token:
  1500 00002C44 C60400              <1> 	mov byte [si], 0
  1501 00002C47 46                  <1> 	inc si
  1502 00002C48 89F7                <1> 	mov di, si
  1503 00002C4A 5E                  <1> 	pop si
  1504 00002C4B C3                  <1> 	ret
  1505                              <1> 
  1506                              <1> .no_more:
  1507 00002C4C 31FF                <1> 	xor di, di
  1508 00002C4E 5E                  <1> 	pop si
  1509 00002C4F C3                  <1> 	ret
  1510                              <1> 
  1511                              <1> ; Converts an unsigned 32-bit integer into a string.
  1512                              <1> ; IN: EAX = unsigned int
  1513                              <1> ; OUT: AX = string location
  1514                              <1> 
  1515                              <1> os_32int_to_string:
  1516 00002C50 6660                <1> 	pushad
  1517                              <1> 
  1518 00002C52 31C9                <1> 	xor cx, cx
  1519 00002C54 66BB0A000000        <1> 	mov ebx, 10			; Set BX 10, for division and mod
  1520 00002C5A BF[7F2C]            <1> 	mov di, .t			; Get our pointer ready
  1521                              <1> 
  1522                              <1> .push:
  1523 00002C5D 6631D2              <1> 	xor edx, edx
  1524 00002C60 66F7F3              <1> 	div ebx				; Remainder in DX, quotient in AX
  1525 00002C63 41                  <1> 	inc cx				; Increase pop loop counter
  1526 00002C64 6652                <1> 	push edx			; Push remainder, so as to reverse order when popping
  1527 00002C66 6685C0              <1> 	test eax, eax		; Is quotient zero?
  1528 00002C69 75F2                <1> 	jnz .push			; If not, loop again
  1529                              <1> 
  1530                              <1> .pop:
  1531 00002C6B 665A                <1> 	pop edx				; Pop off values in reverse order, and add 48 to make them digits
  1532 00002C6D 80C230              <1> 	add dl, '0'			; And save them in the string, increasing the pointer each time
  1533 00002C70 8815                <1> 	mov [di], dl
  1534 00002C72 47                  <1> 	inc di
  1535 00002C73 49                  <1> 	dec cx
  1536 00002C74 75F5                <1> 	jnz .pop
  1537                              <1> 
  1538 00002C76 C60500              <1> 	mov byte [di], 0		; Zero-terminate string
  1539                              <1> 
  1540 00002C79 6661                <1> 	popad
  1541 00002C7B B8[7F2C]            <1> 	mov ax, .t			; Return location of string
  1542 00002C7E C3                  <1> 	ret
  1543                              <1> 
  1544                              <1> 
  1545 00002C7F 00<rep Bh>          <1> 	.t times 11 db 0
  1546                              <1> 
  1547                              <1> ; Converts a string into a 32-bit integer.
  1548                              <1> ; IN: SI = string location
  1549                              <1> ; OUT: EAX = unsigned integer
  1550                              <1> 
  1551                              <1> os_string_to_32int:
  1552 00002C8A 6660                <1> 	pushad
  1553 00002C8C 6631C0              <1> 	xor eax, eax				; Temporary 32-bit integer
  1554                              <1> 	
  1555                              <1> .loop:
  1556 00002C8F 6650                <1> 	push eax
  1557 00002C91 AC                  <1> 	lodsb					; Load a byte from SI
  1558 00002C92 88C1                <1> 	mov cl, al
  1559 00002C94 6658                <1> 	pop eax
  1560 00002C96 80F900              <1> 	cmp cl, 0				; Have we reached the end?
  1561 00002C99 0F841400            <1> 	je near .exit			; If we have, exit
  1562 00002C9D 80E930              <1> 	sub cl, '0'				; Convert the value to decimal
  1563 00002CA0 6681E1FF000000      <1> 	and ecx, 255			; Keep the low 8 bits only
  1564 00002CA7 66F726[C02C]        <1> 	mul dword [.divisor]	; Multiply EAX by 10
  1565 00002CAC 6601C8              <1> 	add eax, ecx			; Add the value to the integer
  1566 00002CAF EBDE                <1> 	jmp .loop				; Loop again
  1567                              <1> 	
  1568                              <1> .exit:
  1569 00002CB1 66A3[BC2C]          <1> 	mov [.tmp_dword], eax
  1570 00002CB5 6661                <1> 	popad
  1571 00002CB7 66A1[BC2C]          <1> 	mov eax, [.tmp_dword]
  1572 00002CBB C3                  <1> 	ret
  1573                              <1> 	
  1574 00002CBC 00000000            <1> 	.tmp_dword	dd 0
  1575 00002CC0 0A000000            <1> 	.divisor	dd 10
  1576                              <1> 	
  1577                              <1> ; Prints a 32 bit integer in decimal.
  1578                              <1> ; IN: EAX = unsigned integer
  1579                              <1> ; OUT: nothing
  1580                              <1> 
  1581                              <1> os_print_32int:
  1582 00002CC4 6660                <1> 	pushad
  1583 00002CC6 E887FF              <1> 	call os_32int_to_string
  1584 00002CC9 89C6                <1> 	mov si, ax
  1585 00002CCB E827EB              <1> 	call os_print_string
  1586 00002CCE 6661                <1> 	popad
  1587 00002CD0 C3                  <1> 	ret
  1588                              <1> 	
  1589                              <1> ; ==================================================================
  1590                              <1> 
   818                                  	%INCLUDE "drivers/basic.asm"
   819                              <1> ; ==================================================================
   820                              <1> ; BASIC CODE INTERPRETER (4.5)
   821                              <1> ; ==================================================================
   822                              <1> 
   823                              <1> ; ------------------------------------------------------------------
   824                              <1> ; Token types
   825                              <1> 
   826                              <1> %DEFINE VARIABLE 1
   827                              <1> %DEFINE STRING_VAR 2
   828                              <1> %DEFINE NUMBER 3
   829                              <1> %DEFINE STRING 4
   830                              <1> %DEFINE QUOTE 5
   831                              <1> %DEFINE CHAR 6
   832                              <1> %DEFINE UNKNOWN 7
   833                              <1> %DEFINE LABEL 8
   834                              <1> 
   835                              <1> ; ------------------------------------------------------------------
   836                              <1> ; The BASIC interpreter execution starts here -- a parameter string
   837                              <1> ; is passed in SI and copied into the first string, unless SI = 0
   838                              <1> 
   839                              <1> os_run_basic:
   840 00002CD1 C606820001          <1> 	mov byte [0082h], 1
   841                              <1> 	
   842 00002CD6 8926[E845]          <1> 	mov word [orig_stack], sp		; Save stack pointer -- we might jump to the
   843                              <1> 						; error printing code and quit in the middle
   844                              <1> 						; some nested loops, and we want to preserve
   845                              <1> 						; the stack
   846                              <1> 
   847 00002CDA A3[EE45]            <1> 	mov word [load_point], ax		; AX was passed as starting location of code
   848                              <1> 
   849 00002CDD A3[EA45]            <1> 	mov word [prog], ax			; prog = pointer to current execution point in code
   850                              <1> 
   851 00002CE0 01C3                <1> 	add bx, ax				; We were passed the .BAS byte size in BX
   852 00002CE2 4B                  <1> 	dec bx
   853 00002CE3 4B                  <1> 	dec bx
   854 00002CE4 891E[EC45]          <1> 	mov word [prog_end], bx			; Make note of program end point
   855                              <1> 
   856                              <1> 
   857 00002CE8 E81D02              <1> 	call clear_ram				; Clear variables etc. from previous run
   858                              <1> 						; of a BASIC program
   859                              <1> 
   860 00002CEB 83FE00              <1> 	cmp si, 0				; Passed a parameter string?
   861 00002CEE 7406                <1> 	je mainloop
   862                              <1> 
   863 00002CF0 BF007C              <1> 	mov di, string_vars			; If so, copy it into $1
   864 00002CF3 E850FD              <1> 	call os_string_copy
   865                              <1> 
   866                              <1> 
   867                              <1> 
   868                              <1> mainloop:
   869 00002CF6 E86D17              <1> 	call get_token				; Get a token from the start of the line
   870                              <1> 
   871 00002CF9 83F804              <1> 	cmp ax, STRING				; Is the type a string of characters?
   872 00002CFC 7418                <1> 	je .keyword				; If so, let's see if it's a keyword to process
   873                              <1> 
   874 00002CFE 83F801              <1> 	cmp ax, VARIABLE			; If it's a variable at the start of the line,
   875 00002D01 0F844702            <1> 	je near assign				; this is an assign (eg "X = Y + 5")
   876                              <1> 
   877 00002D05 83F802              <1> 	cmp ax, STRING_VAR			; Same for a string variable (eg $1)
   878 00002D08 0F844002            <1> 	je near assign
   879                              <1> 
   880 00002D0C 83F808              <1> 	cmp ax, LABEL				; Don't need to do anything here - skip
   881 00002D0F 74E5                <1> 	je mainloop
   882                              <1> 
   883 00002D11 B314                <1> 	mov bl, err_syntax			; Otherwise show an error and quit
   884 00002D13 E96918              <1> 	jmp error
   885                              <1> 
   886                              <1> 
   887                              <1> .keyword:
   888 00002D16 BE007B              <1> 	mov si, token				; Start trying to match commands
   889                              <1> 
   890 00002D19 BF[F645]            <1> 	mov di, alert_cmd
   891 00002D1C E886FD              <1> 	call os_string_compare
   892 00002D1F 0F82CD04            <1> 	jc near do_alert
   893                              <1> 
   894 00002D23 BF[FC45]            <1> 	mov di, askfile_cmd
   895 00002D26 E87CFD              <1> 	call os_string_compare
   896 00002D29 0F820005            <1> 	jc near do_askfile
   897                              <1> 
   898 00002D2D BF[0446]            <1> 	mov di, break_cmd
   899 00002D30 E872FD              <1> 	call os_string_compare
   900 00002D33 0F823105            <1> 	jc near do_break
   901                              <1> 
   902 00002D37 BF[0F46]            <1> 	mov di, case_cmd
   903 00002D3A E868FD              <1> 	call os_string_compare
   904 00002D3D 0F825305            <1> 	jc near do_case
   905                              <1> 
   906 00002D41 BF[0A46]            <1> 	mov di, call_cmd
   907 00002D44 E85EFD              <1> 	call os_string_compare
   908 00002D47 0F822205            <1> 	jc near do_call
   909                              <1> 
   910 00002D4B BF[1446]            <1> 	mov di, cls_cmd
   911 00002D4E E854FD              <1> 	call os_string_compare
   912 00002D51 0F829105            <1> 	jc near do_cls
   913                              <1> 
   914 00002D55 BF[1846]            <1> 	mov di, cursor_cmd
   915 00002D58 E84AFD              <1> 	call os_string_compare
   916 00002D5B 0F829B05            <1> 	jc near do_cursor
   917                              <1> 
   918 00002D5F BF[1F46]            <1> 	mov di, curschar_cmd
   919 00002D62 E840FD              <1> 	call os_string_compare
   920 00002D65 0F82C205            <1> 	jc near do_curschar
   921                              <1> 
   922 00002D69 BF[2846]            <1> 	mov di, curscol_cmd
   923 00002D6C E836FD              <1> 	call os_string_compare
   924 00002D6F 0F82E005            <1> 	jc near do_curscol
   925                              <1> 
   926 00002D73 BF[3046]            <1> 	mov di, curspos_cmd
   927 00002D76 E82CFD              <1> 	call os_string_compare
   928 00002D79 0F82FE05            <1> 	jc near do_curspos
   929                              <1> 	
   930 00002D7D BF[3846]            <1> 	mov di, delete_cmd
   931 00002D80 E822FD              <1> 	call os_string_compare
   932 00002D83 0F822C06            <1> 	jc near do_delete
   933                              <1> 	
   934 00002D87 BF[3F46]            <1> 	mov di, do_cmd
   935 00002D8A E818FD              <1> 	call os_string_compare
   936 00002D8D 0F827906            <1> 	jc near do_do
   937                              <1> 
   938 00002D91 BF[4746]            <1> 	mov di, end_cmd
   939 00002D94 E80EFD              <1> 	call os_string_compare
   940 00002D97 0F82B606            <1> 	jc near do_end
   941                              <1> 
   942 00002D9B BF[4246]            <1> 	mov di, else_cmd
   943 00002D9E E804FD              <1> 	call os_string_compare
   944 00002DA1 0F828D06            <1> 	jc near do_else
   945                              <1> 
   946 00002DA5 BF[4B46]            <1> 	mov di, files_cmd
   947 00002DA8 E8FAFC              <1> 	call os_string_compare
   948 00002DAB 0F82B706            <1> 	jc near do_files
   949                              <1> 
   950 00002DAF BF[5146]            <1> 	mov di, for_cmd
   951 00002DB2 E8F0FC              <1> 	call os_string_compare
   952 00002DB5 0F821107            <1> 	jc near do_for
   953                              <1> 
   954 00002DB9 BF[6046]            <1> 	mov di, getkey_cmd
   955 00002DBC E8E6FC              <1> 	call os_string_compare
   956 00002DBF 0F82B507            <1> 	jc near do_getkey
   957                              <1> 
   958 00002DC3 BF[5546]            <1> 	mov di, gosub_cmd
   959 00002DC6 E8DCFC              <1> 	call os_string_compare
   960 00002DC9 0F82F307            <1> 	jc near do_gosub
   961                              <1> 
   962 00002DCD BF[5B46]            <1> 	mov di, goto_cmd
   963 00002DD0 E8D2FC              <1> 	call os_string_compare
   964 00002DD3 0F828608            <1> 	jc near do_goto
   965                              <1> 
   966 00002DD7 BF[6746]            <1> 	mov di, if_cmd
   967 00002DDA E8C8FC              <1> 	call os_string_compare
   968 00002DDD 0F82FC08            <1> 	jc near do_if
   969                              <1> 
   970 00002DE1 BF[6A46]            <1> 	mov di, include_cmd
   971 00002DE4 E8BEFC              <1> 	call os_string_compare
   972 00002DE7 0F82490A            <1> 	jc near do_include
   973                              <1> 
   974 00002DEB BF[7246]            <1> 	mov di, ink_cmd
   975 00002DEE E8B4FC              <1> 	call os_string_compare
   976 00002DF1 0F826E0A            <1> 	jc near do_ink
   977                              <1> 
   978 00002DF5 BF[7646]            <1> 	mov di, input_cmd
   979 00002DF8 E8AAFC              <1> 	call os_string_compare
   980 00002DFB 0F82870A            <1> 	jc near do_input
   981                              <1> 	
   982 00002DFF BF[7C46]            <1> 	mov di, len_cmd
   983 00002E02 E8A0FC              <1> 	call os_string_compare
   984 00002E05 0F82E90A            <1> 	jc near do_len
   985                              <1> 
   986 00002E09 BF[8046]            <1> 	mov di, listbox_cmd
   987 00002E0C E896FC              <1> 	call os_string_compare
   988 00002E0F 0F82270B            <1> 	jc near do_listbox
   989                              <1> 
   990 00002E13 BF[8846]            <1> 	mov di, load_cmd
   991 00002E16 E88CFC              <1> 	call os_string_compare
   992 00002E19 0F82B60B            <1> 	jc near do_load
   993                              <1> 
   994 00002E1D BF[8D46]            <1> 	mov di, loop_cmd
   995 00002E20 E882FC              <1> 	call os_string_compare
   996 00002E23 0F821E0C            <1> 	jc near do_loop
   997                              <1> 
   998 00002E27 BF[9246]            <1> 	mov di, move_cmd
   999 00002E2A E878FC              <1> 	call os_string_compare
  1000 00002E2D 0F82080D            <1> 	jc near do_move
  1001                              <1> 
  1002 00002E31 BF[9746]            <1> 	mov di, next_cmd
  1003 00002E34 E86EFC              <1> 	call os_string_compare
  1004 00002E37 0F82410D            <1> 	jc near do_next
  1005                              <1> 
  1006 00002E3B BF[9C46]            <1> 	mov di, number_cmd
  1007 00002E3E E864FC              <1> 	call os_string_compare
  1008 00002E41 0F82840D            <1> 	jc near do_number
  1009                              <1> 
  1010 00002E45 BF[A346]            <1> 	mov di, page_cmd
  1011 00002E48 E85AFC              <1> 	call os_string_compare
  1012 00002E4B 0F82E50D            <1> 	jc near do_page
  1013                              <1> 
  1014 00002E4F BF[A846]            <1> 	mov di, pause_cmd
  1015 00002E52 E850FC              <1> 	call os_string_compare
  1016 00002E55 0F820A0E            <1> 	jc near do_pause
  1017                              <1> 
  1018 00002E59 BF[AE46]            <1> 	mov di, peek_cmd
  1019 00002E5C E846FC              <1> 	call os_string_compare
  1020 00002E5F 0F821E0E            <1> 	jc near do_peek
  1021                              <1> 
  1022 00002E63 BF[B346]            <1> 	mov di, peekint_cmd
  1023 00002E66 E83CFC              <1> 	call os_string_compare
  1024 00002E69 0F82560E            <1> 	jc near do_peekint
  1025                              <1> 	
  1026 00002E6D BF[BB46]            <1> 	mov di, poke_cmd
  1027 00002E70 E832FC              <1> 	call os_string_compare
  1028 00002E73 0F82860E            <1> 	jc near do_poke
  1029                              <1> 	
  1030 00002E77 BF[C046]            <1> 	mov di, pokeint_cmd
  1031 00002E7A E828FC              <1> 	call os_string_compare
  1032 00002E7D 0F82D40E            <1> 	jc near do_pokeint
  1033                              <1> 
  1034 00002E81 BF[C846]            <1> 	mov di, port_cmd
  1035 00002E84 E81EFC              <1> 	call os_string_compare
  1036 00002E87 0F820F0F            <1> 	jc near do_port
  1037                              <1> 
  1038 00002E8B BF[CD46]            <1> 	mov di, print_cmd
  1039 00002E8E E814FC              <1> 	call os_string_compare
  1040 00002E91 0F82870F            <1> 	jc near do_print
  1041                              <1> 
  1042 00002E95 BF[D346]            <1> 	mov di, rand_cmd
  1043 00002E98 E80AFC              <1> 	call os_string_compare
  1044 00002E9B 0F82AA10            <1> 	jc near do_rand
  1045                              <1> 
  1046 00002E9F BF[D846]            <1> 	mov di, read_cmd
  1047 00002EA2 E800FC              <1> 	call os_string_compare
  1048 00002EA5 0F82F210            <1> 	jc near do_read
  1049                              <1> 
  1050 00002EA9 BF[DD46]            <1> 	mov di, rem_cmd
  1051 00002EAC E8F6FB              <1> 	call os_string_compare
  1052 00002EAF 0F82BE11            <1> 	jc near do_rem
  1053                              <1> 
  1054 00002EB3 BF[E146]            <1> 	mov di, rename_cmd
  1055 00002EB6 E8ECFB              <1> 	call os_string_compare
  1056 00002EB9 0F82C511            <1> 	jc near do_rename
  1057                              <1> 
  1058 00002EBD BF[E846]            <1> 	mov di, return_cmd
  1059 00002EC0 E8E2FB              <1> 	call os_string_compare
  1060 00002EC3 0F827012            <1> 	jc near do_return
  1061                              <1> 
  1062 00002EC7 BF[EF46]            <1> 	mov di, save_cmd
  1063 00002ECA E8D8FB              <1> 	call os_string_compare
  1064 00002ECD 0F828712            <1> 	jc near do_save
  1065                              <1> 
  1066 00002ED1 BF[F446]            <1> 	mov di, serial_cmd
  1067 00002ED4 E8CEFB              <1> 	call os_string_compare
  1068 00002ED7 0F823C13            <1> 	jc near do_serial
  1069                              <1> 
  1070 00002EDB BF[FB46]            <1> 	mov di, size_cmd
  1071 00002EDE E8C4FB              <1> 	call os_string_compare
  1072 00002EE1 0F82D613            <1> 	jc near do_size
  1073                              <1> 
  1074 00002EE5 BF[0047]            <1> 	mov di, sound_cmd
  1075 00002EE8 E8BAFB              <1> 	call os_string_compare
  1076 00002EEB 0F822114            <1> 	jc near do_sound
  1077                              <1> 	
  1078 00002EEF BF[0647]            <1> 	mov di, string_cmd
  1079 00002EF2 E8B0FB              <1> 	call os_string_compare
  1080 00002EF5 0F825314            <1> 	jc near do_string
  1081                              <1> 
  1082 00002EF9 BF[0D47]            <1> 	mov di, waitkey_cmd
  1083 00002EFC E8A6FB              <1> 	call os_string_compare
  1084 00002EFF 0F82FE14            <1> 	jc near do_waitkey
  1085                              <1> 
  1086 00002F03 B301                <1> 	mov bl, err_cmd_unknown			; Command not found?
  1087 00002F05 E97716              <1> 	jmp error
  1088                              <1> 
  1089                              <1> 
  1090                              <1> ; ------------------------------------------------------------------
  1091                              <1> ; CLEAR RAM
  1092                              <1> 
  1093                              <1> clear_ram:
  1094 00002F08 60                  <1> 	pusha
  1095 00002F09 B000                <1> 	mov al, 0
  1096                              <1> 
  1097 00002F0B BF4C7A              <1> 	mov di, variables
  1098 00002F0E B93400              <1> 	mov cx, 52
  1099 00002F11 F3AA                <1> 	rep stosb
  1100                              <1> 
  1101 00002F13 BF187A              <1> 	mov di, for_variables
  1102 00002F16 B93400              <1> 	mov cx, 52
  1103 00002F19 F3AA                <1> 	rep stosb
  1104                              <1> 
  1105 00002F1B BFE479              <1> 	mov di, for_code_points
  1106 00002F1E B93400              <1> 	mov cx, 52
  1107 00002F21 F3AA                <1> 	rep stosb
  1108                              <1> 	
  1109 00002F23 BFD079              <1> 	mov di, do_loop_store
  1110 00002F26 B90A00              <1> 	mov cx, 10
  1111 00002F29 F3AA                <1> 	rep stosb
  1112                              <1> 
  1113 00002F2B C606[6147]00        <1> 	mov byte [gosub_depth], 0
  1114 00002F30 C606[F145]00        <1> 	mov byte [loop_in], 0
  1115                              <1> 
  1116 00002F35 BFBC79              <1> 	mov di, gosub_points
  1117 00002F38 B91400              <1> 	mov cx, 20
  1118 00002F3B F3AA                <1> 	rep stosb
  1119                              <1> 
  1120 00002F3D BF007C              <1> 	mov di, string_vars
  1121 00002F40 B90004              <1> 	mov cx, 1024
  1122 00002F43 F3AA                <1> 	rep stosb
  1123                              <1> 
  1124 00002F45 C606[F345]07        <1> 	mov byte [ink_colour], 7		; White ink
  1125                              <1> 
  1126 00002F4A 61                  <1> 	popa
  1127 00002F4B C3                  <1> 	ret
  1128                              <1> 
  1129                              <1> 
  1130                              <1> ; ------------------------------------------------------------------
  1131                              <1> ; ASSIGNMENT
  1132                              <1> 
  1133                              <1> assign:
  1134 00002F4C 83F801              <1> 	cmp ax, VARIABLE			; Are we starting with a number var?
  1135 00002F4F 0F84A700            <1> 	je .do_num_var
  1136                              <1> 
  1137 00002F53 BF007C              <1> 	mov di, string_vars			; Otherwise it's a string var
  1138 00002F56 B88000              <1> 	mov ax, 128
  1139 00002F59 F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
  1140 00002F5B 01C7                <1> 	add di, ax
  1141                              <1> 
  1142 00002F5D 57                  <1> 	push di
  1143                              <1> 
  1144 00002F5E E80515              <1> 	call get_token
  1145 00002F61 A0007B              <1> 	mov byte al, [token]
  1146 00002F64 3C3D                <1> 	cmp al, '='
  1147 00002F66 0F857D02            <1> 	jne near .error
  1148                              <1> 
  1149 00002F6A E8F914              <1> 	call get_token				; See if second is quote
  1150 00002F6D 83F805              <1> 	cmp ax, QUOTE
  1151 00002F70 7417                <1> 	je .second_is_quote
  1152                              <1> 
  1153 00002F72 83F802              <1> 	cmp ax, STRING_VAR
  1154 00002F75 0F856E02            <1> 	jne near .error
  1155                              <1> 
  1156 00002F79 BE007C              <1> 	mov si, string_vars			; Otherwise it's a string var
  1157 00002F7C B88000              <1> 	mov ax, 128
  1158 00002F7F F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
  1159 00002F81 01C6                <1> 	add si, ax
  1160                              <1> 
  1161 00002F83 5F                  <1> 	pop di
  1162 00002F84 E8BFFA              <1> 	call os_string_copy
  1163                              <1> 
  1164 00002F87 EB07                <1> 	jmp .string_check_for_more
  1165                              <1> 
  1166                              <1> 
  1167                              <1> .second_is_quote:
  1168 00002F89 BE007B              <1> 	mov si, token
  1169 00002F8C 5F                  <1> 	pop di
  1170 00002F8D E8B6FA              <1> 	call os_string_copy
  1171                              <1> 
  1172                              <1> 
  1173                              <1> .string_check_for_more:
  1174 00002F90 57                  <1> 	push di
  1175 00002F91 A1[EA45]            <1> 	mov word ax, [prog]			; Save code location in case there's no delimiter
  1176 00002F94 A3[ED31]            <1> 	mov word [.tmp_loc], ax
  1177                              <1> 
  1178 00002F97 E8CC14              <1> 	call get_token				; Any more to deal with in this assignment?
  1179 00002F9A A0007B              <1> 	mov byte al, [token]
  1180 00002F9D 3C2B                <1> 	cmp al, '+'
  1181 00002F9F 740A                <1> 	je .string_theres_more
  1182                              <1> 
  1183 00002FA1 A1[ED31]            <1> 	mov word ax, [.tmp_loc]			; Not a delimiter, so step back before the token
  1184 00002FA4 A3[EA45]            <1> 	mov word [prog], ax			; that we just grabbed
  1185                              <1> 
  1186 00002FA7 5F                  <1> 	pop di
  1187 00002FA8 E94BFD              <1> 	jmp mainloop				; And go back to the code interpreter!
  1188                              <1> 
  1189                              <1> 
  1190                              <1> .string_theres_more:
  1191 00002FAB E8B814              <1> 	call get_token
  1192 00002FAE 83F802              <1> 	cmp ax, STRING_VAR
  1193 00002FB1 740D                <1> 	je .another_string_var
  1194 00002FB3 83F805              <1> 	cmp ax, QUOTE
  1195 00002FB6 741E                <1> 	je .another_quote
  1196 00002FB8 83F801              <1> 	cmp ax, VARIABLE
  1197 00002FBB 7426                <1> 	je .add_number_var
  1198 00002FBD E92702              <1> 	jmp .error
  1199                              <1> 
  1200                              <1> 
  1201                              <1> .another_string_var:
  1202 00002FC0 5F                  <1> 	pop di
  1203                              <1> 
  1204 00002FC1 BE007C              <1> 	mov si, string_vars
  1205 00002FC4 B88000              <1> 	mov ax, 128
  1206 00002FC7 F7E3                <1> 	mul bx					; (BX = string number, passed back from get_token)
  1207 00002FC9 01C6                <1> 	add si, ax
  1208                              <1> 
  1209 00002FCB 89F8                <1> 	mov ax, di
  1210 00002FCD 89F9                <1> 	mov cx, di
  1211 00002FCF 89F3                <1> 	mov bx, si
  1212 00002FD1 E87BFA              <1> 	call os_string_join
  1213                              <1> 
  1214 00002FD4 EBBA                <1> 	jmp .string_check_for_more
  1215                              <1> 
  1216                              <1> 
  1217                              <1> 
  1218                              <1> .another_quote:
  1219 00002FD6 5F                  <1> 	pop di
  1220                              <1> 
  1221 00002FD7 89F8                <1> 	mov ax, di
  1222 00002FD9 89F9                <1> 	mov cx, di
  1223 00002FDB BB007B              <1> 	mov bx, token
  1224 00002FDE E86EFA              <1> 	call os_string_join
  1225                              <1> 
  1226 00002FE1 EBAD                <1> 	jmp .string_check_for_more
  1227                              <1> 
  1228                              <1> 
  1229                              <1> .add_number_var:
  1230 00002FE3 31C0                <1> 	xor ax, ax
  1231 00002FE5 A0007B              <1> 	mov byte al, [token]
  1232 00002FE8 E85F14              <1> 	call get_var
  1233 00002FEB E856FB              <1> 	call os_int_to_string
  1234                              <1> 
  1235 00002FEE 89C3                <1> 	mov bx, ax
  1236 00002FF0 5F                  <1> 	pop di
  1237 00002FF1 89F8                <1> 	mov ax, di
  1238 00002FF3 89F9                <1> 	mov cx, di
  1239 00002FF5 E857FA              <1> 	call os_string_join
  1240                              <1> 
  1241 00002FF8 EB96                <1> 	jmp .string_check_for_more
  1242                              <1> 	
  1243                              <1> 
  1244                              <1> 
  1245                              <1> 
  1246                              <1> .do_num_var:
  1247 00002FFA 31C0                <1> 	xor ax, ax
  1248 00002FFC A0007B              <1> 	mov byte al, [token]
  1249 00002FFF A2[EC31]            <1> 	mov byte [.tmp], al
  1250                              <1> 
  1251 00003002 E86114              <1> 	call get_token
  1252 00003005 A0007B              <1> 	mov byte al, [token]
  1253 00003008 3C3D                <1> 	cmp al, '='
  1254 0000300A 0F85D901            <1> 	jne near .error
  1255                              <1> 
  1256 0000300E E85514              <1> 	call get_token
  1257 00003011 83F803              <1> 	cmp ax, NUMBER
  1258 00003014 744D                <1> 	je .second_is_num
  1259                              <1> 
  1260 00003016 83F801              <1> 	cmp ax, VARIABLE
  1261 00003019 7436                <1> 	je .second_is_variable
  1262                              <1> 
  1263 0000301B 83F804              <1> 	cmp ax, STRING
  1264 0000301E 0F842F01            <1> 	je near .second_is_string
  1265                              <1> 
  1266 00003022 83F807              <1> 	cmp ax, UNKNOWN
  1267 00003025 0F85BE01            <1> 	jne near .error
  1268                              <1> 
  1269 00003029 A0007B              <1> 	mov byte al, [token]			; Address of string var?
  1270 0000302C 3C26                <1> 	cmp al, '&'
  1271 0000302E 0F85B501            <1> 	jne near .error
  1272                              <1> 
  1273 00003032 E83114              <1> 	call get_token				; Let's see if there's a string var
  1274 00003035 83F802              <1> 	cmp ax, STRING_VAR
  1275 00003038 0F85AB01            <1> 	jne near .error
  1276                              <1> 
  1277 0000303C BF007C              <1> 	mov di, string_vars
  1278 0000303F B88000              <1> 	mov ax, 128
  1279 00003042 F7E3                <1> 	mul bx
  1280 00003044 01C7                <1> 	add di, ax
  1281                              <1> 
  1282 00003046 89FB                <1> 	mov bx, di
  1283                              <1> 
  1284 00003048 A0[EC31]            <1> 	mov byte al, [.tmp]
  1285 0000304B E80914              <1> 	call set_var
  1286                              <1> 
  1287 0000304E E9A5FC              <1> 	jmp mainloop
  1288                              <1> 
  1289                              <1> 
  1290                              <1> .second_is_variable:
  1291 00003051 31C0                <1> 	xor ax, ax
  1292 00003053 A0007B              <1> 	mov byte al, [token]
  1293                              <1> 
  1294 00003056 E8F113              <1> 	call get_var
  1295 00003059 89C3                <1> 	mov bx, ax
  1296 0000305B A0[EC31]            <1> 	mov byte al, [.tmp]
  1297 0000305E E8F613              <1> 	call set_var
  1298                              <1> 
  1299 00003061 EB10                <1> 	jmp .check_for_more
  1300                              <1> 
  1301                              <1> 
  1302                              <1> .second_is_num:
  1303 00003063 BE007B              <1> 	mov si, token
  1304 00003066 E890FA              <1> 	call os_string_to_int
  1305                              <1> 
  1306 00003069 89C3                <1> 	mov bx, ax				; Number to insert in variable table
  1307                              <1> 
  1308 0000306B 31C0                <1> 	xor ax, ax
  1309 0000306D A0[EC31]            <1> 	mov byte al, [.tmp]
  1310                              <1> 
  1311 00003070 E8E413              <1> 	call set_var
  1312                              <1> 
  1313                              <1> 
  1314                              <1> 	; The assignment could be simply "X = 5" etc. Or it could be
  1315                              <1> 	; "X = Y + 5" -- ie more complicated. So here we check to see if
  1316                              <1> 	; there's a delimiter...
  1317                              <1> 
  1318                              <1> .check_for_more:
  1319 00003073 A1[EA45]            <1> 	mov word ax, [prog]			; Save code location in case there's no delimiter
  1320 00003076 A3[ED31]            <1> 	mov word [.tmp_loc], ax
  1321                              <1> 
  1322 00003079 E8EA13              <1> 	call get_token				; Any more to deal with in this assignment?
  1323 0000307C A0007B              <1> 	mov byte al, [token]
  1324 0000307F 3C2B                <1> 	cmp al, '+'
  1325 00003081 7419                <1> 	je .theres_more
  1326 00003083 3C2D                <1> 	cmp al, '-'
  1327 00003085 7415                <1> 	je .theres_more
  1328 00003087 3C2A                <1> 	cmp al, '*'
  1329 00003089 7411                <1> 	je .theres_more
  1330 0000308B 3C2F                <1> 	cmp al, '/'
  1331 0000308D 740D                <1> 	je .theres_more
  1332 0000308F 3C25                <1> 	cmp al, '%'
  1333 00003091 7409                <1> 	je .theres_more
  1334                              <1> 
  1335 00003093 A1[ED31]            <1> 	mov word ax, [.tmp_loc]			; Not a delimiter, so step back before the token
  1336 00003096 A3[EA45]            <1> 	mov word [prog], ax			; that we just grabbed
  1337                              <1> 
  1338 00003099 E95AFC              <1> 	jmp mainloop				; And go back to the code interpreter!
  1339                              <1> 
  1340                              <1> 
  1341                              <1> .theres_more:
  1342 0000309C A2[EF31]            <1> 	mov byte [.delim], al
  1343                              <1> 
  1344 0000309F E8C413              <1> 	call get_token
  1345 000030A2 83F801              <1> 	cmp ax, VARIABLE
  1346 000030A5 7459                <1> 	je .handle_variable
  1347                              <1> 
  1348 000030A7 BE007B              <1> 	mov si, token
  1349 000030AA E84CFA              <1> 	call os_string_to_int
  1350 000030AD 89C3                <1> 	mov bx, ax
  1351                              <1> 
  1352 000030AF 31C0                <1> 	xor ax, ax
  1353 000030B1 A0[EC31]            <1> 	mov byte al, [.tmp]
  1354                              <1> 
  1355 000030B4 E89313              <1> 	call get_var				; This also points SI at right place in variable table
  1356                              <1> 
  1357 000030B7 803E[EF31]2B        <1> 	cmp byte [.delim], '+'
  1358 000030BC 7504                <1> 	jne .not_plus
  1359                              <1> 
  1360 000030BE 01D8                <1> 	add ax, bx
  1361 000030C0 EB2E                <1> 	jmp .finish
  1362                              <1> 
  1363                              <1> .not_plus:
  1364 000030C2 803E[EF31]2D        <1> 	cmp byte [.delim], '-'
  1365 000030C7 7504                <1> 	jne .not_minus
  1366                              <1> 
  1367 000030C9 29D8                <1> 	sub ax, bx
  1368 000030CB EB23                <1> 	jmp .finish
  1369                              <1> 
  1370                              <1> .not_minus:
  1371 000030CD 803E[EF31]2A        <1> 	cmp byte [.delim], '*'
  1372 000030D2 7504                <1> 	jne .not_times
  1373                              <1> 
  1374 000030D4 F7E3                <1> 	mul bx
  1375 000030D6 EB18                <1> 	jmp .finish
  1376                              <1> 
  1377                              <1> .not_times:
  1378 000030D8 803E[EF31]2F        <1> 	cmp byte [.delim], '/'
  1379 000030DD 750B                <1> 	jne .not_divide
  1380                              <1> 
  1381 000030DF 83FB00              <1> 	cmp bx, 0
  1382 000030E2 7417                <1> 	je .divide_zero
  1383                              <1> 	
  1384 000030E4 31D2                <1> 	xor dx, dx
  1385 000030E6 F7F3                <1> 	div bx
  1386 000030E8 EB06                <1> 	jmp .finish
  1387                              <1> 
  1388                              <1> .not_divide:
  1389 000030EA 31D2                <1> 	xor dx, dx
  1390 000030EC F7F3                <1> 	div bx
  1391 000030EE 89D0                <1> 	mov ax, dx				; Get remainder
  1392                              <1> 
  1393                              <1> .finish:
  1394 000030F0 89C3                <1> 	mov bx, ax
  1395 000030F2 A0[EC31]            <1> 	mov byte al, [.tmp]
  1396 000030F5 E85F13              <1> 	call set_var
  1397                              <1> 
  1398 000030F8 E978FF              <1> 	jmp .check_for_more
  1399                              <1> 
  1400                              <1> .divide_zero:
  1401 000030FB B302                <1> 	mov bl, err_divide_by_zero
  1402 000030FD E97F14              <1> 	jmp error
  1403                              <1> 	
  1404                              <1> .handle_variable:
  1405 00003100 31C0                <1> 	xor ax, ax
  1406 00003102 A0007B              <1> 	mov byte al, [token]
  1407                              <1> 
  1408 00003105 E84213              <1> 	call get_var
  1409                              <1> 
  1410 00003108 89C3                <1> 	mov bx, ax
  1411                              <1> 
  1412 0000310A 31C0                <1> 	xor ax, ax
  1413 0000310C A0[EC31]            <1> 	mov byte al, [.tmp]
  1414                              <1> 
  1415 0000310F E83813              <1> 	call get_var
  1416                              <1> 
  1417 00003112 803E[EF31]2B        <1> 	cmp byte [.delim], '+'
  1418 00003117 7504                <1> 	jne .vnot_plus
  1419                              <1> 
  1420 00003119 01D8                <1> 	add ax, bx
  1421 0000311B EB29                <1> 	jmp .vfinish
  1422                              <1> 
  1423                              <1> .vnot_plus:
  1424 0000311D 803E[EF31]2D        <1> 	cmp byte [.delim], '-'
  1425 00003122 7504                <1> 	jne .vnot_minus
  1426                              <1> 
  1427 00003124 29D8                <1> 	sub ax, bx
  1428 00003126 EB1E                <1> 	jmp .vfinish
  1429                              <1> 
  1430                              <1> .vnot_minus:
  1431 00003128 803E[EF31]2A        <1> 	cmp byte [.delim], '*'
  1432 0000312D 7504                <1> 	jne .vnot_times
  1433                              <1> 
  1434 0000312F F7E3                <1> 	mul bx
  1435 00003131 EB13                <1> 	jmp .vfinish
  1436                              <1> 
  1437                              <1> .vnot_times:
  1438 00003133 803E[EF31]2F        <1> 	cmp byte [.delim], '/'
  1439 00003138 7506                <1> 	jne .vnot_divide
  1440                              <1> 
  1441 0000313A 31D2                <1> 	xor dx, dx
  1442 0000313C F7F3                <1> 	div bx
  1443 0000313E EBB0                <1> 	jmp .finish
  1444                              <1> 
  1445                              <1> .vnot_divide:
  1446 00003140 31D2                <1> 	xor dx, dx
  1447 00003142 F7F3                <1> 	div bx
  1448 00003144 89D0                <1> 	mov ax, dx				; Get remainder
  1449                              <1> 
  1450                              <1> .vfinish:
  1451 00003146 89C3                <1> 	mov bx, ax
  1452 00003148 A0[EC31]            <1> 	mov byte al, [.tmp]
  1453 0000314B E80913              <1> 	call set_var
  1454                              <1> 
  1455 0000314E E922FF              <1> 	jmp .check_for_more
  1456                              <1> 
  1457                              <1> 
  1458                              <1> .second_is_string:				; These are "X = word" functions
  1459 00003151 BF007B              <1> 	mov di, token
  1460                              <1> 	
  1461 00003154 BE[3247]            <1> 	mov si, ink_keyword
  1462 00003157 E84BF9              <1> 	call os_string_compare
  1463 0000315A 742A                <1> 	je .is_ink
  1464                              <1> 	
  1465 0000315C BE[3647]            <1> 	mov si, progstart_keyword
  1466 0000315F E843F9              <1> 	call os_string_compare
  1467 00003162 7433                <1> 	je .is_progstart
  1468                              <1> 
  1469 00003164 BE[4047]            <1> 	mov si, ramstart_keyword
  1470 00003167 E83BF9              <1> 	call os_string_compare
  1471 0000316A 743A                <1> 	je .is_ramstart
  1472                              <1> 
  1473 0000316C BE[4947]            <1> 	mov si, timer_keyword
  1474 0000316F E833F9              <1> 	call os_string_compare
  1475 00003172 7444                <1> 	je .is_timer
  1476                              <1> 	
  1477 00003174 BE[4F47]            <1> 	mov si, variables_keyword
  1478 00003177 E82BF9              <1> 	call os_string_compare
  1479 0000317A 744E                <1> 	je .is_variables
  1480                              <1> 	
  1481 0000317C BE[5947]            <1> 	mov si, version_keyword
  1482 0000317F E823F9              <1> 	call os_string_compare
  1483 00003182 7454                <1> 	je .is_version
  1484                              <1> 
  1485 00003184 EB61                <1> 	jmp .error
  1486                              <1> 
  1487                              <1> 
  1488                              <1> .is_ink:
  1489 00003186 0FB606[EC31]        <1> 	movzx ax, byte [.tmp]
  1490                              <1> 	
  1491 0000318B 31C0                <1> 	xor ax, ax
  1492 0000318D 8A1E[F345]          <1> 	mov byte bl, [ink_colour]
  1493 00003191 E8C312              <1> 	call set_var
  1494                              <1> 	
  1495 00003194 E95FFB              <1> 	jmp mainloop
  1496                              <1> 
  1497                              <1> 
  1498                              <1> .is_progstart:
  1499 00003197 0FB606[EC31]        <1> 	movzx ax, byte [.tmp]
  1500                              <1> 
  1501 0000319C 8B1E[EE45]          <1> 	mov word bx, [load_point]
  1502 000031A0 E8B412              <1> 	call set_var
  1503                              <1> 
  1504 000031A3 E950FB              <1> 	jmp mainloop
  1505                              <1> 
  1506                              <1> 
  1507                              <1> .is_ramstart:
  1508 000031A6 31C0                <1> 	xor ax, ax
  1509 000031A8 A0[EC31]            <1> 	mov byte al, [.tmp]
  1510                              <1> 
  1511 000031AB 8B1E[EC45]          <1> 	mov word bx, [prog_end]
  1512 000031AF 43                  <1> 	inc bx
  1513 000031B0 43                  <1> 	inc bx
  1514 000031B1 43                  <1> 	inc bx
  1515 000031B2 E8A212              <1> 	call set_var
  1516                              <1> 
  1517 000031B5 E93EFB              <1> 	jmp mainloop
  1518                              <1> 
  1519                              <1> 
  1520                              <1> .is_timer:
  1521 000031B8 B400                <1> 	mov ah, 0
  1522 000031BA E8FCE4              <1> 	call os_int_1Ah
  1523 000031BD 89D3                <1> 	mov bx, dx
  1524                              <1> 
  1525 000031BF 31C0                <1> 	xor ax, ax
  1526 000031C1 A0[EC31]            <1> 	mov byte al, [.tmp]
  1527 000031C4 E89012              <1> 	call set_var
  1528                              <1> 
  1529 000031C7 E92CFB              <1> 	jmp mainloop
  1530                              <1> 
  1531                              <1> 
  1532                              <1> .is_variables:
  1533 000031CA BB[F145]            <1> 	mov bx, vars_loc
  1534 000031CD 31C0                <1> 	xor ax, ax
  1535 000031CF A0[EC31]            <1> 	mov byte al, [.tmp]
  1536 000031D2 E88212              <1> 	call set_var
  1537                              <1> 
  1538 000031D5 E91EFB              <1> 	jmp mainloop
  1539                              <1> 
  1540                              <1> 
  1541                              <1> .is_version:
  1542 000031D8 B0FF                <1> 	mov al, 255
  1543                              <1> 	
  1544 000031DA B700                <1> 	mov bh, 0
  1545 000031DC 88C3                <1> 	mov bl, al
  1546 000031DE A0[EC31]            <1> 	mov al, [.tmp]
  1547 000031E1 E87312              <1> 	call set_var
  1548                              <1> 	
  1549 000031E4 E90FFB              <1> 	jmp mainloop 
  1550                              <1> 
  1551                              <1> 
  1552                              <1> .error:
  1553 000031E7 B314                <1> 	mov bl, err_syntax
  1554 000031E9 E99313              <1> 	jmp error
  1555                              <1> 
  1556                              <1> 
  1557 000031EC 00                  <1> 	.tmp		db 0
  1558 000031ED 0000                <1> 	.tmp_loc	dw 0
  1559 000031EF 00                  <1> 	.delim		db 0
  1560                              <1> 
  1561                              <1> 
  1562                              <1> ; ==================================================================
  1563                              <1> ; SPECIFIC COMMAND CODE STARTS HERE
  1564                              <1> 
  1565                              <1> ; ------------------------------------------------------------------
  1566                              <1> ; ALERT
  1567                              <1> 
  1568                              <1> do_alert:
  1569 000031F0 8A3E[F445]          <1> 	mov bh, [work_page]			; Store the cursor position
  1570 000031F4 B403                <1> 	mov ah, 03h
  1571 000031F6 CD10                <1> 	int 10h
  1572                              <1> 
  1573 000031F8 E86B12              <1> 	call get_token
  1574                              <1> 
  1575 000031FB 83F805              <1> 	cmp ax, QUOTE
  1576 000031FE 7416                <1> 	je .is_quote
  1577                              <1> 	
  1578 00003200 83F802              <1> 	cmp ax, STRING_VAR
  1579 00003203 7405                <1> 	je .is_string
  1580                              <1> 
  1581 00003205 B314                <1> 	mov bl, err_syntax
  1582 00003207 E97513              <1> 	jmp error
  1583                              <1> 
  1584                              <1> .is_string:
  1585 0000320A BE007C              <1> 	mov si, string_vars
  1586 0000320D B88000              <1> 	mov ax, 128
  1587 00003210 F7E3                <1> 	mul bx
  1588 00003212 01F0                <1> 	add ax, si
  1589 00003214 EB03                <1> 	jmp .display_message
  1590                              <1> 	
  1591                              <1> .is_quote:
  1592 00003216 B8007B              <1> 	mov ax, token				; First string for alert box
  1593                              <1> 	
  1594                              <1> .display_message:
  1595 00003219 31DB                <1> 	xor bx, bx				; Others are blank
  1596 0000321B 31C9                <1> 	xor cx, cx
  1597 0000321D 31D2                <1> 	xor dx, dx				; One-choice box
  1598 0000321F E816EE              <1> 	call os_dialog_box
  1599                              <1> 	
  1600 00003222 8A3E[F445]          <1> 	mov bh, [work_page]			; Move the cursor back
  1601 00003226 B402                <1> 	mov ah, 02h
  1602 00003228 CD10                <1> 	int 10h
  1603                              <1> 	
  1604 0000322A E9C9FA              <1> 	jmp mainloop
  1605                              <1> 
  1606                              <1> 
  1607                              <1> ;-------------------------------------------------------------------
  1608                              <1> ; ASKFILE
  1609                              <1> 
  1610                              <1> do_askfile:
  1611 0000322D 8A3E[F445]          <1> 	mov bh, [work_page]			; Store the cursor position
  1612 00003231 B403                <1> 	mov ah, 03h
  1613 00003233 CD10                <1> 	int 10h
  1614                              <1> 	
  1615 00003235 E82E12              <1> 	call get_token
  1616                              <1> 	
  1617 00003238 83F802              <1> 	cmp ax, STRING_VAR
  1618 0000323B 7524                <1> 	jne .error
  1619                              <1> 	
  1620 0000323D BE007C              <1> 	mov si, string_vars			; Get the string location
  1621 00003240 B88000              <1> 	mov ax, 128
  1622 00003243 F7E3                <1> 	mul bx
  1623 00003245 01F0                <1> 	add ax, si
  1624 00003247 A3[6632]            <1> 	mov word [.tmp], ax
  1625                              <1> 	
  1626 0000324A E87BE6              <1> 	call os_file_selector			; Present the selector
  1627                              <1> 	
  1628 0000324D 8B3E[6632]          <1> 	mov word di, [.tmp]			; Copy the string
  1629 00003251 89C6                <1> 	mov si, ax
  1630 00003253 E8F0F7              <1> 	call os_string_copy
  1631                              <1> 
  1632 00003256 8A3E[F445]          <1> 	mov bh, [work_page]			; Move the cursor back
  1633 0000325A B402                <1> 	mov ah, 02h
  1634 0000325C CD10                <1> 	int 10h
  1635                              <1> 	
  1636 0000325E E995FA              <1> 	jmp mainloop
  1637                              <1> 	
  1638                              <1> .error:
  1639 00003261 B314                <1> 	mov bl, err_syntax
  1640 00003263 E91913              <1> 	jmp error
  1641                              <1> 
  1642                              <1> .data:
  1643 00003266 0000                <1> 	.tmp					dw 0
  1644                              <1> 
  1645                              <1> 
  1646                              <1> ; ------------------------------------------------------------------
  1647                              <1> ; BREAK
  1648                              <1> 
  1649                              <1> do_break:
  1650 00003268 B3[D2]              <1> 	mov bl, err_break
  1651 0000326A E91213              <1> 	jmp error
  1652                              <1> 
  1653                              <1> 
  1654                              <1> ; ------------------------------------------------------------------
  1655                              <1> ; CALL
  1656                              <1> 
  1657                              <1> do_call:
  1658 0000326D E8F611              <1> 	call get_token
  1659 00003270 83F803              <1> 	cmp ax, NUMBER
  1660 00003273 740A                <1> 	je .is_number
  1661                              <1> 
  1662 00003275 31C0                <1> 	xor ax, ax
  1663 00003277 A0007B              <1> 	mov byte al, [token]
  1664 0000327A E8CD11              <1> 	call get_var
  1665 0000327D EB06                <1> 	jmp .execute_call
  1666                              <1> 
  1667                              <1> .is_number:
  1668 0000327F BE007B              <1> 	mov si, token
  1669 00003282 E874F8              <1> 	call os_string_to_int
  1670                              <1> 
  1671                              <1> .execute_call:
  1672 00003285 31DB                <1> 	xor bx, bx
  1673 00003287 31C9                <1> 	xor cx, cx
  1674 00003289 31D2                <1> 	xor dx, dx
  1675 0000328B 31FF                <1> 	xor di, di
  1676 0000328D 31F6                <1> 	xor si, si
  1677                              <1> 
  1678 0000328F FFD0                <1> 	call ax
  1679                              <1> 
  1680 00003291 E962FA              <1> 	jmp mainloop
  1681                              <1> 
  1682                              <1> 
  1683                              <1> ; ------------------------------------------------------------------
  1684                              <1> ; CASE
  1685                              <1> 
  1686                              <1> do_case:
  1687 00003294 E8CF11              <1> 	call get_token
  1688 00003297 83F804              <1> 	cmp ax, STRING
  1689 0000329A 7545                <1> 	jne .error
  1690                              <1> 	
  1691 0000329C BE007B              <1> 	mov si, token
  1692                              <1> 
  1693 0000329F BF[2C47]            <1> 	mov di, upper_keyword
  1694 000032A2 E800F8              <1> 	call os_string_compare
  1695 000032A5 720A                <1> 	jc .uppercase
  1696                              <1> 	
  1697 000032A7 BF[2647]            <1> 	mov di, lower_keyword
  1698 000032AA E8F8F7              <1> 	call os_string_compare
  1699 000032AD 721A                <1> 	jc .lowercase
  1700                              <1> 	
  1701 000032AF EB30                <1> 	jmp .error
  1702                              <1> 	
  1703                              <1> .uppercase:
  1704 000032B1 E8B211              <1> 	call get_token
  1705 000032B4 83F802              <1> 	cmp ax, STRING_VAR
  1706 000032B7 7528                <1> 	jne .error
  1707                              <1> 	
  1708 000032B9 BE007C              <1> 	mov si, string_vars
  1709 000032BC B88000              <1> 	mov ax, 128
  1710 000032BF F7E3                <1> 	mul bx
  1711 000032C1 01F0                <1> 	add ax, si
  1712                              <1> 	
  1713 000032C3 E846F7              <1> 	call os_string_uppercase
  1714                              <1> 	
  1715 000032C6 E92DFA              <1> 	jmp mainloop
  1716                              <1> 	
  1717                              <1> .lowercase:
  1718 000032C9 E89A11              <1> 	call get_token
  1719 000032CC 83F802              <1> 	cmp ax, STRING_VAR
  1720 000032CF 7510                <1> 	jne .error
  1721                              <1> 	
  1722 000032D1 BE007C              <1> 	mov si, string_vars
  1723 000032D4 B88000              <1> 	mov ax, 128
  1724 000032D7 F7E3                <1> 	mul bx
  1725 000032D9 01F0                <1> 	add ax, si
  1726                              <1> 	
  1727 000032DB E84BF7              <1> 	call os_string_lowercase
  1728                              <1> 	
  1729 000032DE E915FA              <1> 	jmp mainloop
  1730                              <1> 	
  1731                              <1> .error:
  1732 000032E1 B314                <1> 	mov bl, err_syntax
  1733 000032E3 E99912              <1> 	jmp error
  1734                              <1> 
  1735                              <1> 
  1736                              <1> ; ------------------------------------------------------------------
  1737                              <1> ; CLS
  1738                              <1> 
  1739                              <1> do_cls:
  1740 000032E6 B405                <1> 	mov ah, 5
  1741 000032E8 A0[F445]            <1> 	mov byte al, [work_page]
  1742 000032EB CD10                <1> 	int 10h
  1743                              <1> 
  1744 000032ED E860E5              <1> 	call os_clear_screen
  1745                              <1> 
  1746 000032F0 B405                <1> 	mov ah, 5
  1747 000032F2 A0[F545]            <1> 	mov byte al, [disp_page]
  1748 000032F5 CD10                <1> 	int 10h
  1749                              <1> 
  1750 000032F7 E9FCF9              <1> 	jmp mainloop
  1751                              <1> 
  1752                              <1> 
  1753                              <1> 
  1754                              <1> ; ------------------------------------------------------------------
  1755                              <1> ; CURSOR
  1756                              <1> 
  1757                              <1> do_cursor:
  1758 000032FA E86911              <1> 	call get_token
  1759                              <1> 
  1760 000032FD BE007B              <1> 	mov si, token
  1761 00003300 BF[2433]            <1> 	mov di, .on_str
  1762 00003303 E89FF7              <1> 	call os_string_compare
  1763 00003306 7210                <1> 	jc .turn_on
  1764                              <1> 
  1765 00003308 BE007B              <1> 	mov si, token
  1766 0000330B BF[2733]            <1> 	mov di, .off_str
  1767 0000330E E894F7              <1> 	call os_string_compare
  1768 00003311 720B                <1> 	jc .turn_off
  1769                              <1> 
  1770 00003313 B314                <1> 	mov bl, err_syntax
  1771 00003315 E96712              <1> 	jmp error
  1772                              <1> 
  1773                              <1> .turn_on:
  1774 00003318 E880E5              <1> 	call os_show_cursor
  1775 0000331B E9D8F9              <1> 	jmp mainloop
  1776                              <1> 
  1777                              <1> .turn_off:
  1778 0000331E E885E5              <1> 	call os_hide_cursor
  1779 00003321 E9D2F9              <1> 	jmp mainloop
  1780                              <1> 
  1781                              <1> 
  1782 00003324 4F4E00              <1> 	.on_str db "ON", 0
  1783 00003327 4F464600            <1> 	.off_str db "OFF", 0
  1784                              <1> 
  1785                              <1> 
  1786                              <1> ; ------------------------------------------------------------------
  1787                              <1> ; CURSCHAR
  1788                              <1> 
  1789                              <1> do_curschar:
  1790 0000332B E83811              <1> 	call get_token
  1791                              <1> 
  1792 0000332E 83F801              <1> 	cmp ax, VARIABLE
  1793 00003331 7405                <1> 	je .is_variable
  1794                              <1> 
  1795 00003333 B314                <1> 	mov bl, err_syntax
  1796 00003335 E94712              <1> 	jmp error
  1797                              <1> 
  1798                              <1> .is_variable:
  1799 00003338 31C0                <1> 	xor ax, ax
  1800 0000333A A0007B              <1> 	mov byte al, [token]
  1801                              <1> 
  1802 0000333D 50                  <1> 	push ax				; Store variable we're going to use
  1803                              <1> 
  1804 0000333E B408                <1> 	mov ah, 08h
  1805 00003340 31DB                <1> 	xor bx, bx
  1806 00003342 8A3E[F445]          <1> 	mov byte bh, [work_page]
  1807 00003346 CD10                <1> 	int 10h				; Get char at current cursor location
  1808                              <1> 
  1809 00003348 31DB                <1> 	xor bx, bx			; We only want the lower byte (the char, not attribute)
  1810 0000334A 88C3                <1> 	mov bl, al
  1811                              <1> 
  1812 0000334C 58                  <1> 	pop ax				; Get the variable back
  1813                              <1> 
  1814 0000334D E80711              <1> 	call set_var			; And store the value
  1815                              <1> 
  1816 00003350 E9A3F9              <1> 	jmp mainloop
  1817                              <1> 
  1818                              <1> 
  1819                              <1> ; ------------------------------------------------------------------
  1820                              <1> ; CURSCOL
  1821                              <1> 
  1822                              <1> do_curscol:
  1823 00003353 E81011              <1> 	call get_token
  1824                              <1> 
  1825 00003356 83F801              <1> 	cmp ax, VARIABLE
  1826 00003359 751B                <1> 	jne .error
  1827                              <1> 
  1828 0000335B B400                <1> 	mov ah, 0
  1829 0000335D A0007B              <1> 	mov byte al, [token]
  1830 00003360 50                  <1> 	push ax
  1831                              <1> 
  1832 00003361 B408                <1> 	mov ah, 8
  1833 00003363 31DB                <1> 	xor bx, bx
  1834 00003365 8A3E[F445]          <1> 	mov byte bh, [work_page]
  1835 00003369 CD10                <1> 	int 10h
  1836 0000336B B700                <1> 	mov bh, 0
  1837 0000336D 88E3                <1> 	mov bl, ah			; Get colour for higher byte; ignore lower byte (char)
  1838                              <1> 
  1839 0000336F 58                  <1> 	pop ax
  1840 00003370 E8E410              <1> 	call set_var
  1841                              <1> 
  1842 00003373 E980F9              <1> 	jmp mainloop
  1843                              <1> 
  1844                              <1> .error:
  1845 00003376 B314                <1> 	mov bl, err_syntax
  1846 00003378 E90412              <1> 	jmp error
  1847                              <1> 
  1848                              <1> 
  1849                              <1> ; ------------------------------------------------------------------
  1850                              <1> ; CURSPOS
  1851                              <1> 
  1852                              <1> do_curspos:
  1853 0000337B 8A3E[F445]          <1> 	mov byte bh, [work_page]
  1854 0000337F B403                <1> 	mov ah, 3
  1855 00003381 CD10                <1> 	int 10h
  1856                              <1> 
  1857 00003383 E8E010              <1> 	call get_token
  1858 00003386 83F801              <1> 	cmp ax, VARIABLE
  1859 00003389 7523                <1> 	jne .error
  1860                              <1> 
  1861 0000338B 0FB606007B          <1> 	movzx ax, byte [token]
  1862 00003390 31DB                <1> 	xor bx, bx
  1863 00003392 88D3                <1> 	mov bl, dl
  1864 00003394 E8C010              <1> 	call set_var
  1865                              <1> 
  1866 00003397 E8CC10              <1> 	call get_token
  1867 0000339A 83F801              <1> 	cmp ax, VARIABLE
  1868 0000339D 750F                <1> 	jne .error
  1869                              <1> 
  1870 0000339F 0FB606007B          <1> 	movzx ax, byte [token]
  1871 000033A4 31DB                <1> 	xor bx, bx
  1872 000033A6 88F3                <1> 	mov bl, dh
  1873 000033A8 E8AC10              <1> 	call set_var
  1874                              <1> 
  1875 000033AB E948F9              <1> 	jmp mainloop
  1876                              <1> 
  1877                              <1> .error:
  1878 000033AE B314                <1> 	mov bl, err_syntax
  1879 000033B0 E9CC11              <1> 	jmp error
  1880                              <1> 
  1881                              <1> 
  1882                              <1> ; ------------------------------------------------------------------
  1883                              <1> ; DELETE
  1884                              <1> 
  1885                              <1> do_delete:
  1886 000033B3 E8B010              <1> 	call get_token
  1887 000033B6 83F805              <1> 	cmp ax, QUOTE
  1888 000033B9 7413                <1> 	je .is_quote
  1889                              <1> 
  1890 000033BB 83F802              <1> 	cmp ax, STRING_VAR
  1891 000033BE 0F854300            <1> 	jne near .error
  1892                              <1> 
  1893 000033C2 BE007C              <1> 	mov si, string_vars
  1894 000033C5 B88000              <1> 	mov ax, 128
  1895 000033C8 F7E3                <1> 	mul bx
  1896 000033CA 01C6                <1> 	add si, ax
  1897 000033CC EB03                <1> 	jmp .get_filename
  1898                              <1> 
  1899                              <1> .is_quote:
  1900 000033CE BE007B              <1> 	mov si, token
  1901                              <1> 
  1902                              <1> .get_filename:
  1903 000033D1 89F0                <1> 	mov ax, si
  1904 000033D3 E8FBDA              <1> 	call os_file_exists
  1905 000033D6 7207                <1> 	jc .no_file
  1906                              <1> 
  1907 000033D8 E8F5DB              <1> 	call os_remove_file
  1908 000033DB 721B                <1> 	jc .del_fail
  1909                              <1> 
  1910 000033DD EB0D                <1> 	jmp .returngood
  1911                              <1> 
  1912                              <1> .no_file:
  1913 000033DF 31C0                <1> 	xor ax, ax
  1914 000033E1 B052                <1> 	mov byte al, 'R'
  1915 000033E3 BB0200              <1> 	mov bx, 2
  1916 000033E6 E86E10              <1> 	call set_var
  1917 000033E9 E90AF9              <1> 	jmp mainloop
  1918                              <1> 
  1919                              <1> .returngood:
  1920 000033EC 31C0                <1> 	xor ax, ax
  1921 000033EE B052                <1> 	mov byte al, 'R'
  1922 000033F0 31DB                <1> 	xor bx, bx
  1923 000033F2 E86210              <1> 	call set_var
  1924 000033F5 E9FEF8              <1> 	jmp mainloop
  1925                              <1> 
  1926                              <1> .del_fail:
  1927 000033F8 31C0                <1> 	xor ax, ax
  1928 000033FA B052                <1> 	mov byte al, 'R'
  1929 000033FC BB0100              <1> 	mov bx, 1
  1930 000033FF E85510              <1> 	call set_var
  1931 00003402 E9F1F8              <1> 	jmp mainloop
  1932                              <1> 
  1933                              <1> .error:
  1934 00003405 B314                <1> 	mov bl, err_syntax
  1935 00003407 E97511              <1> 	jmp error
  1936                              <1> 	
  1937                              <1> 
  1938                              <1> ; ------------------------------------------------------------------
  1939                              <1> ; DO
  1940                              <1> 
  1941                              <1> do_do:
  1942 0000340A 803E[F145]14        <1> 	cmp byte [loop_in], 20
  1943 0000340F 741C                <1> 	je .loop_max
  1944 00003411 BFD079              <1> 	mov word di, do_loop_store
  1945 00003414 A0[F145]            <1> 	mov byte al, [loop_in]
  1946 00003417 B400                <1> 	mov ah, 0
  1947 00003419 01C7                <1> 	add di, ax
  1948 0000341B A1[EA45]            <1> 	mov word ax, [prog]
  1949 0000341E 83E803              <1> 	sub ax, 3
  1950 00003421 AB                  <1> 	stosw
  1951 00003422 FE06[F145]          <1> 	inc byte [loop_in]
  1952 00003426 FE06[F145]          <1> 	inc byte [loop_in]
  1953 0000342A E9C9F8              <1> 	jmp mainloop
  1954                              <1> 
  1955                              <1> .loop_max:
  1956 0000342D B303                <1> 	mov bl, err_doloop_maximum
  1957 0000342F E94D11              <1> 	jmp error
  1958                              <1> 
  1959                              <1> 	
  1960                              <1> ;-------------------------------------------------------------------
  1961                              <1> ; ELSE
  1962                              <1> 
  1963                              <1> do_else:
  1964 00003432 803E[F245]01        <1> 	cmp byte [last_if_true], 1
  1965 00003437 7407                <1> 	je .last_true
  1966                              <1> 	
  1967 00003439 FF06[EA45]          <1> 	inc word [prog]
  1968 0000343D E9B6F8              <1> 	jmp mainloop
  1969                              <1> 	
  1970                              <1> .last_true:
  1971 00003440 8B36[EA45]          <1> 	mov word si, [prog]
  1972                              <1> 	
  1973                              <1> .next_line:
  1974 00003444 AC                  <1> 	lodsb
  1975 00003445 3C0A                <1> 	cmp al, 10
  1976 00003447 75FB                <1> 	jne .next_line
  1977                              <1> 	
  1978 00003449 4E                  <1> 	dec si
  1979 0000344A 8936[EA45]          <1> 	mov word [prog], si
  1980                              <1> 	
  1981 0000344E E9A5F8              <1> 	jmp mainloop
  1982                              <1> 
  1983                              <1> 
  1984                              <1> ; ------------------------------------------------------------------
  1985                              <1> ; END
  1986                              <1> 
  1987                              <1> do_end:
  1988 00003451 B405                <1> 	mov ah, 5				; Restore active page
  1989 00003453 B000                <1> 	mov al, 0
  1990 00003455 CD10                <1> 	int 10h
  1991                              <1> 
  1992 00003457 C606[F445]00        <1> 	mov byte [work_page], 0
  1993 0000345C C606[F545]00        <1> 	mov byte [disp_page], 0
  1994                              <1> 
  1995 00003461 8B26[E845]          <1> 	mov word sp, [orig_stack]
  1996 00003465 C3                  <1> 	ret
  1997                              <1> 
  1998                              <1> 
  1999                              <1> ; ------------------------------------------------------------------
  2000                              <1> ; FILES
  2001                              <1> 
  2002                              <1> do_files:
  2003 00003466 B800FA              <1> 	mov ax, .filelist			; get a copy of the filelist
  2004 00003469 E8F4D5              <1> 	call os_get_file_list
  2005                              <1> 	
  2006 0000346C 89C6                <1> 	mov si, ax
  2007                              <1> 
  2008 0000346E E8FEE3              <1> 	call os_get_cursor_pos			; move cursor to start of line
  2009 00003471 B200                <1> 	mov dl, 0
  2010 00003473 E8F0E3              <1> 	call os_move_cursor
  2011                              <1> 	
  2012 00003476 B409                <1> 	mov ah, 9				; print character function
  2013 00003478 8A3E[F445]          <1> 	mov bh, [work_page]			; define parameters (page, colour, times)
  2014 0000347C 8A1E[F345]          <1> 	mov bl, [ink_colour]
  2015 00003480 B90100              <1> 	mov cx, 1
  2016                              <1> .file_list_loop:
  2017 00003483 AC                  <1> 	lodsb					; get a byte from the list
  2018 00003484 3C2C                <1> 	cmp al, ','				; a comma means the next file, so create a new line for it
  2019 00003486 7410                <1> 	je .nextfile
  2020                              <1> 	
  2021 00003488 3C00                <1> 	cmp al, 0				; the list is null terminated
  2022 0000348A 7438                <1> 	je .end_of_list
  2023                              <1> 	
  2024 0000348C CD10                <1> 	int 10h					; okay, it's not a comma or a null so print it
  2025                              <1> 
  2026 0000348E E8DEE3              <1> 	call os_get_cursor_pos			; find the location of the cursor
  2027 00003491 FEC2                <1> 	inc dl					; move the cursor forward
  2028 00003493 E8D0E3              <1> 	call os_move_cursor
  2029                              <1> 
  2030 00003496 EBEB                <1> 	jmp .file_list_loop			; keep going until the list is finished
  2031                              <1> 	
  2032                              <1> .nextfile:
  2033 00003498 E8D4E3              <1> 	call os_get_cursor_pos			; if the column is over 60 we need a new line
  2034 0000349B 80FA3C              <1> 	cmp dl, 60
  2035 0000349E 7D1F                <1> 	jge .newline
  2036                              <1> 
  2037                              <1> .next_column:					; print spaces until the next column
  2038 000034A0 B020                <1> 	mov al, ' '
  2039 000034A2 CD10                <1> 	int 10h
  2040                              <1> 	
  2041 000034A4 FEC2                <1> 	inc dl
  2042 000034A6 E8BDE3              <1> 	call os_move_cursor
  2043                              <1> 	
  2044 000034A9 80FA0F              <1> 	cmp dl, 15
  2045 000034AC 74D5                <1> 	je .file_list_loop
  2046                              <1> 	
  2047 000034AE 80FA1E              <1> 	cmp dl, 30
  2048 000034B1 74D0                <1> 	je .file_list_loop
  2049                              <1> 	
  2050 000034B3 80FA2D              <1> 	cmp dl, 45
  2051 000034B6 74CB                <1> 	je .file_list_loop
  2052                              <1> 	
  2053 000034B8 80FA3C              <1> 	cmp dl, 60
  2054 000034BB 74C6                <1> 	je .file_list_loop
  2055                              <1> 	
  2056 000034BD EBE1                <1> 	jmp .next_column
  2057                              <1> 	
  2058                              <1> .newline:
  2059 000034BF E87CEA              <1> 	call os_print_newline			; create a new line
  2060 000034C2 EBBF                <1> 	jmp .file_list_loop
  2061                              <1> 	
  2062                              <1> .end_of_list:
  2063 000034C4 E877EA              <1> 	call os_print_newline
  2064 000034C7 E92CF8              <1> 	jmp mainloop				; preform next command
  2065                              <1> 	
  2066                              <1> .data:
  2067                              <1> 	.filelist		equ 64000
  2068                              <1> 	
  2069                              <1> 
  2070                              <1> 
  2071                              <1> ; ------------------------------------------------------------------
  2072                              <1> ; FOR
  2073                              <1> 
  2074                              <1> do_for:
  2075 000034CA E8990F              <1> 	call get_token				; Get the variable we're using in this loop
  2076                              <1> 
  2077 000034CD 83F801              <1> 	cmp ax, VARIABLE
  2078 000034D0 0F859B00            <1> 	jne near .error
  2079                              <1> 
  2080 000034D4 0FB606007B          <1> 	movzx ax, byte [token]
  2081 000034D9 A2[7435]            <1> 	mov byte [.tmp_var], al			; Store it in a temporary location for now
  2082                              <1> 
  2083 000034DC E8870F              <1> 	call get_token
  2084                              <1> 
  2085 000034DF 0FB606007B          <1> 	movzx ax, byte [token]
  2086 000034E4 3C3D                <1> 	cmp al, '='
  2087 000034E6 0F858500            <1> 	jne .error
  2088                              <1> 
  2089 000034EA E8790F              <1> 	call get_token				; Next we want a number
  2090                              <1> 
  2091 000034ED 83F801              <1> 	cmp ax, VARIABLE
  2092 000034F0 740D                <1> 	je .first_is_var
  2093                              <1> 
  2094 000034F2 83F803              <1> 	cmp ax, NUMBER
  2095 000034F5 7578                <1> 	jne .error
  2096                              <1> 
  2097 000034F7 BE007B              <1> 	mov si, token				; Convert it
  2098 000034FA E8FCF5              <1> 	call os_string_to_int
  2099 000034FD EB08                <1> 	jmp .continue
  2100                              <1> 
  2101                              <1> .first_is_var:
  2102 000034FF 0FB606007B          <1> 	movzx ax, byte [token]
  2103 00003504 E8430F              <1> 	call get_var
  2104                              <1> 	
  2105                              <1> 	; At this stage, we've read something like "FOR X = 1"
  2106                              <1> 	; so let's store that 1 in the variable table
  2107                              <1> 
  2108                              <1> .continue:
  2109 00003507 89C3                <1> 	mov bx, ax
  2110 00003509 0FB606[7435]        <1> 	movzx ax, byte [.tmp_var]
  2111 0000350E E8460F              <1> 	call set_var
  2112                              <1> 
  2113                              <1> 
  2114 00003511 E8520F              <1> 	call get_token				; Next we're looking for "TO"
  2115                              <1> 
  2116 00003514 83F804              <1> 	cmp ax, STRING
  2117 00003517 7556                <1> 	jne .error
  2118                              <1> 
  2119 00003519 B8007B              <1> 	mov ax, token
  2120 0000351C E8EDF4              <1> 	call os_string_uppercase
  2121                              <1> 
  2122 0000351F BE007B              <1> 	mov si, token
  2123 00003522 BF[7535]            <1> 	mov di, .to_string
  2124 00003525 E87DF5              <1> 	call os_string_compare
  2125 00003528 7345                <1> 	jnc .error
  2126                              <1> 
  2127                              <1> 
  2128                              <1> 	; So now we're at "FOR X = 1 TO"
  2129                              <1> 
  2130 0000352A E8390F              <1> 	call get_token
  2131                              <1> 
  2132 0000352D 83F801              <1> 	cmp ax, VARIABLE
  2133 00003530 740D                <1> 	je .second_is_var
  2134                              <1> 
  2135 00003532 83F803              <1> 	cmp ax, NUMBER
  2136 00003535 7538                <1> 	jne .error
  2137                              <1> 
  2138                              <1> .second_is_number:
  2139 00003537 BE007B              <1> 	mov si, token					; Get target number
  2140 0000353A E8BCF5              <1> 	call os_string_to_int
  2141 0000353D EB08                <1> 	jmp .continue2
  2142                              <1> 
  2143                              <1> .second_is_var:
  2144 0000353F 0FB606007B          <1> 	movzx ax, byte [token]
  2145 00003544 E8030F              <1> 	call get_var
  2146                              <1> 
  2147                              <1> .continue2:
  2148 00003547 89C3                <1> 	mov bx, ax
  2149                              <1> 
  2150 00003549 0FB606[7435]        <1> 	movzx ax, byte [.tmp_var]
  2151                              <1> 
  2152 0000354E 2C41                <1> 	sub al, 65					; Store target number in table
  2153 00003550 BF187A              <1> 	mov di, for_variables
  2154 00003553 01C7                <1> 	add di, ax
  2155 00003555 01C7                <1> 	add di, ax
  2156 00003557 89D8                <1> 	mov ax, bx
  2157 00003559 AB                  <1> 	stosw
  2158                              <1> 
  2159                              <1> 
  2160                              <1> 	; So we've got the variable, assigned it the starting number, and put into
  2161                              <1> 	; our table the limit it should reach. But we also need to store the point in
  2162                              <1> 	; code after the FOR line we should return to if NEXT X doesn't complete the loop...
  2163                              <1> 
  2164 0000355A 0FB606[7435]        <1> 	movzx ax, byte [.tmp_var]
  2165                              <1> 
  2166 0000355F 2C41                <1> 	sub al, 65					; Store code position to return to in table
  2167 00003561 BFE479              <1> 	mov di, for_code_points
  2168 00003564 01C7                <1> 	add di, ax
  2169 00003566 01C7                <1> 	add di, ax
  2170 00003568 A1[EA45]            <1> 	mov word ax, [prog]
  2171 0000356B AB                  <1> 	stosw
  2172                              <1> 
  2173 0000356C E987F7              <1> 	jmp mainloop
  2174                              <1> 
  2175                              <1> 
  2176                              <1> .error:
  2177 0000356F B314                <1> 	mov bl, err_syntax
  2178 00003571 E90B10              <1> 	jmp error
  2179                              <1> 
  2180                              <1> 
  2181 00003574 00                  <1> 	.tmp_var	db 0
  2182 00003575 544F00              <1> 	.to_string	db 'TO', 0
  2183                              <1> 
  2184                              <1> 
  2185                              <1> ; ------------------------------------------------------------------
  2186                              <1> ; GETKEY
  2187                              <1> 
  2188                              <1> do_getkey:
  2189 00003578 E8EB0E              <1> 	call get_token
  2190 0000357B 83F801              <1> 	cmp ax, VARIABLE
  2191 0000357E 7405                <1> 	je .is_variable
  2192                              <1> 
  2193 00003580 B314                <1> 	mov bl, err_syntax
  2194 00003582 E9FA0F              <1> 	jmp error
  2195                              <1> 
  2196                              <1> .is_variable:
  2197 00003585 0FB606007B          <1> 	movzx ax, byte [token]
  2198                              <1> 
  2199 0000358A 50                  <1> 	push ax
  2200                              <1> 
  2201 0000358B E88FDD              <1> 	call os_check_for_key
  2202                              <1> 
  2203 0000358E 3DE048              <1> 	cmp ax, 48E0h
  2204 00003591 7419                <1> 	je .up_pressed
  2205                              <1> 
  2206 00003593 3DE050              <1> 	cmp ax, 50E0h
  2207 00003596 7419                <1> 	je .down_pressed
  2208                              <1> 
  2209 00003598 3DE04B              <1> 	cmp ax, 4BE0h
  2210 0000359B 7419                <1> 	je .left_pressed
  2211                              <1> 
  2212 0000359D 3DE04D              <1> 	cmp ax, 4DE0h
  2213 000035A0 7419                <1> 	je .right_pressed
  2214                              <1> 
  2215                              <1> .store:	
  2216 000035A2 0FB6D8              <1> 	movzx bx, al
  2217                              <1> 	
  2218 000035A5 58                  <1> 	pop ax
  2219                              <1> 
  2220 000035A6 E8AE0E              <1> 	call set_var
  2221                              <1> 
  2222 000035A9 E94AF7              <1> 	jmp mainloop
  2223                              <1> 
  2224                              <1> .up_pressed:
  2225 000035AC B80100              <1> 	mov ax, 1
  2226 000035AF EBF1                <1> 	jmp .store
  2227                              <1> 
  2228                              <1> .down_pressed:
  2229 000035B1 B80200              <1> 	mov ax, 2
  2230 000035B4 EBEC                <1> 	jmp .store
  2231                              <1> 
  2232                              <1> .left_pressed:
  2233 000035B6 B80300              <1> 	mov ax, 3
  2234 000035B9 EBE7                <1> 	jmp .store
  2235                              <1> 
  2236                              <1> .right_pressed:
  2237 000035BB B80400              <1> 	mov ax, 4
  2238 000035BE EBE2                <1> 	jmp .store
  2239                              <1> 
  2240                              <1> ; ------------------------------------------------------------------
  2241                              <1> ; GOSUB
  2242                              <1> 
  2243                              <1> do_gosub:
  2244 000035C0 E8A30E              <1> 	call get_token				; Get the number (label)
  2245                              <1> 
  2246 000035C3 83F804              <1> 	cmp ax, STRING
  2247 000035C6 7405                <1> 	je .is_ok
  2248                              <1> 
  2249 000035C8 B305                <1> 	mov bl, err_goto_notlabel
  2250 000035CA E9B20F              <1> 	jmp error
  2251                              <1> 
  2252                              <1> .is_ok:
  2253 000035CD BE007B              <1> 	mov si, token				; Back up this label
  2254 000035D0 BF[3F36]            <1> 	mov di, .tmp_token
  2255 000035D3 E870F4              <1> 	call os_string_copy
  2256                              <1> 
  2257 000035D6 B8[3F36]            <1> 	mov ax, .tmp_token
  2258 000035D9 E8D7F3              <1> 	call os_string_length
  2259                              <1> 
  2260 000035DC BF[3F36]            <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  2261 000035DF 01C7                <1> 	add di, ax
  2262 000035E1 B03A                <1> 	mov al, ':'
  2263 000035E3 AA                  <1> 	stosb
  2264 000035E4 B000                <1> 	mov al, 0
  2265 000035E6 AA                  <1> 	stosb	
  2266                              <1> 
  2267                              <1> 
  2268 000035E7 FE06[6147]          <1> 	inc byte [gosub_depth]
  2269                              <1> 
  2270 000035EB 0FB606[6147]        <1> 	movzx ax, byte [gosub_depth]		; Get current GOSUB nest level
  2271                              <1> 
  2272 000035F0 3C09                <1> 	cmp al, 9
  2273 000035F2 7E05                <1> 	jle .within_limit
  2274                              <1> 
  2275 000035F4 B307                <1> 	mov bl, err_nest_limit
  2276 000035F6 E9860F              <1> 	jmp error
  2277                              <1> 
  2278                              <1> 
  2279                              <1> .within_limit:
  2280 000035F9 BFBC79              <1> 	mov di, gosub_points			; Move into our table of pointers
  2281 000035FC 01C7                <1> 	add di, ax				; Table is words (not bytes)
  2282 000035FE 01C7                <1> 	add di, ax
  2283 00003600 A1[EA45]            <1> 	mov word ax, [prog]
  2284 00003603 AB                  <1> 	stosw					; Store current location before jump
  2285                              <1> 
  2286                              <1> 
  2287 00003604 A1[EE45]            <1> 	mov word ax, [load_point]
  2288 00003607 A3[EA45]            <1> 	mov word [prog], ax			; Return to start of program to find label
  2289                              <1> 
  2290                              <1> .loop:
  2291 0000360A E8590E              <1> 	call get_token
  2292                              <1> 
  2293 0000360D 83F808              <1> 	cmp ax, LABEL
  2294 00003610 750D                <1> 	jne .line_loop
  2295                              <1> 
  2296 00003612 BE007B              <1> 	mov si, token
  2297 00003615 BF[3F36]            <1> 	mov di, .tmp_token
  2298 00003618 E88AF4              <1> 	call os_string_compare
  2299 0000361B 0F82D7F6            <1> 	jc mainloop
  2300                              <1> 
  2301                              <1> 
  2302                              <1> .line_loop:					; Go to end of line
  2303 0000361F 8B36[EA45]          <1> 	mov word si, [prog]
  2304 00003623 8A04                <1> 	mov byte al, [si]
  2305 00003625 FF06[EA45]          <1> 	inc word [prog]
  2306 00003629 3C0A                <1> 	cmp al, 10
  2307 0000362B 75F2                <1> 	jne .line_loop
  2308                              <1> 
  2309 0000362D A1[EA45]            <1> 	mov word ax, [prog]
  2310 00003630 8B1E[EC45]          <1> 	mov word bx, [prog_end]
  2311 00003634 39D8                <1> 	cmp ax, bx
  2312 00003636 7F02                <1> 	jg .past_end
  2313                              <1> 
  2314 00003638 EBD0                <1> 	jmp .loop
  2315                              <1> 
  2316                              <1> 
  2317                              <1> .past_end:
  2318 0000363A B306                <1> 	mov bl, err_label_notfound
  2319 0000363C E9400F              <1> 	jmp error
  2320                              <1> 
  2321                              <1> 
  2322 0000363F 00<rep 1Eh>         <1> 	.tmp_token	times 30 db 0
  2323                              <1> 
  2324                              <1> 
  2325                              <1> ; ------------------------------------------------------------------
  2326                              <1> ; GOTO
  2327                              <1> 
  2328                              <1> do_goto:
  2329 0000365D E8060E              <1> 	call get_token				; Get the next token
  2330                              <1> 
  2331 00003660 83F804              <1> 	cmp ax, STRING
  2332 00003663 7405                <1> 	je .is_ok
  2333                              <1> 
  2334 00003665 B305                <1> 	mov bl, err_goto_notlabel
  2335 00003667 E9150F              <1> 	jmp error
  2336                              <1> 
  2337                              <1> .is_ok:
  2338 0000366A BE007B              <1> 	mov si, token				; Back up this label
  2339 0000366D BF[BF36]            <1> 	mov di, .tmp_token
  2340 00003670 E8D3F3              <1> 	call os_string_copy
  2341                              <1> 
  2342 00003673 B8[BF36]            <1> 	mov ax, .tmp_token
  2343 00003676 E83AF3              <1> 	call os_string_length
  2344                              <1> 
  2345 00003679 BF[BF36]            <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  2346 0000367C 01C7                <1> 	add di, ax
  2347 0000367E B03A                <1> 	mov al, ':'
  2348 00003680 AA                  <1> 	stosb
  2349 00003681 B000                <1> 	mov al, 0
  2350 00003683 AA                  <1> 	stosb	
  2351                              <1> 
  2352 00003684 A1[EE45]            <1> 	mov word ax, [load_point]
  2353 00003687 A3[EA45]            <1> 	mov word [prog], ax			; Return to start of program to find label
  2354                              <1> 
  2355                              <1> .loop:
  2356 0000368A E8D90D              <1> 	call get_token
  2357                              <1> 
  2358 0000368D 83F808              <1> 	cmp ax, LABEL
  2359 00003690 750D                <1> 	jne .line_loop
  2360                              <1> 
  2361 00003692 BE007B              <1> 	mov si, token
  2362 00003695 BF[BF36]            <1> 	mov di, .tmp_token
  2363 00003698 E80AF4              <1> 	call os_string_compare
  2364 0000369B 0F8257F6            <1> 	jc mainloop
  2365                              <1> 
  2366                              <1> .line_loop:					; Go to end of line
  2367 0000369F 8B36[EA45]          <1> 	mov word si, [prog]
  2368 000036A3 8A04                <1> 	mov byte al, [si]
  2369 000036A5 FF06[EA45]          <1> 	inc word [prog]
  2370                              <1> 
  2371 000036A9 3C0A                <1> 	cmp al, 10
  2372 000036AB 75F2                <1> 	jne .line_loop
  2373                              <1> 
  2374 000036AD A1[EA45]            <1> 	mov word ax, [prog]
  2375 000036B0 8B1E[EC45]          <1> 	mov word bx, [prog_end]
  2376 000036B4 39D8                <1> 	cmp ax, bx
  2377 000036B6 7F02                <1> 	jg .past_end
  2378                              <1> 
  2379 000036B8 EBD0                <1> 	jmp .loop
  2380                              <1> 
  2381                              <1> .past_end:
  2382 000036BA B306                <1> 	mov bl, err_label_notfound
  2383 000036BC E9C00E              <1> 	jmp error
  2384                              <1> 
  2385                              <1> 
  2386 000036BF 00<rep 1Eh>         <1> 	.tmp_token 	times 30 db 0
  2387                              <1> 
  2388                              <1> 
  2389                              <1> ; ------------------------------------------------------------------
  2390                              <1> ; IF
  2391                              <1> 
  2392                              <1> do_if:
  2393 000036DD E8860D              <1> 	call get_token
  2394                              <1> 
  2395 000036E0 83F801              <1> 	cmp ax, VARIABLE			; If can only be followed by a variable
  2396 000036E3 740C                <1> 	je .num_var
  2397                              <1> 
  2398 000036E5 83F802              <1> 	cmp ax, STRING_VAR
  2399 000036E8 0F84B300            <1> 	je near .string_var
  2400                              <1> 
  2401 000036EC B314                <1> 	mov bl, err_syntax
  2402 000036EE E98E0E              <1> 	jmp error
  2403                              <1> 
  2404                              <1> .num_var:
  2405 000036F1 0FB606007B          <1> 	movzx ax, byte [token]
  2406 000036F6 E8510D              <1> 	call get_var
  2407                              <1> 
  2408 000036F9 89C2                <1> 	mov dx, ax				; Store value of first part of comparison
  2409                              <1> 
  2410 000036FB E8680D              <1> 	call get_token				; Get the delimiter
  2411 000036FE A0007B              <1> 	mov byte al, [token]
  2412 00003701 3C3D                <1> 	cmp al, '='
  2413 00003703 740D                <1> 	je .equals
  2414 00003705 3C3E                <1> 	cmp al, '>'
  2415 00003707 7447                <1> 	je .greater
  2416 00003709 3C3C                <1> 	cmp al, '<'
  2417 0000370B 746C                <1> 	je .less
  2418                              <1> 
  2419 0000370D B314                <1> 	mov bl, err_syntax			; If not one of the above, error out
  2420 0000370F E96D0E              <1> 	jmp error
  2421                              <1> 
  2422                              <1> .equals:
  2423 00003712 E8510D              <1> 	call get_token				; Is this 'X = Y' (equals another variable?)
  2424                              <1> 
  2425 00003715 83F806              <1> 	cmp ax, CHAR
  2426 00003718 7417                <1> 	je .equals_char
  2427                              <1> 
  2428 0000371A A0007B              <1> 	mov byte al, [token]
  2429 0000371D E8530E              <1> 	call is_letter
  2430 00003720 721D                <1> 	jc .equals_var
  2431                              <1> 
  2432 00003722 BE007B              <1> 	mov si, token				; Otherwise it's, eg 'X = 1' (a number)
  2433 00003725 E8D1F3              <1> 	call os_string_to_int
  2434                              <1> 
  2435 00003728 39D0                <1> 	cmp ax, dx				; On to the THEN bit if 'X = num' matches
  2436 0000372A 0F84C200            <1> 	je near .on_to_then
  2437                              <1> 
  2438 0000372E E9E700              <1> 	jmp .finish_line			; Otherwise skip the rest of the line
  2439                              <1> 
  2440                              <1> 
  2441                              <1> .equals_char:
  2442 00003731 0FB606007B          <1> 	movzx ax, byte [token]
  2443                              <1> 
  2444 00003736 39D0                <1> 	cmp ax, dx
  2445 00003738 0F84B400            <1> 	je near .on_to_then
  2446                              <1> 
  2447 0000373C E9D900              <1> 	jmp .finish_line
  2448                              <1> 
  2449                              <1> 
  2450                              <1> .equals_var:
  2451 0000373F 0FB606007B          <1> 	movzx ax, byte [token]
  2452                              <1> 
  2453 00003744 E8030D              <1> 	call get_var
  2454                              <1> 
  2455 00003747 39D0                <1> 	cmp ax, dx				; Do the variables match?
  2456 00003749 0F84A300            <1> 	je near .on_to_then				; On to the THEN bit if so
  2457                              <1> 
  2458 0000374D E9C800              <1> 	jmp .finish_line			; Otherwise skip the rest of the line
  2459                              <1> 
  2460                              <1> 
  2461                              <1> .greater:
  2462 00003750 E8130D              <1> 	call get_token				; Greater than a variable or number?
  2463 00003753 A0007B              <1> 	mov byte al, [token]
  2464 00003756 E81A0E              <1> 	call is_letter
  2465 00003759 720F                <1> 	jc .greater_var
  2466                              <1> 
  2467 0000375B BE007B              <1> 	mov si, token				; Must be a number here...
  2468 0000375E E898F3              <1> 	call os_string_to_int
  2469                              <1> 
  2470 00003761 39D0                <1> 	cmp ax, dx
  2471 00003763 0F8C8900            <1> 	jl near .on_to_then
  2472                              <1> 
  2473 00003767 E9AE00              <1> 	jmp .finish_line
  2474                              <1> 
  2475                              <1> .greater_var:					; Variable in this case
  2476 0000376A 0FB606007B          <1> 	movzx ax, byte [token]
  2477                              <1> 
  2478 0000376F E8D80C              <1> 	call get_var
  2479                              <1> 
  2480 00003772 39D0                <1> 	cmp ax, dx				; Make the comparison!
  2481 00003774 7C7A                <1> 	jl .on_to_then
  2482                              <1> 
  2483 00003776 E99F00              <1> 	jmp .finish_line
  2484                              <1> 
  2485                              <1> .less:
  2486 00003779 E8EA0C              <1> 	call get_token
  2487 0000377C A0007B              <1> 	mov byte al, [token]
  2488 0000377F E8F10D              <1> 	call is_letter
  2489 00003782 720D                <1> 	jc .less_var
  2490                              <1> 
  2491 00003784 BE007B              <1> 	mov si, token
  2492 00003787 E86FF3              <1> 	call os_string_to_int
  2493                              <1> 
  2494 0000378A 39D0                <1> 	cmp ax, dx
  2495 0000378C 7F62                <1> 	jg .on_to_then
  2496                              <1> 
  2497 0000378E E98700              <1> 	jmp .finish_line
  2498                              <1> 
  2499                              <1> .less_var:
  2500 00003791 0FB606007B          <1> 	movzx ax, byte [token]
  2501                              <1> 
  2502 00003796 E8B10C              <1> 	call get_var
  2503                              <1> 
  2504 00003799 39D0                <1> 	cmp ax, dx
  2505 0000379B 7F53                <1> 	jg .on_to_then
  2506                              <1> 
  2507 0000379D EB79                <1> 	jmp .finish_line
  2508                              <1> 
  2509                              <1> 
  2510                              <1> 
  2511                              <1> .string_var:
  2512 0000379F 881E[3338]          <1> 	mov byte [.tmp_string_var], bl
  2513                              <1> 
  2514 000037A3 E8C00C              <1> 	call get_token
  2515                              <1> 
  2516 000037A6 A0007B              <1> 	mov byte al, [token]
  2517 000037A9 3C3D                <1> 	cmp al, '='
  2518 000037AB 0F857F00            <1> 	jne .error
  2519                              <1> 
  2520 000037AF E8B40C              <1> 	call get_token
  2521 000037B2 83F802              <1> 	cmp ax, STRING_VAR
  2522 000037B5 7419                <1> 	je .second_is_string_var
  2523                              <1> 
  2524 000037B7 83F805              <1> 	cmp ax, QUOTE
  2525 000037BA 7572                <1> 	jne .error
  2526                              <1> 
  2527 000037BC BE007C              <1> 	mov si, string_vars
  2528 000037BF B88000              <1> 	mov ax, 128
  2529 000037C2 F7E3                <1> 	mul bx
  2530 000037C4 01C6                <1> 	add si, ax
  2531 000037C6 BF007B              <1> 	mov di, token
  2532 000037C9 E8D9F2              <1> 	call os_string_compare
  2533 000037CC 7422                <1> 	je .on_to_then
  2534                              <1> 
  2535 000037CE EB48                <1> 	jmp .finish_line
  2536                              <1> 
  2537                              <1> 
  2538                              <1> .second_is_string_var:
  2539 000037D0 BE007C              <1> 	mov si, string_vars
  2540 000037D3 B88000              <1> 	mov ax, 128
  2541 000037D6 F7E3                <1> 	mul bx
  2542 000037D8 01C6                <1> 	add si, ax
  2543                              <1> 
  2544 000037DA BF007C              <1> 	mov di, string_vars
  2545 000037DD 0FB61E[3338]        <1> 	movzx bx, byte [.tmp_string_var]
  2546 000037E2 B88000              <1> 	mov ax, 128
  2547 000037E5 F7E3                <1> 	mul bx
  2548 000037E7 01C7                <1> 	add di, ax
  2549                              <1> 
  2550 000037E9 E8B9F2              <1> 	call os_string_compare
  2551 000037EC 7202                <1> 	jc .on_to_then
  2552                              <1> 
  2553 000037EE EB28                <1> 	jmp .finish_line
  2554                              <1> 
  2555                              <1> 
  2556                              <1> .on_to_then:
  2557 000037F0 E8730C              <1> 	call get_token
  2558                              <1> 
  2559 000037F3 BE007B              <1> 	mov si, token			; Look for AND for more comparison
  2560 000037F6 BF[1547]            <1> 	mov di, and_keyword
  2561 000037F9 E8A9F2              <1> 	call os_string_compare
  2562 000037FC 0F82DDFE            <1> 	jc do_if
  2563                              <1> 
  2564 00003800 BE007B              <1> 	mov si, token			; Look for THEN to perform more operations
  2565 00003803 BF[1947]            <1> 	mov di, then_keyword
  2566 00003806 E89CF2              <1> 	call os_string_compare
  2567 00003809 7205                <1> 	jc .then_present
  2568                              <1> 
  2569 0000380B B314                <1> 	mov bl, err_syntax
  2570 0000380D E96F0D              <1> 	jmp error
  2571                              <1> 
  2572                              <1> .then_present:				; Continue rest of line like any other command!
  2573 00003810 C606[F245]01        <1> 	mov byte [last_if_true], 1
  2574 00003815 E9DEF4              <1> 	jmp mainloop
  2575                              <1> 
  2576                              <1> 
  2577                              <1> .finish_line:				; IF wasn't fulfilled, so skip rest of line
  2578 00003818 8B36[EA45]          <1> 	mov word si, [prog]
  2579 0000381C 8A04                <1> 	mov byte al, [si]
  2580 0000381E FF06[EA45]          <1> 	inc word [prog]
  2581 00003822 3C0A                <1> 	cmp al, 10
  2582 00003824 75F2                <1> 	jne .finish_line
  2583                              <1> 
  2584 00003826 C606[F245]00        <1> 	mov byte [last_if_true], 0
  2585 0000382B E9C8F4              <1> 	jmp mainloop
  2586                              <1> 
  2587                              <1> 
  2588                              <1> .error:
  2589 0000382E B314                <1> 	mov bl, err_syntax
  2590 00003830 E94C0D              <1> 	jmp error
  2591                              <1> 
  2592                              <1> 
  2593 00003833 00                  <1> 	.tmp_string_var		db 0
  2594                              <1> 
  2595                              <1> 
  2596                              <1> ; ------------------------------------------------------------------
  2597                              <1> ; INCLUDE
  2598                              <1> 
  2599                              <1> do_include:
  2600 00003834 E82F0C              <1> 	call get_token
  2601 00003837 83F805              <1> 	cmp ax, QUOTE
  2602 0000383A 7406                <1> 	je .is_ok
  2603                              <1> 
  2604 0000383C BE1400              <1> 	mov si, err_syntax
  2605 0000383F E93D0D              <1> 	jmp error
  2606                              <1> 
  2607                              <1> .is_ok:
  2608 00003842 B8007B              <1> 	mov ax, token
  2609 00003845 8B0E[EC45]          <1> 	mov word cx, [prog_end]
  2610 00003849 41                  <1> 	inc cx				; Add a bit of space after original code
  2611 0000384A 41                  <1> 	inc cx
  2612 0000384B 41                  <1> 	inc cx
  2613 0000384C 51                  <1> 	push cx
  2614 0000384D E83DD3              <1> 	call os_load_file
  2615 00003850 720A                <1> 	jc .load_fail
  2616                              <1> 
  2617 00003852 59                  <1> 	pop cx
  2618 00003853 01D9                <1> 	add cx, bx
  2619 00003855 890E[EC45]          <1> 	mov word [prog_end], cx
  2620                              <1> 
  2621 00003859 E99AF4              <1> 	jmp mainloop
  2622                              <1> 
  2623                              <1> 
  2624                              <1> .load_fail:
  2625 0000385C 59                  <1> 	pop cx
  2626 0000385D BE0400              <1> 	mov si, err_file_notfound
  2627 00003860 E91C0D              <1> 	jmp error
  2628                              <1> 
  2629                              <1> 
  2630                              <1> ; ------------------------------------------------------------------
  2631                              <1> ; INK
  2632                              <1> 
  2633                              <1> do_ink:
  2634 00003863 E8000C              <1> 	call get_token				; Get column
  2635                              <1> 
  2636 00003866 83F801              <1> 	cmp ax, VARIABLE
  2637 00003869 740C                <1> 	je .first_is_var
  2638                              <1> 
  2639 0000386B BE007B              <1> 	mov si, token
  2640 0000386E E888F2              <1> 	call os_string_to_int
  2641 00003871 A2[F345]            <1> 	mov byte [ink_colour], al
  2642 00003874 E97FF4              <1> 	jmp mainloop
  2643                              <1> 
  2644                              <1> .first_is_var:
  2645 00003877 B80000              <1> 	mov ax, 0
  2646 0000387A A0007B              <1> 	mov byte al, [token]
  2647 0000387D E8CA0B              <1> 	call get_var
  2648 00003880 A2[F345]            <1> 	mov byte [ink_colour], al
  2649 00003883 E970F4              <1> 	jmp mainloop
  2650                              <1> 
  2651                              <1> 
  2652                              <1> ; ------------------------------------------------------------------
  2653                              <1> ; INPUT
  2654                              <1> 
  2655                              <1> do_input:
  2656 00003886 B000                <1> 	mov al, 0				; Clear string from previous usage
  2657 00003888 BF807A              <1> 	mov di, .tmpstring
  2658 0000388B B98000              <1> 	mov cx, 128
  2659 0000388E F3AA                <1> 	rep stosb
  2660                              <1> 
  2661 00003890 E8D30B              <1> 	call get_token
  2662                              <1> 
  2663 00003893 83F801              <1> 	cmp ax, VARIABLE			; We can only INPUT to variables!
  2664 00003896 740B                <1> 	je .number_var
  2665                              <1> 
  2666 00003898 83F802              <1> 	cmp ax, STRING_VAR
  2667 0000389B 7437                <1> 	je .string_var
  2668                              <1> 
  2669 0000389D BE1400              <1> 	mov si, err_syntax
  2670 000038A0 E9DC0C              <1> 	jmp error
  2671                              <1> 
  2672                              <1> .number_var:
  2673 000038A3 B8807A              <1> 	mov ax, .tmpstring			; Get input from the user
  2674 000038A6 E804E9              <1> 	call os_input_string
  2675                              <1> 
  2676 000038A9 B8807A              <1> 	mov ax, .tmpstring
  2677 000038AC E804F1              <1> 	call os_string_length
  2678 000038AF 83F800              <1> 	cmp ax, 0
  2679 000038B2 750A                <1> 	jne .char_entered
  2680                              <1> 
  2681 000038B4 C606807A30          <1> 	mov byte [.tmpstring], '0'		; If enter hit, fill variable with zero
  2682 000038B9 C606817A00          <1> 	mov byte [.tmpstring + 1], 0
  2683                              <1> 
  2684                              <1> .char_entered:
  2685 000038BE BE807A              <1> 	mov si, .tmpstring			; Convert to integer format
  2686 000038C1 E835F2              <1> 	call os_string_to_int
  2687 000038C4 89C3                <1> 	mov bx, ax
  2688                              <1> 
  2689 000038C6 0FB606007B          <1> 	movzx ax, byte [token]
  2690 000038CB E8890B              <1> 	call set_var				; ...and store it!
  2691                              <1> 
  2692 000038CE E86DE6              <1> 	call os_print_newline
  2693                              <1> 
  2694 000038D1 E922F4              <1> 	jmp mainloop
  2695                              <1> 
  2696                              <1> 
  2697                              <1> .string_var:
  2698 000038D4 53                  <1> 	push bx
  2699                              <1> 
  2700 000038D5 B8807A              <1> 	mov ax, .tmpstring
  2701 000038D8 E8D2E8              <1> 	call os_input_string
  2702                              <1> 
  2703 000038DB BE807A              <1> 	mov si, .tmpstring
  2704 000038DE BF007C              <1> 	mov di, string_vars
  2705                              <1> 
  2706 000038E1 5B                  <1> 	pop bx
  2707                              <1> 
  2708 000038E2 B88000              <1> 	mov ax, 128
  2709 000038E5 F7E3                <1> 	mul bx
  2710                              <1> 
  2711 000038E7 01C7                <1> 	add di, ax
  2712 000038E9 E85AF1              <1> 	call os_string_copy
  2713                              <1> 
  2714 000038EC E84FE6              <1> 	call os_print_newline
  2715                              <1> 
  2716 000038EF E904F4              <1> 	jmp mainloop
  2717                              <1> 
  2718                              <1> 
  2719                              <1> ;	.tmpstring	times 128 db 0
  2720                              <1> 	.tmpstring	equ 32768-1024-256-128
  2721                              <1> 
  2722                              <1> ; -----------------------------------------------------------
  2723                              <1> ; LEN
  2724                              <1> 
  2725                              <1> do_len:
  2726 000038F2 E8710B              <1> 	call get_token
  2727 000038F5 83F802              <1> 	cmp ax, STRING_VAR
  2728 000038F8 7538                <1> 	jne .error
  2729                              <1>  
  2730 000038FA BE007C              <1> 	mov si, string_vars
  2731 000038FD B88000              <1> 	mov ax, 128
  2732 00003900 F7E3                <1> 	mul bx
  2733 00003902 01C6                <1> 	add si, ax
  2734                              <1> 
  2735 00003904 89F0                <1> 	mov ax, si
  2736 00003906 E8AAF0              <1> 	call os_string_length
  2737 00003909 A3[3839]            <1> 	mov word [.num1], ax
  2738                              <1> 
  2739 0000390C E8570B              <1> 	call get_token
  2740 0000390F 83F801              <1> 	cmp ax, VARIABLE
  2741 00003912 7406                <1> 	je .is_ok
  2742                              <1> 	
  2743 00003914 BE1400              <1> 	mov si, err_syntax
  2744 00003917 E9650C              <1> 	jmp error
  2745                              <1> 
  2746                              <1> .is_ok:
  2747 0000391A 0FB606007B          <1> 	movzx ax, byte [token]
  2748 0000391F 88C3                <1> 	mov bl, al
  2749 00003921 EB00                <1> 	jmp .finish
  2750                              <1> 
  2751                              <1> .finish:	
  2752 00003923 8B1E[3839]          <1> 	mov bx, [.num1]
  2753 00003927 A0007B              <1> 	mov byte al, [token]
  2754 0000392A E82A0B              <1> 	call set_var
  2755 0000392D 31C0                <1> 	xor ax, ax
  2756 0000392F E9C4F3              <1> 	jmp mainloop
  2757                              <1>  
  2758                              <1> .error:
  2759 00003932 BE1400              <1> 	mov si, err_syntax
  2760 00003935 E9470C              <1> 	jmp error
  2761                              <1> 
  2762                              <1> 
  2763 00003938 0000                <1> 	.num1 dw 0
  2764                              <1> 
  2765                              <1> 
  2766                              <1> ; ------------------------------------------------------------------
  2767                              <1> ; LISTBOX
  2768                              <1> 
  2769                              <1> do_listbox:
  2770 0000393A 8A3E[F445]          <1> 	mov bh, [work_page]			; Store the cursor position
  2771 0000393E B403                <1> 	mov ah, 03h
  2772 00003940 CD10                <1> 	int 10h
  2773                              <1> 	
  2774 00003942 E8210B              <1> 	call get_token
  2775 00003945 83F802              <1> 	cmp ax, STRING_VAR
  2776 00003948 757C                <1> 	jne .error
  2777                              <1> 
  2778 0000394A BE007C              <1> 	mov si, string_vars
  2779 0000394D B88000              <1> 	mov ax, 128
  2780 00003950 F7E3                <1> 	mul bx
  2781 00003952 01C6                <1> 	add si, ax
  2782                              <1> 
  2783 00003954 8936[CC39]          <1> 	mov word [.s1], si
  2784                              <1> 
  2785 00003958 E80B0B              <1> 	call get_token
  2786 0000395B 83F802              <1> 	cmp ax, STRING_VAR
  2787 0000395E 7566                <1> 	jne .error
  2788                              <1> 
  2789 00003960 BE007C              <1> 	mov si, string_vars
  2790 00003963 B88000              <1> 	mov ax, 128
  2791 00003966 F7E3                <1> 	mul bx
  2792 00003968 01C6                <1> 	add si, ax
  2793                              <1> 
  2794 0000396A 8936[CE39]          <1> 	mov word [.s2], si
  2795                              <1> 
  2796 0000396E E8F50A              <1> 	call get_token
  2797 00003971 83F802              <1> 	cmp ax, STRING_VAR
  2798 00003974 7550                <1> 	jne .error
  2799                              <1> 
  2800 00003976 BE007C              <1> 	mov si, string_vars
  2801 00003979 B88000              <1> 	mov ax, 128
  2802 0000397C F7E3                <1> 	mul bx
  2803 0000397E 01C6                <1> 	add si, ax
  2804                              <1> 
  2805 00003980 8936[D039]          <1> 	mov word [.s3], si
  2806                              <1> 
  2807                              <1> 
  2808 00003984 E8DF0A              <1> 	call get_token
  2809 00003987 83F801              <1> 	cmp ax, VARIABLE
  2810 0000398A 753A                <1> 	jne .error
  2811                              <1> 
  2812 0000398C A0007B              <1> 	mov byte al, [token]
  2813 0000398F A2[D239]            <1> 	mov byte [.var], al
  2814                              <1> 
  2815 00003992 A1[CC39]            <1> 	mov word ax, [.s1]
  2816 00003995 8B1E[CE39]          <1> 	mov word bx, [.s2]
  2817 00003999 8B0E[D039]          <1> 	mov word cx, [.s3]
  2818                              <1> 
  2819 0000399D E814E2              <1> 	call os_list_dialog
  2820 000039A0 7217                <1> 	jc .esc_pressed
  2821                              <1> 
  2822 000039A2 60                  <1> 	pusha
  2823 000039A3 8A3E[F445]          <1> 	mov bh, [work_page]			; Move the cursor back
  2824 000039A7 B402                <1> 	mov ah, 02h
  2825 000039A9 CD10                <1> 	int 10h
  2826 000039AB 61                  <1> 	popa
  2827                              <1> 
  2828 000039AC 89C3                <1> 	mov bx, ax
  2829 000039AE 0FB606[D239]        <1> 	movzx ax, byte [.var]
  2830 000039B3 E8A10A              <1> 	call set_var
  2831                              <1> 
  2832 000039B6 E93DF3              <1> 	jmp mainloop
  2833                              <1> 
  2834                              <1> 
  2835                              <1> .esc_pressed:
  2836 000039B9 0FB606[D239]        <1> 	movzx ax, byte [.var]
  2837 000039BE 31DB                <1> 	xor bx, bx
  2838 000039C0 E8940A              <1> 	call set_var
  2839 000039C3 E930F3              <1> 	jmp mainloop
  2840                              <1> 
  2841                              <1> 
  2842                              <1> .error:
  2843 000039C6 BE1400              <1> 	mov si, err_syntax
  2844 000039C9 E9B30B              <1> 	jmp error
  2845                              <1> 
  2846 000039CC 0000                <1> 	.s1 dw 0
  2847 000039CE 0000                <1> 	.s2 dw 0
  2848 000039D0 0000                <1> 	.s3 dw 0
  2849 000039D2 00                  <1> 	.var db 0
  2850                              <1> 
  2851                              <1> 
  2852                              <1> ; ------------------------------------------------------------------
  2853                              <1> ; LOAD
  2854                              <1> 
  2855                              <1> do_load:
  2856 000039D3 E8900A              <1> 	call get_token
  2857 000039D6 83F805              <1> 	cmp ax, QUOTE
  2858 000039D9 7411                <1> 	je .is_quote
  2859                              <1> 
  2860 000039DB 83F802              <1> 	cmp ax, STRING_VAR
  2861 000039DE 755F                <1> 	jne .error
  2862                              <1> 
  2863 000039E0 BE007C              <1> 	mov si, string_vars
  2864 000039E3 B88000              <1> 	mov ax, 128
  2865 000039E6 F7E3                <1> 	mul bx
  2866 000039E8 01C6                <1> 	add si, ax
  2867 000039EA EB03                <1> 	jmp .get_position
  2868                              <1> 
  2869                              <1> .is_quote:
  2870 000039EC BE007B              <1> 	mov si, token
  2871                              <1> 
  2872                              <1> .get_position:
  2873 000039EF 89F0                <1> 	mov ax, si
  2874 000039F1 E8DDD4              <1> 	call os_file_exists
  2875 000039F4 7239                <1> 	jc .file_not_exists
  2876                              <1> 
  2877 000039F6 89C2                <1> 	mov dx, ax			; Store for now
  2878                              <1> 
  2879 000039F8 E86B0A              <1> 	call get_token
  2880                              <1> 
  2881 000039FB 83F801              <1> 	cmp ax, VARIABLE
  2882 000039FE 7425                <1> 	je .second_is_var
  2883                              <1> 
  2884 00003A00 83F803              <1> 	cmp ax, NUMBER
  2885 00003A03 753A                <1> 	jne .error
  2886                              <1> 
  2887 00003A05 BE007B              <1> 	mov si, token
  2888 00003A08 E8EEF0              <1> 	call os_string_to_int
  2889                              <1> 
  2890                              <1> .load_part:
  2891 00003A0B 89C1                <1> 	mov cx, ax
  2892                              <1> 
  2893 00003A0D 89D0                <1> 	mov ax, dx
  2894                              <1> 
  2895 00003A0F E87BD1              <1> 	call os_load_file
  2896                              <1> 
  2897 00003A12 31C0                <1> 	xor ax, ax
  2898 00003A14 B053                <1> 	mov byte al, 'S'
  2899 00003A16 E83E0A              <1> 	call set_var
  2900                              <1> 
  2901 00003A19 31C0                <1> 	xor ax, ax
  2902 00003A1B B052                <1> 	mov byte al, 'R'
  2903 00003A1D 31DB                <1> 	xor bx, bx
  2904 00003A1F E8350A              <1> 	call set_var
  2905                              <1> 
  2906 00003A22 E9D1F2              <1> 	jmp mainloop
  2907                              <1> 
  2908                              <1> 
  2909                              <1> .second_is_var:
  2910 00003A25 0FB606007B          <1> 	movzx ax, byte [token]
  2911 00003A2A E81D0A              <1> 	call get_var
  2912 00003A2D EBDC                <1> 	jmp .load_part
  2913                              <1> 
  2914                              <1> 
  2915                              <1> .file_not_exists:
  2916 00003A2F 31C0                <1> 	xor ax, ax
  2917 00003A31 B052                <1> 	mov byte al, 'R'
  2918 00003A33 BB0100              <1> 	mov bx, 1
  2919 00003A36 E81E0A              <1> 	call set_var
  2920                              <1> 
  2921 00003A39 E82A0A              <1> 	call get_token				; Skip past the loading point -- unnecessary now
  2922                              <1> 
  2923 00003A3C E9B7F2              <1> 	jmp mainloop
  2924                              <1> 
  2925                              <1> 
  2926                              <1> .error:
  2927 00003A3F BE1400              <1> 	mov si, err_syntax
  2928 00003A42 E93A0B              <1> 	jmp error
  2929                              <1> 
  2930                              <1> 
  2931                              <1> ; ------------------------------------------------------------------
  2932                              <1> ; LOOP
  2933                              <1> 
  2934                              <1> do_loop:
  2935 00003A45 803E[F145]00        <1> 	cmp byte [loop_in], 0
  2936 00003A4A 0F84CA00            <1> 	je .no_do
  2937                              <1> 
  2938 00003A4E 802E[F145]02        <1> 	sub byte [loop_in], 2
  2939                              <1> 
  2940 00003A53 31D2                <1> 	xor dx, dx
  2941                              <1> 
  2942 00003A55 E80E0A              <1> 	call get_token
  2943 00003A58 BF007B              <1> 	mov di, token
  2944                              <1> 	
  2945 00003A5B BE[303B]            <1> 	mov si, .endless_word
  2946 00003A5E E844F0              <1> 	call os_string_compare
  2947 00003A61 0F829C00            <1> 	jc .loop_back
  2948                              <1> 	
  2949 00003A65 BE[243B]            <1> 	mov si, .while_word
  2950 00003A68 E83AF0              <1> 	call os_string_compare
  2951 00003A6B 0F82A300            <1> 	jc .while_set
  2952                              <1> 	
  2953 00003A6F BE[2A3B]            <1> 	mov si, .until_word
  2954 00003A72 E830F0              <1> 	call os_string_compare
  2955 00003A75 0F83A500            <1> 	jnc .error
  2956                              <1> 	
  2957                              <1> .get_first_var:
  2958 00003A79 E8EA09              <1> 	call get_token
  2959 00003A7C 83F801              <1> 	cmp ax, VARIABLE
  2960 00003A7F 0F859B00            <1> 	jne .error
  2961                              <1> 	
  2962 00003A83 A0007B              <1> 	mov al, [token]
  2963 00003A86 E8C109              <1> 	call get_var
  2964 00003A89 89C1                <1> 	mov cx, ax
  2965                              <1> 	
  2966                              <1> .check_equals:
  2967 00003A8B E8D809              <1> 	call get_token
  2968 00003A8E 83F807              <1> 	cmp ax, UNKNOWN
  2969 00003A91 0F858900            <1> 	jne .error
  2970                              <1> 
  2971 00003A95 A1007B              <1> 	mov ax, [token]
  2972 00003A98 3C3D                <1> 	cmp al, '='
  2973 00003A9A 740A                <1> 	je .sign_ok
  2974 00003A9C 3C3E                <1> 	cmp al, '>'
  2975 00003A9E 7406                <1> 	je .sign_ok
  2976 00003AA0 3C3C                <1> 	cmp al, '<'
  2977 00003AA2 7402                <1> 	je .sign_ok
  2978 00003AA4 EB78                <1> 	jmp .error
  2979                              <1> 	.sign_ok:
  2980 00003AA6 A2[383B]            <1> 	mov byte [.sign], al
  2981                              <1> 	
  2982                              <1> .get_second_var:
  2983 00003AA9 E8BA09              <1>  	call get_token
  2984                              <1> 
  2985 00003AAC 83F803              <1> 	cmp ax, NUMBER
  2986 00003AAF 7419                <1> 	je .second_is_num
  2987                              <1> 
  2988 00003AB1 83F801              <1> 	cmp ax, VARIABLE
  2989 00003AB4 740C                <1> 	je .second_is_var
  2990                              <1> 
  2991 00003AB6 83F806              <1> 	cmp ax, CHAR
  2992 00003AB9 7563                <1> 	jne .error
  2993                              <1> 
  2994                              <1> .second_is_char:
  2995 00003ABB B400                <1> 	mov ah, 0
  2996 00003ABD A0007B              <1> 	mov al, [token]
  2997 00003AC0 EB0E                <1> 	jmp .check_true
  2998                              <1> 	
  2999                              <1> .second_is_var:
  3000 00003AC2 A0007B              <1> 	mov al, [token]
  3001 00003AC5 E88209              <1> 	call get_var
  3002 00003AC8 EB06                <1> 	jmp .check_true
  3003                              <1> 	
  3004                              <1> .second_is_num:
  3005 00003ACA BE007B              <1> 	mov si, token
  3006 00003ACD E829F0              <1> 	call os_string_to_int
  3007                              <1> 	
  3008                              <1> .check_true:
  3009 00003AD0 8A1E[383B]          <1> 	mov byte bl, [.sign]
  3010 00003AD4 80FB3D              <1> 	cmp bl, '='
  3011 00003AD7 7407                <1> 	je .sign_equals
  3012                              <1> 	
  3013 00003AD9 80FB3E              <1> 	cmp bl, '>'
  3014 00003ADC 7408                <1> 	je .sign_greater
  3015                              <1> 	
  3016 00003ADE EB0C                <1> 	jmp .sign_lesser
  3017                              <1> 	
  3018                              <1> .sign_equals:
  3019 00003AE0 39C8                <1> 	cmp ax, cx
  3020 00003AE2 7516                <1> 	jne .false
  3021 00003AE4 EB0C                <1> 	jmp .true
  3022                              <1> 	
  3023                              <1> .sign_greater:
  3024 00003AE6 39C8                <1> 	cmp ax, cx
  3025 00003AE8 7D10                <1> 	jge .false
  3026 00003AEA EB06                <1> 	jmp .true
  3027                              <1> 	
  3028                              <1> .sign_lesser:
  3029 00003AEC 39C8                <1> 	cmp ax, cx
  3030 00003AEE 7E0A                <1> 	jle .false
  3031 00003AF0 EB00                <1> 	jmp .true
  3032                              <1> .true:
  3033 00003AF2 83FA01              <1> 	cmp dx, 1
  3034 00003AF5 740A                <1> 	je .loop_back
  3035 00003AF7 E9FCF1              <1> 	jmp mainloop
  3036                              <1> .false:
  3037 00003AFA 83FA01              <1> 	cmp dx, 1
  3038 00003AFD 0F84F5F1            <1> 	je mainloop
  3039                              <1> 	
  3040                              <1> .loop_back:	
  3041 00003B01 BED079              <1> 	mov word si, do_loop_store
  3042 00003B04 A0[F145]            <1> 	mov byte al, [loop_in]
  3043 00003B07 B400                <1> 	mov ah, 0
  3044 00003B09 01C6                <1> 	add si, ax
  3045 00003B0B AD                  <1> 	lodsw
  3046 00003B0C A3[EA45]            <1> 	mov word [prog], ax
  3047 00003B0F E9E4F1              <1> 	jmp mainloop
  3048                              <1> 	
  3049                              <1> .while_set:
  3050 00003B12 BA0100              <1> 	mov dx, 1
  3051 00003B15 E961FF              <1> 	jmp .get_first_var
  3052                              <1> 	
  3053                              <1> .no_do:
  3054 00003B18 BE0900              <1> 	mov si, err_loop
  3055 00003B1B E9610A              <1> 	jmp error
  3056                              <1> 
  3057                              <1> .error:
  3058 00003B1E BE1400              <1> 	mov si, err_syntax
  3059 00003B21 E95B0A              <1> 	jmp error
  3060                              <1> 	
  3061                              <1> .data:
  3062 00003B24 5748494C4500        <1> 	.while_word			db "WHILE", 0
  3063 00003B2A 554E54494C00        <1> 	.until_word			db "UNTIL", 0
  3064 00003B30 454E444C45535300    <1> 	.endless_word			db "ENDLESS", 0
  3065 00003B38 00                  <1> 	.sign				db 0
  3066                              <1> 	
  3067                              <1> 	
  3068                              <1> ; ------------------------------------------------------------------
  3069                              <1> ; MOVE
  3070                              <1> 
  3071                              <1> do_move:
  3072 00003B39 E82A09              <1> 	call get_token
  3073                              <1> 
  3074 00003B3C 83F801              <1> 	cmp ax, VARIABLE
  3075 00003B3F 740A                <1> 	je .first_is_var
  3076                              <1> 
  3077 00003B41 BE007B              <1> 	mov si, token
  3078 00003B44 E8B2EF              <1> 	call os_string_to_int
  3079 00003B47 88C2                <1> 	mov dl, al
  3080 00003B49 EB0A                <1> 	jmp .onto_second
  3081                              <1> 
  3082                              <1> .first_is_var:
  3083 00003B4B 0FB606007B          <1> 	movzx ax, byte [token]
  3084 00003B50 E8F708              <1> 	call get_var
  3085 00003B53 88C2                <1> 	mov dl, al
  3086                              <1> 
  3087                              <1> .onto_second:
  3088 00003B55 E80E09              <1> 	call get_token
  3089                              <1> 
  3090 00003B58 83F801              <1> 	cmp ax, VARIABLE
  3091 00003B5B 740A                <1> 	je .second_is_var
  3092                              <1> 
  3093 00003B5D BE007B              <1> 	mov si, token
  3094 00003B60 E896EF              <1> 	call os_string_to_int
  3095 00003B63 88C6                <1> 	mov dh, al
  3096 00003B65 EB0A                <1> 	jmp .finish
  3097                              <1> 
  3098                              <1> .second_is_var:
  3099 00003B67 0FB606007B          <1> 	movzx ax, byte [token]
  3100 00003B6C E8DB08              <1> 	call get_var
  3101 00003B6F 88C6                <1> 	mov dh, al
  3102                              <1> 
  3103                              <1> .finish:
  3104 00003B71 8A3E[F445]          <1> 	mov byte bh, [work_page]
  3105 00003B75 B402                <1> 	mov ah, 2
  3106 00003B77 CD10                <1> 	int 10h
  3107                              <1> 
  3108 00003B79 E97AF1              <1> 	jmp mainloop
  3109                              <1> 
  3110                              <1> 
  3111                              <1> ; ------------------------------------------------------------------
  3112                              <1> ; NEXT
  3113                              <1> 
  3114                              <1> do_next:
  3115 00003B7C E8E708              <1> 	call get_token
  3116                              <1> 
  3117 00003B7F 83F801              <1> 	cmp ax, VARIABLE			; NEXT must be followed by a variable
  3118 00003B82 753F                <1> 	jne .error
  3119                              <1> 
  3120 00003B84 0FB606007B          <1> 	movzx ax, byte [token]
  3121 00003B89 E8BE08              <1> 	call get_var
  3122                              <1> 
  3123 00003B8C 40                  <1> 	inc ax					; NEXT increments the variable, of course!
  3124                              <1> 
  3125 00003B8D 89C3                <1> 	mov bx, ax
  3126                              <1> 
  3127 00003B8F 0FB606007B          <1> 	movzx ax, byte [token]
  3128                              <1> 
  3129 00003B94 2C41                <1> 	sub al, 65
  3130 00003B96 BE187A              <1> 	mov si, for_variables
  3131 00003B99 01C6                <1> 	add si, ax
  3132 00003B9B 01C6                <1> 	add si, ax
  3133 00003B9D AD                  <1> 	lodsw					; Get the target number from the table
  3134                              <1> 
  3135 00003B9E 40                  <1> 	inc ax					; (Make the loop inclusive of target number)
  3136 00003B9F 39D8                <1> 	cmp ax, bx				; Do the variable and target match?
  3137 00003BA1 741D                <1> 	je .loop_finished
  3138                              <1> 
  3139 00003BA3 0FB606007B          <1> 	movzx ax, byte [token]
  3140 00003BA8 E8AC08              <1> 	call set_var
  3141                              <1> 
  3142 00003BAB 0FB606007B          <1> 	movzx ax, byte [token]
  3143 00003BB0 2C41                <1> 	sub al, 65
  3144 00003BB2 BEE479              <1> 	mov si, for_code_points
  3145 00003BB5 01C6                <1> 	add si, ax
  3146 00003BB7 01C6                <1> 	add si, ax
  3147 00003BB9 AD                  <1> 	lodsw
  3148                              <1> 
  3149 00003BBA A3[EA45]            <1> 	mov word [prog], ax
  3150 00003BBD E936F1              <1> 	jmp mainloop
  3151                              <1> 
  3152                              <1> 
  3153                              <1> .loop_finished:
  3154 00003BC0 E933F1              <1> 	jmp mainloop
  3155                              <1> 
  3156                              <1> .error:
  3157 00003BC3 BE1400              <1> 	mov si, err_syntax
  3158 00003BC6 E9B609              <1> 	jmp error
  3159                              <1> 
  3160                              <1> 
  3161                              <1> 
  3162                              <1> ;-------------------------------------------------------------------
  3163                              <1> ; NUMBER
  3164                              <1> 
  3165                              <1> do_number:
  3166 00003BC9 E89A08              <1> 	call get_token			; Check if it's string to number, or number to string
  3167                              <1> 
  3168 00003BCC 83F802              <1> 	cmp ax, STRING_VAR
  3169 00003BCF 7407                <1> 	je .is_string
  3170                              <1> 
  3171 00003BD1 83F801              <1> 	cmp ax, VARIABLE
  3172 00003BD4 742C                <1> 	je .is_variable
  3173                              <1> 
  3174 00003BD6 EB54                <1> 	jmp .error
  3175                              <1> 
  3176                              <1> .is_string:
  3177                              <1> 
  3178 00003BD8 BE007C              <1> 	mov si, string_vars
  3179 00003BDB B88000              <1> 	mov ax, 128
  3180 00003BDE F7E3                <1> 	mul bx
  3181 00003BE0 01C6                <1> 	add si, ax
  3182 00003BE2 8936[323C]          <1> 	mov [.tmp], si
  3183                              <1> 
  3184 00003BE6 E87D08              <1> 	call get_token
  3185                              <1> 
  3186 00003BE9 8B36[323C]          <1> 	mov si, [.tmp]
  3187                              <1> 
  3188 00003BED 83F801              <1> 	cmp ax, VARIABLE
  3189 00003BF0 753A                <1> 	jne .error
  3190                              <1> 
  3191 00003BF2 E804EF              <1> 	call os_string_to_int
  3192 00003BF5 89C3                <1> 	mov bx, ax
  3193                              <1> 
  3194 00003BF7 0FB606007B          <1> 	movzx ax, byte [token]
  3195 00003BFC E85808              <1> 	call set_var
  3196                              <1> 
  3197 00003BFF E9F4F0              <1> 	jmp mainloop
  3198                              <1> 
  3199                              <1> .is_variable:
  3200 00003C02 0FB606007B          <1> 	movzx ax, byte [token]
  3201 00003C07 E84008              <1> 	call get_var
  3202                              <1> 
  3203 00003C0A E837EF              <1> 	call os_int_to_string		; Convert to a string
  3204 00003C0D A3[323C]            <1> 	mov [.tmp], ax
  3205                              <1> 
  3206 00003C10 E85308              <1> 	call get_token			; Get the second parameter
  3207                              <1> 
  3208 00003C13 8B36[323C]          <1> 	mov si, [.tmp]
  3209                              <1> 
  3210 00003C17 83F802              <1> 	cmp ax, STRING_VAR		; Make sure it's a string variable
  3211 00003C1A 7510                <1> 	jne .error
  3212                              <1> 
  3213 00003C1C BF007C              <1> 	mov di, string_vars		; Locate string variable
  3214 00003C1F B88000              <1> 	mov ax, 128
  3215 00003C22 F7E3                <1> 	mul bx
  3216 00003C24 01C7                <1> 	add di, ax
  3217                              <1> 
  3218 00003C26 E81DEE              <1> 	call os_string_copy		; Save converted string
  3219                              <1> 
  3220 00003C29 E9CAF0              <1> 	jmp mainloop
  3221                              <1> 
  3222                              <1> .error:
  3223 00003C2C BE1400              <1> 	mov si, err_syntax
  3224 00003C2F E94D09              <1> 	jmp error
  3225                              <1> 
  3226                              <1> 
  3227 00003C32 0000                <1> 	.tmp		dw 	0
  3228                              <1> 
  3229                              <1> 
  3230                              <1> ;-------------------------------------------------------------------
  3231                              <1> ; PAGE
  3232                              <1> 
  3233                              <1> do_page:
  3234 00003C34 E82F08              <1> 	call get_token
  3235 00003C37 83F803              <1> 	cmp ax, NUMBER
  3236 00003C3A 7521                <1> 	jne .error
  3237                              <1> 
  3238 00003C3C BE007B              <1> 	mov si, token
  3239 00003C3F E8B7EE              <1> 	call os_string_to_int
  3240 00003C42 A2[F445]            <1> 	mov byte [work_page], al	; Set work page variable
  3241                              <1> 
  3242 00003C45 E81E08              <1> 	call get_token
  3243 00003C48 83F803              <1> 	cmp ax, NUMBER
  3244 00003C4B 7510                <1> 	jne .error
  3245                              <1> 
  3246 00003C4D BE007B              <1> 	mov si, token
  3247 00003C50 E8A6EE              <1> 	call os_string_to_int
  3248 00003C53 A2[F545]            <1> 	mov byte [disp_page], al	; Set display page variable
  3249                              <1> 
  3250                              <1> 	; Change display page -- AL should already be present from the os_string_to_int
  3251 00003C56 B405                <1> 	mov ah, 5
  3252 00003C58 CD10                <1> 	int 10h
  3253                              <1> 
  3254 00003C5A E999F0              <1> 	jmp mainloop
  3255                              <1> 
  3256                              <1> .error:
  3257 00003C5D BE1400              <1> 	mov si, err_syntax
  3258 00003C60 E91C09              <1> 	jmp error
  3259                              <1> 
  3260                              <1> 
  3261                              <1> ; ------------------------------------------------------------------
  3262                              <1> ; PAUSE
  3263                              <1> 
  3264                              <1> do_pause:
  3265 00003C63 E80008              <1> 	call get_token
  3266                              <1> 
  3267 00003C66 83F801              <1> 	cmp ax, VARIABLE
  3268 00003C69 7408                <1> 	je .is_var
  3269                              <1> 
  3270 00003C6B BE007B              <1> 	mov si, token
  3271 00003C6E E888EE              <1> 	call os_string_to_int
  3272 00003C71 EB08                <1> 	jmp .finish
  3273                              <1> 
  3274                              <1> .is_var:
  3275 00003C73 0FB606007B          <1> 	movzx ax, byte [token]
  3276 00003C78 E8CF07              <1> 	call get_var
  3277                              <1> 
  3278                              <1> .finish:
  3279 00003C7B E84ED8              <1> 	call os_pause
  3280 00003C7E E975F0              <1> 	jmp mainloop
  3281                              <1> 
  3282                              <1> 
  3283                              <1> ; ------------------------------------------------------------------
  3284                              <1> ; PEEK
  3285                              <1> 
  3286                              <1> do_peek:
  3287 00003C81 E8E207              <1> 	call get_token
  3288                              <1> 
  3289 00003C84 83F801              <1> 	cmp ax, VARIABLE
  3290 00003C87 7533                <1> 	jne .error
  3291                              <1> 
  3292 00003C89 0FB606007B          <1> 	movzx ax, byte [token]
  3293 00003C8E A2[C23C]            <1> 	mov byte [.tmp_var], al
  3294                              <1> 
  3295 00003C91 E8D207              <1> 	call get_token
  3296                              <1> 
  3297 00003C94 83F801              <1> 	cmp ax, VARIABLE
  3298 00003C97 741B                <1> 	je .dereference
  3299                              <1> 
  3300 00003C99 83F803              <1> 	cmp ax, NUMBER
  3301 00003C9C 751E                <1> 	jne .error
  3302                              <1> 
  3303 00003C9E BE007B              <1> 	mov si, token
  3304 00003CA1 E855EE              <1> 	call os_string_to_int
  3305                              <1> 
  3306                              <1> .store:
  3307 00003CA4 89C6                <1> 	mov si, ax
  3308 00003CA6 0FB61C              <1> 	movzx bx, byte [si]
  3309 00003CA9 0FB606[C23C]        <1> 	movzx ax, byte [.tmp_var]
  3310 00003CAE E8A607              <1> 	call set_var
  3311                              <1> 
  3312 00003CB1 E942F0              <1> 	jmp mainloop
  3313                              <1> 
  3314                              <1> .dereference:
  3315 00003CB4 A0007B              <1> 	mov byte al, [token]
  3316 00003CB7 E89007              <1> 	call get_var
  3317 00003CBA EBE8                <1> 	jmp .store
  3318                              <1> 
  3319                              <1> .error:
  3320 00003CBC BE1400              <1> 	mov si, err_syntax
  3321 00003CBF E9BD08              <1> 	jmp error
  3322                              <1> 
  3323                              <1> 
  3324 00003CC2 00                  <1> 	.tmp_var	db 0
  3325                              <1> 	
  3326                              <1> 	
  3327                              <1> 	
  3328                              <1> ; ------------------------------------------------------------------
  3329                              <1> ; PEEKINT
  3330                              <1> 
  3331                              <1> do_peekint:
  3332 00003CC3 E8A007              <1> 	call get_token
  3333                              <1> 	
  3334 00003CC6 83F801              <1> 	cmp ax, VARIABLE
  3335 00003CC9 752C                <1> 	jne .error
  3336                              <1> 
  3337                              <1> .get_second:
  3338 00003CCB A0007B              <1> 	mov al, [token]
  3339 00003CCE 89C1                <1> 	mov cx, ax
  3340                              <1> 	
  3341 00003CD0 E89307              <1> 	call get_token
  3342                              <1> 	
  3343 00003CD3 83F801              <1> 	cmp ax, VARIABLE
  3344 00003CD6 740D                <1> 	je .address_is_var
  3345                              <1> 	
  3346 00003CD8 83F803              <1> 	cmp ax, NUMBER
  3347 00003CDB 751A                <1> 	jne .error
  3348                              <1> 	
  3349                              <1> .address_is_number:
  3350 00003CDD BE007B              <1> 	mov si, token
  3351 00003CE0 E816EE              <1> 	call os_string_to_int
  3352 00003CE3 EB06                <1> 	jmp .load_data
  3353                              <1> 	
  3354                              <1> .address_is_var:
  3355 00003CE5 A0007B              <1> 	mov al, [token]
  3356 00003CE8 E85F07              <1> 	call get_var
  3357                              <1> 	
  3358                              <1> .load_data:
  3359 00003CEB 89C6                <1> 	mov si, ax
  3360 00003CED 8B1C                <1> 	mov bx, [si]
  3361 00003CEF 89C8                <1> 	mov ax, cx
  3362 00003CF1 E86307              <1> 	call set_var
  3363                              <1> 	
  3364 00003CF4 E9FFEF              <1> 	jmp mainloop
  3365                              <1> 	
  3366                              <1> .error:
  3367 00003CF7 BE1400              <1> 	mov si, err_syntax
  3368 00003CFA E98208              <1> 	jmp error
  3369                              <1> 
  3370                              <1> 
  3371                              <1> 
  3372                              <1> ; ------------------------------------------------------------------
  3373                              <1> ; POKE
  3374                              <1> 
  3375                              <1> do_poke:
  3376 00003CFD E86607              <1> 	call get_token
  3377                              <1> 
  3378 00003D00 83F801              <1> 	cmp ax, VARIABLE
  3379 00003D03 7415                <1> 	je .first_is_var
  3380                              <1> 
  3381 00003D05 83F803              <1> 	cmp ax, NUMBER
  3382 00003D08 7544                <1> 	jne .error
  3383                              <1> 
  3384 00003D0A BE007B              <1> 	mov si, token
  3385 00003D0D E8E9ED              <1> 	call os_string_to_int
  3386                              <1> 
  3387 00003D10 3DFF00              <1> 	cmp ax, 255
  3388 00003D13 7F39                <1> 	jg .error
  3389                              <1> 
  3390 00003D15 A2[543D]            <1> 	mov byte [.first_value], al
  3391 00003D18 EB0B                <1> 	jmp .onto_second
  3392                              <1> 
  3393                              <1> 
  3394                              <1> .first_is_var:
  3395 00003D1A 0FB606007B          <1> 	movzx ax, byte [token]
  3396 00003D1F E82807              <1> 	call get_var
  3397                              <1> 
  3398 00003D22 A2[543D]            <1> 	mov byte [.first_value], al
  3399                              <1> 
  3400                              <1> .onto_second:
  3401 00003D25 E83E07              <1> 	call get_token
  3402                              <1> 
  3403 00003D28 83F801              <1> 	cmp ax, VARIABLE
  3404 00003D2B 7417                <1> 	je .second_is_var
  3405                              <1> 
  3406 00003D2D 83F803              <1> 	cmp ax, NUMBER
  3407 00003D30 751C                <1> 	jne .error
  3408                              <1> 
  3409 00003D32 BE007B              <1> 	mov si, token
  3410 00003D35 E8C1ED              <1> 	call os_string_to_int
  3411                              <1> 
  3412                              <1> .got_value:
  3413 00003D38 89C7                <1> 	mov di, ax
  3414 00003D3A 0FB606[543D]        <1> 	movzx ax, byte [.first_value]
  3415 00003D3F 8805                <1> 	mov byte [di], al
  3416                              <1> 
  3417 00003D41 E9B2EF              <1> 	jmp mainloop
  3418                              <1> 
  3419                              <1> .second_is_var:
  3420 00003D44 0FB606007B          <1> 	movzx ax, byte [token]
  3421 00003D49 E8FE06              <1> 	call get_var
  3422 00003D4C EBEA                <1> 	jmp .got_value
  3423                              <1> 
  3424                              <1> .error:
  3425 00003D4E BE1400              <1> 	mov si, err_syntax
  3426 00003D51 E92B08              <1> 	jmp error
  3427                              <1> 
  3428                              <1> 
  3429 00003D54 00                  <1> 	.first_value	db 0
  3430                              <1> 
  3431                              <1> 
  3432                              <1> 
  3433                              <1> 
  3434                              <1> ; ------------------------------------------------------------------
  3435                              <1> ; POKEINT
  3436                              <1> 
  3437                              <1> do_pokeint:
  3438 00003D55 E80E07              <1> 	call get_token
  3439                              <1> 	
  3440 00003D58 83F801              <1> 	cmp ax, VARIABLE
  3441 00003D5B 740D                <1> 	je .data_is_var
  3442                              <1> 	
  3443 00003D5D 83F803              <1> 	cmp ax, NUMBER
  3444 00003D60 7532                <1> 	jne .error
  3445                              <1> 
  3446                              <1> .data_is_num:
  3447 00003D62 BE007B              <1> 	mov si, token
  3448 00003D65 E891ED              <1> 	call os_string_to_int
  3449 00003D68 EB06                <1> 	jmp .get_second
  3450                              <1> 	
  3451                              <1> .data_is_var:
  3452 00003D6A A0007B              <1> 	mov al, [token]
  3453 00003D6D E8DA06              <1> 	call get_var
  3454                              <1> 	
  3455                              <1> .get_second:
  3456 00003D70 89C1                <1> 	mov cx, ax
  3457                              <1> 	
  3458 00003D72 E8F106              <1> 	call get_token
  3459                              <1> 	
  3460 00003D75 83F801              <1> 	cmp ax, VARIABLE
  3461 00003D78 740D                <1> 	je .address_is_var
  3462                              <1> 	
  3463 00003D7A 83F803              <1> 	cmp ax, NUMBER
  3464 00003D7D 7515                <1> 	jne .error
  3465                              <1> 	
  3466                              <1> .address_is_num:
  3467 00003D7F BE007B              <1> 	mov si, token
  3468 00003D82 E874ED              <1> 	call os_string_to_int
  3469 00003D85 EB06                <1> 	jmp .save_data
  3470                              <1> 	
  3471                              <1> .address_is_var:
  3472 00003D87 A0007B              <1> 	mov al, [token]
  3473 00003D8A E8BD06              <1> 	call get_var
  3474                              <1> 	
  3475                              <1> .save_data:
  3476 00003D8D 89C6                <1> 	mov si, ax
  3477 00003D8F 890C                <1> 	mov [si], cx
  3478                              <1> 	
  3479 00003D91 E962EF              <1> 	jmp mainloop
  3480                              <1> 	
  3481                              <1> .error:
  3482 00003D94 BE1400              <1> 	mov si, err_syntax
  3483 00003D97 E9E507              <1> 	jmp error
  3484                              <1> 
  3485                              <1> 
  3486                              <1> 
  3487                              <1> 
  3488                              <1> ; ------------------------------------------------------------------
  3489                              <1> ; PORT
  3490                              <1> 
  3491                              <1> do_port:
  3492 00003D9A E8C906              <1> 	call get_token
  3493 00003D9D BE007B              <1> 	mov si, token
  3494                              <1> 
  3495 00003DA0 BF[153E]            <1> 	mov di, .out_cmd
  3496 00003DA3 E8FFEC              <1> 	call os_string_compare
  3497 00003DA6 720A                <1> 	jc .do_out_cmd
  3498                              <1> 
  3499 00003DA8 BF[193E]            <1> 	mov di, .in_cmd
  3500 00003DAB E8F7EC              <1> 	call os_string_compare
  3501 00003DAE 7237                <1> 	jc .do_in_cmd
  3502                              <1> 
  3503 00003DB0 EB5D                <1> 	jmp .error
  3504                              <1> 
  3505                              <1> 
  3506                              <1> .do_out_cmd:
  3507 00003DB2 E8B106              <1> 	call get_token
  3508 00003DB5 83F803              <1> 	cmp ax, NUMBER
  3509 00003DB8 7555                <1> 	jne .error
  3510                              <1> 
  3511 00003DBA BE007B              <1> 	mov si, token
  3512 00003DBD E839ED              <1> 	call os_string_to_int		; Now AX = port number
  3513 00003DC0 89C2                <1> 	mov dx, ax
  3514                              <1> 
  3515 00003DC2 E8A106              <1> 	call get_token
  3516 00003DC5 83F803              <1> 	cmp ax, NUMBER
  3517 00003DC8 7407                <1> 	je .out_is_num
  3518                              <1> 
  3519 00003DCA 83F801              <1> 	cmp ax, VARIABLE
  3520 00003DCD 740C                <1> 	je .out_is_var
  3521                              <1> 
  3522 00003DCF EB3E                <1> 	jmp .error
  3523                              <1> 
  3524                              <1> .out_is_num:
  3525 00003DD1 BE007B              <1> 	mov si, token
  3526 00003DD4 E822ED              <1> 	call os_string_to_int
  3527 00003DD7 EE                  <1> 	out dx, al
  3528 00003DD8 E91BEF              <1> 	jmp mainloop
  3529                              <1> 
  3530                              <1> .out_is_var:
  3531 00003DDB 0FB606007B          <1> 	movzx ax, byte [token]
  3532 00003DE0 E86706              <1> 	call get_var
  3533                              <1> 
  3534 00003DE3 EE                  <1> 	out dx, al
  3535 00003DE4 E90FEF              <1> 	jmp mainloop
  3536                              <1> 
  3537                              <1> 
  3538                              <1> .do_in_cmd:
  3539 00003DE7 E87C06              <1> 	call get_token
  3540 00003DEA 83F803              <1> 	cmp ax, NUMBER
  3541 00003DED 7520                <1> 	jne .error
  3542                              <1> 
  3543 00003DEF BE007B              <1> 	mov si, token
  3544 00003DF2 E804ED              <1> 	call os_string_to_int
  3545 00003DF5 89C2                <1> 	mov dx, ax
  3546                              <1> 
  3547 00003DF7 E86C06              <1> 	call get_token
  3548 00003DFA 83F801              <1> 	cmp ax, VARIABLE
  3549 00003DFD 7510                <1> 	jne .error
  3550                              <1> 
  3551 00003DFF 8A0E007B            <1> 	mov byte cl, [token]
  3552                              <1> 
  3553 00003E03 EC                  <1> 	in al, dx
  3554 00003E04 0FB6D8              <1> 	movzx bx, al
  3555                              <1> 
  3556 00003E07 88C8                <1> 	mov al, cl
  3557 00003E09 E84B06              <1> 	call set_var
  3558                              <1> 
  3559 00003E0C E9E7EE              <1> 	jmp mainloop
  3560                              <1> 
  3561                              <1> 
  3562                              <1> .error:
  3563 00003E0F BE1400              <1> 	mov si, err_syntax
  3564 00003E12 E96A07              <1> 	jmp error
  3565                              <1> 
  3566                              <1> 
  3567 00003E15 4F555400            <1> 	.out_cmd	db "OUT", 0
  3568 00003E19 494E00              <1> 	.in_cmd		db "IN", 0
  3569                              <1> 
  3570                              <1> 
  3571                              <1> ; ------------------------------------------------------------------
  3572                              <1> ; PRINT
  3573                              <1> 
  3574                              <1> do_print:
  3575 00003E1C E84706              <1> 	call get_token				; Get part after PRINT
  3576                              <1> 
  3577 00003E1F 83F805              <1> 	cmp ax, QUOTE				; What type is it?
  3578 00003E22 7428                <1> 	je .print_quote
  3579                              <1> 
  3580 00003E24 83F801              <1> 	cmp ax, VARIABLE			; Numerical variable (eg X)
  3581 00003E27 7410                <1> 	je .print_var
  3582                              <1> 
  3583 00003E29 83F802              <1> 	cmp ax, STRING_VAR			; String variable (eg $1)
  3584 00003E2C 7457                <1> 	je .print_string_var
  3585                              <1> 
  3586 00003E2E 83F804              <1> 	cmp ax, STRING				; Special keyword (eg CHR or HEX)
  3587 00003E31 745E                <1> 	je .print_keyword
  3588                              <1> 
  3589 00003E33 BE1000              <1> 	mov si, err_print_type			; We only print quoted strings and vars!
  3590 00003E36 E94607              <1> 	jmp error
  3591                              <1> 
  3592                              <1> 
  3593                              <1> .print_var:
  3594 00003E39 0FB606007B          <1> 	movzx ax, byte [token]
  3595 00003E3E E80906              <1> 	call get_var				; Get its value
  3596                              <1> 
  3597 00003E41 E800ED              <1> 	call os_int_to_string			; Convert to string
  3598 00003E44 89C6                <1> 	mov si, ax
  3599 00003E46 E8ACD9              <1> 	call os_print_string
  3600                              <1> 
  3601 00003E49 E9C500              <1> 	jmp .newline_or_not
  3602                              <1> 
  3603                              <1> 
  3604                              <1> .print_quote:					; If it's quoted text, print it
  3605 00003E4C BE007B              <1> 	mov si, token
  3606                              <1> .print_quote_loop:
  3607 00003E4F AC                  <1> 	lodsb
  3608 00003E50 3C00                <1> 	cmp al, 0
  3609 00003E52 0F84BB00            <1> 	je .newline_or_not
  3610                              <1> 
  3611 00003E56 B409                <1> 	mov ah, 09h
  3612 00003E58 8A1E[F345]          <1> 	mov byte bl, [ink_colour]
  3613 00003E5C 8A3E[F445]          <1> 	mov byte bh, [work_page]
  3614 00003E60 B90100              <1> 	mov cx, 1
  3615 00003E63 CD10                <1> 	int 10h
  3616                              <1> 
  3617 00003E65 B403                <1> 	mov ah, 3
  3618 00003E67 CD10                <1> 	int 10h
  3619                              <1> 
  3620 00003E69 80FA4F              <1> 	cmp dl, 79
  3621 00003E6C 7D0C                <1> 	jge .quote_newline
  3622 00003E6E FEC2                <1> 	inc dl
  3623                              <1> 
  3624                              <1> .move_cur_quote:
  3625 00003E70 8A3E[F445]          <1> 	mov byte bh, [work_page]
  3626 00003E74 B402                <1> 	mov ah, 02h
  3627 00003E76 CD10                <1> 	int 10h
  3628 00003E78 EBD5                <1> 	jmp .print_quote_loop
  3629                              <1> 
  3630                              <1> 
  3631                              <1> .quote_newline:
  3632 00003E7A 80FE18              <1> 	cmp dh, 24
  3633 00003E7D 74F1                <1> 	je .move_cur_quote
  3634 00003E7F B200                <1> 	mov dl, 0
  3635 00003E81 FEC6                <1> 	inc dh
  3636 00003E83 EBEB                <1> 	jmp .move_cur_quote
  3637                              <1> 
  3638                              <1> .print_string_var:
  3639 00003E85 BE007C              <1> 	mov si, string_vars
  3640 00003E88 B88000              <1> 	mov ax, 128
  3641 00003E8B F7E3                <1> 	mul bx
  3642 00003E8D 01C6                <1> 	add si, ax
  3643                              <1> 
  3644 00003E8F EBBE                <1> 	jmp .print_quote_loop
  3645                              <1> 
  3646                              <1> 
  3647                              <1> .print_keyword:
  3648 00003E91 BE007B              <1> 	mov si, token
  3649 00003E94 BF[1E47]            <1> 	mov di, chr_keyword
  3650 00003E97 E80BEC              <1> 	call os_string_compare
  3651 00003E9A 720E                <1> 	jc .is_chr
  3652                              <1> 
  3653 00003E9C BF[2247]            <1> 	mov di, hex_keyword
  3654 00003E9F E803EC              <1> 	call os_string_compare
  3655 00003EA2 7243                <1> 	jc .is_hex
  3656                              <1> 
  3657 00003EA4 BE1400              <1> 	mov si, err_syntax
  3658 00003EA7 E9D506              <1> 	jmp error
  3659                              <1> 
  3660                              <1> .is_chr:
  3661 00003EAA E8B905              <1> 	call get_token
  3662                              <1> 
  3663 00003EAD 83F801              <1> 	cmp ax, VARIABLE
  3664 00003EB0 7405                <1> 	je .is_chr_variable
  3665                              <1> 	
  3666 00003EB2 83F803              <1> 	cmp ax, NUMBER
  3667 00003EB5 740A                <1> 	je .is_chr_number
  3668                              <1> 
  3669                              <1> .is_chr_variable:
  3670 00003EB7 0FB606007B          <1> 	movzx ax, byte [token]
  3671 00003EBC E88B05              <1> 	call get_var
  3672 00003EBF EB06                <1> 	jmp .print_chr
  3673                              <1> 	
  3674                              <1> .is_chr_number:
  3675 00003EC1 BE007B              <1> 	mov si, token
  3676 00003EC4 E832EC              <1> 	call os_string_to_int
  3677                              <1> 
  3678                              <1> .print_chr:
  3679 00003EC7 B409                <1> 	mov ah, 09h
  3680 00003EC9 8A1E[F345]          <1> 	mov byte bl, [ink_colour]
  3681 00003ECD 8A3E[F445]          <1> 	mov byte bh, [work_page]
  3682 00003ED1 B90100              <1> 	mov cx, 1
  3683 00003ED4 CD10                <1> 	int 10h
  3684                              <1> 
  3685 00003ED6 B403                <1> 	mov ah, 3		; Move the cursor forward
  3686 00003ED8 CD10                <1> 	int 10h
  3687 00003EDA FEC2                <1> 	inc dl
  3688 00003EDC 80FA4F              <1> 	cmp dl, 79
  3689 00003EDF 7F1B                <1> 	jg .end_line		; If it's over the end of the line
  3690                              <1> .move_cur:
  3691 00003EE1 B402                <1> 	mov ah, 2
  3692 00003EE3 CD10                <1> 	int 10h
  3693                              <1> 
  3694 00003EE5 EB2A                <1> 	jmp .newline_or_not
  3695                              <1> 
  3696                              <1> 
  3697                              <1> .is_hex:
  3698 00003EE7 E87C05              <1> 	call get_token
  3699                              <1> 
  3700 00003EEA 83F801              <1> 	cmp ax, VARIABLE
  3701 00003EED 751C                <1> 	jne .error
  3702                              <1> 
  3703 00003EEF 0FB606007B          <1> 	movzx ax, byte [token]
  3704 00003EF4 E85305              <1> 	call get_var
  3705                              <1> 
  3706 00003EF7 E898E2              <1> 	call os_print_2hex
  3707                              <1> 
  3708 00003EFA EB15                <1> 	jmp .newline_or_not
  3709                              <1> 
  3710                              <1> .end_line:
  3711 00003EFC B200                <1> 	mov dl, 0
  3712 00003EFE FEC6                <1> 	inc dh
  3713 00003F00 80FE19              <1> 	cmp dh, 25
  3714 00003F03 7CDC                <1> 	jl .move_cur
  3715 00003F05 B618                <1> 	mov dh, 24
  3716 00003F07 B24F                <1> 	mov dl, 79
  3717 00003F09 EBD6                <1> 	jmp .move_cur
  3718                              <1> 
  3719                              <1> .error:
  3720 00003F0B BE1400              <1> 	mov si, err_syntax
  3721 00003F0E E96E06              <1> 	jmp error
  3722                              <1> 	
  3723                              <1> 
  3724                              <1> 
  3725                              <1> .newline_or_not:
  3726                              <1> 	; We want to see if the command ends with ';' -- which means that
  3727                              <1> 	; we shouldn't print a newline after it finishes. So we store the
  3728                              <1> 	; current program location to pop ahead and see if there's the ';'
  3729                              <1> 	; character -- otherwise we put the program location back and resume
  3730                              <1> 	; the main loop
  3731                              <1> 
  3732 00003F11 A1[EA45]            <1> 	mov word ax, [prog]
  3733 00003F14 A3[473F]            <1> 	mov word [.tmp_loc], ax
  3734                              <1> 
  3735 00003F17 E84C05              <1> 	call get_token
  3736 00003F1A 83F807              <1> 	cmp ax, UNKNOWN
  3737 00003F1D 750C                <1> 	jne .ignore
  3738                              <1> 
  3739 00003F1F 0FB606007B          <1> 	movzx ax, byte [token]
  3740 00003F24 3C3B                <1> 	cmp al, ';'
  3741 00003F26 7503                <1> 	jne .ignore
  3742                              <1> 
  3743 00003F28 E9CBED              <1> 	jmp mainloop				; And go back to interpreting the code!
  3744                              <1> 
  3745                              <1> .ignore:
  3746 00003F2B B405                <1> 	mov ah, 5
  3747 00003F2D A0[F445]            <1> 	mov al, [work_page]
  3748 00003F30 CD10                <1> 	int 10h
  3749                              <1> 
  3750 00003F32 8A3E[F445]          <1> 	mov bh, [work_page]
  3751 00003F36 E805E0              <1> 	call os_print_newline
  3752                              <1> 
  3753 00003F39 B405                <1> 	mov ah, 5
  3754 00003F3B A0[F545]            <1> 	mov al, [disp_page]
  3755                              <1> 
  3756 00003F3E A1[473F]            <1> 	mov word ax, [.tmp_loc]
  3757 00003F41 A3[EA45]            <1> 	mov word [prog], ax
  3758                              <1> 
  3759 00003F44 E9AFED              <1> 	jmp mainloop
  3760                              <1> 
  3761                              <1> 
  3762 00003F47 0000                <1> 	.tmp_loc	dw 0
  3763                              <1> 
  3764                              <1> 
  3765                              <1> ; ------------------------------------------------------------------
  3766                              <1> ; RAND
  3767                              <1> 
  3768                              <1> do_rand:
  3769 00003F49 E81A05              <1> 	call get_token
  3770 00003F4C 83F801              <1> 	cmp ax, VARIABLE
  3771 00003F4F 7544                <1> 	jne .error
  3772                              <1> 
  3773 00003F51 A0007B              <1> 	mov byte al, [token]
  3774 00003F54 A2[903F]            <1> 	mov byte [.tmp], al
  3775                              <1> 
  3776 00003F57 E80C05              <1> 	call get_token
  3777 00003F5A 83F803              <1> 	cmp ax, NUMBER
  3778 00003F5D 7536                <1> 	jne .error
  3779                              <1> 
  3780 00003F5F BE007B              <1> 	mov si, token
  3781 00003F62 E894EB              <1> 	call os_string_to_int
  3782 00003F65 A3[913F]            <1> 	mov word [.num1], ax
  3783                              <1> 
  3784 00003F68 E8FB04              <1> 	call get_token
  3785 00003F6B 83F803              <1> 	cmp ax, NUMBER
  3786 00003F6E 7525                <1> 	jne .error
  3787                              <1> 
  3788 00003F70 BE007B              <1> 	mov si, token
  3789 00003F73 E883EB              <1> 	call os_string_to_int
  3790 00003F76 A3[933F]            <1> 	mov word [.num2], ax
  3791                              <1> 
  3792 00003F79 A1[913F]            <1> 	mov word ax, [.num1]
  3793 00003F7C 8B1E[933F]          <1> 	mov word bx, [.num2]
  3794 00003F80 E85BD4              <1> 	call os_get_random
  3795                              <1> 
  3796 00003F83 89CB                <1> 	mov bx, cx
  3797 00003F85 0FB606[903F]        <1> 	movzx ax, byte [.tmp]
  3798 00003F8A E8CA04              <1> 	call set_var
  3799                              <1> 
  3800 00003F8D E966ED              <1> 	jmp mainloop
  3801                              <1> 
  3802                              <1> 
  3803 00003F90 00                  <1> 	.tmp	db 0
  3804 00003F91 0000                <1> 	.num1	dw 0
  3805 00003F93 0000                <1> 	.num2	dw 0
  3806                              <1> 
  3807                              <1> 
  3808                              <1> .error:
  3809 00003F95 BE1400              <1> 	mov si, err_syntax
  3810 00003F98 E9E405              <1> 	jmp error
  3811                              <1> 
  3812                              <1> 
  3813                              <1> ; ------------------------------------------------------------------
  3814                              <1> ; READ
  3815                              <1> 
  3816                              <1> do_read:
  3817 00003F9B E8C804              <1> 	call get_token				; Get the next token
  3818                              <1> 
  3819 00003F9E 83F804              <1> 	cmp ax, STRING				; Check for a label
  3820 00003FA1 7406                <1> 	je .is_ok
  3821                              <1> 
  3822 00003FA3 BE0500              <1> 	mov si, err_goto_notlabel
  3823 00003FA6 E9D605              <1> 	jmp error
  3824                              <1> 
  3825                              <1> .is_ok:
  3826 00003FA9 BE007B              <1> 	mov si, token				; Back up this label
  3827 00003FAC BFE27A              <1> 	mov di, .tmp_token
  3828 00003FAF E894EA              <1> 	call os_string_copy
  3829                              <1> 
  3830 00003FB2 B8E27A              <1> 	mov ax, .tmp_token
  3831 00003FB5 E8FBE9              <1> 	call os_string_length
  3832                              <1> 
  3833 00003FB8 BFE27A              <1> 	mov di, .tmp_token			; Add ':' char to end for searching
  3834 00003FBB 01C7                <1> 	add di, ax
  3835 00003FBD B03A                <1> 	mov al, ':'
  3836 00003FBF AA                  <1> 	stosb
  3837 00003FC0 B000                <1> 	mov al, 0
  3838 00003FC2 AA                  <1> 	stosb
  3839                              <1> 
  3840 00003FC3 E8A004              <1> 	call get_token				; Now get the offset variable
  3841 00003FC6 83F801              <1> 	cmp ax, VARIABLE
  3842 00003FC9 7406                <1> 	je .second_part_is_var
  3843                              <1> 
  3844 00003FCB BE1400              <1> 	mov si, err_syntax
  3845 00003FCE E9AE05              <1> 	jmp error
  3846                              <1> 
  3847                              <1> 
  3848                              <1> .second_part_is_var:
  3849 00003FD1 0FB606007B          <1> 	movzx ax, byte [token]
  3850 00003FD6 E87104              <1> 	call get_var
  3851                              <1> 
  3852 00003FD9 83F800              <1> 	cmp ax, 0				; Want to be searching for at least the first byte!
  3853 00003FDC 7F06                <1> 	jg .var_bigger_than_zero
  3854                              <1> 
  3855 00003FDE BE1400              <1> 	mov si, err_syntax
  3856 00003FE1 E99B05              <1> 	jmp error
  3857                              <1> 
  3858                              <1> 
  3859                              <1> .var_bigger_than_zero:
  3860 00003FE4 A3[6E40]            <1> 	mov word [.to_skip], ax
  3861                              <1> 
  3862                              <1> 
  3863 00003FE7 E87C04              <1> 	call get_token				; And now the var to store result into
  3864 00003FEA 83F801              <1> 	cmp ax, VARIABLE
  3865 00003FED 7406                <1> 	je .third_part_is_var
  3866                              <1> 
  3867 00003FEF BE1400              <1> 	mov si, err_syntax
  3868 00003FF2 E98A05              <1> 	jmp error
  3869                              <1> 
  3870                              <1> 
  3871                              <1> .third_part_is_var:				; Keep it for later
  3872 00003FF5 0FB606007B          <1> 	movzx ax, byte [token]
  3873 00003FFA A2[7040]            <1> 	mov byte [.var_to_use], al
  3874                              <1> 
  3875                              <1> 
  3876                              <1> 
  3877                              <1> 	; OK, so now we have all the stuff we need. Let's search for the label
  3878                              <1> 
  3879 00003FFD A1[EA45]            <1> 	mov word ax, [prog]			; Store current location
  3880 00004000 A3[6C40]            <1> 	mov word [.curr_location], ax
  3881                              <1> 
  3882 00004003 A1[EE45]            <1> 	mov word ax, [load_point]
  3883 00004006 A3[EA45]            <1> 	mov word [prog], ax			; Return to start of program to find label
  3884                              <1> 
  3885                              <1> .loop:
  3886 00004009 E85A04              <1> 	call get_token
  3887                              <1> 
  3888 0000400C 83F808              <1> 	cmp ax, LABEL
  3889 0000400F 750B                <1> 	jne .line_loop
  3890                              <1> 
  3891 00004011 BE007B              <1> 	mov si, token
  3892 00004014 BFE27A              <1> 	mov di, .tmp_token
  3893 00004017 E88BEA              <1> 	call os_string_compare
  3894 0000401A 7221                <1> 	jc .found_label
  3895                              <1> 
  3896                              <1> .line_loop:					; Go to end of line
  3897 0000401C 8B36[EA45]          <1> 	mov word si, [prog]
  3898 00004020 8A04                <1> 	mov byte al, [si]
  3899 00004022 FF06[EA45]          <1> 	inc word [prog]
  3900                              <1> 
  3901 00004026 3C0A                <1> 	cmp al, 10
  3902 00004028 75F2                <1> 	jne .line_loop
  3903                              <1> 
  3904 0000402A A1[EA45]            <1> 	mov word ax, [prog]
  3905 0000402D 8B1E[EC45]          <1> 	mov word bx, [prog_end]
  3906 00004031 39D8                <1> 	cmp ax, bx
  3907 00004033 7F02                <1> 	jg .past_end
  3908                              <1> 
  3909 00004035 EBD2                <1> 	jmp .loop
  3910                              <1> 
  3911                              <1> .past_end:
  3912 00004037 BE0600              <1> 	mov si, err_label_notfound
  3913 0000403A E94205              <1> 	jmp error
  3914                              <1> 
  3915                              <1> 
  3916                              <1> .found_label:
  3917 0000403D 8B0E[6E40]          <1> 	mov word cx, [.to_skip]			; Skip requested number of data entries
  3918                              <1> 
  3919                              <1> .data_skip_loop:
  3920 00004041 51                  <1> 	push cx
  3921 00004042 E82104              <1> 	call get_token
  3922 00004045 59                  <1> 	pop cx
  3923 00004046 E2F9                <1> 	loop .data_skip_loop
  3924                              <1> 
  3925 00004048 83F803              <1> 	cmp ax, NUMBER
  3926 0000404B 7406                <1> 	je .data_is_num
  3927                              <1> 
  3928 0000404D BE1400              <1> 	mov si, err_syntax
  3929 00004050 E92C05              <1> 	jmp error
  3930                              <1> 
  3931                              <1> .data_is_num:
  3932 00004053 BE007B              <1> 	mov si, token
  3933 00004056 E8A0EA              <1> 	call os_string_to_int
  3934                              <1> 
  3935 00004059 89C3                <1> 	mov bx, ax
  3936 0000405B 0FB606[7040]        <1> 	movzx ax, byte [.var_to_use]
  3937 00004060 E8F403              <1> 	call set_var
  3938                              <1> 
  3939 00004063 A1[6C40]            <1> 	mov word ax, [.curr_location]
  3940 00004066 A3[EA45]            <1> 	mov word [prog], ax
  3941                              <1> 
  3942 00004069 E98AEC              <1> 	jmp mainloop
  3943                              <1> 
  3944                              <1> 
  3945 0000406C 0000                <1> 	.curr_location	dw 0
  3946                              <1> 
  3947 0000406E 0000                <1> 	.to_skip	dw 0
  3948 00004070 00                  <1> 	.var_to_use	db 0
  3949                              <1> ;	.tmp_token 	times 30 db 0
  3950                              <1> 	.tmp_token 	equ 32768-1024-256-30
  3951                              <1> 
  3952                              <1> 
  3953                              <1> ; ------------------------------------------------------------------
  3954                              <1> ; REM
  3955                              <1> 
  3956                              <1> do_rem:
  3957 00004071 8B36[EA45]          <1> 	mov word si, [prog]
  3958 00004075 8A04                <1> 	mov byte al, [si]
  3959 00004077 FF06[EA45]          <1> 	inc word [prog]
  3960 0000407B 3C0A                <1> 	cmp al, 10			; Find end of line after REM
  3961 0000407D 75F2                <1> 	jne do_rem
  3962                              <1> 
  3963 0000407F E974EC              <1> 	jmp mainloop
  3964                              <1> 
  3965                              <1> 
  3966                              <1> ; ------------------------------------------------------------------
  3967                              <1> ; RENAME
  3968                              <1> 
  3969                              <1> do_rename:
  3970 00004082 E8E103              <1> 	call get_token
  3971                              <1> 
  3972 00004085 83F802              <1> 	cmp ax, STRING_VAR		; Is it a string or a quote?
  3973 00004088 7407                <1> 	je .first_is_string
  3974                              <1> 
  3975 0000408A 83F805              <1> 	cmp ax, QUOTE
  3976 0000408D 740E                <1> 	je .first_is_quote
  3977                              <1> 
  3978 0000408F EB61                <1> 	jmp .error
  3979                              <1> 
  3980                              <1> .first_is_string:
  3981 00004091 BE007C              <1> 	mov si, string_vars		; Locate string
  3982 00004094 B88000              <1> 	mov ax, 128
  3983 00004097 F7E3                <1> 	mul bx
  3984 00004099 01C6                <1> 	add si, ax
  3985                              <1> 
  3986 0000409B EB03                <1> 	jmp .save_file1
  3987                              <1> 
  3988                              <1> .first_is_quote:
  3989 0000409D BE007B              <1> 	mov si, token			; The location of quotes is provided
  3990                              <1> 
  3991                              <1> .save_file1:
  3992 000040A0 BF[1F41]            <1> 	mov word di, .file1		; The filename is saved to temporary strings because
  3993 000040A3 E8A0E9              <1> 	call os_string_copy		; getting a second quote will overwrite the previous
  3994                              <1> 	
  3995                              <1> .get_second:
  3996 000040A6 E8BD03              <1> 	call get_token
  3997                              <1> 
  3998 000040A9 83F802              <1> 	cmp ax, STRING_VAR
  3999 000040AC 7407                <1> 	je .second_is_string
  4000                              <1> 
  4001 000040AE 83F805              <1> 	cmp ax, QUOTE
  4002 000040B1 740E                <1> 	je .second_is_quote
  4003                              <1> 
  4004 000040B3 EB3D                <1> 	jmp .error
  4005                              <1> 
  4006                              <1> .second_is_string:
  4007 000040B5 BE007C              <1> 	mov si, string_vars		; Locate second string
  4008 000040B8 B88000              <1> 	mov ax, 128
  4009 000040BB F7E3                <1> 	mul bx
  4010 000040BD 01C6                <1> 	add si, ax
  4011                              <1> 
  4012 000040BF EB03                <1> 	jmp .save_file2
  4013                              <1> 
  4014                              <1> .second_is_quote:
  4015 000040C1 BE007B              <1> 	mov si, token
  4016                              <1> 
  4017                              <1> .save_file2:
  4018 000040C4 BF[2B41]            <1> 	mov word di, .file2
  4019 000040C7 E87CE9              <1> 	call os_string_copy
  4020                              <1> 	
  4021                              <1> .check_exists:
  4022 000040CA B8[1F41]            <1> 	mov word ax, .file1		; Check if the source file exists
  4023 000040CD E801CE              <1> 	call os_file_exists
  4024 000040D0 7226                <1> 	jc .file_not_found		; If it doesn't exists set "R = 1"
  4025                              <1> 
  4026 000040D2 F8                  <1> 	clc
  4027 000040D3 B8[2B41]            <1> 	mov ax, .file2			; The second file is the destination and should not exist
  4028 000040D6 E8F8CD              <1> 	call os_file_exists
  4029 000040D9 7337                <1> 	jnc .file_exists		; If it exists set "R = 3"
  4030                              <1> 	
  4031                              <1> .rename:
  4032 000040DB B8[1F41]            <1> 	mov word ax, .file1		; Seem to be okay, lets rename
  4033 000040DE BB[2B41]            <1> 	mov word bx, .file2
  4034 000040E1 E86ECF              <1> 	call os_rename_file
  4035                              <1> 
  4036 000040E4 721F                <1> 	jc .rename_failed		; If it failed set "R = 2", usually caused by a read-only disk
  4037                              <1> 
  4038 000040E6 31C0                <1> 	xor ax, ax			; It worked sucessfully, so set "R = 0" to indicate no error
  4039 000040E8 B052                <1> 	mov byte al, 'R'
  4040 000040EA 31DB                <1> 	xor bx, bx
  4041 000040EC E86803              <1> 	call set_var
  4042                              <1> 
  4043 000040EF E904EC              <1> 	jmp mainloop
  4044                              <1> 
  4045                              <1> .error:
  4046 000040F2 BE1400              <1> 	mov si, err_syntax
  4047 000040F5 E98704              <1> 	jmp error
  4048                              <1> 
  4049                              <1> .file_not_found:
  4050 000040F8 31C0                <1> 	xor ax, ax			; Set R variable to 1
  4051 000040FA B052                <1> 	mov byte al, 'R'
  4052 000040FC BB0100              <1> 	mov bx, 1
  4053 000040FF E85503              <1> 	call set_var
  4054                              <1> 
  4055 00004102 E9F1EB              <1> 	jmp mainloop
  4056                              <1> 
  4057                              <1> .rename_failed:
  4058 00004105 31C0                <1> 	xor ax, ax			; Set R variable to 2
  4059 00004107 B052                <1> 	mov byte al, 'R'
  4060 00004109 BB0200              <1> 	mov bx, 2
  4061 0000410C E84803              <1> 	call set_var
  4062                              <1> 
  4063 0000410F E9E4EB              <1> 	jmp mainloop
  4064                              <1> 
  4065                              <1> .file_exists:
  4066 00004112 31C0                <1> 	xor ax, ax
  4067 00004114 B052                <1> 	mov byte al, 'R'		; Set R variable to 3
  4068 00004116 BB0300              <1> 	mov bx, 3
  4069 00004119 E83B03              <1> 	call set_var
  4070                              <1> 
  4071 0000411C E9D7EB              <1> 	jmp mainloop
  4072                              <1> 
  4073                              <1> .data:
  4074 0000411F 00<rep Ch>          <1> 	.file1				times 12 db 0
  4075 0000412B 00<rep Ch>          <1> 	.file2				times 12 db 0
  4076                              <1> 
  4077                              <1> 
  4078                              <1> ; ------------------------------------------------------------------
  4079                              <1> ; RETURN
  4080                              <1> 
  4081                              <1> do_return:
  4082 00004137 0FB606[6147]        <1> 	movzx ax, byte [gosub_depth]
  4083 0000413C 3C00                <1> 	cmp al, 0
  4084 0000413E 7506                <1> 	jne .is_ok
  4085                              <1> 
  4086 00004140 BE1200              <1> 	mov si, err_return
  4087 00004143 E93904              <1> 	jmp error
  4088                              <1> 
  4089                              <1> .is_ok:
  4090 00004146 BEBC79              <1> 	mov si, gosub_points
  4091 00004149 01C6                <1> 	add si, ax				; Table is words (not bytes)
  4092 0000414B 01C6                <1> 	add si, ax
  4093 0000414D AD                  <1> 	lodsw
  4094 0000414E A3[EA45]            <1> 	mov word [prog], ax
  4095 00004151 FE0E[6147]          <1> 	dec byte [gosub_depth]
  4096                              <1> 
  4097 00004155 E99EEB              <1> 	jmp mainloop	
  4098                              <1> 
  4099                              <1> 
  4100                              <1> ; ------------------------------------------------------------------
  4101                              <1> ; SAVE
  4102                              <1> 
  4103                              <1> do_save:
  4104 00004158 E80B03              <1> 	call get_token
  4105 0000415B 83F805              <1> 	cmp ax, QUOTE
  4106 0000415E 7413                <1> 	je .is_quote
  4107                              <1> 
  4108 00004160 83F802              <1> 	cmp ax, STRING_VAR
  4109 00004163 0F859500            <1> 	jne near .error
  4110                              <1> 
  4111 00004167 BE007C              <1> 	mov si, string_vars
  4112 0000416A B88000              <1> 	mov ax, 128
  4113 0000416D F7E3                <1> 	mul bx
  4114 0000416F 01C6                <1> 	add si, ax
  4115 00004171 EB03                <1> 	jmp .get_position
  4116                              <1> 
  4117                              <1> .is_quote:
  4118 00004173 BE007B              <1> 	mov si, token
  4119                              <1> 
  4120                              <1> .get_position:
  4121 00004176 BF[0842]            <1> 	mov di, .tmp_filename
  4122 00004179 E8CAE8              <1> 	call os_string_copy
  4123                              <1> 
  4124 0000417C E8E702              <1> 	call get_token
  4125                              <1> 
  4126 0000417F 83F801              <1> 	cmp ax, VARIABLE
  4127 00004182 744A                <1> 	je .second_is_var
  4128                              <1> 
  4129 00004184 83F803              <1> 	cmp ax, NUMBER
  4130 00004187 7573                <1> 	jne .error
  4131                              <1> 
  4132 00004189 BE007B              <1> 	mov si, token
  4133 0000418C E86AE9              <1> 	call os_string_to_int
  4134                              <1> 
  4135                              <1> .set_data_loc:
  4136 0000418F A3[0442]            <1> 	mov word [.data_loc], ax
  4137                              <1> 
  4138 00004192 E8D102              <1> 	call get_token
  4139                              <1> 
  4140 00004195 83F801              <1> 	cmp ax, VARIABLE
  4141 00004198 743E                <1> 	je .third_is_var
  4142                              <1> 
  4143 0000419A 83F803              <1> 	cmp ax, NUMBER
  4144 0000419D 755D                <1> 	jne .error
  4145                              <1> 
  4146 0000419F BE007B              <1> 	mov si, token
  4147 000041A2 E854E9              <1> 	call os_string_to_int
  4148                              <1> 
  4149                              <1> .check_exists:
  4150 000041A5 A3[0642]            <1> 	mov word [.data_size], ax
  4151 000041A8 B8[0842]            <1> 	mov word ax, .tmp_filename
  4152 000041AB E823CD              <1> 	call os_file_exists
  4153 000041AE 7202                <1> 	jc .write_file
  4154 000041B0 EB30                <1> 	jmp .file_exists_fail
  4155                              <1> 	
  4156                              <1> .write_file:
  4157                              <1> 
  4158 000041B2 B8[0842]            <1> 	mov word ax, .tmp_filename
  4159 000041B5 8B1E[0442]          <1> 	mov word bx, [.data_loc]
  4160 000041B9 8B0E[0642]          <1> 	mov word cx, [.data_size]
  4161                              <1> 	
  4162 000041BD E82FCB              <1> 	call os_write_file
  4163 000041C0 722D                <1> 	jc .save_failure
  4164                              <1> 
  4165 000041C2 31C0                <1> 	xor ax, ax
  4166 000041C4 B052                <1> 	mov byte al, 'R'
  4167 000041C6 31DB                <1> 	xor bx, bx
  4168 000041C8 E88C02              <1> 	call set_var
  4169                              <1> 
  4170 000041CB E928EB              <1> 	jmp mainloop
  4171                              <1> 
  4172                              <1> 
  4173                              <1> .second_is_var:
  4174 000041CE 0FB606007B          <1> 	movzx ax, byte [token]
  4175 000041D3 E87402              <1> 	call get_var
  4176 000041D6 EBB7                <1> 	jmp .set_data_loc
  4177                              <1> 
  4178                              <1> 
  4179                              <1> .third_is_var:
  4180 000041D8 0FB606007B          <1> 	movzx ax, byte [token]
  4181 000041DD E86A02              <1> 	call get_var
  4182 000041E0 EBC3                <1> 	jmp .check_exists
  4183                              <1> 
  4184                              <1> .file_exists_fail:
  4185 000041E2 31C0                <1> 	xor ax, ax
  4186 000041E4 B052                <1> 	mov byte al, 'R'
  4187 000041E6 BB0200              <1> 	mov bx, 2
  4188 000041E9 E86B02              <1> 	call set_var
  4189 000041EC E907EB              <1> 	jmp mainloop
  4190                              <1> 	
  4191                              <1> .save_failure:
  4192 000041EF 31C0                <1> 	xor ax, ax
  4193 000041F1 B052                <1> 	mov byte al, 'R'
  4194 000041F3 BB0100              <1> 	mov bx, 1
  4195 000041F6 E85E02              <1> 	call set_var
  4196                              <1> 
  4197 000041F9 E9FAEA              <1> 	jmp mainloop
  4198                              <1> 
  4199                              <1> .error:
  4200 000041FC BE1400              <1> 	mov si, err_syntax
  4201 000041FF E97D03              <1> 	jmp error
  4202                              <1> 
  4203                              <1> 
  4204 00004202 0000                <1> 	.filename_loc	dw 0
  4205 00004204 0000                <1> 	.data_loc	dw 0
  4206 00004206 0000                <1> 	.data_size	dw 0
  4207                              <1> 
  4208 00004208 00<rep Fh>          <1> 	.tmp_filename	times 15 db 0
  4209                              <1> 
  4210                              <1> 
  4211                              <1> ; ------------------------------------------------------------------
  4212                              <1> ; SERIAL
  4213                              <1> 
  4214                              <1> do_serial:
  4215 00004217 E84C02              <1> 	call get_token
  4216 0000421A BE007B              <1> 	mov si, token
  4217                              <1> 
  4218 0000421D BF[AF42]            <1> 	mov di, .on_cmd
  4219 00004220 E882E8              <1> 	call os_string_compare
  4220 00004223 7212                <1> 	jc .do_on_cmd
  4221                              <1> 
  4222 00004225 BF[B242]            <1> 	mov di, .send_cmd
  4223 00004228 E87AE8              <1> 	call os_string_compare
  4224 0000422B 7237                <1> 	jc .do_send_cmd
  4225                              <1> 
  4226 0000422D BF[B742]            <1> 	mov di, .rec_cmd
  4227 00004230 E872E8              <1> 	call os_string_compare
  4228 00004233 7258                <1> 	jc .do_rec_cmd
  4229                              <1> 
  4230 00004235 EB72                <1> 	jmp .error
  4231                              <1> 
  4232                              <1> .do_on_cmd:
  4233 00004237 E82C02              <1> 	call get_token
  4234 0000423A 83F803              <1> 	cmp ax, NUMBER
  4235 0000423D 7402                <1> 	je .do_on_cmd_ok
  4236 0000423F EB68                <1> 	jmp .error
  4237                              <1> 
  4238                              <1> .do_on_cmd_ok:
  4239 00004241 BE007B              <1> 	mov si, token
  4240 00004244 E8B2E8              <1> 	call os_string_to_int
  4241 00004247 3DB004              <1> 	cmp ax, 1200
  4242 0000424A 740F                <1> 	je .on_cmd_slow_mode
  4243 0000424C 3D8025              <1> 	cmp ax, 9600
  4244 0000424F 7402                <1> 	je .on_cmd_fast_mode
  4245                              <1> 
  4246 00004251 EB56                <1> 	jmp .error
  4247                              <1> 
  4248                              <1> .on_cmd_fast_mode:
  4249 00004253 31C0                <1> 	xor ax, ax
  4250 00004255 E852D5              <1> 	call os_serial_port_enable
  4251 00004258 E99BEA              <1> 	jmp mainloop
  4252                              <1> 
  4253                              <1> .on_cmd_slow_mode:
  4254 0000425B B80100              <1> 	mov ax, 1
  4255 0000425E E849D5              <1> 	call os_serial_port_enable
  4256 00004261 E992EA              <1> 	jmp mainloop
  4257                              <1> 
  4258                              <1> 
  4259                              <1> .do_send_cmd:
  4260 00004264 E8FF01              <1> 	call get_token
  4261 00004267 83F803              <1> 	cmp ax, NUMBER
  4262 0000426A 7407                <1> 	je .send_number
  4263                              <1> 
  4264 0000426C 83F801              <1> 	cmp ax, VARIABLE
  4265 0000426F 740E                <1> 	je .send_variable
  4266                              <1> 
  4267 00004271 EB36                <1> 	jmp .error
  4268                              <1> 
  4269                              <1> .send_number:
  4270 00004273 BE007B              <1> 	mov si, token
  4271 00004276 E880E8              <1> 	call os_string_to_int
  4272 00004279 E842D5              <1> 	call os_send_via_serial
  4273 0000427C E977EA              <1> 	jmp mainloop
  4274                              <1> 
  4275                              <1> .send_variable:
  4276 0000427F 0FB606007B          <1> 	movzx ax, byte [token]
  4277 00004284 E8C301              <1> 	call get_var
  4278 00004287 E834D5              <1> 	call os_send_via_serial
  4279 0000428A E969EA              <1> 	jmp mainloop
  4280                              <1> 
  4281                              <1> 
  4282                              <1> .do_rec_cmd:
  4283 0000428D E8D601              <1> 	call get_token
  4284 00004290 83F801              <1> 	cmp ax, VARIABLE
  4285 00004293 7514                <1> 	jne .error
  4286                              <1> 
  4287 00004295 A0007B              <1> 	mov byte al, [token]
  4288                              <1> 
  4289 00004298 0FB6C8              <1> 	movzx cx, al
  4290 0000429B E832D5              <1> 	call os_get_via_serial
  4291                              <1> 
  4292 0000429E 0FB6D8              <1> 	movzx bx, al
  4293 000042A1 88C8                <1> 	mov al, cl
  4294 000042A3 E8B101              <1> 	call set_var
  4295                              <1> 
  4296 000042A6 E94DEA              <1> 	jmp mainloop
  4297                              <1> 
  4298                              <1> 
  4299                              <1> .error:
  4300 000042A9 BE1400              <1> 	mov si, err_syntax
  4301 000042AC E9D002              <1> 	jmp error
  4302                              <1> 
  4303                              <1> 
  4304 000042AF 4F4E00              <1> 	.on_cmd		db "ON", 0
  4305 000042B2 53454E4400          <1> 	.send_cmd	db "SEND", 0
  4306 000042B7 52454300            <1> 	.rec_cmd	db "REC", 0
  4307                              <1> 
  4308                              <1> 
  4309                              <1> ; ------------------------------------------------------------------
  4310                              <1> ; SIZE
  4311                              <1> 
  4312                              <1> do_size:
  4313 000042BB E8A801              <1> 	call get_token
  4314                              <1> 
  4315 000042BE 83F802              <1> 	cmp ax, STRING_VAR
  4316 000042C1 7407                <1> 	je .is_string
  4317                              <1> 
  4318 000042C3 83F805              <1> 	cmp ax, QUOTE
  4319 000042C6 7410                <1> 	je .is_quote
  4320                              <1> 
  4321 000042C8 EB29                <1> 	jmp .error
  4322                              <1> 
  4323                              <1> .is_string:
  4324 000042CA BE007C              <1> 	mov si, string_vars
  4325 000042CD B88000              <1> 	mov ax, 128
  4326 000042D0 F7E3                <1> 	mul bx
  4327 000042D2 01C6                <1> 	add si, ax
  4328                              <1> 
  4329 000042D4 89F0                <1> 	mov ax, si
  4330 000042D6 EB03                <1> 	jmp .get_size
  4331                              <1> 
  4332                              <1> .is_quote:
  4333 000042D8 B8007B              <1> 	mov ax, token
  4334                              <1> 
  4335                              <1> .get_size:
  4336 000042DB E8A9CD              <1> 	call os_get_file_size
  4337 000042DE 7219                <1> 	jc .file_not_found
  4338                              <1> 
  4339 000042E0 31C0                <1> 	xor ax, ax
  4340 000042E2 B053                <1> 	mov al, 'S'
  4341 000042E4 E87001              <1> 	call set_var
  4342                              <1> 
  4343 000042E7 31C0                <1> 	xor ax, ax
  4344 000042E9 B052                <1> 	mov al, 'R'
  4345 000042EB 31DB                <1> 	xor bx, bx
  4346 000042ED E86701              <1> 	call set_var
  4347                              <1> 
  4348 000042F0 E903EA              <1> 	jmp mainloop
  4349                              <1> 
  4350                              <1> .error:
  4351 000042F3 BE1400              <1> 	mov si, err_syntax
  4352 000042F6 E98602              <1> 	jmp error
  4353                              <1> 
  4354                              <1> .file_not_found:
  4355 000042F9 0FB606007B          <1> 	movzx ax, byte [token]
  4356 000042FE 89DB                <1> 	mov bx, bx
  4357 00004300 E85401              <1> 	call set_var
  4358                              <1> 
  4359 00004303 31C0                <1> 	xor ax, ax
  4360 00004305 B052                <1> 	mov al, 'R'
  4361 00004307 BB0100              <1> 	mov bx, 1
  4362 0000430A E84A01              <1>  	call set_var
  4363                              <1>  	
  4364 0000430D E9E6E9              <1> 	jmp mainloop
  4365                              <1> 
  4366                              <1> 
  4367                              <1> 
  4368                              <1> ; ------------------------------------------------------------------
  4369                              <1> ; SOUND
  4370                              <1> 
  4371                              <1> do_sound:
  4372 00004310 E85301              <1> 	call get_token
  4373                              <1> 
  4374 00004313 83F801              <1> 	cmp ax, VARIABLE
  4375 00004316 7408                <1> 	je .first_is_var
  4376                              <1> 
  4377 00004318 BE007B              <1> 	mov si, token
  4378 0000431B E8DBE7              <1> 	call os_string_to_int
  4379 0000431E EB08                <1> 	jmp .done_first
  4380                              <1> 
  4381                              <1> .first_is_var:
  4382 00004320 0FB606007B          <1> 	movzx ax, byte [token]
  4383 00004325 E82201              <1> 	call get_var
  4384                              <1> 
  4385                              <1> .done_first:
  4386 00004328 E8FFE2              <1> 	call os_speaker_tone
  4387                              <1> 
  4388 0000432B E83801              <1> 	call get_token
  4389                              <1> 
  4390 0000432E 83F801              <1> 	cmp ax, VARIABLE
  4391 00004331 7408                <1> 	je .second_is_var
  4392                              <1> 
  4393 00004333 BE007B              <1> 	mov si, token
  4394 00004336 E8C0E7              <1> 	call os_string_to_int
  4395 00004339 EB08                <1> 	jmp .finish
  4396                              <1> 
  4397                              <1> .second_is_var:
  4398 0000433B 0FB606007B          <1> 	movzx ax, byte [token]
  4399 00004340 E80701              <1> 	call get_var
  4400                              <1> 
  4401                              <1> .finish:
  4402 00004343 E886D1              <1> 	call os_pause
  4403 00004346 E821E3              <1> 	call os_speaker_off
  4404                              <1> 
  4405 00004349 E9AAE9              <1> 	jmp mainloop
  4406                              <1> 
  4407                              <1> 
  4408                              <1> ;-------------------------------------------------------------------
  4409                              <1> ; STRING
  4410                              <1> do_string:
  4411 0000434C E81701              <1> 	call get_token			; The first parameter is the word 'GET' or 'SET'
  4412 0000434F BE007B              <1> 	mov si, token
  4413                              <1> 	
  4414 00004352 BF[F643]            <1> 	mov di, .get_cmd
  4415 00004355 E84DE7              <1> 	call os_string_compare
  4416 00004358 720B                <1> 	jc .set_str
  4417                              <1> 		
  4418 0000435A BF[FA43]            <1> 	mov di, .set_cmd
  4419 0000435D E845E7              <1> 	call os_string_compare
  4420 00004360 7208                <1> 	jc .get_str
  4421                              <1> 	
  4422 00004362 E98500              <1> 	jmp .error
  4423                              <1> 	
  4424                              <1> 	.set_str:
  4425 00004365 B90100              <1> 	mov cx, 1
  4426 00004368 EB03                <1> 	jmp .check_second
  4427                              <1> 	.get_str:
  4428 0000436A B90200              <1> 	mov cx, 2
  4429                              <1> 
  4430                              <1> .check_second:
  4431 0000436D E8F600              <1> 	call get_token			; The next should be a string variable, locate it
  4432                              <1> 	
  4433 00004370 83F802              <1> 	cmp ax, STRING_VAR
  4434 00004373 7575                <1> 	jne .error
  4435                              <1> 	
  4436 00004375 BE007C              <1> 	mov si, string_vars
  4437 00004378 B88000              <1> 	mov ax, 128
  4438 0000437B F7E3                <1> 	mul bx
  4439 0000437D 01C6                <1> 	add si, ax
  4440 0000437F 8936[FE43]          <1> 	mov word [.string_loc], si
  4441                              <1> 	
  4442                              <1> .check_third:
  4443 00004383 E8E000              <1> 	call get_token			; Now there should be a number
  4444                              <1> 	
  4445 00004386 83F803              <1> 	cmp ax, NUMBER
  4446 00004389 7407                <1> 	je .third_is_number
  4447                              <1> 	
  4448 0000438B 83F801              <1> 	cmp ax, VARIABLE
  4449 0000438E 740A                <1> 	je .third_is_variable
  4450                              <1> 	
  4451 00004390 EB58                <1> 	jmp .error
  4452                              <1> 	
  4453                              <1> .third_is_number:	
  4454 00004392 BE007B              <1> 	mov si, token
  4455 00004395 E861E7              <1> 	call os_string_to_int
  4456 00004398 EB0A                <1> 	jmp .got_number	
  4457                              <1> 
  4458                              <1> .third_is_variable:
  4459 0000439A B400                <1> 	mov ah, 0
  4460 0000439C A0007B              <1> 	mov al, [token]
  4461 0000439F E8A800              <1> 	call get_var
  4462 000043A2 EB00                <1> 	jmp .got_number
  4463                              <1> 
  4464                              <1> .got_number:
  4465 000043A4 3D8000              <1> 	cmp ax, 128
  4466 000043A7 7F47                <1> 	jg .outrange
  4467 000043A9 83F800              <1> 	cmp ax, 0
  4468 000043AC 7442                <1> 	je .outrange
  4469 000043AE 83E801              <1> 	sub ax, 1
  4470 000043B1 89C2                <1> 	mov dx, ax
  4471                              <1> 	
  4472                              <1> .check_forth:
  4473 000043B3 E8B000              <1> 	call get_token			; Next a numerical variable
  4474                              <1> 	
  4475 000043B6 83F801              <1> 	cmp ax, VARIABLE
  4476 000043B9 752F                <1> 	jne .error
  4477                              <1> 	
  4478 000043BB A0007B              <1> 	mov byte al, [token]
  4479 000043BE A2[0044]            <1> 	mov byte [.tmp], al
  4480                              <1> 	
  4481 000043C1 83F902              <1> 	cmp cx, 2
  4482 000043C4 7414                <1> 	je .set_var
  4483                              <1> 	
  4484                              <1> .get_var:
  4485 000043C6 8B36[FE43]          <1> 	mov word si, [.string_loc]	; Move to string location
  4486 000043CA 01D6                <1> 	add si, dx			; Add offset
  4487 000043CC AC                  <1> 	lodsb				; Load data
  4488 000043CD B400                <1> 	mov ah, 0
  4489 000043CF 89C3                <1> 	mov bx, ax			; Set data in numerical variable
  4490 000043D1 A0[0044]            <1> 	mov byte al, [.tmp]
  4491 000043D4 E88000              <1> 	call set_var
  4492 000043D7 E91CE9              <1> 	jmp mainloop
  4493                              <1> 	
  4494                              <1> .set_var:
  4495 000043DA A0[0044]            <1> 	mov byte al, [.tmp]		; Retrieve the variable
  4496 000043DD E86A00              <1> 	call get_var			; Get it's value
  4497 000043E0 8B3E[FE43]          <1> 	mov di, [.string_loc]		; Locate the string
  4498 000043E4 01D7                <1> 	add di, dx			; Add the offset
  4499 000043E6 AA                  <1> 	stosb				; Store data
  4500 000043E7 E90CE9              <1> 	jmp mainloop
  4501                              <1> 	
  4502                              <1> .error:
  4503 000043EA BE1400              <1> 	mov si, err_syntax
  4504 000043ED E98F01              <1> 	jmp error
  4505                              <1> 	
  4506                              <1> .outrange:
  4507 000043F0 BE1300              <1> 	mov si, err_string_range
  4508 000043F3 E98901              <1> 	jmp error
  4509                              <1> 
  4510                              <1> .data:
  4511 000043F6 47455400            <1> 	.get_cmd		db "GET", 0
  4512 000043FA 53455400            <1> 	.set_cmd		db "SET", 0
  4513 000043FE 0000                <1> 	.string_loc		dw 0
  4514 00004400 00                  <1> 	.tmp			db 0
  4515                              <1> 
  4516                              <1> 
  4517                              <1> 
  4518                              <1> ; ------------------------------------------------------------------
  4519                              <1> ; WAITKEY
  4520                              <1> 
  4521                              <1> do_waitkey:
  4522 00004401 E86200              <1> 	call get_token
  4523 00004404 83F801              <1> 	cmp ax, VARIABLE
  4524 00004407 7406                <1> 	je .is_variable
  4525                              <1> 
  4526 00004409 BE1400              <1> 	mov si, err_syntax
  4527 0000440C E97001              <1> 	jmp error
  4528                              <1> 
  4529                              <1> .is_variable:
  4530 0000440F 0FB606007B          <1> 	movzx ax, byte [token]
  4531                              <1> 
  4532 00004414 50                  <1> 	push ax
  4533                              <1> 
  4534 00004415 E862CE              <1> 	call os_wait_for_key
  4535                              <1> 
  4536 00004418 80FC48              <1> 	cmp ah, 48h
  4537 0000441B 7419                <1> 	je .up_pressed
  4538                              <1> 	
  4539 0000441D 80FC50              <1> 	cmp ah, 50h
  4540 00004420 7419                <1> 	je .down_pressed
  4541                              <1> 
  4542 00004422 80FC4B              <1> 	cmp ah, 4Bh
  4543 00004425 7419                <1> 	je .left_pressed
  4544                              <1> 
  4545 00004427 80FC4D              <1> 	cmp ah, 4Dh
  4546 0000442A 7419                <1> 	je .right_pressed
  4547                              <1> 
  4548                              <1> .store:
  4549 0000442C 0FB6D8              <1> 	movzx bx, al
  4550                              <1> 
  4551 0000442F 58                  <1> 	pop ax
  4552                              <1> 
  4553 00004430 E82400              <1> 	call set_var
  4554                              <1> 
  4555 00004433 E9C0E8              <1> 	jmp mainloop
  4556                              <1> 
  4557                              <1> 
  4558                              <1> .up_pressed:
  4559 00004436 B80100              <1> 	mov ax, 1
  4560 00004439 EBF1                <1> 	jmp .store
  4561                              <1> 
  4562                              <1> .down_pressed:
  4563 0000443B B80200              <1> 	mov ax, 2
  4564 0000443E EBEC                <1> 	jmp .store
  4565                              <1> 
  4566                              <1> .left_pressed:
  4567 00004440 B80300              <1> 	mov ax, 3
  4568 00004443 EBE7                <1> 	jmp .store
  4569                              <1> 
  4570                              <1> .right_pressed:
  4571 00004445 B80400              <1> 	mov ax, 4
  4572 00004448 EBE2                <1> 	jmp .store
  4573                              <1> 
  4574                              <1> 
  4575                              <1> ; ==================================================================
  4576                              <1> ; INTERNAL ROUTINES FOR INTERPRETER
  4577                              <1> 
  4578                              <1> ; ------------------------------------------------------------------
  4579                              <1> ; Get value of variable character specified in AL (eg 'A')
  4580                              <1> 
  4581                              <1> get_var:
  4582 0000444A B400                <1> 	mov ah, 0
  4583 0000444C 2C41                <1> 	sub al, 65
  4584 0000444E BE4C7A              <1> 	mov si, variables
  4585 00004451 01C6                <1> 	add si, ax
  4586 00004453 01C6                <1> 	add si, ax
  4587 00004455 AD                  <1> 	lodsw
  4588 00004456 C3                  <1> 	ret
  4589                              <1> 
  4590                              <1> 
  4591                              <1> ; ------------------------------------------------------------------
  4592                              <1> ; Set value of variable character specified in AL (eg 'A')
  4593                              <1> ; with number specified in BX
  4594                              <1> 
  4595                              <1> set_var:
  4596 00004457 B400                <1> 	mov ah, 0
  4597 00004459 2C41                <1> 	sub al, 65				; Remove ASCII codes before 'A'
  4598                              <1> 
  4599 0000445B BF4C7A              <1> 	mov di, variables			; Find position in table (of words)
  4600 0000445E 01C7                <1> 	add di, ax
  4601 00004460 01C7                <1> 	add di, ax
  4602 00004462 89D8                <1> 	mov ax, bx
  4603 00004464 AB                  <1> 	stosw
  4604 00004465 C3                  <1> 	ret
  4605                              <1> 
  4606                              <1> 
  4607                              <1> ; ------------------------------------------------------------------
  4608                              <1> ; Get token from current position in prog
  4609                              <1> 
  4610                              <1> get_token:
  4611 00004466 8B36[EA45]          <1> 	mov word si, [prog]
  4612 0000446A AC                  <1> 	lodsb
  4613                              <1> 
  4614 0000446B 3C0A                <1> 	cmp al, 10
  4615 0000446D 741A                <1> 	je .newline
  4616                              <1> 
  4617 0000446F 3C20                <1> 	cmp al, ' '
  4618 00004471 7416                <1> 	je .newline
  4619                              <1> 
  4620 00004473 E8F100              <1> 	call is_number
  4621 00004476 7217                <1> 	jc get_number_token
  4622                              <1> 
  4623 00004478 3C22                <1> 	cmp al, '"'
  4624 0000447A 745F                <1> 	je get_quote_token
  4625                              <1> 
  4626 0000447C 3C27                <1> 	cmp al, 39			; Quote mark (')
  4627 0000447E 7438                <1> 	je get_char_token
  4628                              <1> 
  4629 00004480 3C24                <1> 	cmp al, '$'
  4630 00004482 0F848000            <1> 	je near get_string_var_token
  4631                              <1> 
  4632 00004486 E99000              <1> 	jmp get_string_token
  4633                              <1> 
  4634                              <1> 
  4635                              <1> .newline:
  4636 00004489 FF06[EA45]          <1> 	inc word [prog]
  4637 0000448D EBD7                <1> 	jmp get_token
  4638                              <1> 
  4639                              <1> 
  4640                              <1> 
  4641                              <1> get_number_token:
  4642 0000448F 8B36[EA45]          <1> 	mov word si, [prog]
  4643 00004493 BF007B              <1> 	mov di, token
  4644                              <1> 
  4645                              <1> .loop:
  4646 00004496 AC                  <1> 	lodsb
  4647 00004497 3C0A                <1> 	cmp al, 10
  4648 00004499 7416                <1> 	je .done
  4649 0000449B 3C20                <1> 	cmp al, ' '
  4650 0000449D 7412                <1> 	je .done
  4651 0000449F E8C500              <1> 	call is_number
  4652 000044A2 7206                <1> 	jc .fine
  4653                              <1> 
  4654 000044A4 BE0000              <1> 	mov si, err_char_in_num
  4655 000044A7 E9D500              <1> 	jmp error
  4656                              <1> 
  4657                              <1> .fine:
  4658 000044AA AA                  <1> 	stosb
  4659 000044AB FF06[EA45]          <1> 	inc word [prog]
  4660 000044AF EBE5                <1> 	jmp .loop
  4661                              <1> 
  4662                              <1> .done:
  4663 000044B1 B000                <1> 	mov al, 0			; Zero-terminate the token
  4664 000044B3 AA                  <1> 	stosb
  4665                              <1> 
  4666 000044B4 B80300              <1> 	mov ax, NUMBER			; Pass back the token type
  4667 000044B7 C3                  <1> 	ret
  4668                              <1> 
  4669                              <1> 
  4670                              <1> get_char_token:
  4671 000044B8 FF06[EA45]          <1> 	inc word [prog]			; Move past first quote (')
  4672                              <1> 
  4673 000044BC 8B36[EA45]          <1> 	mov word si, [prog]
  4674 000044C0 AC                  <1> 	lodsb
  4675                              <1> 
  4676 000044C1 A2007B              <1> 	mov byte [token], al
  4677                              <1> 
  4678 000044C4 AC                  <1> 	lodsb
  4679 000044C5 3C27                <1> 	cmp al, 39			; Needs to finish with another quote
  4680 000044C7 7406                <1> 	je .is_ok
  4681                              <1> 
  4682 000044C9 BE1100              <1> 	mov si, err_quote_term
  4683 000044CC E9B000              <1> 	jmp error
  4684                              <1> 
  4685                              <1> .is_ok:
  4686 000044CF FF06[EA45]          <1> 	inc word [prog]
  4687 000044D3 FF06[EA45]          <1> 	inc word [prog]
  4688                              <1> 
  4689 000044D7 B80600              <1> 	mov ax, CHAR
  4690 000044DA C3                  <1> 	ret
  4691                              <1> 
  4692                              <1> 
  4693                              <1> get_quote_token:
  4694 000044DB FF06[EA45]          <1> 	inc word [prog]			; Move past first quote (") char
  4695 000044DF 8B36[EA45]          <1> 	mov word si, [prog]
  4696 000044E3 BF007B              <1> 	mov di, token
  4697                              <1> .loop:
  4698 000044E6 AC                  <1> 	lodsb
  4699 000044E7 3C22                <1> 	cmp al, '"'
  4700 000044E9 740B                <1> 	je .done
  4701 000044EB 3C0A                <1> 	cmp al, 10
  4702 000044ED 7412                <1> 	je .error
  4703 000044EF AA                  <1> 	stosb
  4704 000044F0 FF06[EA45]          <1> 	inc word [prog]
  4705 000044F4 EBF0                <1> 	jmp .loop
  4706                              <1> 
  4707                              <1> .done:
  4708 000044F6 B000                <1> 	mov al, 0			; Zero-terminate the token
  4709 000044F8 AA                  <1> 	stosb
  4710 000044F9 FF06[EA45]          <1> 	inc word [prog]			; Move past final quote
  4711                              <1> 
  4712 000044FD B80500              <1> 	mov ax, QUOTE			; Pass back token type
  4713 00004500 C3                  <1> 	ret
  4714                              <1> 
  4715                              <1> .error:
  4716 00004501 BE1100              <1> 	mov si, err_quote_term
  4717 00004504 EB79                <1> 	jmp error
  4718                              <1> 
  4719                              <1> 
  4720                              <1> get_string_var_token:
  4721 00004506 AC                  <1> 	lodsb
  4722 00004507 0FB6D8              <1> 	movzx bx, al
  4723 0000450A 80EB31              <1> 	sub bl, 49
  4724                              <1> 
  4725 0000450D FF06[EA45]          <1> 	inc word [prog]
  4726 00004511 FF06[EA45]          <1> 	inc word [prog]
  4727                              <1> 
  4728 00004515 B80200              <1> 	mov ax, STRING_VAR
  4729 00004518 C3                  <1> 	ret
  4730                              <1> 	
  4731                              <1> 
  4732                              <1> get_string_token:
  4733 00004519 8B36[EA45]          <1> 	mov word si, [prog]
  4734 0000451D BF007B              <1> 	mov di, token
  4735                              <1> .loop:
  4736 00004520 AC                  <1> 	lodsb
  4737 00004521 3C0A                <1> 	cmp al, 10
  4738 00004523 740B                <1> 	je .done
  4739 00004525 3C20                <1> 	cmp al, ' '
  4740 00004527 7407                <1> 	je .done
  4741 00004529 AA                  <1> 	stosb
  4742 0000452A FF06[EA45]          <1> 	inc word [prog]
  4743 0000452E EBF0                <1> 	jmp .loop
  4744                              <1> .done:
  4745 00004530 B000                <1> 	mov al, 0			; Zero-terminate the token
  4746 00004532 AA                  <1> 	stosb
  4747                              <1> 
  4748 00004533 B8007B              <1> 	mov ax, token
  4749 00004536 E8D3E4              <1> 	call os_string_uppercase
  4750                              <1> 
  4751 00004539 B8007B              <1> 	mov ax, token
  4752 0000453C E874E4              <1> 	call os_string_length		; How long was the token?
  4753 0000453F 83F801              <1> 	cmp ax, 1			; If 1 char, it's a variable or delimiter
  4754 00004542 7413                <1> 	je .is_not_string
  4755                              <1> 
  4756 00004544 BE007B              <1> 	mov si, token			; If the token ends with ':', it's a label
  4757 00004547 01C6                <1> 	add si, ax
  4758 00004549 4E                  <1> 	dec si
  4759 0000454A AC                  <1> 	lodsb
  4760 0000454B 3C3A                <1> 	cmp al, ':'
  4761 0000454D 7404                <1> 	je .is_label
  4762                              <1> 
  4763 0000454F B80400              <1> 	mov ax, STRING			; Otherwise it's a general string of characters
  4764 00004552 C3                  <1> 	ret
  4765                              <1> 
  4766                              <1> .is_label:
  4767 00004553 B80800              <1> 	mov ax, LABEL
  4768 00004556 C3                  <1> 	ret
  4769                              <1> 
  4770                              <1> 
  4771                              <1> .is_not_string:
  4772 00004557 A0007B              <1> 	mov byte al, [token]
  4773 0000455A E81600              <1> 	call is_letter
  4774 0000455D 7204                <1> 	jc .is_var
  4775                              <1> 
  4776 0000455F B80700              <1> 	mov ax, UNKNOWN
  4777 00004562 C3                  <1> 	ret
  4778                              <1> 
  4779                              <1> .is_var:
  4780 00004563 B80100              <1> 	mov ax, VARIABLE		; Otherwise probably a variable
  4781 00004566 C3                  <1> 	ret
  4782                              <1> 
  4783                              <1> 
  4784                              <1> ; ------------------------------------------------------------------
  4785                              <1> ; Set carry flag if AL contains ASCII number
  4786                              <1> 
  4787                              <1> is_number:
  4788 00004567 3C30                <1> 	cmp al, 48
  4789 00004569 7C06                <1> 	jl .not_number
  4790 0000456B 3C39                <1> 	cmp al, 57
  4791 0000456D 7F02                <1> 	jg .not_number
  4792 0000456F F9                  <1> 	stc
  4793 00004570 C3                  <1> 	ret
  4794                              <1> .not_number:
  4795 00004571 F8                  <1> 	clc
  4796 00004572 C3                  <1> 	ret
  4797                              <1> 
  4798                              <1> 
  4799                              <1> ; ------------------------------------------------------------------
  4800                              <1> ; Set carry flag if AL contains ASCII letter
  4801                              <1> 
  4802                              <1> is_letter:
  4803 00004573 3C41                <1> 	cmp al, 65
  4804 00004575 7C06                <1> 	jl .not_letter
  4805 00004577 3C5A                <1> 	cmp al, 90
  4806 00004579 7F02                <1> 	jg .not_letter
  4807 0000457B F9                  <1> 	stc
  4808 0000457C C3                  <1> 	ret
  4809                              <1> 
  4810                              <1> .not_letter:
  4811 0000457D F8                  <1> 	clc
  4812 0000457E C3                  <1> 	ret
  4813                              <1> 
  4814                              <1> 
  4815                              <1> ; ------------------------------------------------------------------
  4816                              <1> ; Print error message and quit out
  4817                              <1> 
  4818                              <1> error:
  4819 0000457F B80005              <1> 	mov ax, 5 * 256			; Revert display page
  4820 00004582 CD10                <1> 	int 10h
  4821                              <1> 
  4822 00004584 E8B7D9              <1> 	call os_print_newline
  4823 00004587 BE[CB45]            <1> 	mov si, err_msg
  4824 0000458A E868D2              <1> 	call os_print_string
  4825                              <1> 	
  4826 0000458D 88D8                <1> 	mov al, bl
  4827 0000458F E800DC              <1> 	call os_print_2hex
  4828                              <1> 	
  4829 00004592 C606[F445]00        <1> 	mov byte [work_page], 0
  4830 00004597 C606[F545]00        <1> 	mov byte [disp_page], 0
  4831                              <1> 
  4832 0000459C BE[DF45]            <1> 	mov si, line_num_starter
  4833 0000459F E853D2              <1> 	call os_print_string
  4834                              <1> 
  4835                              <1> 
  4836                              <1> 	; And now print the line number where the error occurred. We do this
  4837                              <1> 	; by working from the start of the program to the current point,
  4838                              <1> 	; counting the number of newline characters along the way
  4839                              <1> 
  4840 000045A2 8B36[EE45]          <1> 	mov word si, [load_point]
  4841 000045A6 8B1E[EA45]          <1> 	mov word bx, [prog]
  4842 000045AA B90100              <1> 	mov cx, 1
  4843                              <1> 
  4844                              <1> .loop:
  4845 000045AD AC                  <1> 	lodsb
  4846 000045AE 3C0A                <1> 	cmp al, 10
  4847 000045B0 7501                <1> 	jne .not_newline
  4848 000045B2 41                  <1> 	inc cx
  4849                              <1> .not_newline:
  4850 000045B3 39DE                <1> 	cmp si, bx
  4851 000045B5 7402                <1> 	je .finish
  4852 000045B7 EBF4                <1> 	jmp .loop
  4853                              <1> .finish:
  4854                              <1> 
  4855 000045B9 89C8                <1> 	mov ax, cx
  4856 000045BB E886E5              <1> 	call os_int_to_string
  4857 000045BE 89C6                <1> 	mov si, ax
  4858 000045C0 E832D2              <1> 	call os_print_string
  4859                              <1> 
  4860                              <1> 
  4861 000045C3 E878D9              <1> 	call os_print_newline
  4862                              <1> 
  4863 000045C6 8B26[E845]          <1> 	mov word sp, [orig_stack]	; Restore the stack to as it was when BASIC started
  4864                              <1> 
  4865 000045CA C3                  <1> 	ret				; And finish
  4866                              <1> 
  4867                              <1> 
  4868                              <1> 	; Error messages text...
  4869                              <1> 
  4870                              <1> 	err_char_in_num		equ 00h
  4871                              <1> 	err_cmd_unknown		equ 01h
  4872                              <1> 	err_divide_by_zero	equ 02h
  4873                              <1> 	err_doloop_maximum	equ 03h
  4874                              <1> 	err_file_notfound	equ 04h
  4875                              <1> 	err_goto_notlabel	equ 05h
  4876                              <1> 	err_label_notfound	equ 06h
  4877                              <1> 	err_nest_limit		equ 07h
  4878                              <1> 	err_next			equ 08h
  4879                              <1> 	err_loop			equ 09h
  4880                              <1> 	err_print_type		equ 10h
  4881                              <1> 	err_quote_term		equ 11h
  4882                              <1> 	err_return			equ 12h
  4883                              <1> 	err_string_range	equ 13h
  4884                              <1> 	err_syntax			equ 14h
  4885                              <1> 
  4886 000045CB 4572726F722000      <1> 	err_msg				db "Error ", 0
  4887                              <1> 
  4888 000045D2 425245414B2043414C- <1> 	err_break			db "BREAK CALLED", 0
  4888 000045DB 4C454400            <1>
  4889                              <1> 
  4890 000045DF 202D206C696E652000  <1> 	line_num_starter	db " - line ", 0
  4891                              <1> 
  4892                              <1> 
  4893                              <1> ; ==================================================================
  4894                              <1> ; DATA SECTION
  4895                              <1> 
  4896 000045E8 0000                <1> 	orig_stack		dw 0		; Original stack location when BASIC started
  4897                              <1> 
  4898 000045EA 0000                <1> 	prog			dw 0		; Pointer to current location in BASIC code
  4899 000045EC 0000                <1> 	prog_end		dw 0		; Pointer to final byte of BASIC code
  4900                              <1> 
  4901 000045EE 0000                <1> 	load_point		dw 0
  4902                              <1> 
  4903 000045F0 00                  <1> 	token_type		db 0		; Type of last token read (eg NUMBER, VARIABLE)
  4904                              <1> 	token			equ 32768-1024-256
  4905                              <1> 
  4906                              <1> vars_loc:
  4907                              <1> ;	variables		times 26 dw 0	; Storage space for variables A to Z
  4908                              <1> 	variables		equ 32768-1024-384-52	; Storage space for variables A to Z
  4909                              <1> 
  4910                              <1> ;	for_variables		times 26 dw 0	; Storage for FOR loops
  4911                              <1> 	for_variables		equ 32768-1024-384-104	; Storage for FOR loops
  4912                              <1> ;	for_code_points		times 26 dw 0	; Storage for code positions where FOR loops start
  4913                              <1> 	for_code_points		equ 32768-1024-384-156	; Storage for code positions where FOR loops start
  4914                              <1> 	
  4915                              <1> ;	do_loop_store		times 10 dw 0	; Storage for DO loops
  4916                              <1> 	do_loop_store		equ 32768-1024-384-176	; Storage for DO loops
  4917 000045F1 00                  <1> 	loop_in			db 0		; Loop level
  4918                              <1> 
  4919 000045F2 01                  <1> 	last_if_true		db 1		; Checking for 'ELSE'
  4920                              <1> 
  4921 000045F3 00                  <1> 	ink_colour		db 0		; Text printing colour
  4922 000045F4 00                  <1> 	work_page		db 0		; Page to print to
  4923 000045F5 00                  <1> 	disp_page		db 0		; Page to display
  4924                              <1> 	
  4925 000045F6 414C45525400        <1> 	alert_cmd			db "ALERT", 0
  4926 000045FC 41534B46494C4500    <1> 	askfile_cmd			db "ASKFILE", 0
  4927 00004604 425245414B00        <1> 	break_cmd			db "BREAK", 0
  4928 0000460A 43414C4C00          <1> 	call_cmd			db "CALL", 0
  4929 0000460F 4341534500          <1> 	case_cmd			db "CASE", 0
  4930 00004614 434C5300            <1> 	cls_cmd				db "CLS", 0
  4931 00004618 435552534F5200      <1> 	cursor_cmd			db "CURSOR", 0
  4932 0000461F 435552534348415200  <1> 	curschar_cmd		db "CURSCHAR", 0
  4933 00004628 43555253434F4C00    <1> 	curscol_cmd			db "CURSCOL", 0
  4934 00004630 43555253504F5300    <1> 	curspos_cmd			db "CURSPOS", 0
  4935 00004638 44454C45544500      <1> 	delete_cmd			db "DELETE", 0
  4936 0000463F 444F00              <1> 	do_cmd				db "DO", 0
  4937 00004642 454C534500          <1> 	else_cmd			db "ELSE", 0
  4938 00004647 454E4400            <1> 	end_cmd				db "END", 0
  4939 0000464B 46494C455300        <1> 	files_cmd			db "FILES", 0
  4940 00004651 464F5200            <1> 	for_cmd 			db "FOR", 0
  4941 00004655 474F53554200        <1> 	gosub_cmd			db "GOSUB", 0
  4942 0000465B 474F544F00          <1> 	goto_cmd			db "GOTO", 0
  4943 00004660 4745544B455900      <1> 	getkey_cmd			db "GETKEY", 0
  4944 00004667 494600              <1> 	if_cmd 				db "IF", 0
  4945 0000466A 494E434C55444500    <1> 	include_cmd			db "INCLUDE", 0
  4946 00004672 494E4B00            <1> 	ink_cmd				db "INK", 0
  4947 00004676 494E50555400        <1> 	input_cmd 			db "INPUT", 0
  4948 0000467C 4C454E00            <1> 	len_cmd				db "LEN", 0
  4949 00004680 4C495354424F5800    <1> 	listbox_cmd			db "LISTBOX", 0
  4950 00004688 4C4F414400          <1> 	load_cmd			db "LOAD", 0
  4951 0000468D 4C4F4F5000          <1> 	loop_cmd			db "LOOP", 0
  4952 00004692 4D4F564500          <1> 	move_cmd 			db "MOVE", 0
  4953 00004697 4E45585400          <1> 	next_cmd 			db "NEXT", 0
  4954 0000469C 4E554D42455200      <1> 	number_cmd			db "NUMBER", 0
  4955 000046A3 5041474500          <1> 	page_cmd			db "PAGE", 0
  4956 000046A8 504155534500        <1> 	pause_cmd 			db "PAUSE", 0
  4957 000046AE 5045454B00          <1> 	peek_cmd			db "PEEK", 0
  4958 000046B3 5045454B494E5400    <1> 	peekint_cmd			db "PEEKINT", 0
  4959 000046BB 504F4B4500          <1> 	poke_cmd			db "POKE", 0
  4960 000046C0 504F4B45494E5400    <1> 	pokeint_cmd			db "POKEINT", 0
  4961 000046C8 504F525400          <1> 	port_cmd			db "PORT", 0
  4962 000046CD 5052494E5400        <1> 	print_cmd 			db "PRINT", 0
  4963 000046D3 52414E4400          <1> 	rand_cmd			db "RAND", 0
  4964 000046D8 5245414400          <1> 	read_cmd			db "READ", 0
  4965 000046DD 52454D00            <1> 	rem_cmd				db "REM", 0
  4966 000046E1 52454E414D4500      <1> 	rename_cmd			db "RENAME", 0
  4967 000046E8 52455455524E00      <1> 	return_cmd			db "RETURN", 0
  4968 000046EF 5341564500          <1> 	save_cmd			db "SAVE", 0
  4969 000046F4 53455249414C00      <1> 	serial_cmd			db "SERIAL", 0
  4970 000046FB 53495A4500          <1> 	size_cmd			db "SIZE", 0
  4971 00004700 534F554E4400        <1> 	sound_cmd 			db "SOUND", 0
  4972 00004706 535452494E4700      <1> 	string_cmd			db "STRING", 0
  4973 0000470D 574149544B455900    <1> 	waitkey_cmd			db "WAITKEY", 0
  4974                              <1> 
  4975 00004715 414E4400            <1> 	and_keyword			db "AND", 0
  4976 00004719 5448454E00          <1> 	then_keyword		db "THEN", 0
  4977 0000471E 43485200            <1> 	chr_keyword			db "CHR", 0
  4978 00004722 48455800            <1> 	hex_keyword			db "HEX", 0
  4979                              <1> 	
  4980 00004726 4C4F57455200        <1> 	lower_keyword		db "LOWER", 0
  4981 0000472C 555050455200        <1> 	upper_keyword		db "UPPER", 0
  4982                              <1> 
  4983 00004732 494E4B00            <1> 	ink_keyword			db "INK", 0
  4984 00004736 50524F475354415254- <1> 	progstart_keyword	db "PROGSTART", 0
  4984 0000473F 00                  <1>
  4985 00004740 52414D535441525400  <1> 	ramstart_keyword	db "RAMSTART", 0
  4986 00004749 54494D455200        <1> 	timer_keyword		db "TIMER", 0
  4987 0000474F 5641524941424C4553- <1> 	variables_keyword	db "VARIABLES", 0
  4987 00004758 00                  <1>
  4988 00004759 56455253494F4E00    <1> 	version_keyword		db "VERSION", 0
  4989                              <1> 
  4990 00004761 00                  <1> 	gosub_depth		db 0
  4991                              <1> 	gosub_points		equ 32768-1024-384-196	; Points in code to RETURN to
  4992                              <1> 
  4993                              <1> 	string_vars		equ 32768-1024
  4994                              <1> 
  4995                              <1> ; ------------------------------------------------------------------
  4996                              <1> 
   819                                  	%INCLUDE "drivers/int.asm"
   820                              <1> ; -----------------------------------------------------------------
   821                              <1> ; os_modify_int_handler -- Change location of interrupt handler
   822                              <1> ; IN: CL = int number, DI:SI = handler location
   823                              <1> 
   824                              <1> os_modify_int_handler:
   825 00004762 60                  <1> 	pusha
   826                              <1> 
   827 00004763 FA                  <1> 	cli
   828                              <1> 
   829 00004764 06                  <1> 	push es
   830                              <1> 	
   831 00004765 8E06[F205]          <1> 	mov es, [driversgmt]
   832                              <1> 	
   833 00004769 0FB6D9              <1> 	movzx bx, cl			; Move supplied int into BX
   834                              <1> 
   835 0000476C C1E302              <1> 	shl bx, 2			; Multiply by four to get position
   836                              <1> 	
   837 0000476F 268937              <1> 	mov [es:bx], si		; First store offset
   838                              <1> 
   839 00004772 83C302              <1> 	add bx, 2
   840                              <1> 	
   841 00004775 26893F              <1> 	mov [es:bx], di		; Then segment of our handler
   842                              <1> 
   843 00004778 07                  <1> 	pop es
   844                              <1> 	
   845 00004779 FB                  <1> 	sti
   846                              <1> 
   847 0000477A 61                  <1> 	popa
   848 0000477B C3                  <1> 	ret
   849                              <1> 
   850                              <1> ; -----------------------------------------------------------------
   851                              <1> ; os_get_int_handler -- Change location of interrupt handler
   852                              <1> ; IN: CL = int number; OUT: DI:SI = handler location
   853                              <1> 
   854                              <1> os_get_int_handler:
   855 0000477C 60                  <1> 	pusha
   856                              <1> 
   857 0000477D 1E                  <1> 	push ds
   858                              <1> 	
   859 0000477E 8E1E[F205]          <1> 	mov ds, [driversgmt]
   860                              <1> 	
   861 00004782 0FB6D9              <1> 	movzx bx, cl			; Move supplied int into BX
   862                              <1> 
   863 00004785 C1E302              <1> 	shl bx, 2			; Multiply by four to get position
   864                              <1> 	
   865 00004788 3E8B37              <1> 	mov si, [ds:bx]		; First store offset
   866 0000478B 83C302              <1> 	add bx, 2
   867                              <1> 
   868 0000478E 3E8B3F              <1> 	mov di, [ds:bx]		; Then segment of our handler
   869                              <1> 
   870 00004791 1F                  <1> 	pop ds
   871                              <1> 
   872 00004792 8936[A447]          <1> 	mov [.tmp_word], si
   873 00004796 893E[A647]          <1> 	mov [.tmp_sgmt], di
   874 0000479A 61                  <1> 	popa
   875 0000479B 8B36[A447]          <1> 	mov si, [.tmp_word]
   876 0000479F 8B3E[A647]          <1> 	mov di, [.tmp_sgmt]
   877 000047A3 C3                  <1> 	ret
   878                              <1> 
   879 000047A4 0000                <1> 	.tmp_word	dw 0
   880 000047A6 0000                <1> 	.tmp_sgmt	dw 0
   881                              <1> 	
   882                              <1> ; -----------------------------------------------------------------
   883                              <1> ; os_attach_timer_interrupt -- Attach a timer interrupt to an application and sets the timer speed
   884                              <1> ; Formula: speed = (105000000 / 88) / frequency
   885                              <1> ; IN: SI = handler location, CX = speed
   886                              <1> 
   887                              <1> os_attach_app_timer:
   888 000047A8 60                  <1> 	pusha
   889 000047A9 8936[B148]          <1> 	mov [timer_application_offset], si
   890 000047AD C606[B048]01        <1> 	mov byte [timer_application_attached], 1
   891                              <1> 	
   892 000047B2 E81A00              <1> 	call os_set_timer_speed
   893 000047B5 61                  <1> 	popa
   894 000047B6 C3                  <1> 	ret
   895                              <1> 	
   896                              <1> ; -----------------------------------------------------------------
   897                              <1> ; os_return_timer_interrupt -- Returns the timer interrupt back to the system and resets the timer speed
   898                              <1> ; IN: nothing
   899                              <1> 
   900                              <1> os_return_app_timer:
   901 000047B7 60                  <1> 	pusha
   902 000047B8 C606[B048]00        <1> 	mov byte [timer_application_attached], 0
   903                              <1> 	
   904 000047BD B90000              <1> 	mov cx, 0
   905 000047C0 E80C00              <1> 	call os_set_timer_speed
   906                              <1> 	
   907 000047C3 B11C                <1> 	mov cl, 1Ch					; RTC handler
   908 000047C5 BE[7848]            <1> 	mov si, os_compat_int1C
   909 000047C8 8CCF                <1> 	mov di, cs
   910 000047CA E895FF              <1> 	call os_modify_int_handler
   911 000047CD 61                  <1> 	popa
   912 000047CE C3                  <1> 	ret
   913                              <1> 	
   914                              <1> ; -----------------------------------------------------------------
   915                              <1> ; os_set_timer_speed -- Sets the timer's trigger speed.
   916                              <1> ; Formula: speed = (105000000 / 88) / frequency
   917                              <1> ; IN: CX = speed
   918                              <1> 
   919                              <1> os_set_timer_speed:
   920 000047CF 60                  <1> 	pusha
   921                              <1> 	
   922 000047D0 890E[B348]          <1> 	mov [current_timer_speed], cx
   923                              <1> 	
   924 000047D4 B036                <1> 	mov al, 00110110b	; Timer 0, square wave
   925 000047D6 E643                <1> 	out 43h, al
   926 000047D8 88C8                <1> 	mov al, cl
   927 000047DA E640                <1> 	out 40h, al
   928 000047DC 88E8                <1> 	mov al, ch
   929 000047DE E640                <1> 	out 40h, al
   930                              <1> 	
   931 000047E0 61                  <1> 	popa
   932 000047E1 C3                  <1> 	ret
   933                              <1> 	
   934                              <1> ; -----------------------------------------------------------------
   935                              <1> ; Interrupt call parsers
   936                              <1> 
   937                              <1> ; Division by 0 error handler
   938                              <1> os_compat_int00:
   939 000047E2 B8[E847]            <1> 	mov ax, .msg
   940 000047E5 E9B8CD              <1> 	jmp os_fatal_error
   941                              <1> 
   942 000047E8 4350553A2044697669- <1> 	.msg db 'CPU: Division by zero error', 0
   942 000047F1 73696F6E206279207A- <1>
   942 000047FA 65726F206572726F72- <1>
   942 00004803 00                  <1>
   943                              <1> 
   944                              <1> os_compat_int05:
   945 00004804 B8[0A48]            <1> 	mov ax, .msg
   946 00004807 E996CD              <1> 	jmp os_fatal_error
   947                              <1> 
   948 0000480A 557365722074726967- <1> 	.msg db 'User triggered crash', 0
   948 00004813 676572656420637261- <1>
   948 0000481C 736800              <1>
   949                              <1> 
   950                              <1> os_compat_int0C:
   951 0000481F FA                  <1> 	cli
   952 00004820 BCFEFF              <1> 	mov sp, 0FFFEh
   953 00004823 FB                  <1> 	sti
   954                              <1> 	
   955 00004824 B8[2A48]            <1> 	mov ax, .msg
   956 00004827 E976CD              <1> 	jmp os_fatal_error
   957                              <1> 	
   958 0000482A 537461636B206F7665- <1> 	.msg db 'Stack overflow', 0
   958 00004833 72666C6F7700        <1>
   959                              <1> 	
   960                              <1> ; Invalid opcode handler
   961                              <1> os_compat_int06:
   962 00004839 B8[3F48]            <1> 	mov ax, .msg
   963 0000483C E961CD              <1> 	jmp os_fatal_error
   964                              <1> 
   965 0000483F 4350553A20496E7661- <1> 	.msg db 'CPU: Invalid opcode', 0
   965 00004848 6C6964206F70636F64- <1>
   965 00004851 6500                <1>
   966                              <1> 
   967                              <1> ; Processor extension error handler
   968                              <1> os_compat_int07:
   969 00004853 B8[5948]            <1> 	mov ax, .msg
   970 00004856 E947CD              <1> 	jmp os_fatal_error
   971                              <1> 
   972 00004859 4350553A2050726F63- <1> 	.msg db 'CPU: Processor extension error', 0
   972 00004862 6573736F7220657874- <1>
   972 0000486B 656E73696F6E206572- <1>
   972 00004874 726F7200            <1>
   973                              <1> 
   974                              <1> ; System timer handler (8253/8254)
   975                              <1> os_compat_int1C:
   976 00004878 FA                  <1> 	cli
   977 00004879 6660                <1> 	pushad
   978 0000487B 1E                  <1> 	push ds
   979 0000487C 06                  <1> 	push es
   980                              <1> 	
   981 0000487D 8CC8                <1> 	mov ax, cs
   982 0000487F 8ED8                <1> 	mov ds, ax
   983 00004881 8EC0                <1> 	mov es, ax
   984                              <1> 	
   985 00004883 803E820001          <1> 	cmp byte [0082h], 1
   986 00004888 740E                <1> 	je .no_update
   987                              <1> 	
   988 0000488A 833E[B548]00        <1> 	cmp word [screensaver_timer], 0
   989 0000488F 7404                <1> 	je .no_update_screensaver
   990                              <1> 	
   991 00004891 FF0E[B548]          <1> 	dec word [screensaver_timer]
   992                              <1> 	
   993                              <1> .no_update_screensaver:	
   994 00004895 E8B2CC              <1> 	call os_update_clock
   995                              <1> 
   996                              <1> .no_update:
   997 00004898 2E803E[B048]01      <1> 	cmp byte [cs:timer_application_attached], 1
   998 0000489E 7406                <1> 	je .app_routine
   999                              <1> 
  1000 000048A0 07                  <1> 	pop es
  1001 000048A1 1F                  <1> 	pop ds
  1002 000048A2 6661                <1> 	popad
  1003 000048A4 FB                  <1> 	sti
  1004 000048A5 CF                  <1> 	iret
  1005                              <1> 
  1006                              <1> .app_routine:
  1007 000048A6 2EFF16[B148]        <1> 	call [cs:timer_application_offset]
  1008                              <1> 	
  1009 000048AB 07                  <1> 	pop es
  1010 000048AC 1F                  <1> 	pop ds	
  1011 000048AD 6661                <1> 	popad
  1012 000048AF CF                  <1> 	iret
  1013                              <1> 
  1014 000048B0 00                  <1> 	timer_application_attached	db 0
  1015 000048B1 0000                <1> 	timer_application_offset	dw 0
  1016                              <1> 	
  1017 000048B3 0000                <1> 	current_timer_speed			dw 0
  1018                              <1> 	
  1019 000048B5 0000                <1> 	screensaver_timer			dw 0
   820                                  	%INCLUDE "drivers/graphics.asm"
   821                              <1> 
   822                              <1> ; Puts a pixel on the screen.
   823                              <1> ; IN: AL = Color; BH = Page; CX = X position; DX = Y position
   824                              <1> ; OUT: nothing
   825                              <1> os_put_pixel:
   826 000048B7 60                  <1> 	pusha
   827 000048B8 B40C                <1> 	mov ah, 0Ch
   828 000048BA CD10                <1> 	int 10h
   829 000048BC 61                  <1> 	popa
   830 000048BD C3                  <1> 	ret
   831                              <1> 	
   832                              <1> ; Gets a pixel from the screen.
   833                              <1> ; IN: BH = Page; CX = X position; DX = Y position
   834                              <1> ; OUT: AL = Color
   835                              <1> os_get_pixel:
   836 000048BE 60                  <1> 	pusha
   837 000048BF B40D                <1> 	mov ah, 0Dh
   838 000048C1 CD10                <1> 	int 10h
   839 000048C3 A2[CB48]            <1> 	mov [.tmp_byte], al
   840 000048C6 61                  <1> 	popa
   841 000048C7 A0[CB48]            <1> 	mov al, [.tmp_byte]
   842 000048CA C3                  <1> 	ret
   843                              <1> 	
   844 000048CB 00                  <1> 	.tmp_byte	db 0
   845                              <1> 
   846                              <1> os_set_pixel:
   847 000048CC 60                  <1> 	pusha
   848 000048CD 89CA                <1> 	mov dx, cx
   849 000048CF 89C1                <1> 	mov cx, ax
   850 000048D1 88D8                <1> 	mov al, bl
   851 000048D3 B700                <1> 	mov bh, 0
   852 000048D5 E8DFFF              <1> 	call os_put_pixel
   853 000048D8 61                  <1> 	popa
   854 000048D9 C3                  <1> 	ret
   855                              <1> 	
   856                              <1> ; Implementation of Bresenham's line algorithm. Translated from an implementation in C (http://www.edepot.com/linebresenham.html)
   857                              <1> ; IN: CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour
   858                              <1> ; OUT: None, registers preserved
   859                              <1> os_draw_line:
   860 000048DA 60                  <1> 	pusha				; Save parameters
   861                              <1> 	
   862 000048DB 31C0                <1> 	xor ax, ax			; Clear variables
   863 000048DD BF[404A]            <1> 	mov di, .x1
   864 000048E0 B90B00              <1> 	mov cx, 11
   865 000048E3 F3AB                <1> 	rep stosw
   866                              <1> 	
   867 000048E5 61                  <1> 	popa				; Restore and save parameters
   868 000048E6 60                  <1> 	pusha
   869                              <1> 	
   870 000048E7 890E[404A]          <1> 	mov [.x1], cx			; Save points
   871 000048EB 890E[484A]          <1> 	mov [.x], cx
   872 000048EF 8916[424A]          <1> 	mov [.y1], dx
   873 000048F3 8916[4A4A]          <1> 	mov [.y], dx
   874 000048F7 8936[444A]          <1> 	mov [.x2], si
   875 000048FB 893E[464A]          <1> 	mov [.y2], di
   876                              <1> 	
   877 000048FF 881E[564A]          <1> 	mov [.colour], bl		; Save the colour
   878                              <1> 	
   879 00004903 8B1E[444A]          <1> 	mov bx, [.x2]
   880 00004907 A1[404A]            <1> 	mov ax, [.x1]
   881 0000490A 39C3                <1> 	cmp bx, ax
   882 0000490C 7C0E                <1> 	jl .x1gtx2
   883                              <1> 	
   884 0000490E 29C3                <1> 	sub bx, ax
   885 00004910 891E[4C4A]          <1> 	mov [.dx], bx
   886 00004914 B80100              <1> 	mov ax, 1
   887 00004917 A3[504A]            <1> 	mov [.incx], ax
   888 0000491A EB0B                <1> 	jmp .test2
   889                              <1> 	
   890                              <1> .x1gtx2:
   891 0000491C 29D8                <1> 	sub ax, bx
   892 0000491E A3[4C4A]            <1> 	mov [.dx], ax
   893 00004921 B8FFFF              <1> 	mov ax, -1
   894 00004924 A3[504A]            <1> 	mov [.incx], ax
   895                              <1> 	
   896                              <1> .test2:
   897 00004927 8B1E[464A]          <1> 	mov bx, [.y2]
   898 0000492B A1[424A]            <1> 	mov ax, [.y1]
   899 0000492E 39C3                <1> 	cmp bx, ax
   900 00004930 7C0E                <1> 	jl .y1gty2
   901                              <1> 	
   902 00004932 29C3                <1> 	sub bx, ax
   903 00004934 891E[4E4A]          <1> 	mov [.dy], bx
   904 00004938 B80100              <1> 	mov ax, 1
   905 0000493B A3[524A]            <1> 	mov [.incy], ax
   906 0000493E EB0B                <1> 	jmp .test3
   907                              <1> 	
   908                              <1> .y1gty2:
   909 00004940 29D8                <1> 	sub ax, bx
   910 00004942 A3[4E4A]            <1> 	mov [.dy], ax
   911 00004945 B8FFFF              <1> 	mov ax, -1
   912 00004948 A3[524A]            <1> 	mov [.incy], ax
   913                              <1> 	
   914                              <1> .test3:
   915 0000494B 8B1E[4C4A]          <1> 	mov bx, [.dx]
   916 0000494F A1[4E4A]            <1> 	mov ax, [.dy]
   917 00004952 39C3                <1> 	cmp bx, ax
   918 00004954 7C6E                <1> 	jl .dygtdx
   919                              <1> 	
   920 00004956 A1[4E4A]            <1> 	mov ax, [.dy]
   921 00004959 D1E0                <1> 	shl ax, 1
   922 0000495B A3[4E4A]            <1> 	mov [.dy], ax
   923                              <1> 	
   924 0000495E 8B1E[4C4A]          <1> 	mov bx, [.dx]
   925 00004962 29D8                <1> 	sub ax, bx
   926 00004964 A3[544A]            <1> 	mov [.balance], ax
   927                              <1> 	
   928 00004967 D1E3                <1> 	shl bx, 1
   929 00004969 891E[4C4A]          <1> 	mov [.dx], bx
   930                              <1> 	
   931                              <1> .xloop:
   932 0000496D A1[484A]            <1> 	mov ax, [.x]
   933 00004970 8B1E[444A]          <1> 	mov bx, [.x2]
   934 00004974 39D8                <1> 	cmp ax, bx
   935 00004976 0F84B600            <1> 	je .done
   936                              <1> 	
   937 0000497A A1[484A]            <1> 	mov ax, [.x]
   938 0000497D 8B0E[4A4A]          <1> 	mov cx, [.y]
   939 00004981 8A1E[564A]          <1> 	mov bl, [.colour]
   940 00004985 E844FF              <1> 	call os_set_pixel
   941                              <1> 	
   942 00004988 31F6                <1> 	xor si, si
   943 0000498A 8B3E[544A]          <1> 	mov di, [.balance]
   944 0000498E 39F7                <1> 	cmp di, si
   945 00004990 7C18                <1> 	jl .xloop1
   946                              <1> 	
   947 00004992 A1[4A4A]            <1> 	mov ax, [.y]
   948 00004995 8B1E[524A]          <1> 	mov bx, [.incy]
   949 00004999 01D8                <1> 	add ax, bx
   950 0000499B A3[4A4A]            <1> 	mov [.y], ax
   951                              <1> 	
   952 0000499E A1[544A]            <1> 	mov ax, [.balance]
   953 000049A1 8B1E[4C4A]          <1> 	mov bx, [.dx]
   954 000049A5 29D8                <1> 	sub ax, bx
   955 000049A7 A3[544A]            <1> 	mov [.balance], ax
   956                              <1> 	
   957                              <1> .xloop1:
   958 000049AA A1[544A]            <1> 	mov ax, [.balance]
   959 000049AD 8B1E[4E4A]          <1> 	mov bx, [.dy]
   960 000049B1 01D8                <1> 	add ax, bx
   961 000049B3 A3[544A]            <1> 	mov [.balance], ax
   962                              <1> 	
   963 000049B6 A1[484A]            <1> 	mov ax, [.x]
   964 000049B9 8B1E[504A]          <1> 	mov bx, [.incx]
   965 000049BD 01D8                <1> 	add ax, bx
   966 000049BF A3[484A]            <1> 	mov [.x], ax
   967                              <1> 	
   968 000049C2 EBA9                <1> 	jmp .xloop
   969                              <1> 	
   970                              <1> .dygtdx:
   971 000049C4 A1[4C4A]            <1> 	mov ax, [.dx]
   972 000049C7 D1E0                <1> 	shl ax, 1
   973 000049C9 A3[4C4A]            <1> 	mov [.dx], ax
   974                              <1> 	
   975 000049CC 8B1E[4E4A]          <1> 	mov bx, [.dy]
   976 000049D0 29D8                <1> 	sub ax, bx
   977 000049D2 A3[544A]            <1> 	mov [.balance], ax
   978                              <1> 	
   979 000049D5 D1E3                <1> 	shl bx, 1
   980 000049D7 891E[4E4A]          <1> 	mov [.dy], bx
   981                              <1> 	
   982                              <1> .yloop:
   983 000049DB A1[4A4A]            <1> 	mov ax, [.y]
   984 000049DE 8B1E[464A]          <1> 	mov bx, [.y2]
   985 000049E2 39D8                <1> 	cmp ax, bx
   986 000049E4 744A                <1> 	je .done
   987                              <1> 	
   988 000049E6 A1[484A]            <1> 	mov ax, [.x]
   989 000049E9 8B0E[4A4A]          <1> 	mov cx, [.y]
   990 000049ED 8A1E[564A]          <1> 	mov bl, [.colour]
   991 000049F1 E8D8FE              <1> 	call os_set_pixel
   992                              <1> 	
   993 000049F4 31F6                <1> 	xor si, si
   994 000049F6 8B3E[544A]          <1> 	mov di, [.balance]
   995 000049FA 39F7                <1> 	cmp di, si
   996 000049FC 7C18                <1> 	jl .yloop1
   997                              <1> 	
   998 000049FE A1[484A]            <1> 	mov ax, [.x]
   999 00004A01 8B1E[504A]          <1> 	mov bx, [.incx]
  1000 00004A05 01D8                <1> 	add ax, bx
  1001 00004A07 A3[484A]            <1> 	mov [.x], ax
  1002                              <1> 	
  1003 00004A0A A1[544A]            <1> 	mov ax, [.balance]
  1004 00004A0D 8B1E[4E4A]          <1> 	mov bx, [.dy]
  1005 00004A11 29D8                <1> 	sub ax, bx
  1006 00004A13 A3[544A]            <1> 	mov [.balance], ax
  1007                              <1> 	
  1008                              <1> .yloop1:
  1009 00004A16 A1[544A]            <1> 	mov ax, [.balance]
  1010 00004A19 8B1E[4C4A]          <1> 	mov bx, [.dx]
  1011 00004A1D 01D8                <1> 	add ax, bx
  1012 00004A1F A3[544A]            <1> 	mov [.balance], ax
  1013                              <1> 	
  1014 00004A22 A1[4A4A]            <1> 	mov ax, [.y]
  1015 00004A25 8B1E[524A]          <1> 	mov bx, [.incy]
  1016 00004A29 01D8                <1> 	add ax, bx
  1017 00004A2B A3[4A4A]            <1> 	mov [.y], ax
  1018                              <1> 	
  1019 00004A2E EBAB                <1> 	jmp .yloop
  1020                              <1> 	
  1021                              <1> .done:
  1022 00004A30 A1[484A]            <1> 	mov ax, [.x]
  1023 00004A33 8B0E[4A4A]          <1> 	mov cx, [.y]
  1024 00004A37 8A1E[564A]          <1> 	mov bl, [.colour]
  1025 00004A3B E88EFE              <1> 	call os_set_pixel
  1026                              <1> 	
  1027 00004A3E 61                  <1> 	popa
  1028 00004A3F C3                  <1> 	ret
  1029                              <1> 	
  1030                              <1> 	
  1031 00004A40 0000                <1> 	.x1 dw 0
  1032 00004A42 0000                <1> 	.y1 dw 0
  1033 00004A44 0000                <1> 	.x2 dw 0
  1034 00004A46 0000                <1> 	.y2 dw 0
  1035                              <1> 	
  1036 00004A48 0000                <1> 	.x dw 0
  1037 00004A4A 0000                <1> 	.y dw 0
  1038 00004A4C 0000                <1> 	.dx dw 0
  1039 00004A4E 0000                <1> 	.dy dw 0
  1040 00004A50 0000                <1> 	.incx dw 0
  1041 00004A52 0000                <1> 	.incy dw 0
  1042 00004A54 0000                <1> 	.balance dw 0
  1043 00004A56 00                  <1> 	.colour db 0
  1044 00004A57 00                  <1> 	.pad db 0
  1045                              <1> 	
  1046                              <1> ; Draw (straight) rectangle
  1047                              <1> ; IN: CX=X1, DX=Y1, SI=X2, DI=Y2, BL=colour, CF = set if filled or clear if not
  1048                              <1> ; OUT: None, registers preserved
  1049                              <1> os_draw_rectangle:
  1050 00004A58 60                  <1> 	pusha
  1051 00004A59 9C                  <1> 	pushf
  1052                              <1> 	
  1053 00004A5A 890E[E44A]          <1> 	mov word [.x1], cx
  1054 00004A5E 8916[E84A]          <1> 	mov word [.y1], dx
  1055 00004A62 8936[E64A]          <1> 	mov word [.x2], si
  1056 00004A66 893E[EA4A]          <1> 	mov word [.y2], di
  1057                              <1> 	
  1058 00004A6A 9D                  <1> 	popf
  1059 00004A6B 7302                <1> 	jnc .draw_line
  1060                              <1> 
  1061 00004A6D EB4E                <1> 	jmp .fill_shape
  1062                              <1> 	
  1063                              <1> .draw_line:
  1064                              <1> 	; top line
  1065 00004A6F 8B0E[E44A]          <1> 	mov cx, [.x1]
  1066 00004A73 8B16[E84A]          <1> 	mov dx, [.y1]
  1067 00004A77 8B36[E64A]          <1> 	mov si, [.x2]
  1068 00004A7B 8B3E[E84A]          <1> 	mov di, [.y1]
  1069 00004A7F E858FE              <1> 	call os_draw_line
  1070                              <1> 	
  1071                              <1> 	; left line
  1072 00004A82 8B0E[E44A]          <1> 	mov cx, [.x1]
  1073 00004A86 8B16[E84A]          <1> 	mov dx, [.y1]
  1074 00004A8A 8B36[E44A]          <1> 	mov si, [.x1]
  1075 00004A8E 8B3E[EA4A]          <1> 	mov di, [.y2]
  1076 00004A92 E845FE              <1> 	call os_draw_line
  1077                              <1> 	
  1078                              <1> 	; right line
  1079 00004A95 8B0E[E64A]          <1> 	mov cx, [.x2]
  1080 00004A99 8B16[E84A]          <1> 	mov dx, [.y1]
  1081 00004A9D 8B36[E64A]          <1> 	mov si, [.x2]
  1082 00004AA1 8B3E[EA4A]          <1> 	mov di, [.y2]
  1083 00004AA5 E832FE              <1> 	call os_draw_line
  1084                              <1> 
  1085                              <1> 	; bottom line
  1086 00004AA8 8B0E[E44A]          <1> 	mov cx, [.x1]
  1087 00004AAC 8B16[EA4A]          <1> 	mov dx, [.y2]
  1088 00004AB0 8B36[E64A]          <1> 	mov si, [.x2]
  1089 00004AB4 8B3E[EA4A]          <1> 	mov di, [.y2]
  1090 00004AB8 E81FFE              <1> 	call os_draw_line
  1091                              <1> 		
  1092 00004ABB EB25                <1> 	jmp .finished_fill
  1093                              <1> 		
  1094                              <1> .fill_shape:
  1095 00004ABD 88D8                <1> 	mov al, bl
  1096                              <1> 
  1097 00004ABF 39F1                <1> 	cmp cx, si		; Is X1 smaller than X2?
  1098 00004AC1 7C02                <1> 	jl .x_good
  1099 00004AC3 87CE                <1> 	xchg cx, si		; If not, exchange them
  1100                              <1> .x_good:
  1101 00004AC5 39FA                <1> 	cmp dx, di		; Is Y1 smaller than Y2?
  1102 00004AC7 7C02                <1> 	jl .y_good
  1103 00004AC9 87D7                <1> 	xchg dx, di		; If not, exchange them
  1104                              <1> .y_good:
  1105 00004ACB 890E[E44A]          <1> 	mov [.x1], cx
  1106 00004ACF B700                <1> 	mov bh, 0
  1107                              <1> .x_loop:
  1108 00004AD1 E8E3FD              <1> 	call os_put_pixel
  1109 00004AD4 41                  <1> 	inc cx
  1110                              <1> 	
  1111 00004AD5 39F1                <1> 	cmp cx, si
  1112 00004AD7 7CF8                <1> 	jl .x_loop
  1113                              <1> 	
  1114 00004AD9 42                  <1> 	inc dx
  1115 00004ADA 8B0E[E44A]          <1> 	mov cx, [.x1]
  1116                              <1> 	
  1117 00004ADE 39FA                <1> 	cmp dx, di
  1118 00004AE0 7CEF                <1> 	jl .x_loop
  1119                              <1> 		
  1120                              <1> .finished_fill:
  1121 00004AE2 61                  <1> 	popa
  1122 00004AE3 C3                  <1> 	ret
  1123                              <1> 	
  1124 00004AE4 0000                <1> 	.x1				dw 0
  1125 00004AE6 0000                <1> 	.x2				dw 0
  1126 00004AE8 0000                <1> 	.y1				dw 0
  1127 00004AEA 0000                <1> 	.y2				dw 0
  1128                              <1> 
  1129                              <1> ; Draw freeform shape
  1130                              <1> ; IN: BH = number of points, BL = colour, SI = location of shape points data
  1131                              <1> ; OUT: None, registers preserved
  1132                              <1> ; DATA FORMAT: x1, y1, x2, y2, x3, y3, etc
  1133                              <1> os_draw_polygon:
  1134 00004AEC 60                  <1> 	pusha
  1135                              <1> 	
  1136 00004AED FECF                <1> 	dec bh
  1137 00004AEF 883E[5A4B]          <1> 	mov byte [.points], bh
  1138                              <1> 	
  1139 00004AF3 648B04              <1> 	mov word ax, [fs:si]
  1140 00004AF6 83C602              <1> 	add si, 2
  1141 00004AF9 A3[524B]            <1> 	mov word [.xi], ax
  1142 00004AFC A3[564B]            <1> 	mov word [.xl], ax
  1143                              <1> 	
  1144 00004AFF 648B04              <1> 	mov word ax, [fs:si]
  1145 00004B02 83C602              <1> 	add si, 2
  1146 00004B05 A3[544B]            <1> 	mov word [.yi], ax
  1147 00004B08 A3[584B]            <1> 	mov word [.yl], ax
  1148                              <1> 	
  1149                              <1> 	.draw_points:
  1150 00004B0B 8B0E[564B]          <1> 		mov cx, [.xl]
  1151 00004B0F 8B16[584B]          <1> 		mov dx, [.yl]
  1152                              <1> 		
  1153 00004B13 648B04              <1> 		mov word ax, [fs:si]
  1154 00004B16 83C602              <1> 		add si, 2
  1155 00004B19 A3[564B]            <1> 		mov word [.xl], ax
  1156                              <1> 		
  1157 00004B1C 648B04              <1> 		mov word ax, [fs:si]
  1158 00004B1F 83C602              <1> 		add si, 2
  1159 00004B22 A3[584B]            <1> 		mov word [.yl], ax
  1160                              <1> 		
  1161 00004B25 56                  <1> 		push si
  1162                              <1> 		
  1163 00004B26 8B36[564B]          <1> 		mov si, [.xl]
  1164 00004B2A 8B3E[584B]          <1> 		mov di, [.yl]
  1165                              <1> 		
  1166 00004B2E E8A9FD              <1> 		call os_draw_line
  1167                              <1> 		
  1168 00004B31 5E                  <1> 		pop si
  1169                              <1> 		
  1170 00004B32 FE0E[5A4B]          <1> 		dec byte [.points]
  1171 00004B36 803E[5A4B]00        <1> 		cmp byte [.points], 0
  1172 00004B3B 75CE                <1> 		jne .draw_points
  1173                              <1> 		
  1174 00004B3D 8B0E[564B]          <1> 	mov cx, [.xl]
  1175 00004B41 8B16[584B]          <1> 	mov dx, [.yl]
  1176 00004B45 8B36[524B]          <1> 	mov si, [.xi]
  1177 00004B49 8B3E[544B]          <1> 	mov di, [.yi]
  1178 00004B4D E88AFD              <1> 	call os_draw_line
  1179                              <1> 	
  1180 00004B50 61                  <1> 	popa
  1181 00004B51 C3                  <1> 	ret
  1182                              <1> 	
  1183 00004B52 0000                <1> 	.xi				dw 0
  1184 00004B54 0000                <1> 	.yi				dw 0
  1185 00004B56 0000                <1> 	.xl				dw 0
  1186 00004B58 0000                <1> 	.yl				dw 0
  1187 00004B5A 00                  <1> 	.points				db 0
  1188                              <1> 	
  1189                              <1> 
  1190                              <1> ; Clear the screen by setting all pixels to a single colour
  1191                              <1> ; BL = colour to set
  1192                              <1> os_clear_graphics:
  1193 00004B5B 60                  <1> 	pusha
  1194 00004B5C 06                  <1> 	push es
  1195                              <1> 	
  1196 00004B5D B800A0              <1> 	mov ax, 0xA000
  1197 00004B60 8EC0                <1> 	mov es, ax
  1198                              <1> 
  1199 00004B62 88D8                <1> 	mov al, bl
  1200 00004B64 BF0000              <1> 	mov di, 0
  1201 00004B67 B900FA              <1> 	mov cx, 64000
  1202 00004B6A F3AA                <1> 	rep stosb
  1203                              <1> 
  1204 00004B6C 07                  <1> 	pop es
  1205 00004B6D 61                  <1> 	popa
  1206 00004B6E C3                  <1> 	ret
  1207                              <1> 	
  1208                              <1> 	
  1209                              <1> ; ----------------------------------------
  1210                              <1> ; os_draw_circle -- draw a circular shape
  1211                              <1> ; IN: AL = colour, BX = radius, CX = middle X, DX = middle y
  1212                              <1> 
  1213                              <1> os_draw_circle:
  1214 00004B6F 60                  <1> 	pusha
  1215 00004B70 A2[314C]            <1> 	mov [.colour], al
  1216 00004B73 891E[364C]          <1> 	mov [.radius], bx
  1217 00004B77 890E[324C]          <1> 	mov [.x0], cx
  1218 00004B7B 8916[344C]          <1> 	mov [.y0], dx
  1219                              <1> 
  1220 00004B7F 891E[384C]          <1> 	mov [.x], bx
  1221 00004B83 C706[3A4C]0000      <1> 	mov word [.y], 0
  1222 00004B89 B80100              <1> 	mov ax, 1
  1223 00004B8C D1E3                <1> 	shl bx, 1
  1224 00004B8E 29D8                <1> 	sub ax, bx
  1225 00004B90 A3[3C4C]            <1> 	mov [.xChange], ax
  1226 00004B93 C706[3E4C]0000      <1> 	mov word [.yChange], 0
  1227 00004B99 C706[404C]0000      <1> 	mov word [.radiusError], 0
  1228                              <1> 
  1229                              <1> .next_point:
  1230 00004B9F 8B0E[384C]          <1> 	mov cx, [.x]
  1231 00004BA3 8B16[3A4C]          <1> 	mov dx, [.y]
  1232 00004BA7 39D1                <1> 	cmp cx, dx
  1233 00004BA9 0F8C8200            <1> 	jl .finish
  1234                              <1> 
  1235                              <1> 	;ax bx - function points
  1236                              <1> 	;cx = x 
  1237                              <1> 	;dx = y
  1238                              <1> 	;si = -x
  1239                              <1> 	;di = -y
  1240                              <1> 
  1241 00004BAD 89CE                <1> 	mov si, cx
  1242 00004BAF 83F6FF              <1> 	xor si, 0xFFFF
  1243 00004BB2 46                  <1> 	inc si
  1244 00004BB3 89D7                <1> 	mov di, dx
  1245 00004BB5 83F7FF              <1> 	xor di, 0xFFFF
  1246 00004BB8 47                  <1> 	inc di
  1247                              <1> 
  1248                              <1> 	; (x + x0, y + y0)
  1249 00004BB9 89C8                <1> 	mov ax, cx
  1250 00004BBB 89D3                <1> 	mov bx, dx
  1251 00004BBD E85B00              <1> 	call .draw_point
  1252                              <1> 
  1253                              <1> 	; (y + x0, x + y0)
  1254 00004BC0 93                  <1> 	xchg ax, bx
  1255 00004BC1 E85700              <1> 	call .draw_point
  1256                              <1> 
  1257                              <1> 	; (-x + x0, y + y0)
  1258 00004BC4 89F0                <1> 	mov ax, si
  1259 00004BC6 89D3                <1> 	mov bx, dx
  1260 00004BC8 E85000              <1> 	call .draw_point
  1261                              <1> 
  1262                              <1> 	; (-y + x0, x + y0)
  1263 00004BCB 89F8                <1> 	mov ax, di
  1264 00004BCD 89CB                <1> 	mov bx, cx
  1265 00004BCF E84900              <1> 	call .draw_point
  1266                              <1> 
  1267                              <1> 	; (-x + x0, -y + y0)
  1268 00004BD2 89F0                <1> 	mov ax, si
  1269 00004BD4 89FB                <1> 	mov bx, di
  1270 00004BD6 E84200              <1> 	call .draw_point
  1271                              <1> 
  1272                              <1> 	; (-y + x0, -x + y0)
  1273 00004BD9 93                  <1> 	xchg ax, bx
  1274 00004BDA E83E00              <1> 	call .draw_point
  1275                              <1> 
  1276                              <1> 	; (x + x0, -y + y0)
  1277 00004BDD 89C8                <1> 	mov ax, cx
  1278 00004BDF 89FB                <1> 	mov bx, di
  1279 00004BE1 E83700              <1> 	call .draw_point
  1280                              <1> 
  1281                              <1> 	; (y + x0, -x + y0)
  1282 00004BE4 89D0                <1> 	mov ax, dx
  1283 00004BE6 89F3                <1> 	mov bx, si
  1284 00004BE8 E83000              <1> 	call .draw_point
  1285                              <1> 	
  1286 00004BEB FF06[3A4C]          <1> 	inc word [.y]
  1287 00004BEF A1[3E4C]            <1> 	mov ax, [.yChange]
  1288 00004BF2 0106[404C]          <1> 	add [.radiusError], ax
  1289 00004BF6 8306[3E4C]02        <1> 	add word [.yChange], 2
  1290                              <1> 	
  1291 00004BFB A1[404C]            <1> 	mov ax, [.radiusError]
  1292 00004BFE D1E0                <1> 	shl ax, 1
  1293 00004C00 0306[3C4C]          <1> 	add ax, [.xChange]
  1294                              <1> 	
  1295 00004C04 83F800              <1> 	cmp ax, 0
  1296 00004C07 7E96                <1> 	jle .next_point
  1297                              <1> 	
  1298 00004C09 FF0E[384C]          <1> 	dec word [.x]
  1299 00004C0D A1[3C4C]            <1> 	mov ax, [.xChange]
  1300 00004C10 0106[404C]          <1> 	add [.radiusError], ax
  1301 00004C14 8306[3C4C]02        <1> 	add word [.xChange], 2
  1302                              <1> 
  1303 00004C19 EB84                <1> 	jmp .next_point
  1304                              <1> 
  1305                              <1> .draw_point:
  1306                              <1> 	; AX = X, BX = Y
  1307 00004C1B 60                  <1> 	pusha
  1308 00004C1C 0306[324C]          <1> 	add ax, [.x0]
  1309 00004C20 031E[344C]          <1> 	add bx, [.y0]
  1310 00004C24 89D9                <1> 	mov cx, bx
  1311 00004C26 8A1E[314C]          <1> 	mov bl, [.colour]
  1312 00004C2A E89FFC              <1> 	call os_set_pixel
  1313 00004C2D 61                  <1> 	popa
  1314 00004C2E C3                  <1> 	ret
  1315                              <1> 	
  1316                              <1> .finish:
  1317 00004C2F 61                  <1> 	popa
  1318 00004C30 C3                  <1> 	ret
  1319                              <1> 	
  1320                              <1> 
  1321                              <1> 
  1322 00004C31 00                  <1> .colour				db 0
  1323 00004C32 0000                <1> .x0					dw 0
  1324 00004C34 0000                <1> .y0					dw 0
  1325 00004C36 0000                <1> .radius				dw 0
  1326 00004C38 0000                <1> .x					dw 0
  1327 00004C3A 0000                <1> .y					dw 0
  1328 00004C3C 0000                <1> .xChange			dw 0
  1329 00004C3E 0000                <1> .yChange			dw 0
  1330 00004C40 0000                <1> .radiusError		dw 0
   821                                  	%INCLUDE "drivers/name.asm"
   822                              <1> 
   823 00004C42 43726570654F532076- <1> 	osname	db 'CrepeOS v0.7b2', 0
   823 00004C4B 302E37623200        <1>
   822                                  	%INCLUDE "drivers/shutdown.asm"
   823                              <1> 
   824                              <1> os_shutdown:
   825 00004C51 C606820001          <1> 	mov byte [0082h], 1
   826 00004C56 E84DCC              <1> 	call os_hide_cursor
   827 00004C59 E8E000              <1> 	call .drawbackground
   828 00004C5C E87E00              <1> 	call .drawwindow
   829 00004C5F E81200              <1> 	call .selector
   830                              <1> 	
   831 00004C62 3C01                <1> 	cmp al, 1
   832 00004C64 0F841101            <1> 	je near .shutdown
   833                              <1> 	
   834 00004C68 3C02                <1> 	cmp al, 2
   835 00004C6A 0F840601            <1> 	je near .reset
   836                              <1> 	
   837 00004C6E 3C03                <1> 	cmp al, 3
   838 00004C70 0F845FB6            <1> 	je near checkformenu
   839                              <1> 	
   840                              <1> .selector:
   841 00004C74 BA1C0B              <1> 	mov dx, 11 * 256 + 28
   842 00004C77 E8ECCB              <1> 	call os_move_cursor
   843                              <1> 
   844                              <1> .selectorloop:
   845 00004C7A E87000              <1> 	call .drawcontents
   846 00004C7D E83A00              <1> 	call .invert
   847                              <1> 	
   848 00004C80 E8F7C5              <1> 	call os_wait_for_key
   849                              <1> 	
   850 00004C83 80FC50              <1> 	cmp ah, 80
   851 00004C86 7417                <1> 	je .selectdown
   852                              <1> 	
   853 00004C88 80FC48              <1> 	cmp ah, 72
   854 00004C8B 741D                <1> 	je .selectup
   855                              <1> 	
   856 00004C8D 3C0D                <1> 	cmp al, 13
   857 00004C8F 7424                <1> 	je .select
   858                              <1> 	
   859 00004C91 3C1B                <1> 	cmp al, 27
   860 00004C93 7402                <1> 	je .return
   861                              <1> 	
   862 00004C95 EBE3                <1> 	jmp .selectorloop
   863                              <1> 
   864                              <1> .return:
   865 00004C97 B003                <1> 	mov al, 3
   866 00004C99 C606820001          <1> 	mov byte [0082h], 1
   867 00004C9E C3                  <1> 	ret
   868                              <1> 
   869                              <1> .selectdown:
   870 00004C9F 80FE0D              <1> 	cmp dh, 13
   871 00004CA2 0F84D4FF            <1> 	je near .selectorloop
   872 00004CA6 FEC6                <1> 	inc dh
   873 00004CA8 EBD0                <1> 	jmp .selectorloop
   874                              <1> 
   875                              <1> .selectup:
   876 00004CAA 80FE0B              <1> 	cmp dh, 11
   877 00004CAD 0F84C9FF            <1> 	je near .selectorloop
   878 00004CB1 FECE                <1> 	dec dh
   879 00004CB3 EBC5                <1> 	jmp .selectorloop
   880                              <1> 
   881                              <1> .select:
   882 00004CB5 88F0                <1> 	mov al, dh
   883 00004CB7 2C0A                <1> 	sub al, 10
   884 00004CB9 C3                  <1> 	ret
   885                              <1> 	
   886                              <1> .invert:
   887 00004CBA B21C                <1> 	mov dl, 28
   888                              <1> 
   889                              <1> .invertloop:
   890 00004CBC E8A7CB              <1> 	call os_move_cursor
   891 00004CBF B408                <1> 	mov ah, 08h
   892 00004CC1 B700                <1> 	mov bh, 0
   893 00004CC3 CD10                <1> 	int 10h
   894                              <1> 
   895 00004CC5 BBF000              <1> 	mov bx, 240			; Black on white
   896 00004CC8 B409                <1> 	mov ah, 09h
   897 00004CCA B90100              <1> 	mov cx, 1
   898 00004CCD CD10                <1> 	int 10h
   899                              <1> 
   900 00004CCF FEC2                <1> 	inc dl
   901 00004CD1 80FA3C              <1> 	cmp dl, 60
   902 00004CD4 0F840200            <1> 	je near .invertend
   903 00004CD8 EBE2                <1> 	jmp .invertloop
   904                              <1> 	
   905                              <1> .invertend:
   906 00004CDA B21C                <1> 	mov dl, 28
   907 00004CDC C3                  <1> 	ret
   908                              <1> 	
   909                              <1> .drawwindow:
   910 00004CDD BA1309              <1> 	mov dx, 9 * 256 + 19			; First, draw white background box
   911 00004CE0 8A1EA9DE            <1> 	mov bl, [57001]
   912 00004CE4 BE2A00              <1> 	mov si, 42
   913 00004CE7 BF0F00              <1> 	mov di, 15
   914 00004CEA E8C3CB              <1> 	call os_draw_block
   915                              <1> 
   916                              <1> .drawcontents:
   917 00004CED 60                  <1> 	pusha
   918 00004CEE 8A1EA9DE            <1> 	mov bl, [57001]
   919 00004CF2 BA140A              <1> 	mov dx, 10 * 256 + 20
   920 00004CF5 E86ECB              <1> 	call os_move_cursor
   921                              <1> 
   922 00004CF8 BE[154E]            <1> 	mov si, .dialogmsg1
   923 00004CFB E821CB              <1> 	call os_format_string
   924 00004CFE BECCDE              <1> 	mov si, 57036
   925 00004D01 E81BCB              <1> 	call os_format_string
   926 00004D04 BE[1F4E]            <1> 	mov si, .dialogmsg2
   927 00004D07 E815CB              <1> 	call os_format_string
   928                              <1> 
   929 00004D0A BA140B              <1> 	mov dx, 11 * 256 + 20
   930 00004D0D E856CB              <1> 	call os_move_cursor
   931 00004D10 BE[B24F]            <1> 	mov si, .logo0
   932 00004D13 E809CB              <1> 	call os_format_string
   933                              <1> 
   934 00004D16 BA140C              <1> 	mov dx, 12 * 256 + 20
   935 00004D19 E84ACB              <1> 	call os_move_cursor
   936 00004D1C BE[DB4F]            <1> 	mov si, .logo1
   937 00004D1F E8FDCA              <1> 	call os_format_string
   938                              <1> 
   939 00004D22 BA140D              <1> 	mov dx, 13 * 256 + 20
   940 00004D25 E83ECB              <1> 	call os_move_cursor
   941 00004D28 BE[0450]            <1> 	mov si, .logo2
   942 00004D2B E8F1CA              <1> 	call os_format_string
   943                              <1> 
   944 00004D2E BA140E              <1> 	mov dx, 14 * 256 + 20
   945 00004D31 E832CB              <1> 	call os_move_cursor
   946 00004D34 BE[2D50]            <1> 	mov si, .logo3
   947 00004D37 E8E5CA              <1> 	call os_format_string
   948 00004D3A 61                  <1> 	popa
   949 00004D3B C3                  <1> 	ret
   950                              <1> 
   951                              <1> .drawbackground:
   952 00004D3C E811CB              <1> 	call os_clear_screen
   953 00004D3F BA0000              <1> 	mov dx, 0
   954 00004D42 E821CB              <1> 	call os_move_cursor
   955                              <1> 	
   956 00004D45 B82009              <1> 	mov ax, 0920h
   957 00004D48 BB7000              <1> 	mov bx, 112			; Black on gray
   958 00004D4B B95000              <1> 	mov cx, 80
   959 00004D4E CD10                <1> 	int 10h
   960                              <1> 	
   961 00004D50 BA0001              <1> 	mov dx, 1 * 256
   962 00004D53 E810CB              <1> 	call os_move_cursor
   963                              <1> 	
   964 00004D56 8A1EA8DE            <1> 	mov bl, [57000]		; Color from RAM
   965 00004D5A 80E3F0              <1> 	and bl, 11110000b
   966 00004D5D B93007              <1> 	mov cx, 1840
   967 00004D60 B0B1                <1> 	mov al, 177
   968 00004D62 CD10                <1> 	int 10h
   969                              <1> 	
   970 00004D64 BA0018              <1> 	mov dx, 24 * 256
   971 00004D67 E8FCCA              <1> 	call os_move_cursor
   972 00004D6A B370                <1> 	mov bl, 112			; Black on gray
   973 00004D6C B95000              <1> 	mov cx, 80
   974 00004D6F B020                <1> 	mov al, 32
   975 00004D71 CD10                <1> 	int 10h
   976 00004D73 C3                  <1> 	ret
   977                              <1> 	
   978                              <1> .reset:
   979 00004D74 EA0000FFFF          <1> 	jmp 0FFFFh:0
   980                              <1> 
   981                              <1> .shutdown:
   982 00004D79 E8D4CA              <1> 	call os_clear_screen
   983 00004D7C E81CCB              <1> 	call os_show_cursor
   984                              <1> 
   985 00004D7F BE[E44E]            <1> 	mov si, .apmmsg
   986 00004D82 E870CA              <1> 	call os_print_string
   987                              <1> 	
   988 00004D85 BE[094F]            <1> 	mov si, .dbgmsg1
   989 00004D88 E86ACA              <1> 	call os_print_string
   990                              <1> 	
   991 00004D8B B80053              <1> 	mov ax, 5300h
   992 00004D8E 31DB                <1> 	xor bx, bx
   993 00004D90 CD15                <1> 	int 15h				; check if APM is present
   994 00004D92 724F                <1> 	jc .APM_missing
   995                              <1> 
   996 00004D94 BE[1B4F]            <1> 	mov si, .dbgmsg2
   997 00004D97 E85BCA              <1> 	call os_print_string
   998                              <1> 
   999 00004D9A B80453              <1> 	mov ax, 5304h
  1000 00004D9D 31DB                <1> 	xor bx, bx
  1001 00004D9F CD15                <1> 	int 15h				; disconnect any previous APM interface	
  1002                              <1> 	
  1003 00004DA1 BE[494F]            <1> 	mov si, .dbgmsg2_1
  1004 00004DA4 E84ECA              <1> 	call os_print_string
  1005                              <1> 	
  1006 00004DA7 B80E53              <1> 	mov ax, 530Eh		; Set APM to version 1.2
  1007 00004DAA 31DB                <1> 	xor bx, bx
  1008 00004DAC B90201              <1> 	mov cx, 0102h
  1009 00004DAF CD15                <1> 	int 15h
  1010                              <1> 
  1011 00004DB1 BE[694F]            <1> 	mov si, .dbgmsg3
  1012 00004DB4 E83ECA              <1> 	call os_print_string
  1013                              <1> 
  1014 00004DB7 B80153              <1> 	mov ax, 5301h
  1015 00004DBA 31DB                <1> 	xor bx, bx
  1016 00004DBC 31C9                <1> 	xor cx, cx
  1017 00004DBE CD15                <1> 	int 15h				; open an interface with APM
  1018 00004DC0 7231                <1> 	jc .APM_interface
  1019                              <1> 
  1020 00004DC2 BE[804F]            <1> 	mov si, .dbgmsg4
  1021 00004DC5 E82DCA              <1> 	call os_print_string
  1022                              <1> 
  1023 00004DC8 B80753              <1> 	mov ax, 5307h
  1024 00004DCB BB0100              <1> 	mov bx, 1
  1025 00004DCE B90300              <1> 	mov cx, 3
  1026 00004DD1 CD15                <1> 	int 15h				; do a power off
  1027                              <1> 	
  1028                              <1> .APM_error:
  1029 00004DD3 B8[214E]            <1> 	mov ax, .errormsg1
  1030 00004DD6 BB[854E]            <1> 	mov bx, .errormsg4
  1031 00004DD9 B9[AC4E]            <1> 	mov cx, .errormsg45
  1032 00004DDC 31D2                <1> 	xor dx, dx
  1033 00004DDE E857D2              <1> 	call os_dialog_box
  1034                              <1> 	
  1035 00004DE1 EB91                <1> 	jmp .reset
  1036                              <1> 	
  1037                              <1> .APM_missing:
  1038 00004DE3 B8[434E]            <1> 	mov ax, .errormsg2
  1039 00004DE6 BB[854E]            <1> 	mov bx, .errormsg4
  1040 00004DE9 B9[AC4E]            <1> 	mov cx, .errormsg45
  1041 00004DEC 31D2                <1> 	xor dx, dx
  1042 00004DEE E847D2              <1> 	call os_dialog_box
  1043                              <1> 	
  1044 00004DF1 EB81                <1> 	jmp .reset
  1045                              <1> 	
  1046                              <1> .APM_interface:
  1047 00004DF3 B8[674E]            <1> 	mov ax, .errormsg3
  1048 00004DF6 BB[854E]            <1> 	mov bx, .errormsg4
  1049 00004DF9 B9[AC4E]            <1> 	mov cx, .errormsg45
  1050 00004DFC 31D2                <1> 	xor dx, dx
  1051 00004DFE E837D2              <1> 	call os_dialog_box
  1052                              <1> 	
  1053 00004E01 E970FF              <1> 	jmp .reset
  1054                              <1> 	
  1055                              <1> .APM_pwrmgmt:
  1056 00004E04 B8[C34E]            <1> 	mov ax, .errormsg5
  1057 00004E07 BB[854E]            <1> 	mov bx, .errormsg4
  1058 00004E0A B9[AC4E]            <1> 	mov cx, .errormsg45
  1059 00004E0D 31D2                <1> 	xor dx, dx
  1060 00004E0F E826D2              <1> 	call os_dialog_box
  1061                              <1> 	
  1062 00004E12 E95FFF              <1> 	jmp .reset
  1063                              <1> 
  1064                              <1> 	
  1065 00004E15 476F6F646279652C20- <1> 	.dialogmsg1	db 'Goodbye, ', 0
  1065 00004E1E 00                  <1>
  1066 00004E1F 2E00                <1> 	.dialogmsg2	db '.', 0
  1067 00004E21 4572726F7220736875- <1> 	.errormsg1	db 'Error shutting down the computer.', 0
  1067 00004E2A 7474696E6720646F77- <1>
  1067 00004E33 6E2074686520636F6D- <1>
  1067 00004E3C 70757465722E00      <1>
  1068 00004E43 5468697320636F6D70- <1> 	.errormsg2	db 'This computer does not support APM.', 0
  1068 00004E4C 7574657220646F6573- <1>
  1068 00004E55 206E6F742073757070- <1>
  1068 00004E5E 6F72742041504D2E00  <1>
  1069 00004E67 4572726F7220636F6D- <1> 	.errormsg3	db 'Error communicating with APM.', 0
  1069 00004E70 6D756E69636174696E- <1>
  1069 00004E79 672077697468204150- <1>
  1069 00004E82 4D2E00              <1>
  1070 00004E85 506C65617365207475- <1> 	.errormsg4	db 'Please turn off the computer manually,', 0
  1070 00004E8E 726E206F6666207468- <1>
  1070 00004E97 6520636F6D70757465- <1>
  1070 00004EA0 72206D616E75616C6C- <1>
  1070 00004EA9 792C00              <1>
  1071 00004EAC 6F7220707265737320- <1> 	.errormsg45	db 'or press OK to reboot.', 0
  1071 00004EB5 4F4B20746F20726562- <1>
  1071 00004EBE 6F6F742E00          <1>
  1072 00004EC3 4572726F7220656E61- <1> 	.errormsg5	db 'Error enabling power management.', 0
  1072 00004ECC 626C696E6720706F77- <1>
  1072 00004ED5 6572206D616E616765- <1>
  1072 00004EDE 6D656E742E00        <1>
  1073                              <1> 	
  1074 00004EE4 417474656D7074696E- <1> 	.apmmsg		db 'Attempting shutdown through APM...', 13, 10, 0
  1074 00004EED 672073687574646F77- <1>
  1074 00004EF6 6E207468726F756768- <1>
  1074 00004EFF 2041504D2E2E2E0D0A- <1>
  1074 00004F08 00                  <1>
  1075                              <1> 	
  1076                              <1> 	
  1077 00004F09 436865636B696E6720- <1> 	.dbgmsg1	db 'Checking APM...', 13, 10, 0
  1077 00004F12 41504D2E2E2E0D0A00  <1>
  1078 00004F1B 446973636F6E6E6563- <1> 	.dbgmsg2	db 'Disconnecting any previous APM interface...', 13, 10, 0
  1078 00004F24 74696E6720616E7920- <1>
  1078 00004F2D 70726576696F757320- <1>
  1078 00004F36 41504D20696E746572- <1>
  1078 00004F3F 666163652E2E2E0D0A- <1>
  1078 00004F48 00                  <1>
  1079 00004F49 53657474696E672041- <1> 	.dbgmsg2_1	db 'Setting APM version to 1.2...', 13, 10, 0
  1079 00004F52 504D2076657273696F- <1>
  1079 00004F5B 6E20746F20312E322E- <1>
  1079 00004F64 2E2E0D0A00          <1>
  1080 00004F69 436F6E6E656374696E- <1> 	.dbgmsg3	db 'Connecting to APM...', 13, 10, 0
  1080 00004F72 6720746F2041504D2E- <1>
  1080 00004F7B 2E2E0D0A00          <1>
  1081 00004F80 456E61626C696E6720- <1> 	.dbgmsg4	db 'Enabling power management...', 13, 10, 0
  1081 00004F89 706F776572206D616E- <1>
  1081 00004F92 6167656D656E742E2E- <1>
  1081 00004F9B 2E0D0A00            <1>
  1082 00004F9F 5368757474696E6720- <1> 	.dbgmsg5	db 'Shutting down...', 13, 10, 0
  1082 00004FA8 646F776E2E2E2E0D0A- <1>
  1082 00004FB1 00                  <1>
  1083                              <1> 	
  1084 00004FB2 DAC4C4B3C4C4BF2020- <1> 	.logo0		db 218, 196, 196, 179, 196, 196, 191, '  Shut down the computer         ', 0
  1084 00004FBB 5368757420646F776E- <1>
  1084 00004FC4 2074686520636F6D70- <1>
  1084 00004FCD 757465722020202020- <1>
  1084 00004FD6 2020202000          <1>
  1085 00004FDB B32020B32020B32020- <1> 	.logo1		db 179, 32, 32, 179, 32, 32, 179,     '  Soft reboot the computer       ', 0
  1085 00004FE4 536F6674207265626F- <1>
  1085 00004FED 6F742074686520636F- <1>
  1085 00004FF6 6D7075746572202020- <1>
  1085 00004FFF 2020202000          <1>
  1086 00005004 B32020202020B32020- <1> 	.logo2		db 179, 32, 32, 32, 32, 32, 179,      '  Go back                        ', 0
  1086 0000500D 476F206261636B2020- <1>
  1086 00005016 202020202020202020- <1>
  1086 0000501F 202020202020202020- <1>
  1086 00005028 2020202000          <1>
  1087 0000502D C0C4C4C4C4C4D900    <1> 	.logo3		db 192, 196, 196, 196, 196, 196, 217, 0
   823                                  
   824                                  ; ==================================================================
   825                                  ; END OF KERNEL
   826                                  ; ==================================================================
   827                                  
   828                                  os_kernel_end:
